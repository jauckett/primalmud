head	1.56;
access;
symbols
	LATEST:1.7
	A3_0_1:1.7;
locks; strict;
comment	@ * @;


1.56
date	2004.12.06.05.55.11;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	2004.08.27.02.13.41;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	2004.07.18.11.16.50;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	2004.07.11.02.19.06;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	2004.07.10.03.29.43;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	2004.07.07.14.13.22;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	2004.07.07.11.38.16;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.05.14.42.58;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.05.03.47.21;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	2004.06.03.02.50.31;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.24.11.39.40;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.21.14.17.27;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.18.11.08.39;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	2004.05.10.03.26.04;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.06.02.23.30;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.29.08.02.23;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.21.07.10.19;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.01.03.35.45;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.30.04.18.23;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.30.04.09.02;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.29.11.12.45;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.27.10.06.52;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.21.08.14.34;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.12.04.40.53;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.11.03.48.42;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.10.22.28.15;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.10.12.02.27;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.31.22.20.28;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.09.05.42.45;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	2003.11.27.06.16.00;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.24.00.14.49;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.17.12.36.24;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.12.11.00.14;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.05.12.17.14;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.01.10.26.03;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.20.08.17.56;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.10.10.48.30;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.14.06.10.19;	author primal;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.25.03.55.52;	author primal;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.09.13.08.06;	author rod;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.09.12.22.56;	author rod;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.30.13.57.17;	author rod;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.15.04.21.09;	author rod;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.03.05.31.03;	author artus;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.26.06.49.15;	author primal;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.04.08.02.16;	author primal;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.06.08.18.37;	author primal;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.05.00.12.08;	author primal;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.02.04.34.51;	author primal;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.20.16.32.50;	author primal;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.17.14.08.51;	author primal;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.05.02.28.47;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.14.10.03.18;	author primal;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.22.09.22.36;	author talisman;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.12.29.22;	author talisman;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.44.00;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Artus> Added calc_modifier function.
@
text
@/* ************************************************************************
*   File: utils.c                                       Part of CircleMUD *
*  Usage: various internal functions of a utility nature                  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "db.h"
#include "comm.h"
#include "screen.h"
#include "spells.h"
#include "handler.h"
#include "interpreter.h"
#include "constants.h"
#include "colour.h"

extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct time_data time_info;
extern struct room_data *world;
extern struct event_list events;

struct spell_info_type spell_info[TOP_SPELL_DEFINE + 1];

/* local functions */
struct time_info_data *real_time_passed(time_t t2, time_t t1);
struct time_info_data *mud_time_passed(time_t t2, time_t t1);
void prune_crlf(char *txt);

extern int level_exp(struct char_data *ch, int level);
extern struct questlist_element *questlist_table;


/* DM - temporary localtime, till the deb libs are fixed
struct tm *localtime(const time_t *timer) {
  struct tm *tmptime;

  tmptime = (struct tm *)malloc(sizeof(struct tm));

  tmptime->tm_sec = 0;
  tmptime->tm_min = 0;
  tmptime->tm_hour = 17;
  tmptime->tm_mday = 5;
  tmptime->tm_mon = 1;
  tmptime->tm_year = 2002;
  tmptime->tm_wday = 6;
  tmptime->tm_yday = 5;
  tmptime->tm_isdst = 1;

  return tmptime;
} */

#ifdef NO_LOCALTIME
/* Artus> Alternative localtime, this one won't crash out :o)..
 * Pretty much ripped the __offtime() function, but with a hardcoded offset.  */
//int jk_localtime(struct tm *lt, long int t)
int jk_localtime_now(struct tm *lt)
{
  return jk_localtime(lt, time(0));
}

int jk_localtime(struct tm *lt, long int t)
{ 
#ifndef SECS_PER_DAY
#define SECS_PER_DAY 86400
#define SECS_PER_HOUR 3600
#endif
  long int days, rem, y;
  const unsigned short int *ip;
  const unsigned short int mon_yday[2][13] =
  {
    /* Normal years.  */
    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
    /* Leap years.  */
    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
  };

  days = t / SECS_PER_DAY;
  rem = t % SECS_PER_DAY;
  rem += 10 * SECS_PER_HOUR;
  while (rem < 0)
    {
      rem += SECS_PER_DAY;
      --days;
    }
  while (rem >= SECS_PER_DAY)
    {
      rem -= SECS_PER_DAY;
      ++days;
    }
  lt->tm_hour = rem / SECS_PER_HOUR;
  rem %= SECS_PER_HOUR;
  lt->tm_min = rem / 60;
  lt->tm_sec = rem % 60;
  /* January 1, 1970 was a Thursday.  */
  lt->tm_wday = (4 + days) % 7;
  if (lt->tm_wday < 0)
    lt->tm_wday += 7;
  y = 1970;

#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))
#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))

  while (days < 0 || days >= (__isleap (y) ? 366 : 365))
    {
      /* Guess a corrected year, assuming 365 days per year.  */
      long int yg = y + days / 365 - (days % 365 < 0);

      /* Adjust DAYS and Y to match the guessed year.  */
      days -= ((yg - y) * 365
	       + LEAPS_THRU_END_OF (yg - 1)
	       - LEAPS_THRU_END_OF (y - 1));
      y = yg;
    }
  lt->tm_year = y - 1900;
  if (lt->tm_year != y - 1900)
    return 1;
  lt->tm_yday = days;
  ip = mon_yday[__isleap(y)];

  for (y = 11; days < (long int) ip[y]; --y)
    continue;
  days -= ip[y];
  lt->tm_mon = y;
  lt->tm_mday = days + 1;
  
  return 0;
}
#endif


// DM - quest eq check
// returns TRUE if the character is allowed to use the item,
// FALSE otherwise.
bool quest_obj_ok(struct char_data *ch, struct obj_data *obj) {

  extern struct index_data *obj_index;
  
  if (ch == NULL || obj == NULL) {
    mudlog("NULL ch or obj passed to quest_obj_ok().", NRM, LVL_ANGEL, TRUE);
    return FALSE;
  }

  if (GET_OBJ_TYPE(obj) != ITEM_QUEST) {
    return TRUE;
  }
 
  for (int i = 0; i < MAX_QUEST_ITEMS; i++) {
    if (GET_QUEST_ITEM(ch, i) == GET_OBJ_VNUM(obj)) {
      return TRUE;
    }
  }
  
  return FALSE;
}

// Returns the maximum stat value for the given type of stat based on the
// character race (stats) and class (points)
int max_stat_value(struct char_data *ch, int stat)
{
  if (IS_NPC(ch))
  {
    basic_mud_log("SYSERR: mobile passed to max_stat_value");
    return 25;
  }
  
  // Impose some limits for gods
  if (!LR_FAIL(ch, LVL_IS_GOD))
    switch (stat) 
    {
      case STAT_INT:
      case STAT_WIS:
      case STAT_STR:
      case STAT_CON:
      case STAT_DEX:
      case STAT_CHA:
        return 25;
      case STAT_HIT:
      case STAT_MANA:
      case STAT_MOVE:
        return 32000;
      default:
        basic_mud_log("SYSERR: Invalid stat value passed to max_stat_value"); 
        return 25;
    }

  /* Masters max stat values are 21 */
  if (GET_CLASS(ch) == CLASS_MASTER) 
    switch (stat) 
    {
      case STAT_INT:
      case STAT_WIS:
      case STAT_STR:
      case STAT_CON:
      case STAT_DEX:
      case STAT_CHA:
        return 21;
      case STAT_HIT:
      case STAT_MANA:
      case STAT_MOVE:
        return (int) ((pc_max_class_points[(int)GET_CLASS(ch)][stat-6] * GET_LEVEL(ch))
                      / 100);
      default:
        basic_mud_log("SYSERR: Invalid stat value passed to max_stat_value"); 
    }
  
  /*
   * Max stat limits obtained directly from pc_max_race_stats array
   */
  switch (stat)
  {
    case STAT_INT:
    case STAT_WIS:
    case STAT_STR:
    case STAT_CON:
    case STAT_DEX:
    case STAT_CHA:
      return pc_max_race_stats[GET_RACE(ch)][stat];

    /*
     * Max point limit is linearly based on the max point values for the given 
     * class:
     *
     * (max point limit * char level) / 100
     */
    case STAT_HIT:
    case STAT_MANA:
    case STAT_MOVE:
      return (int) ((pc_max_class_points[(int)GET_CLASS(ch)][stat-6] * 
	             GET_LEVEL(ch)) / 100);

    default:
      basic_mud_log("SYSERR: Invalid stat value passed to max_stat_value"); 
      break;
  }
  // Doh.
  return 0;
}

// Returns the cost to train the given stat 1 time
int train_cost(struct char_data *ch, int stat, int curr_value)
{
  int tempi1, tempi2;
  float tempf1, tempf2;

  if (IS_NPC(ch))
  {
    basic_mud_log("SYSERR: mobile passed to train_cost");
    return 99999999;
  }

  // Not that this should really get used, but it wont cost gods jack to train
  if (!LR_FAIL(ch, LVL_ISNOT_GOD))
    return 0;

  /*
   * Training costs for stats INT WIS STR CON DEX CHA:
   * stat_costs[max stat value - current value] * stat_mods[current value]
   *
   * ie. a function of stat_costs (actual cost for max stat difference) and 
   * stat_mods (relative costs for actual stat value)
   */
  switch (stat)
  {
    case STAT_INT:
    case STAT_WIS:
    case STAT_STR:
    case STAT_CON:
    case STAT_DEX:
    case STAT_CHA:
      tempi1 = stat_costs[max_stat_value(ch, stat) - curr_value]; 
      tempf1 = stat_mods[curr_value + 1];
      tempi2 = (int) ((float)tempi1 * tempf1);

//      basic_mud_log("stat_costs[max (%d) - current (%d)] = %d", max_stat_value(ch, stat), curr_value, tempi1);
//      basic_mud_log("stat_mods[stat (%d) + 1] = %f", curr_value, tempf1);
//      basic_mud_log("1 * 2 = %d", tempi2);

      return (tempi2);

    /*
     * Training costs for HMV points:
     * current points   level_exp
     * -------------- * ----------
     *   max points     level * 10
     *
     * perform calculation as (so we dont go over any limits in calculation):
     *   (current value / (level * 10))
     *     *
     *   (level_exp / max value)
     */
     
    case STAT_HIT:
    case STAT_MANA:
    case STAT_MOVE:
      //hit_perc = GET_REAL_STAT(ch, stat) * level_exp(ch, GET_LEVEL(ch));
      //lvl_perc = max_stat_value(ch, stat) * GET_LEVEL(ch);

      tempf1 = ((float)curr_value / (GET_LEVEL(ch) * 10));
      tempf2= ((float)level_exp(ch, GET_LEVEL(ch)) / max_stat_value(ch, stat));

//      basic_mud_log("current point value (%d) / (char level (%d) * 10) = %0.2f", curr_value, GET_LEVEL(ch), tempf1);
//      basic_mud_log("level_exp (%d) / max stat val (%d) = %0.2f", level_exp(ch, GET_LEVEL(ch)), max_stat_value(ch, stat), tempf2); 

      tempf2 = tempf2 * tempf1;

//      basic_mud_log("1 / 2 = %0.2f", tempf2);

      return (int)(tempf2);

    default:
      basic_mud_log("SYSERR: Invalid stat value passed to max_stat_value"); 
      break;
  }
  // Doh.
  return (99999999);
}

  // returns -1 if where position is not finger,
  //          0 if where position is finger, but char cant use that position 
  //          1 if where position is finger, and char can use that position
  int can_wear_finger(struct char_data *ch, int where) {

    const byte finger_positions[NUM_CLASSES] = {
      3, // Mage
      2, // Cleric    
      2, // Thief
      1, // Warrior
      5, // Druid
      3, // Priest
      3, // Nightblade
      4, // Battlemage
      4, // Spellsword
      3, // Paladin
      5  // Master
    };
	  
    // Class restricted positions - fingers 
    if (where == WEAR_FINGER_1 || where == WEAR_FINGER_2) { 
      return (where <= finger_positions[(int)GET_CLASS(ch)]);
    }

    // (reminder - WEAR_FINGER_3 is 18, and does not procede WEAR_FINGER_2 = 2
    // hence difference is 15 (WEAR_FINGER_3 (18) - 15 = 3
    if (where >= WEAR_FINGER_3 && where <= WEAR_FINGER_5) { 
      return ((where-15) <= finger_positions[(int)GET_CLASS(ch)]);
    }

    return -1;
}

int eq_pos_ok(struct char_data *ch, int where)
{
  // mobs can wear eq anywhere - should we limit this?
  if (IS_NPC(ch))
    return TRUE; 
  switch (can_wear_finger(ch, where))
  {
    case 0: // wear position is finger, but position restricted by class
      break;
    case 1: // wear position is finger, can use position
      return TRUE;
    // wear position is not finger
    default:       
      // Race restricted positions - rest
      // Use the mask defined in the array for each race, check if the wear
      // bit is set. 
      if (IS_SET(pc_race_eq_masks[GET_RACE(ch)], (1 << where)))
	return TRUE;
  }
  if (GET_UNHOLINESS(ch) > 0)
    return TRUE;
  return FALSE;
}


int is_axe(struct obj_data *obj)
{
  	char *desc = obj->name;
	char *keywords[3] = {
		"AXE",
		"HATCHET",
		"AX"
	};
	// Only if its a weapon.
	if (!(CAN_WEAR(obj, ITEM_WEAR_WIELD)))
	  return FALSE;

	for (int i = 0; i < 3; i++)
	{
		half_chop(desc, buf2, buf);
		while(*buf2)
		{	
			toUpper((char *)buf2);
			if( strcmp(buf2, keywords[i]) == 0)
				return (TRUE); 

			half_chop(buf, buf2, buf);
		} 
	}

	return (FALSE);
}

int is_blade(struct obj_data *obj)
{
  	char *desc = obj->name;
	char *keywords[5] = {
		"SWORD",
		"BLADE",
		"KNIFE",
		"SCIMITAR",
		"DAGGER"
	};

	for (int i = 0; i < 5; i++)
	{
		half_chop(desc, buf2, buf);
		while(*buf2)
		{	
			toUpper((char *)buf2);
			if( strcmp(buf2, keywords[i]) == 0)
				return (TRUE); 

			half_chop(buf, buf2, buf);
		} 
	}

	return (FALSE);
}

char *toUpper(char *oStr)
{
   int nSize = strlen(oStr), i;

   for(i = 0; i < nSize; i++)
     oStr[i] = toupper(oStr[i]);

   return oStr;
}

/* JA is_wearing function to check if player is wearing a certain item type */
int is_wearing(struct char_data *ch, int item_type)
{
  int i;
 
  for (i = 0; i < NUM_WEARS; i++)
        {
                if (ch->equipment[i])
        if (GET_OBJ_TYPE(ch->equipment[i]) == item_type)
          return(1);
        }
  return(0);
}
 
/* JA is_carrying function to check if player is carrying a certain item type */
int is_carrying(struct char_data *ch, int item_type)
{
  struct obj_data *obj;
 
  for (obj = ch->carrying; obj; obj = obj->next_content)
    if (GET_OBJ_TYPE(obj) == item_type)
      return(1);
  return(0);
} 

/* creates a random number in interval [from;to] */
int number(int from, int to)
{
  /* error checking in case people call number() incorrectly */
  if (from > to) {
    int tmp = from;
    from = to;
    to = tmp;
    basic_mud_log("SYSERR: number() should be called with lowest, then highest. number(%d, %d), not number(%d, %d).", from, to, to, from);
  }

  return ((circle_random() % (to - from + 1)) + from);
}


/* simulates dice roll */
int dice(int number, int size)
{
  int sum = 0;

  if (size <= 0 || number <= 0)
    return (0);

  while (number-- > 0)
    sum += ((circle_random() % size) + 1);

  return (sum);
}


int MIN(int a, int b)
{
  return (a < b ? a : b);
}


int MAX(int a, int b)
{
  return (a > b ? a : b);
}


int MINMAX(int min, int max, int val) {
  return MAX(min, MIN(max, val)); 
}

char *CAP(char *txt)
{
  int i = first_disp_char(txt);
  *(txt+i) = UPPER(*(txt+i));
  return (txt);
}


/* Create a duplicate of a string */
char *str_dup(const char *source)
{
  char *new_z;

  // DM: will crash if source is null, best just return NULL ...
  if (source != NULL) {
    CREATE(new_z, char, strlen(source) + 1);
    return (strcpy(new_z, source));
  } else {
    return NULL;
  }
}


/*
 * Strips \r\n from end of string.
 */
void prune_crlf(char *txt)
{
  int i = strlen(txt) - 1;

  while (txt[i] == '\n' || txt[i] == '\r')
    txt[i--] = '\0';
}


/*
 * str_cmp: a case-insensitive version of strcmp().
 * Returns: 0 if equal, > 0 if arg1 > arg2, or < 0 if arg1 < arg2.
 *
 * Scan until strings are found different or we reach the end of both.
 */
int str_cmp(const char *arg1, const char *arg2)
{
  int chk, i;

  if (arg1 == NULL || arg2 == NULL) {
    basic_mud_log("SYSERR: str_cmp() passed a NULL pointer, %p or %p.", arg1, arg2);
    return (0);
  }

  for (i = 0; arg1[i] || arg2[i]; i++)
    if ((chk = LOWER(arg1[i]) - LOWER(arg2[i])) != 0)
      return (chk);	/* not equal */

  return (0);
}


/*
 * strn_cmp: a case-insensitive version of strncmp().
 * Returns: 0 if equal, > 0 if arg1 > arg2, or < 0 if arg1 < arg2.
 *
 * Scan until strings are found different, the end of both, or n is reached.
 */
int strn_cmp(const char *arg1, const char *arg2, int n)
{
  int chk, i;

  if (arg1 == NULL || arg2 == NULL) {
    basic_mud_log("SYSERR: strn_cmp() passed a NULL pointer, %p or %p.", arg1, arg2);
    return (0);
  }

  for (i = 0; (arg1[i] || arg2[i]) && (n > 0); i++, n--)
    if ((chk = LOWER(arg1[i]) - LOWER(arg2[i])) != 0)
      return (chk);	/* not equal */

  return (0);
}

// Artus> Is the room a death room. Probably won't catch everything ;o)
bool is_death_room(room_rnum nr)
{
  int environ = world[nr].sector_type & 0xfff0;

  if (ROOM_FLAGGED(nr, ROOM_DEATH)) // Room flagged as DEATH
    return TRUE;

  switch (TEMPERATURE(environ)) // Incinerate, Absolute Zero Rooms.
  {
    case SECT_INCINERATE:
    case SECT_ABSZERO:
      return TRUE;
  }
  
  if (GRAVITY(environ) == SECT_CRUSH) // Crushing Rooms.
    return TRUE;

  return FALSE;
}

/* log a death trap hit */
void log_death_trap(struct char_data *ch, int dtype)
{
  char fmt[256] = "";

  switch (dtype)
  {
    case DT_MISC:
      strcat(fmt, "%s hit \"misc\" death trap #%d (%s)");
      break;
    case DT_DEATH:
      strcat(fmt, "%s hit \"death\" death trap #%d (%s)");
      break;
    case DT_INCINERATE:
      strcat(fmt, "%s hit \"incinerate\" death trap #%d (%s)");
      break;
    case DT_ABSZERO:
      strcat(fmt, "%s hit \"absolute zero\" death trap #%d (%s)");
      break;
    default:
      sprintf(fmt, "%%s hit \"unknown (%d)\" death trap #%%d (%%s)", dtype);
      break;
  }
  sprintf(buf, fmt, GET_NAME(ch),
	  GET_ROOM_VNUM(IN_ROOM(ch)), world[ch->in_room].name);
  mudlog(buf, BRF, LVL_ANGEL, TRUE);
}

/*
 * New variable argument log() function.  Works the same as the old for
 * previously written code but is very nice for new code.
 */
void basic_mud_log(const char *format, ...)
{
  va_list args;

  // DM .. ok crashing on the localtime call in here on the deb libs
  // have temporarily commented that stuff out until a fix is found.
#ifndef NO_LOCALTIME
  time_t ct;
  char *time_s = NULL;
  
  ct = time(0);
  time_s = (char *)asctime(localtime(&ct));
#else
  struct tm lt;
  char time_s[20];

  if (jk_localtime_now(&lt))
    strcpy(time_s, "jk_localtime ERR ");
  else
    sprintf(time_s, "%04d-%02d-%02d %02d:%02d:%02d ", (1900 + lt.tm_year), lt.tm_mon+1, lt.tm_mday, lt.tm_hour, lt.tm_min, lt.tm_sec);
#endif 
  
  if (logfile == NULL) {
    puts("SYSERR: Using log() before stream was initialized!");
    return;
  }

  if (format == NULL)
    format = "SYSERR: log() received a NULL format.";
 
  time_s[strlen(time_s) - 1] = '\0';

#ifndef NO_LOCALTIME
  fprintf(logfile, "%-15.15s :: ", time_s + 4);
#else
  fprintf(logfile, "%-19.19s :: ", time_s);
#endif

  va_start(args, format);
  vfprintf(logfile, format, args);
  va_end(args);

  fprintf(logfile, "\n");
  fflush(logfile);
}

/* the "touch" command, essentially. */
int touch(const char *path)
{
  FILE *fl;

  if (!(fl = fopen(path, "a"))) {
    basic_mud_log("SYSERR: %s: %s", path, strerror(errno));
    return (-1);
  } else {
    fclose(fl);
    return (0);
  }
}

/*
 * mudlog -- log mud messages to a file & to online imm's syslogs
 * based on syslog by Fen Jul 3, 1992
 *
 * Modified DM - check on level for punishments
 * if level < LVL_GOD, then always display
 */
void mudlog(const char *str, int type, int level, int file)
{
  char buf[MAX_STRING_LENGTH], tp;
  struct descriptor_data *i;

   if (str == NULL)
     return;    /* eh, oh well. */
   if (file)
    basic_mud_log("%s", str);
   if (level < 0)
     return;    

  sprintf(buf, "&G[&g %s &G]&n\r\n", str);

  for (i = descriptor_list; i; i = i->next)
  {
    if (STATE(i) != CON_PLAYING || IS_NPC(i->character)) /* switch */
      continue;
    if (LR_FAIL(i->character, level))
      continue;
    if (PLR_FLAGGED(i->character, PLR_WRITING))
      continue;
    tp = ((PRF_FLAGGED(i->character, PRF_LOG1) ? 1 : 0) +
	  (PRF_FLAGGED(i->character, PRF_LOG2) ? 2 : 0));
    if (type == DBG)
      tp = (GET_DEBUG(i->character) ? DBG : tp);
    if (tp < type)
      continue;
    send_to_char(buf, i->character);
  }
}



/*
 * If you don't have a 'const' array, just cast it as such.  It's safer
 * to cast a non-const array as const than to cast a const one as non-const.
 * Doesn't really matter since this function doesn't change the array though.
 */
void sprintbit(bitvector_t bitvector, const char *names[], char *result)
{
  long nr;

  *result = '\0';

  for (nr = 0; bitvector; bitvector >>= 1) {
    if (IS_SET(bitvector, 1)) {
      if (*names[nr] != '\n') {
	strcat(result, names[nr]);
	strcat(result, " ");
      } else
	strcat(result, "UNDEFINED ");
    }
    if (*names[nr] != '\n')
      nr++;
  }

  if (!*result)
    strcpy(result, "NOBITS ");
}



void sprinttype(int type, const char *names[], char *result)
{
  int nr = 0;

  while (type && *names[nr] != '\n') {
    type--;
    nr++;
  }

  if (*names[nr] != '\n')
    strcpy(result, names[nr]);
  else
    strcpy(result, "UNDEFINED");
}


/* Calculate the REAL time passed over the last t2-t1 centuries (secs) */
struct time_info_data *real_time_passed(time_t t2, time_t t1)
{
  long secs;
  static struct time_info_data now;

  secs = (long) (t2 - t1);

  now.hours = (secs / SECS_PER_REAL_HOUR) % 24;	/* 0..23 hours */
  secs -= SECS_PER_REAL_HOUR * now.hours;

  now.day = (secs / SECS_PER_REAL_DAY);	/* 0..34 days  */
  /* secs -= SECS_PER_REAL_DAY * now.day; - Not used. */

  now.month = -1;
  now.year = -1;

  return (&now);
}



/* Calculate the MUD time passed over the last t2-t1 centuries (secs) */
struct time_info_data *mud_time_passed(time_t t2, time_t t1)
{
  long secs;
  static struct time_info_data now;

  secs = (long) (t2 - t1);

  now.hours = (secs / SECS_PER_MUD_HOUR) % 24;	/* 0..23 hours */
  secs -= SECS_PER_MUD_HOUR * now.hours;

  now.day = (secs / SECS_PER_MUD_DAY) % 35;	/* 0..34 days  */
  secs -= SECS_PER_MUD_DAY * now.day;

  now.month = (secs / SECS_PER_MUD_MONTH) % 17;	/* 0..16 months */
  secs -= SECS_PER_MUD_MONTH * now.month;

  now.year = (secs / SECS_PER_MUD_YEAR);	/* 0..XX? years */

  return (&now);
}



struct time_info_data *age(struct char_data * ch)
{
  static struct time_info_data player_age;

  player_age = *mud_time_passed(time(0), ch->player.time.birth);

  player_age.year += 17;	/* All players start at 17 */

  return (&player_age);
}


/* Check if making CH follow VICTIM will create an illegal */
/* Follow "Loop/circle"                                    */
bool circle_follow(struct char_data * ch, struct char_data * victim)
{
  struct char_data *k;

  for (k = victim; k; k = k->master) {
    if (k == ch || k == MOUNTING(ch))
      return (TRUE);
  }

  return (FALSE);
}



/* Called when stop following persons, or stopping charm */
/* This will NOT do if a character quits/dies!!          */
void stop_follower(struct char_data * ch)
{
  struct follow_type *j, *k;

  if (ch->master == NULL) {
    core_dump();
    return;
  }

  if (AFF_FLAGGED(ch, AFF_CHARM)) {
    act("You realize that $N is a jerk!", FALSE, ch, 0, ch->master, TO_CHAR);
    act("$n realizes that $N is a jerk!", FALSE, ch, 0, ch->master, TO_NOTVICT);
    act("$n hates your guts!", FALSE, ch, 0, ch->master, TO_VICT);
    if (affected_by_spell(ch, SPELL_CHARM))
      affect_from_char(ch, SPELL_CHARM);
  } else {
    act("You stop following $N.", FALSE, ch, 0, ch->master, TO_CHAR);
    act("$n stops following $N.", TRUE, ch, 0, ch->master, TO_NOTVICT);
    act("$n stops following you.", TRUE, ch, 0, ch->master, TO_VICT);
  }

  // Display group leave message
  if (AFF_FLAGGED(ch, AFF_GROUP)) {
    act("$n leaves the group.", FALSE, ch, 0, ch->master, TO_VICT);
    act("You leave the group.", FALSE, ch, 0, NULL, TO_CHAR);
    for (k = ch->master->followers; k != NULL; k = k->next) {
      if (k->follower != ch) {
        act("$n leaves the group.", FALSE, ch, 0, k->follower, TO_VICT);
      }
    } 
  }

  if (ch->master->followers->follower == ch) {	/* Head of follower-list? */
    k = ch->master->followers;
    ch->master->followers = k->next;
    free(k);
  } else {			/* locate follower who is not head of list */
    for (k = ch->master->followers; k->next->follower != ch; k = k->next);
    j = k->next;
    k->next = j->next;
    free(j);
  }

  ch->master = NULL;
  REMOVE_BIT(AFF_FLAGS(ch), AFF_CHARM | AFF_GROUP);
}

/* DM - send clone message, and kill it */
void die_clone(struct char_data *ch, struct char_data *killer) {
	act("$n realises that $e is not the real $n!", FALSE, ch, 0, 0, TO_ROOM);
	act("You realise you are merely a clone of $n...", FALSE, ch, 0,0, TO_CHAR);
	act("$n grasps $s chest in pain and dies of shock!", FALSE, ch, 0,0, TO_ROOM);
	act("You die from the shock of not being who you are!", FALSE, ch,0, 0, TO_CHAR);
	raw_kill(ch, killer);
}

/* Called when a character that follows/is followed dies */
void die_follower(struct char_data * ch)
{
  struct follow_type *j, *k;

  if (ch->master)
    stop_follower(ch);

  for (k = ch->followers; k; k = j) {
    j = k->next;
    stop_follower(k->follower);
  }
}



/* Do NOT call this before having checked if a circle of followers */
/* will arise. CH will follow leader                               */
void add_follower(struct char_data * ch, struct char_data * leader)
{
  struct follow_type *k;

  if (ch->master) {
    core_dump();
    return;
  }

  ch->master = leader;

  CREATE(k, struct follow_type, 1);

  k->follower = ch;
  k->next = leader->followers;
  leader->followers = k;

  act("You now follow $N.", FALSE, ch, 0, leader, TO_CHAR);
  if (CAN_SEE(leader, ch))
    act("$n starts following you.", TRUE, ch, 0, leader, TO_VICT);
  act("$n starts to follow $N.", TRUE, ch, 0, leader, TO_NOTVICT);
}

/*
 * get_line reads the next non-blank line off of the input stream.
 * The newline character is removed from the input.  Lines which begin
 * with '*' are considered to be comments.
 *
 * Returns the number of lines advanced in the file.
 */
int get_line(FILE * fl, char *buf)
{
  char temp[256];
  int lines = 0;

  do {
    fgets(temp, 256, fl);
    if (feof(fl))
      return (0);
    lines++;
  } while (*temp == '*' || *temp == '\n');

  temp[strlen(temp) - 1] = '\0';
  strcpy(buf, temp);
  return (lines);
}


int get_filename(char *orig_name, char *filename, int mode)
{
  const char *prefix, *middle, *suffix;
  char name[64], *ptr;

  if (orig_name == NULL || *orig_name == '\0' || filename == NULL) {
    basic_mud_log("SYSERR: NULL pointer or empty string passed to get_filename(), %p or %p.",
		orig_name, filename);
    return (0);
  }

  switch (mode) {
  case CRASH_FILE:
    prefix = LIB_PLROBJS;
    suffix = SUF_OBJS;
    break;
  case ALIAS_FILE:
    prefix = LIB_PLRALIAS;
    suffix = SUF_ALIAS;
    break;
  case ETEXT_FILE:
    prefix = LIB_PLRTEXT;
    suffix = SUF_TEXT;
    break;
  case SCRIPT_VARS_FILE:
    prefix = LIB_PLRVARS;
    suffix = SUF_MEM;
    break;
  default:
    return (0);
  }

  strcpy(name, orig_name);
  for (ptr = name; *ptr; ptr++)
    *ptr = LOWER(*ptr);

  switch (LOWER(*name)) {
  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':
    middle = "A-E";
    break;
  case 'f':  case 'g':  case 'h':  case 'i':  case 'j':
    middle = "F-J";
    break;
  case 'k':  case 'l':  case 'm':  case 'n':  case 'o':
    middle = "K-O";
    break;
  case 'p':  case 'q':  case 'r':  case 's':  case 't':
    middle = "P-T";
    break;
  case 'u':  case 'v':  case 'w':  case 'x':  case 'y':  case 'z':
    middle = "U-Z";
    break;
  default:
    middle = "ZZZ";
    break;
  }

  sprintf(filename, "%s%s"SLASH"%s.%s", prefix, middle, name, suffix);
  return (1);
}


int num_pc_in_room(struct room_data *room)
{
  int i = 0;
  struct char_data *ch;

  for (ch = room->people; ch != NULL; ch = ch->next_in_room)
    if (!IS_NPC(ch))
      i++;

  return (i);
}

/*
 * This function (derived from basic fork(); abort(); idea by Erwin S.
 * Andreasen) causes your MUD to dump core (assuming you can) but
 * continue running.  The core dump will allow post-mortem debugging
 * that is less severe than assert();  Don't call this directly as
 * core_dump_unix() but as simply 'core_dump()' so that it will be
 * excluded from systems not supporting them. (e.g. Windows '95).
 *
 * You still want to call abort() or exit(1) for
 * non-recoverable errors, of course...
 *
 * XXX: Wonder if flushing streams includes sockets?
 */
void core_dump_real(const char *who, int line)
{
  basic_mud_log("SYSERR: Assertion failed at %s:%d!", who, line);

#if defined(CIRCLE_UNIX)
  /* These would be duplicated otherwise... */
  fflush(stdout);
  fflush(stderr);
  fflush(logfile);

  /*
   * Kill the child so the debugger or script doesn't think the MUD
   * crashed.  The 'autorun' script would otherwise run it again.
   */
  if (fork() == 0)
    abort();
#endif
}

int has_stats_for_prac(struct char_data *ch, int skillnum, bool show)
{
  int return_val = 1;
  int class_index = GET_CLASS(ch);
  // Level...
  if (LR_FAIL(ch, spell_info[skillnum].min_level[(int) GET_CLASS(ch)]))
  {
#ifndef IGNORE_DEBUG
    if (GET_DEBUG(ch))
    {
      sprintf(buf, "&gDBG: Skillnum: %d, Level Failed.&n\r\n", skillnum);
      send_to_char(buf, ch);
    }
#endif
    if (show)
    {
      if (IS_SKILL(skillnum))
	send_to_char("You do not know of that skill!\r\n", ch);
      else
	send_to_char("You do not know of that spell!\r\n", ch);
    }
    return(0);
  }
  // STR...
  if (GET_REAL_STR(ch) < spell_info[skillnum].str[class_index]) 
  {
    if (show)
    {
      if (IS_SKILL(skillnum))
	send_to_char("You don't have the natural strength to use this skill\n\r", ch);
      else
	send_to_char("You don't have the natural strength to use this spell\n\r", ch);
    }
    return_val = 0;
  }
  // INT...
  if (GET_REAL_INT(ch) < spell_info[skillnum].intl[class_index]) 
  {
    if (show)
    {
      if (IS_SKILL(skillnum))
	send_to_char("You don't have the natural intelligence to use this skill\n\r", ch);
      else
	send_to_char("You don't have the natural intelligence to use this spell\n\r", ch);
    }
    return_val = 0;
  }
  // WIS...
  if (GET_REAL_WIS(ch) < spell_info[skillnum].wis[class_index]) 
  {
    if (show)
    {
      if (IS_SKILL(skillnum))
	send_to_char("You don't have the natural wisdom to use this skill\n\r", ch);
      else
	send_to_char("You don't have the natural wisdom to use this spell\n\r", ch);
    }
    return_val = 0;
  }
  // DEX...
  if (GET_REAL_DEX(ch) < spell_info[skillnum].dex[class_index]) 
  {
    if (show)
    {
      if (IS_SKILL(skillnum))
	send_to_char("You don't have the natural dexterity to use this skill\n\r", ch);
      else
	send_to_char("You don't have the natural dexterity to use this spell\n\r", ch);
    }
    return_val = 0;
  }
  // CON...
  if (GET_REAL_CON(ch) < spell_info[skillnum].con[class_index]) 
  {
    if (show)
    {
      if (IS_SKILL(skillnum))
	send_to_char("You don't have the natural constitution to use this skill\n\r", ch);
      else
	send_to_char("You don't have the natural constitution to use this spell\n\r", ch);
    }
    return_val = 0;
  }
  // CHA...
  if (GET_REAL_CHA(ch) < spell_info[skillnum].cha[class_index]) 
  {
    if (show)
    {
      if (IS_SKILL(skillnum))
	send_to_char("You don't have the natural charisma to use this skill\n\r", ch);
      else
	send_to_char("You don't have the natural charisma to use this spell\n\r", ch);
    }
    return_val = 0;
  }
  return(return_val);
}

/* check if player has minimum stats to use this skill */
int has_stats_for_skill(struct char_data *ch, int skillnum, bool show)
{
  // What ever. I do what i want.
  if (!LR_FAIL(ch, LVL_IMPL))
    return(1);
  if (GET_SKILL(ch, skillnum) == 0) 
  {
    if (show)
    {
      if (IS_SKILL(skillnum))
	send_to_char(UNFAMILIARSKILL, ch);
      else
	send_to_char(UNFAMILIARSPELL, ch);
    }
    return(0);
  }
  return(has_stats_for_prac(ch, skillnum, show));
} 

/* Get world from zone_table now - DM */
// probably should use room rnum instead of ch, anyhow ...
int get_world(room_rnum room)
{
  extern struct zone_data *zone_table;
  int zone;
 
  if (room < 0 || room > top_of_world)
    return (-1);

  // DM - the world values are saved as 1,2,3 (silly)
  // and they are used in all code as 0,1,2
  // see: WORLD_XXX
  zone = zone_table[world[room].zone].world;
  
  return (zone-1);
} 

int same_world(struct char_data *ch,struct char_data *ch2)
{
  if (!LR_FAIL(ch, LVL_IMPL) || !LR_FAIL(ch2, LVL_IMPL))
    return 1;
  return (get_world(ch->in_room) == get_world(ch2->in_room));
} 

/* Info channel added by hal */
void info_channel( char *str , struct char_data *ch )
{
  char buf[MAX_STRING_LENGTH];
  extern struct descriptor_data *descriptor_list;
  struct descriptor_data *i;
 
  sprintf(buf, "INFO: [ %s ]\r\n", str);
 
  for (i = descriptor_list; i ; i = i->next)
    if (!i->connected && !PLR_FLAGGED(i->character, PLR_WRITING))
    {
      if (!(PRF_FLAGGED(i->character, PRF_NOINFO) ))
      {
        if ( CAN_SEE(i->character, ch) )
	{
          send_to_char(CCGRN(i->character, C_NRM), i->character);
          send_to_char(buf, i->character);
          send_to_char(CCNRM(i->character, C_NRM), i->character);
        }
      }
    }
} 

/* Called when char stops autoassisting another single char     */
/* This will NOT do if a character quits/dies!!          */
void stop_assisting(struct char_data * ch)
{
  struct char_data *autoassisting;
  struct assisters_type *temp, *temp2;
 
  autoassisting=AUTOASSIST(ch);
 
  /* The character that ch is autoassisting */
  if (autoassisting) {
    act("You stop auto assisting $N.", FALSE, ch, 0, autoassisting, TO_CHAR);
    act("$n stops auto assisting $N.", TRUE, ch, 0, autoassisting, TO_NOTVICT);
    act("$n stops auto assisting you.", TRUE, ch, 0, autoassisting, TO_VICT);
 
    if (autoassisting->autoassisters->assister == ch) {  /* Head of assister-list? */
      temp = autoassisting->autoassisters;
      autoassisting->autoassisters = temp->next;
      temp->assister=NULL;
      free(temp);
    } else {                      /* locate assister who is not head of list */
      for (temp = autoassisting->autoassisters; temp->next->assister != ch; temp = temp->next);
 
      temp2 = temp->next;
      temp->next = temp2->next;
      temp2->assister=NULL;
      free(temp2);
    }
 
    AUTOASSIST(ch) = NULL;
  }
} 

/* Called when all autoassister's stop assisting char   */
/* This will NOT do if a character quits/dies!!          */
void stop_assisters(struct char_data *ch)
{
  struct assisters_type *k, *j;
 
  for (k = ch->autoassisters; k; k = j) {
    j = k->next;
    stop_assisting(k->assister);
  }
} 

/* Called when a character that autoassists/is followed dies */
void die_assisting(struct char_data * ch)
{
  if (ch->autoassisters)
    stop_assisters(ch);
  if (AUTOASSIST(ch))
    stop_assisting(ch);
} 

/* Number of attacks the PC/NPC has available - DM */
int num_attacks(struct char_data *ch)
{
  if (!IS_NPC(ch)) 
  {
    if ((GET_SKILL(ch,SKILL_3RD_ATTACK) > 0) &&
	has_stats_for_skill(ch, SKILL_3RD_ATTACK, FALSE) &&
	(GET_SKILL(ch,SKILL_2ND_ATTACK) > 0))
      return 3;
    else if ((GET_SKILL(ch,SKILL_2ND_ATTACK) > 0) &&
	     has_stats_for_skill(ch, SKILL_3RD_ATTACK, FALSE))
      return 2;
    else
      return 1;
  } else {
    if (MOB_FLAGGED(ch,MOB_3RD_ATTACK))
      return 3;
    else if (MOB_FLAGGED(ch,MOB_2ND_ATTACK))
      return 2;
    else
      return 1;
  }
} 

/* Auction system functions */
#if 0
int add_lot(struct obj_data *obj, struct char_data *ch, long amount)
{
 
   int i = 0;
   int done= 0;
 
   while ( !done && i < MAX_LOTS )
   {
     if ( avail_lots[i].sellerid == 0 )
     {
        avail_lots[i].sellerid = GET_IDNUM(ch);
        strcpy(avail_lots[i].sellername, GET_NAME(ch));
        avail_lots[i].buyerid = 0;
        avail_lots[i].obj = obj;
        avail_lots[i].offer = amount;
  
        done = 1;
     }
     i++;
  }
 
  return i;

} 

void show_lots (struct char_data *ch)
{
        int i = 0;
        if (COLOR_LEV(ch) >= C_NRM)
                        send_to_char(KMAG, ch);
  
        while ( avail_lots[i].sellerid != 0 )
        {
             if ( avail_lots[i].buyerid == 0 )
                  strcpy ( avail_lots[i].buyername, "no one");
 
             sprintf(buf, "Item %d: %s is selling %s to %s for %ld.\r\n",
                             i+1,
                             avail_lots[i].sellername,
                             avail_lots[i].obj->short_description,
                             avail_lots[i].buyername,
                             avail_lots[i].offer );
 
             send_to_char( buf, ch);
             i++;
        }
 
        if ( i == 0 )
             send_to_char( "No items available.\r\n", ch);
 
         if (COLOR_LEV(ch) >= C_NRM)
                        send_to_char(KNRM, ch);
}  

int check_seller(struct char_data *ch)
{
    int i = 0;
    int check = -1;
 
    while ( avail_lots[i].sellerid != 0 )
    {
       if ( avail_lots[i].sellerid == GET_IDNUM(ch))
            check = i;
       i++;
    }
 
    return check;
}
 
void remove_lot(int lot)
{
        int i = lot;
 
        avail_lots[lot].sellerid = 0;
 
        while ( avail_lots[i+1].sellerid != 0 )
        {
          avail_lots[i].sellerid = avail_lots[i+1].sellerid;
          avail_lots[i].buyerid = avail_lots[i+1].buyerid;
	  strcpy(avail_lots[i].buyername, avail_lots[i+1].buyername);
          strcpy(avail_lots[i].sellername, avail_lots[i+1].sellername);

          avail_lots[i].obj = avail_lots[i+1].obj;
          avail_lots[i].offer = avail_lots[i+1].offer;
 
          avail_lots[i+1].sellerid = 0;
          i++;
        }
}   
#endif

// Calculate the unholiness modifier and return the result
double unholiness_modifier(struct char_data *ch)
{
  if (GET_UNHOLINESS(ch) < 1)
    return 0;
  if (GET_UNHOLINESS(ch) >= 10)
    return -1;
  return (double)(0-GET_UNHOLINESS(ch) * 0.1);
}

// Calculate the elitist modifier and return the result.
float elitist_modifier(struct char_data *ch)
{
  float fModifier = 0.0;
  int i;
 
  if (GET_CLASS(ch) <= CLASS_WARRIOR)
    return 0;
  
  if (GET_CLASS(ch) == CLASS_MASTER)
  {
    i = GET_REM_TWO(ch) - 75;
    if (i == 20) 
    {
      if (GET_REM_ONE(ch) == RONE_MAX_LVL)
	fModifier -= 0.5;
      else
	fModifier -= 0.4;
    }
    else if (i > 15) 
      fModifier -= 0.3;
    else if (i > 10) 
      fModifier -= 0.2;
    else if (i > 5)
      fModifier -= 0.1;
  }

  i = GET_REM_ONE(ch) - 50;
  if (i == 41) 
    fModifier -= 0.5;
  else if (i == 40)
    fModifier -= 0.4;
  else if (i >= 35)
    fModifier -= 0.35;
  else if (i >= 30)
    fModifier -= 0.3;
  else if (i >= 25)
    fModifier -= 0.25;
  else if (i >= 20)
    fModifier -= 0.2;
  else if (i >= 15)
    fModifier -= 0.15;
  else if (i >= 10)
    fModifier -= 0.1;

  return fModifier;
}

// return the extra values for the characters special modifiers
// ie. permanent's 
// TALI - TODONE.
float special_modifier(struct char_data *ch)
{
  float fModifier = 0.0;
  long lSpecials = GET_SPECIALS(ch);
  
  if (IS_SET(lSpecials, SPECIAL_INVIS))		// 2%
    fModifier += 0.02;				
  if (IS_SET(lSpecials, SPECIAL_SNEAK))		// 2%
    fModifier += 0.02;
  if (IS_SET(lSpecials, SPECIAL_MULTIWEAPON))	// 9%
    fModifier += 0.09;
  if (IS_SET(lSpecials, SPECIAL_FOREST_SPELLS))	// 2%
    fModifier += 0.02;
  if (IS_SET(lSpecials, SPECIAL_FOREST_HELP))    // 2%
    fModifier += 0.02;
  if (IS_SET(lSpecials, SPECIAL_HEALER))	// 12%
    fModifier += 0.12;
  if (IS_SET(lSpecials, SPECIAL_PRIEST))	// %2
    fModifier += 0.02;
  if (IS_SET(lSpecials, SPECIAL_BACKSTAB))	// 12%
    fModifier += 0.12;
  if (IS_SET(lSpecials, SPECIAL_BATTLEMAGE))	// 7%
    fModifier += 0.07;
  if (IS_SET(lSpecials, SPECIAL_MANA_THIEF))	// 5%
    fModifier += 0.05;
  if (IS_SET(lSpecials, SPECIAL_HOLY))		// 3%
  {
    //  fModifier += 0.03;
    char mybuf[MAX_STRING_LENGTH]="";
    REMOVE_BIT(GET_SPECIALS(ch), SPECIAL_HOLY);
    sprintf(mybuf, "SYSERR: %s has SPECIAL_HOLY. Removed.", GET_NAME(ch));
    mudlog(mybuf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
  }
  if (IS_SET(lSpecials, SPECIAL_DISGUISE))	// 1%
    fModifier += 0.01;
  if (IS_SET(lSpecials, SPECIAL_ESCAPE))	// 1%
    fModifier += 0.01;
  if (IS_SET(lSpecials, SPECIAL_INFRA))		// 2%
    fModifier += 0.02;
  if (IS_SET(lSpecials, SPECIAL_DWARF))		// 2%
    fModifier += 0.02;
  if (IS_SET(lSpecials, SPECIAL_GROUP_SNEAK))   // 3%
    fModifier += 0.03;
  if (IS_SET(lSpecials, SPECIAL_THIEF))		// 5%
    fModifier += 0.05;
  if (IS_SET(lSpecials, SPECIAL_GORE))		// 5%
    fModifier += 0.05;
  if (IS_SET(lSpecials, SPECIAL_MINOTAUR))	// 8%
    fModifier += 0.08;
  if (IS_SET(lSpecials, SPECIAL_CHARMER))	// 3%
    fModifier += 0.03;
  if (IS_SET(lSpecials, SPECIAL_SUPERMAN))	// 4%
    fModifier += 0.04;
  if (IS_SET(lSpecials, SPECIAL_FLY))		// 2%
    fModifier += 0.02;
  if (IS_SET(lSpecials, SPECIAL_ELF))		// 2%
    fModifier += 0.02;
  if (IS_SET(lSpecials, SPECIAL_TRACKER))	// 3%
    fModifier += 0.03;
  if (IS_SET(lSpecials, SPECIAL_EMPATH))        // 1%
    fModifier += 0.01;
#ifndef IGNORE_DEBUG
  if (GET_DEBUG(ch))
  {
    sprintf(buf, "DBG: specials_modifier = %1.3f\r\n", fModifier);
    send_to_char(buf, ch);
  }
#endif
  return fModifier;
}

// Artus calculate the modifier for ch and return the result.
double calc_modifier(struct char_data *ch)
{
  if (IS_NPC(ch))
    return 1.00;
  GET_MODIFIER(ch) = race_modifiers[GET_RACE(ch)] + 
		     class_modifiers[(int)GET_CLASS(ch)] +
		     special_modifier(ch) + 
		     elitist_modifier(ch) +
		     unholiness_modifier(ch);
  if (GET_MODIFIER(ch) < 0.5)
    GET_MODIFIER(ch) = 0.5;
  else if (GET_MODIFIER(ch) > 2)
    GET_MODIFIER(ch) = 2;
  return GET_MODIFIER(ch);
}

void add_mud_event(struct event_data *ev)
{
  struct event_data *temp = events.list;
  ev->next = NULL;
  
  // Is it the first?
  if(events.list == NULL)
  {
    events.list = ev;
    events.num_events++;
    return;
  }

  // Add it at the end..
  while (temp->next)
    temp = temp->next;
  temp->next = ev;

  events.num_events++;
}

void remove_mud_event(struct event_data *ev)
{
  struct event_data *temp = ev->next;	// Needed for REMOVE_FROM_LIST

  REMOVE_FROM_LIST(ev, events.list, next);
  free(ev);

  events.num_events--;
}

/* Calculate Damage/Heal Amounts. */
int calc_dam_amt(struct char_data *ch, struct char_data *vict, int skillnum)
{
  float dam = 0;

  if ((!ch) || (!vict))
  {
    sprintf(buf, "SYSERR: calc_dam_amt() called without ch or vict! [Skillnum: %d]", skillnum);
    mudlog(buf, NRM, LVL_IMPL, TRUE);
    return 0;
  }

  switch (skillnum)
  {
    case SKILL_BASH:
      dam = GET_LEVEL(ch);
      break;
    case SKILL_BEARHUG:
      dam = GET_LEVEL(ch);
      break;
    case SKILL_BODYSLAM:
      dam = GET_LEVEL(ch);
      dam += number(1, MAX(1, GET_WEIGHT(ch) - 100));
      if (GET_EQ(ch, WEAR_BODY) && !(GET_EQ(vict, WEAR_BODY)))
	dam *= 1.5;
      else if (GET_EQ(vict, WEAR_BODY))
	dam /= 2;
      dam *= MAX(1, STRTODAM(ch));
      break;
    case SKILL_FLYINGTACKLE:
      dam = GET_LEVEL(ch) + (GET_STR(ch) * 2);
      break;
    case SKILL_HEADBUTT:
      dam = GET_LEVEL(ch);
      if (GET_EQ(ch, WEAR_HEAD) && !(GET_EQ(vict, WEAR_HEAD)))
	dam *= 1.5;
      else if (GET_EQ(vict, WEAR_HEAD))
	dam /= 2;
      dam *= MAX(1, STRTODAM(ch));
      break;
    case SKILL_KICK:
      dam = GET_LEVEL(ch);
      break;
    case SKILL_PILEDRIVE:
      dam = GET_HEIGHT(ch) + GET_WEIGHT(ch);
      dam /= 10;
      dam += GET_LEVEL(ch);
      break;
    case SKILL_PRIMAL_SCREAM:
      dam = dice(4, GET_AFF_DEX(ch)) + 6;
      break;
    case SKILL_THROW:
      // The original throw should be fine.
      break;
    case SKILL_TRAP_PIT:
      dam = GET_LEVEL(ch) * 2 + GET_DEX(ch);
      break;
    case SKILL_TRIP:
      dam = GET_LEVEL(ch) * 2 + STRTODAM(ch);
      break;
    default:
      sprintf(buf, "SYSERR: calc_dam_amt called with unexpected skillnum: %d",
	      skillnum);
      mudlog(buf, NRM, LVL_IMPL, TRUE);
      dam = GET_LEVEL(ch);
      break;
  }
  dam = APPLY_SPELL_EFFEC(ch, skillnum, dam);
  dam = APPLY_SKILL(ch, skillnum, dam);
  return (int)(dam);
}

bool aggro_attack(struct char_data *ch, struct char_data *vict, int type)
{
  if (type == AGGRA_PUNISH) // Punish.
  {
    act("$n senses dishonour in you, and attacks with rage!", FALSE, ch, 0,
	vict, TO_VICT);
    act("$n senses dishonour in $N, and attacks with rage!", FALSE, ch, 0,
	vict, TO_NOTVICT);
    hit(ch, vict, TYPE_UNDEFINED);
    return true;
  }
  if (type == AGGRA_HELPER) // Helper.
  {
    // Artus> Mounting.
    if (MOUNTING(ch))
      return false;
    act("$n jumps to the aid of $N!", FALSE, ch, 0, vict, TO_ROOM);
    hit(ch, FIGHTING(vict), TYPE_UNDEFINED);
    return true;
  }
  if (PRF_FLAGGED(vict, PRF_NOHASSLE) ||
      AFF_FLAGGED(vict, AFF_NOHASSLE))
    return false;
  // Artus> Handle Sneak.
  if (AFF_FLAGGED(vict, AFF_SNEAK))
  {
    if (!AFF_FLAGGED(ch, AFF_SENSE_LIFE))
    {
      if (GET_DEX(vict) > 18)
	return false;
      if (number(GET_DEX(vict), 100) > 18)
	return false;
    } else if (GET_DEX(vict) > number(0, 22))
      return false;
    send_to_char("You hear a noise beneath your feet.\r\n", ch);
  }
  if (GET_CHA(ch) > number(0, 22))
  {
    act("$n looks at you with an indifference.", FALSE, ch, 0, vict, TO_VICT);
    return false;
  }
  if (type == AGGRA_AGGR_EVIL)
  {
    act("$n attempts to rid the world of your evil!", FALSE, ch, 0, vict,
	TO_VICT);
    act("$n attempts to rid the world of $N's evil!", FALSE, ch, 0, vict,
	TO_NOTVICT);
  } else if (type == AGGRA_AGGR_GOOD) {
    act("$n cannot bear your goodness a minute longer.", FALSE, ch, 0, vict,
	TO_VICT);
    act("$n cannot bear $N's goodness a minute longer.", FALSE, ch, 0, vict,
	TO_NOTVICT);
  } else {
    act("$n lunges at you.", FALSE, ch, 0, vict, TO_VICT);
    act("$n lunges at $N.", FALSE, ch, 0, vict, TO_NOTVICT);
  }
  hit(ch, vict, TYPE_UNDEFINED);
  return true;
}
  

#define WOLF_FROM 10001 // Citizen of Darask.
// Load the werewolf and vampire on a full moon.
void init_nocturnal(void)
{
  struct char_data *wolf, *vamp, *samp;
  struct descriptor_data *d;
  room_rnum construct = NOWHERE;
  int i;
  ACMD(do_gen_comm);
  void perform_change(struct char_data *ch);

  wolf = NULL; 
  vamp = NULL;

  // Where oh where are we going to load the wolf?..
  for (i = 0; i < 10; i++)
    if ((construct = real_room(10000 + number(1, 15))) > NOWHERE)
      break;
  if (construct != NOWHERE) // Load the wolf and put it there.
  {
    wolf = read_mobile(WOLF_VNUM, VIRTUAL);
    if (wolf)
    {
      samp = read_mobile(WOLF_FROM, VIRTUAL);
      if (samp)
      {
	char_to_room(samp, construct);
	act("$n screams in agony as $e breaks out in hair!", FALSE, samp, NULL,
	    NULL, TO_ROOM);
	do_gen_comm(samp, "What the heck is happenaarghhHHHHHHHHOOOOOOOOWWWW--", 0,
	            SCMD_HOLLER);
	extract_char(samp);
	do_gen_comm(wolf, "--WWWWLLLLLLLL!!!!!!!!", 0, SCMD_HOLLER);
	char_to_room(wolf, construct);
      } else {
	char_to_room(wolf, construct);
	do_gen_comm(wolf,"HHHHHHHHOOOOOOOOWWWWWWWWLLLLLLLL!!!!!!!!",0,
	            SCMD_HOLLER);
	act("$n has arrived.", TRUE, wolf, NULL, NULL, TO_ROOM);
      }
    }
  }

  // Where oh where are we going to load the vamp?..
  for (i = 0; i < 10; i++)
    if ((construct = real_room(1600 + number(0, 104))) > NOWHERE)
      break;
  if (construct != NOWHERE) // Load the vamp and put it there.
  {
    vamp = read_mobile(VAMP_VNUM, VIRTUAL);
    if (vamp)
    {
      char_to_room(vamp, construct);
      act("$n has arrived.", TRUE, wolf, NULL, NULL, TO_ROOM);
    }
  }
  // Change infected players.
  for (d = descriptor_list; d; d = d->next)
  {
    if (!(d->character) || (STATE(d) != CON_PLAYING) || 
	!(PRF_FLAGGED(d->character, PRF_WOLF) || 
	  PRF_FLAGGED(d->character, PRF_VAMPIRE)))
      continue;
    perform_change(d->character);
  }
}

// Remove wolves/vampires from the game when the sun rises.
void exit_nocturnal(void)
{
  extern struct index_data *mob_index;
  struct char_data *vict, *next_vict = NULL;
  
  for (vict = character_list; vict; vict = next_vict)
  {
    next_vict = vict->next;
    if (!IS_NPC(vict))
    {
      if (affected_by_spell(vict, SPELL_CHANGED))
      {
	affect_from_char(vict, SPELL_CHANGED);
	send_to_char("You return to your original form.\r\n",vict);
	if(PRF_FLAGGED(vict,PRF_WOLF))
	  sprintf(buf,"$n whimpers in pain as $e returns to $s original form.");
	else if(PRF_FLAGGED(vict,PRF_VAMPIRE))
	  sprintf(buf,"$n's fangs retract as $e returns to normal.");
	else
	  sprintf(buf,"$n pulls a pair of fake fangs out of $s mouth.");
	act(buf,FALSE,vict,0,0,TO_ROOM);
      }
      continue;
    }
    if ((GET_MOB_VNUM(vict) != WOLF_VNUM) &&
	(GET_MOB_VNUM(vict) != VAMP_VNUM))
      continue;
    if (FIGHTING(vict))
    {
      stop_fighting(FIGHTING(vict));
      stop_fighting(vict);
    }
    act("$n spontaneously combusts before your very eyes!", TRUE, vict, NULL,
	NULL, TO_ROOM);
    extract_char(vict);
  }
}

// Read Auction List from File.
void init_auctions(void)
{
  extern struct auc_data *auc_list;
  struct auc_data *lot, *prev=NULL;
  struct auc_file_elem tmp_store;
  struct obj_data *obj;
  struct obj_data *Obj_from_store(struct obj_file_elem object, int *location);
  room_rnum auc_room;
  FILE *fl;
  int dummy=0;

  auc_room = real_room(AUC_ROOM);

  // Hopefully this is a waste of time :o)
  if (auc_list != NULL)
  {
    basic_mud_log("WARNING: auc_list was not null! [idnum: %d, sellerid: %ld]",
	          auc_list->idnum, auc_list->sellerid);
    auc_list = NULL;
  }

  if (!(fl = fopen(AUC_FILE, "rb")))
    return;

  fread(&tmp_store, sizeof(struct auc_file_elem), 1, fl);
  while (!feof(fl))
  {
    if (!(obj = Obj_from_store(tmp_store.obj, &dummy)))
    {
      basic_mud_log("SYSERR: Failed to read object #%d", 
	            tmp_store.obj.item_number);
      continue;
    }
    obj_to_room(obj, auc_room);
    CREATE(lot, struct auc_data, 1);
    memset(lot->buyername, '\0', MAX_NAME_LENGTH+1);
    memset(lot->sellername, '\0', MAX_NAME_LENGTH+1);
    lot->idnum = tmp_store.idnum;
    lot->sellerid = tmp_store.sellerid;
    strncpy(lot->sellername, tmp_store.sellername, MAX_NAME_LENGTH);
    lot->buyerid = tmp_store.buyerid;
    strncpy(lot->buyername, tmp_store.buyername, MAX_NAME_LENGTH);
    lot->offer = tmp_store.offer;
    lot->obj = obj;
    lot->next = NULL;
    if (!(prev))
      auc_list = lot;
    else
      prev->next = lot;
    prev = lot;
/*    basic_mud_log("Auction %d: Obj: %d (%s); Seller %d (%s); Offer %d", 
	          lot->idnum, tmp_store.obj.item_number, 
		  lot->obj->short_description, lot->sellerid, lot->sellername,
		  lot->offer); */
    fread(&tmp_store, sizeof(struct auc_file_elem), 1, fl);
  }
  fclose(fl);
}

// Artus> Make sure the character is in the list.
struct char_data *is_valid_char(struct char_data *ch)
{
  for (struct char_data *i = character_list; i; i = i->next)
    if (i == ch)
      return i;
  return NULL;
}

// Artus> Add a player to the immlist. Can also be used for updating.
void add_to_immlist(char *name, long idnum, long immkills, ubyte unholiness)
{
  extern struct imm_list_element *immlist_table;
  struct imm_list_element *k, *noob;
  // Beginning of list.
  if (!immlist_table)
  {
    CREATE(immlist_table, struct imm_list_element, 1);
    immlist_table->name = str_dup(name);
    immlist_table->id = idnum;
    immlist_table->kills = immkills;
    immlist_table->unholiness = unholiness;
    immlist_table->next = NULL;
    return;
  }
  // Updating.
  for (k = immlist_table; k->next; k = k->next)
    if (k->id == idnum)
    {
      k->kills = immkills;
      k->unholiness = unholiness;
      return;
    }
  if (k->id == idnum)
  {
    k->kills = immkills;
    k->unholiness = unholiness;
    return;
  }
  // Append list.
  CREATE(noob, struct imm_list_element, 1);
  noob->name = str_dup(name);
  noob->id = idnum;
  noob->kills = immkills;
  noob->unholiness = unholiness;
  k->next = noob;
  noob->next = NULL;
}

// Artus> Update teh questlist.
void update_questlist(struct char_data *vict, int qitemno)
{
  struct questlist_element *k;
  if (GET_QUEST_ITEM(vict, qitemno) == 0)
    return;
  for (k=questlist_table; k; k=k->next)
    if (k->objdata.vnum == GET_QUEST_ITEM(vict, qitemno))
      break;
  if (!k)
    return;
  memcpy(&k->objdata, &GET_QUEST_ITEM_DATA(vict, qitemno),
         sizeof(struct quest_obj_data));
}

// Artus> Add data to quest list.
void add_to_questlist(char *name, long idnum, struct quest_obj_data *item)
{
  struct questlist_element *k, *noob;

  CREATE(noob, struct questlist_element, 1);
  noob->name = str_dup(name);
  noob->id = idnum;
  memcpy(&noob->objdata, item, sizeof(struct quest_obj_data));
  noob->objrnum = real_object(noob->objdata.vnum);
  noob->next = NULL;
  if (!(questlist_table))
  {
    questlist_table = noob;
    return;
  }
  for (k = questlist_table; k; k = k->next)
    if (!(k->next))
    {
      k->next = noob;
      return;
    }
}

// Write Auction List to File.
void write_auction_file(void)
{
  extern struct auc_data *auc_list;
  struct auc_data *lot;
  struct auc_file_elem tmp_store;
  void Obj_to_file_elem(struct obj_data *obj, struct obj_file_elem *dest, 
			int location);
  FILE *fl;

  if (!(fl = fopen(AUC_FILE, "wb")))
    return;

  for (lot = auc_list; lot; lot = lot->next)
  {
    memset(&tmp_store.sellername, '\0', MAX_NAME_LENGTH+1);
    memset(&tmp_store.buyername, '\0', MAX_NAME_LENGTH+1);
    tmp_store.idnum = lot->idnum;
    tmp_store.sellerid = lot->sellerid;
    strncpy(tmp_store.sellername, lot->sellername, MAX_NAME_LENGTH);
    tmp_store.buyerid = lot->buyerid;
    tmp_store.offer = lot->offer;
    strncpy(tmp_store.buyername, lot->buyername, MAX_NAME_LENGTH);
    Obj_to_file_elem(lot->obj, &tmp_store.obj, 0);
    fwrite(&tmp_store, sizeof(struct auc_file_elem), 1, fl);
  }
  fflush(fl);
  fclose(fl);
}
@


1.55
log
@Artus> Changed a couple of LVL_IMMORTS to LVL_IMMORT+1, LVL_IS_GOD and
       LVL_ISNOT_GOD
@
text
@d1443 1
d1453 1
d1575 17
@


1.54
log
@Artus> Fixed crash / memory leak.
@
text
@d177 1
a177 1
  if (!LR_FAIL(ch, LVL_IMMORT+1))
d262 1
a262 1
  if (!LR_FAIL(ch, LVL_IMMORT))
d364 1
a364 1
  if (IS_NPC(ch)) {
d366 13
a378 17
  } else {
    switch (can_wear_finger(ch, where))
    {
      // wear position is finger, but position restricted by class
      case 0:
        return FALSE;
      // wear position is finger, can use position
      case 1:
        return TRUE;
      // wear position is not finger
      default:       
        // Race restricted positions - rest
        // Use the mask defined in the array for each race, check if the wear
        // bit is set. 
        if (IS_SET(pc_race_eq_masks[GET_RACE(ch)], (1 << where)))
          return TRUE;
    }
d380 2
d1447 3
a1449 1
  return (double)(GET_UNHOLINESS(ch) * 0.025);
@


1.53
log
@Artus> slightly modified eq_pos_ok.
@
text
@a1990 3
//	    add_to_questlist(dummy.name, dummy.idnum,
//			     dummy.player_specials_primalsaved.quest_eq[i]);

@


1.52
log
@Artus> add_to_questlist(), update_questlist().
@
text
@d361 2
a362 2
int eq_pos_ok(struct char_data *ch, int where) {

d367 2
a368 2

    switch (can_wear_finger(ch, where)) {
a371 1

a374 1

a377 1
    
d380 2
a381 3
        if (IS_SET(pc_race_eq_masks[GET_RACE(ch)], (1 << where))) { 
          return TRUE;           
        } 
@


1.51
log
@Artus> Changed immlist to keep a list in memory instead of reading from disk.
@
text
@d40 1
d1956 42
@


1.50
log
@Artus> Mounting chars will no longer attack as helpers.
@
text
@d1915 40
@


1.49
log
@Artus> Fixed bug in NOHASSLE.
@
text
@d1692 3
@


1.48
log
@Artus> Improved sneak/sense life checks in aggro routine.
@
text
@a1680 6
  if (type == AGGRA_HELPER) // Helper.
  {
    act("$n jumps to the aid of $N!", FALSE, ch, 0, vict, TO_ROOM);
    hit(ch, FIGHTING(vict), TYPE_UNDEFINED);
    return true;
  }
d1690 9
@


1.47
log
@Artus> Aggro changes.
@
text
@d1699 7
a1705 3
    if (AFF_FLAGGED(ch, AFF_SENSE_LIFE) && (number(0, 3) == 0))
      return false;
    if (number(0, 25) <= GET_DEX(vict))
d1707 1
@


1.46
log
@Artus> Moved all the quest event stuff to quest.[ch].
       Added trivia quest type.
@
text
@d1679 50
@


1.45
log
@Artus> find_quest_event();
@
text
@a1575 10
// Artus> Find a quest event.
struct event_data *find_quest_event()
{
  struct event_data *temp;
  for (temp = events.list; temp; temp = temp->next)
    if (temp->type == EVENT_QUEST)
      return temp;
  return NULL;
}

@


1.44
log
@Artus> Unholy Vengeance.
@
text
@a1449 1
  float fModifier = 0.0;
d1576 10
@


1.43
log
@Artus> Added is_valid_char(), checks for char in character_list.
@
text
@d1263 6
a1268 3
    if (!i->connected && !PLR_FLAGGED(i->character, PLR_WRITING)) {
      if (!(PRF_FLAGGED(i->character, PRF_NOINFO) )) {
        if ( CAN_SEE(i->character, ch) ) {
d1448 8
@


1.42
log
@Artus> Now warning free :o)
@
text
@d26 1
a1738 1
  extern struct char_data *character_list;
d1835 9
@


1.41
log
@Artus> Conditionals for IGNORE_DEBUG.
       Fixed some logging issues.
@
text
@d166 4
a169 3
int max_stat_value(struct char_data *ch, int stat) {

  if (IS_NPC(ch)) {
d208 1
a208 1
        return (int) ((pc_max_class_points[GET_CLASS(ch)][stat-6] * GET_LEVEL(ch))
d236 1
a236 1
      return (int) ((pc_max_class_points[GET_CLASS(ch)][stat-6] * 
d243 2
d248 2
a249 2
int train_cost(struct char_data *ch, int stat, int curr_value) {

d253 2
a254 1
  if (IS_NPC(ch)) {
d270 2
a271 1
  switch (stat) {
d322 2
d326 29
a354 29
// returns -1 if where position is not finger,
//          0 if where position is finger, but char cant use that position 
//          1 if where position is finger, and char can use that position
int can_wear_finger(struct char_data *ch, int where) {

  const byte finger_positions[NUM_CLASSES] = {
    3, // Mage
    2, // Cleric    
    2, // Thief
    1, // Warrior
    5, // Druid
    3, // Priest
    3, // Nightblade
    4, // Battlemage
    4, // Spellsword
    3, // Paladin
    5  // Master
  };
        
  // Class restricted positions - fingers 
  if (where == WEAR_FINGER_1 || where == WEAR_FINGER_2) { 
    return (where <= finger_positions[GET_CLASS(ch)]);
  }

  // (reminder - WEAR_FINGER_3 is 18, and does not procede WEAR_FINGER_2 = 2
  // hence difference is 15 (WEAR_FINGER_3 (18) - 15 = 3
  if (where >= WEAR_FINGER_3 && where <= WEAR_FINGER_5) { 
    return ((where-15) <= finger_positions[GET_CLASS(ch)]);
  }
d356 1
a356 1
  return -1;
a1209 2
  int return_val = 1;
  int class_index = GET_CLASS(ch);
a1782 1
  extern struct index_data *obj_index;
d1792 1
a1792 1
    basic_mud_log("WARNING: auc_list was not null! [idnum: %d, sellerid: %d]",
a1840 1
  extern struct index_data *obj_index;
a1842 1
  int j;
@


1.40
log
@Artus> Modified log_death_trap, to show different DT types.
       SPECIAL_HOLY will now be removed from players.
@
text
@d733 2
a734 1
  for (i = descriptor_list; i; i = i->next) {
d741 5
a745 6
    if (type < DBG)
      tp = ((PRF_FLAGGED(i->character, PRF_LOG1) ? 1 : 0) +
	    (PRF_FLAGGED(i->character, PRF_LOG2) ? 2 : 0));
    else
      tp = (GET_DEBUG(i->character) ? DBG : 0);
    if ((GET_LEVEL(i->character) >= LVL_GOD) && tp < type)
a746 1

d1109 1
d1115 1
d1550 1
d1556 1
a1556 1

@


1.39
log
@Artus> Removed an unused var i stumbled across.
@
text
@d599 21
d621 1
a621 1
void log_death_trap(struct char_data * ch)
d623 1
a623 1
  char buf[256];
d625 19
a643 1
  sprintf(buf, "%s hit death trap #%d (%s)", GET_NAME(ch),
d645 1
a645 1
  mudlog(buf, BRF, LVL_IMMORT, TRUE);
d1494 1
a1494 1
    	fModifier += 0.02;				
d1496 1
a1496 1
	fModifier += 0.02;
d1498 1
a1498 1
	fModifier += 0.09;
d1500 1
a1500 1
	fModifier += 0.02;
d1502 1
a1502 1
	fModifier += 0.02;
d1504 1
a1504 1
	fModifier += 0.12;
d1506 1
a1506 1
	fModifier += 0.02;
d1508 1
a1508 1
	fModifier += 0.12;
d1510 1
a1510 1
	fModifier += 0.07;
d1512 1
a1512 1
	fModifier += 0.05;
d1514 7
a1520 1
	fModifier += 0.03;
d1522 1
a1522 1
	fModifier += 0.01;
d1524 1
a1524 1
	fModifier += 0.01;
d1526 1
a1526 1
	fModifier += 0.02;
d1528 1
a1528 1
	fModifier += 0.02;
d1530 1
a1530 1
	fModifier += 0.03;
d1532 1
a1532 1
	fModifier += 0.05;
d1534 1
a1534 1
	fModifier += 0.05;
d1536 1
a1536 1
	fModifier += 0.08;
d1538 1
a1538 1
	fModifier += 0.03;
d1540 1
a1540 1
	fModifier += 0.04;
d1542 1
a1542 1
	fModifier += 0.02;
d1544 1
a1544 1
	fModifier += 0.02;
d1546 1
a1546 1
        fModifier += 0.03;
d1548 3
a1550 2
        fModifier += 0.01;
  if (GET_DEBUG(ch)) {
@


1.38
log
@Artus> increased modifier bonus.
@
text
@d1547 1
a1547 1
  struct obj_data *obj;
@


1.37
log
@Artus> Added DBG target for mudlog, shown only to chars with DEBUG set on.
       Changed the way the event list is added to / removed from slightly.
@
text
@d1413 1
a1413 1
	fModifier -= 0.3;
d1415 1
a1415 1
	fModifier -= 0.2;
d1418 1
a1418 1
      fModifier -= 0.15;
d1420 2
a1422 2
    else if (i > 5)
      fModifier -= 0.05;
d1427 3
a1429 1
    fModifier -= 0.2;
d1431 1
a1431 1
    fModifier -= 0.15;
d1433 1
a1433 1
    fModifier -= 0.125;
d1435 1
a1435 1
    fModifier -= 0.1;
d1437 1
a1437 1
    fModifier -= 0.075;
d1439 1
a1439 1
    fModifier -= 0.05;
d1441 1
a1441 1
    fModifier -= 0.025;
@


1.36
log
@Artus> remove_event => remove_mud_event, to differ from dgscripts remove_event.
@
text
@d701 5
a705 2
    tp = ((PRF_FLAGGED(i->character, PRF_LOG1) ? 1 : 0) +
	  (PRF_FLAGGED(i->character, PRF_LOG2) ? 2 : 0));
d1071 5
d1512 2
a1513 1
  struct event_data *temp;
d1523 4
a1526 4
  // Add it after the leader
  temp = events.list->next;
  events.list->next = ev;
  ev->next = temp;
d1533 1
a1533 1
  struct event_data *temp; 		// Needed for REMOVE_FROM_LIST
@


1.35
log
@Artus> Cleaned up.
@
text
@d1522 1
a1522 1
void remove_event(struct event_data *ev)
@


1.34
log
@Artus> Minor changes to calc_dam_amt.. Removed axethrow, added trap_pit.
@
text
@d1502 1
a1502 1
void add_event(struct event_data *ev)
d1504 14
a1517 14
	struct event_data *temp;
	
	// Is it the first?
	if(events.list == NULL)
	{
	  	events.list = ev;
		events.num_events++;
		return;
	}

	// Add it after the leader
	temp = events.list->next;
	events.list->next = ev;
	ev->next = temp;
d1519 1
a1519 1
	events.num_events++;
d1524 1
a1524 1
	struct event_data *temp; 		// Needed for REMOVE_FROM_LIST
d1526 2
a1527 2
	REMOVE_FROM_LIST(ev, events.list, next);
	free(ev);
d1529 1
a1529 1
	events.num_events--;
@


1.33
log
@Artus> SPECIAL_EMPATH
@
text
@a1545 10
    case SKILL_AXETHROW:
      if (!ch->carrying)
        return(-1);
      obj = NULL;
      for (obj = ch->carrying; obj; obj = obj->next_content)
        if (is_axe(obj))
          break;
      if (obj == NULL)
        return(-1);
      break;
d1585 4
a1590 1
      // The original trip should be fine.
@


1.32
log
@Artus> init_nocturnal(), exit_nocturnal().
       APPLY_SPELL_EFFEC
@
text
@d1492 2
a1493 1

d1683 1
a1683 1
  struct char_data *vict, *next_vict;
@


1.31
log
@Artus> 2nd/3rd now check has_stats_for_skill.
       3rd will not work without 2nd.
@
text
@d1534 1
a1534 1
  double dam = 0;
d1540 1
d1605 2
a1606 2
  dam *= SPELL_EFFEC(ch, skillnum) / 100;
  dam *= GET_SKILL(ch, skillnum) / 100;
d1610 107
@


1.30
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d1277 5
a1281 2
  if (!IS_NPC(ch)) {
    if (GET_SKILL(ch,SKILL_3RD_ATTACK) > 0)
d1283 2
a1284 1
    else if (GET_SKILL(ch,SKILL_2ND_ATTACK) > 0)
@


1.29
log
@Artus> Moving stuff across to live.

act.informative.c:
  Info on it's own will now display the info file. Use me or self to see your
own info.
  Score and Exp now both show gained and remaining exp.
  Gold value is now to a max of 30000. (60000 in lvl 40+ zones, 120 in 70+)
  Gold rushes no longer occur in !GOLDRUSH zones, city sectors, etc.

act.other.c:
  Mana retained on remort is now floored at 100 instead of 50.
  Added elitist bonus for chars who play past the earliest remort point(s).

act.wizard.c:
  Gold rush events are now only advertised within the world they occur.

genolc.h:
  Added special #defines for different OLC levels whether running live or test.
  (Noted by compiling with -DPRIMAL_LIVE)

interpreter.c:
  Aliases will now be saved automatically, when added or remoed.
  Added elitist_modifier() to modifier calculation.
  Replaced Huh?!? with HUH.

limits.c:
  NPC corpses are no longer emptied before they are purged. Too much clutter.

spells.c:
  Reduced the amount of weight applied by create water to 1/3 of what it was.

comm.c:       Added send_to_not_zone_world()
db.c:         Added elitist_modifier() to modifier calculation.
dg_mobcmd.c:  Replaced Huh?!? with the define, HUH.
dg_scripts.h: Changed version string so it will fit on one line :o)
fight.c:      Eq should no longer be damaged when a hit fails.
handler.c:    Now, when the sleep spell wears of an NPC, it will wake up.
structs.h:    Added HUH define.
utils.c:      Added elitist_modifier() calculation.
utils.h:      Added elitist_modifier() prototype.
@
text
@a28 1
extern struct auction_lot avail_lots[MAX_LOTS];
d174 3
a176 2
  if (GET_LEVEL(ch) > LVL_IMMORT) {
    switch (stat) {
a191 1
  }
d194 3
a196 2
  if (GET_CLASS(ch) == CLASS_MASTER) {
    switch (stat) {
a211 1
  }
d216 2
a217 1
  switch (stat) {
d235 2
a236 2
      return (int) ((pc_max_class_points[GET_CLASS(ch)][stat-6] * GET_LEVEL(ch))
                      / 100);
d256 1
a256 1
  if (GET_LEVEL(ch) > LVL_IMMORT) {
a257 1
  }
d391 3
d697 1
a697 1
    if (GET_LEVEL(i->character) < level)
d1066 1
a1066 1
  if (GET_LEVEL(ch) < spell_info[skillnum].min_level[(int) GET_CLASS(ch)]) 
d1158 1
a1158 1
  if (GET_LEVEL(ch) >= LVL_IMPL) 
d1194 1
a1194 1
  if (GET_LEVEL(ch)==LVL_IMPL || GET_LEVEL(ch2)==LVL_IMPL)
d1295 1
a1295 1

d1385 1
d1526 171
@


1.28
log
@Artus>
\r\n appended to gold rush message: act.informative.c

Imms no longer affected by underwater: act.movement.c, limits.c

Changed remort some more.. New special, tracker (SPECIAL_TRACKER):
act.other.c, act.wizard.c, constants.c, graph.c, structs.h, utils.c

Object and Room triggers can now %send% <room vnum> <message>:
dg_objcmd.c, dg_wldcmd.c

%self.direction% now has a vnum subfield to return the exit room's vnum.
(Eg: %self.north(vnum)%): dg_scripts.c

%actor.hisher%, %actor.himher%, %actor.heshe% implemented: dg_scripts.c

vnum, name, can_see, can_see_me added to %actor.next_in_room%, returning char
vnum, char name, if actor can see char, and if char can see actor respectively:
dg_scripts.c

Changed "do not know that spell" to "do not know of that spell": spell_parser.c

Changed "do not of know that skill/spell" to "do not know of..": utils.c

SECT_UNDERWATER and SECT_INSIDE now checked in OUTSIDE() macro: utils.h
@
text
@d1384 45
@


1.27
log
@Artus> Breakin now requires mount skill, and is tested vs it.
       Remort ability list changed some more, also remort ability parser.
       DGScript Force/Teleport commands now tell >=LVL_ANGEL what they were
       trying to do..
       MultiWeapon is once more required for dual wield.
       Lowered exp gained whilst grouping by about 30%.
@
text
@d1069 1
a1069 1
	send_to_char("You do not of know that skill!\r\n", ch);
d1071 1
a1071 1
	send_to_char("You do not of know that spell!\r\n", ch);
d1436 4
a1439 2
  if (IS_SET(lSpecials, SPECIAL_ELF))		// 5%
	fModifier += 0.05;
@


1.26
log
@Artus> Changed remort, in particular, list remort abilities to char.. Also,
       spellsword was incorrectly being listed as a possible path for a
       warrior.

       Replaced #ifdef USE_LOCALTIME with #ifndef NO_LOCALTIME..

       Added define NOTELL_SOUNDPROOF .. Define this to stop people telling
       to/from soundproof rooms.

       Removed extraneous level checking from do_wear.. This is handled
       better by perform_wear.
@
text
@d1436 2
a1437 2
  if (IS_SET(lSpecials, SPECIAL_ELF))		// 7%
	fModifier += 0.07;
@


1.25
log
@Artus>
---
drop_otrigger takes an extra paramater for subcmd. With drop triggers you can
now specify whether the trigger is for drop, junk, donate and put. Specify
in the argument either/combination of 'junk', 'drop', 'donate', 'put'. No
argument means any type will be triggered:

act.item.c, dg_scripts.h, dg_triggers.c, interpreter.h
---
fixed colour bleed in dc:

act.wizard.c
---
Not reapplying empty timers in char_to_store:
Not calling object triggers from char_to_store:

db.c
---
Modified hunt so that with special_elf you can track through !TRACK rooms
(Modifier for Elf has been increased from 0.02 to 0.07%):

graph.c, utils.c
---
Timers should only show remove messages when being removed because they're
wearing off (duration = 0):

handler.c
---
Not calling object triggers when auto_equipping.

objsave.c
---
#defined around love_ring specproc. What a joke. define DRAX_IS_TEH_SUXOR if
you want it back ;o)

spec_assign.c, spec_procs.c
---
@
text
@d61 1
a61 1
#ifndef USE_LOCALTIME
d617 1
a617 1
#ifdef USE_LOCALTIME
d643 1
a643 1
#ifdef USE_LOCALTIME
@


1.24
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@d1436 2
a1437 2
  if (IS_SET(lSpecials, SPECIAL_ELF))		// 2%
	fModifier += 0.02;
@


1.23
log
@Artus> Sorry, Dish.. Another bastard change..

       has_stats_for_skill now takes an extra arg (bool) to determine whether
       or not to display messages.

       new routine: has_stats_for_prac.. Basically the same as
       has_stas_for_skill, without GET_SKILL(ch, i) == 0 check..

       Force is now restricted for <GRGOD.

       Score no longer displays punishment lines twice.

       New macro: IS_SKILL(skillnum) .. Used to determine whether skillnum is
                  a skill.
@
text
@d170 1
a170 1
    log("SYSERR: mobile passed to max_stat_value");
d189 1
a189 1
        log("SYSERR: Invalid stat value passed to max_stat_value"); 
d210 1
a210 1
        log("SYSERR: Invalid stat value passed to max_stat_value"); 
d239 1
a239 1
      log("SYSERR: Invalid stat value passed to max_stat_value"); 
d251 1
a251 1
    log("SYSERR: mobile passed to train_cost");
d278 3
a280 3
//      log("stat_costs[max (%d) - current (%d)] = %d", max_stat_value(ch, stat), curr_value, tempi1);
//      log("stat_mods[stat (%d) + 1] = %f", curr_value, tempf1);
//      log("1 * 2 = %d", tempi2);
d305 2
a306 2
//      log("current point value (%d) / (char level (%d) * 10) = %0.2f", curr_value, GET_LEVEL(ch), tempf1);
//      log("level_exp (%d) / max stat val (%d) = %0.2f", level_exp(ch, GET_LEVEL(ch)), max_stat_value(ch, stat), tempf2); 
d310 1
a310 1
//      log("1 / 2 = %0.2f", tempf2);
d315 1
a315 1
      log("SYSERR: Invalid stat value passed to max_stat_value"); 
d479 1
a479 1
    log("SYSERR: number() should be called with lowest, then highest. number(%d, %d), not number(%d, %d).", from, to, to, from);
d563 1
a563 1
    log("SYSERR: str_cmp() passed a NULL pointer, %p or %p.", arg1, arg2);
d586 1
a586 1
    log("SYSERR: strn_cmp() passed a NULL pointer, %p or %p.", arg1, arg2);
d663 1
a663 1
    log("SYSERR: %s: %s", path, strerror(errno));
d686 1
a686 1
    log("%s", str);
d959 1
a959 1
    log("SYSERR: NULL pointer or empty string passed to get_filename(), %p or %p.",
d1042 1
a1042 1
  log("SYSERR: Assertion failed at %s:%d!", who, line);
@


1.22
log
@Work done at artus house a while ago
@
text
@d1059 1
a1059 2
/* check if player has minimum stats to use this skill */
int has_stats_for_skill(struct char_data *ch, int skillnum)
d1063 22
a1084 3
 
  if (GET_REAL_STR(ch) < spell_info[skillnum].str[class_index]) {
    send_to_char("You don't have the natural strength to use this skill\n\r", ch);
d1087 10
a1096 3

  if (GET_REAL_INT(ch) < spell_info[skillnum].intl[class_index]) {
    send_to_char("You don't have the natural intelligence to use this skill\n\r", ch);
d1099 10
a1108 3

  if (GET_REAL_WIS(ch) < spell_info[skillnum].wis[class_index]) {
    send_to_char("You don't have the natural wisdom to use this skill\n\r", ch);
d1111 10
a1120 3

  if (GET_REAL_DEX(ch) < spell_info[skillnum].dex[class_index]) {
    send_to_char("You don't have the natural dexterity to use this skill\n\r", ch);
d1123 10
a1132 3

  if (GET_REAL_CON(ch) < spell_info[skillnum].con[class_index]) {
    send_to_char("You don't have the natural constitution to use this skill\n\r", ch);
d1135 10
a1144 3

  if (GET_REAL_CHA(ch) < spell_info[skillnum].cha[class_index]) {
    send_to_char("You don't have the natural charisma to use this skill\n\r", ch);
a1146 1
 
d1148 22
@


1.21
log
@Latest Version
@
text
@d513 4
@


1.20
log
@Artus> Localtime fix.
@
text
@d194 20
d626 1
a626 1
    sprintf(time_s, "%04d-%02d-%02d %02d:%02d:%02d ", (1900 + lt.tm_year), lt.tm_mon, lt.tm_mday, lt.tm_hour, lt.tm_min, lt.tm_sec);
a1305 1
// DM - TODO - work this out
d1360 5
@


1.19
log
@
Modified: DM

Changed:
- Don't ask (large group checkin) - lots of bug fixes mainly.
- Use cvs diff if you really wanna see the changes.
@
text
@d42 1
a42 1
// DM - temporary localtime, till the deb libs are fixed
d59 77
d137 1
a137 1

d593 1
a593 1
  /*
d599 2
a600 1
  */
d603 5
a607 1
  strcpy(time_s, "SORRY!");
d619 1
d621 3
@


1.18
log
@
Modified: DM

Changed:
- temporary fix for deb library crash due to localtime() call
 overridden localtime() function ...
@
text
@d42 1
a42 1
// DM - temporary overrise of localtime, till the deb libs are fixed
@


1.17
log
@
Modified: DM

Changed:
- fixed quest_obj_ok to check and return correct vale
@
text
@d41 22
a512 2
  time_t ct = time(0);
  char *time_s = asctime(localtime(&ct));
d514 13
@


1.16
log
@*** empty log message ***
@
text
@d49 1
d53 1
a53 1
  if (!OBJ_FLAGGED(obj, ITEM_QUEST)) {
@


1.15
log
@
Modified: DM

Changed:
- CAP() to capitalise the first displayed char in a given string rather the
  first character (to ignore capitalisation of colour codes)
@
text
@d41 4
a44 3
// returns the number of characters which will be displayed on the screen
// taking the colour codes out ...
int strdisplen(char *string) {
d46 17
@


1.14
log
@
Modified: DM

Changed:
- finished fixing up score?
- added strdisplen function (colour.c)
- paging fix up
@
text
@d377 2
a378 1
  *txt = UPPER(*txt);
@


1.13
log
@Modified: DM

Changed:
- only comments
@
text
@d41 5
@


1.12
log
@*** empty log message ***
@
text
@d41 1
d218 1
a218 1
      // where position is finger, but position restricted by class
d222 1
a222 1
      // where position is finger, can use position
d226 1
a226 1
      // where position is not finger
d230 1
a230 1
        // Use the mask defined in the array for each race, check if the where 
@


1.11
log
@Added group leave message (when Player leaves a group)
@
text
@d1144 1
d1147 49
d1197 1
a1197 4
  // accumulate the additional modifier cost for each of the specials in
  // SPEC_FLAGGED (ch->player_specials.primalsaved.misc_specials; 
  
  return 0.0;
@


1.10
log
@
Changed:
- get_world(struct char_data *ch) -> get_world(room_rnum room)
@
text
@d683 11
a699 1

@


1.9
log
@
Changed:
- minor formatting in get_world
@
text
@d920 2
a921 1
int get_world(struct char_data *ch)
d926 2
a927 2
  if (!ch)
    return (1);
d931 2
a932 1
  zone = zone_table[world[IN_ROOM(ch)].zone].world;
a933 2
  log("zone: %d",zone);
 
d941 1
a941 1
  return (get_world(ch) == get_world(ch2));
@


1.8
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d925 3
a927 2
        if (!ch)
                return(1);
d934 1
a934 1
  return zone-1;
@


1.7
log
@
Added:
- stat and training functions
@
text
@d798 4
@


1.6
log
@
Added:
- new eq position functions
- check in str_dup if source is NULL, previously it would just crash
@
text
@d39 137
d181 1
a181 1
  const byte finger_positions[MAX_RACES] = {
@


1.5
log
@
Added:
- Cant remember
@
text
@d39 64
d244 7
a250 2
  CREATE(new_z, char, strlen(source) + 1);
  return (strcpy(new_z, source));
a364 1

d368 3
d395 1
a395 1
    if (tp < type)
a397 1
//    send_to_char(CCGRN(i->character, C_NRM), i->character);
a398 1
//    send_to_char(CCNRM(i->character, C_NRM), i->character);
@


1.4
log
@
Added:

- Changes on the latest circle snapshot:
========================================
1/23/2000

no -- gg - constants.c/structs.h: Welcome to bpl18.

no -- gg - Makefile.lcc: Remove some constants I have to change every patch.

no -- gg - doc/README.CYGWIN: bpl17 -> bpl18

7/3/2000

no -- gg - doc/license.doc: Add copyright information that seems lacking
        elsewhere.

no -- gg - build_circlemud.com: Update from author.

yes -- gg - utils.h: -1 => NOBODY/NOWHERE/NOTHING cleanups.

yes (and other relevant ROOM flags)
-- gg - spells.c: spell_teleport(): No teleporting into ROOM_GODROOM.

yes -- gg - spec_procs.c: Restrict pets to NPCs.

yes? -- gg - interpreter.c: is_abbrev(): s/returnss/returns/

yes -- gg - handler.c: affect_join(): Keep 'next' pointer for extracted
        objects in list.

no -- gg - act.wizard.c: perform_immort_invis(): Remove redundant
        IS_NPC check.

yes ? -- gg - utils.c: basic_mud_log(): Cancel message if stream hasn't
        been initialized.

7/7/2000

yes ? -- gg - utils.c: mudlog(): log(var) => log("%s", var); to avoid
        interpreting %% codes.

yes - drink aliases no -- gg - db.c: parse_object(): Print the offending character.
        check_object(): Drink aliases should last now.  The code
        to remove the aliases shouldn't care where it is, though.

no -- gg - act.item.c: name_from_drinkcon()/name_to_drinkcon():
        Much more intelligent support for removing/adding the
        drink name to containers.

no -- gg - lib/world/obj/0.obj: An extra ~ escaped the removal of
        object #99.
@
text
@d313 1
a313 1
  sprintf(buf, "[ %s ]\r\n", str);
d327 1
a327 1
    send_to_char(CCGRN(i->character, C_NRM), i->character);
d329 1
a329 1
    send_to_char(CCNRM(i->character, C_NRM), i->character);
@


1.3
log
@

Added:
- Events
-

Changed:
- Score command
-

TODO:
- Finish the base
-
@
text
@d262 1
a262 1
  if (logfile == NULL)
d264 3
d269 1
a269 1

d306 6
a311 6
  if (str == NULL)
    return;	/* eh, oh well. */
  if (file)
    log(str);
  if (level < 0)
    return;
@


1.2
log
@my new skills!


Added:
-
-

Removed:
-
-

Changed:
-
-

TODO:
-
-
@
text
@d30 1
d830 2
a831 2
 int i = 0;
 int done= 0;
d833 1
a833 3
 while ( !done && i < MAX_LOTS )
 {
   if ( !avail_lots[i].seller )
d835 12
d848 2
a849 14
           avail_lots[i].seller = ch;
           avail_lots[i].buyer = NULL;
           avail_lots[i].obj = obj;
           avail_lots[i].offer = amount;
 
           done = 1;
   }
 
   i++;
 
 }
 
 return i;
 
a854 1
        char buyer[30];
d857 5
d863 6
d870 3
d874 2
a875 21
        while ( !(avail_lots[i].seller == NULL) )
                {
                        if ( avail_lots[i].buyer == NULL )
                                strcpy ( buyer, "no one");
                        else
                                strcpy ( buyer, avail_lots[i].buyer->player.name);
 
 
                        sprintf(buf, "Item %d: %s is selling %s to %s for %ld.\r\n",
                                i+1,
                                avail_lots[i].seller->player.name,
                                avail_lots[i].obj->short_description,
                                buyer,
                                avail_lots[i].offer );
 
                        send_to_char( buf, ch);
                        i++;
                }
 
    if ( i == 0 )
                send_to_char( "No items available.\r\n", ch);
d877 1
a877 2
 
        if (COLOR_LEV(ch) >= C_NRM)
d883 1
a883 1
        int i = 0;
d886 6
a891 4
        while ( !(avail_lots[i].seller == NULL) )
                {
                    if ( avail_lots[i].seller == ch)
                         check = i;
d893 1
a893 4
                        i++;
                }
 
        return check;
d900 1
a900 13
        avail_lots[lot].seller = NULL;
 
        while ( !(avail_lots[i+1].seller == NULL) )
                {
                    avail_lots[i].seller = avail_lots[i+1].seller;
                avail_lots[i].buyer = avail_lots[i+1].buyer;
                avail_lots[i].obj = avail_lots[i+1].obj;
                avail_lots[i].offer = avail_lots[i+1].offer;
 
                        avail_lots[i+1].seller = NULL;
 
                        i++;
                }
d902 9
d912 3
d927 30
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d38 62
@

