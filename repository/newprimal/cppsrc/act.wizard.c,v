head	1.111;
access;
symbols
	A3_0_59:1.13
	LATEST:1.13
	A3_0_1:1.12;
locks; strict;
comment	@ * @;


1.111
date	2005.02.01.00.27.20;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	2004.12.06.05.55.52;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	2004.11.29.02.12.07;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	2004.11.24.06.45.31;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	2004.11.24.05.48.52;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	2004.08.27.01.46.18;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	2004.07.10.03.27.06;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	2004.07.07.14.13.22;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	2004.07.07.11.36.58;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	2004.06.08.10.55.49;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	2004.06.05.08.28.48;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	2004.06.04.12.24.07;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	2004.06.03.02.50.09;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	2004.05.29.01.00.32;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	2004.05.26.06.51.08;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	2004.05.25.06.50.02;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	2004.05.25.04.38.12;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	2004.05.24.11.39.40;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	2004.05.21.15.17.22;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	2004.05.21.14.18.27;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	2004.05.21.14.14.39;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	2004.05.20.02.36.50;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	2004.05.19.08.56.51;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	2004.05.18.11.05.32;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	2004.05.17.01.06.34;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	2004.05.16.14.29.21;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	2004.05.15.22.39.58;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	2004.05.10.03.20.06;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	2004.05.07.06.08.51;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	2004.05.06.02.40.02;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	2004.05.06.02.23.29;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	2004.05.02.04.27.54;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	2004.04.29.07.57.44;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	2004.04.21.07.01.42;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	2004.03.01.03.31.28;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	2004.02.23.04.46.50;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	2004.02.23.04.28.28;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	2004.02.23.03.00.15;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	2004.01.31.08.42.17;	author john;	state Exp;
branches;
next	1.72;

1.72
date	2004.01.30.05.26.15;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	2004.01.30.04.06.46;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	2004.01.29.13.18.17;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	2004.01.29.11.09.47;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.27.09.50.10;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	2004.01.12.04.34.23;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.10.12.02.25;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	2003.12.31.22.20.27;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	2003.12.09.05.42.45;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	2003.11.25.05.37.15;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	2003.11.24.00.14.49;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	2003.11.17.12.36.24;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	2003.11.12.11.00.13;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	2003.11.08.11.58.22;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	2003.11.06.20.29.17;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	2003.11.06.06.06.32;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	2003.11.06.03.47.15;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	2003.11.05.12.17.14;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	2003.11.01.00.23.51;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	2003.10.20.12.01.49;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	2003.10.14.07.24.16;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	2003.09.17.01.48.14;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.16.10.05.36;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	2002.07.20.08.17.56;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	2002.04.18.14.46.18;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	2002.04.10.10.48.30;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	2002.04.07.05.14.11;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.14.06.10.18;	author primal;	state Exp;
branches;
next	1.44;

1.44
date	2002.01.23.05.52.52;	author primal;	state Exp;
branches;
next	1.43;

1.43
date	2001.12.09.13.06.54;	author rod;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.07.01.05.33;	author karma;	state Exp;
branches;
next	1.41;

1.41
date	2001.11.29.08.14.27;	author karma;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.25.04.07.00;	author karma;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.25.00.11.31;	author artus;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.20.05.58.09;	author rod;	state Exp;
branches;
next	1.37;

1.37
date	2001.11.11.04.49.24;	author rod;	state Exp;
branches;
next	1.36;

1.36
date	2001.10.28.06.37.47;	author karma;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.28.03.23.33;	author rod;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.27.22.10.41;	author primal;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.13.10.06.58;	author primal;	state Exp;
branches;
next	1.32;

1.32
date	2001.08.12.01.43.50;	author artus;	state Exp;
branches;
next	1.31;

1.31
date	2001.08.11.14.15.12;	author artus;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.26.23.41.20;	author primal;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.09.03.39.59;	author artus;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.03.03.15.29;	author primal;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.02.00.28.59;	author primal;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.28.07.44.26;	author artus;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.27.06.54.19;	author primal;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.26.07.21.09;	author primal;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.23.11.26.22;	author primal;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.11.14.25.50;	author artus;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.04.08.05.41;	author primal;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.04.07.57.39;	author primal;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.07.05.53.29;	author primal;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.06.08.11.31;	author primal;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.04.18.14.01;	author primal;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.03.01.09.07;	author primal;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.02.07.02.27;	author primal;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.02.04.34.44;	author primal;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.29.21.50.27;	author primal;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.20.23.50.50;	author primal;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.17.13.05.45;	author primal;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.14.00.52.55;	author primal;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.28.21.12.19;	author primal;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.05.02.28.45;	author primal;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.26.07.52.26;	author primal;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.13.02.46.31;	author primal;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.13.00.59.18;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.27.11.26.38;	author talisman;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.22.09.22.34;	author talisman;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.12.29.17;	author talisman;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.57;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.111
log
@Artus> Minor bugfixes.. Mod to unholy vengeance.
@
text
@/* ************************************************************************
*   File: act.wizard.c                                  Part of CircleMUD *
*  Usage: Player-level god commands and other goodies                     *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#ifndef _XOPEN_SOURCE
#define _XOPEN_SOURCE
#endif

#include <fcntl.h>  // open() used in john_in, cassandra_in 
#include <unistd.h>

#include <list>

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "house.h"
#include "screen.h"
#include "constants.h"
#include "oasis.h"
#include "genzon.h"
#include "balance.h"
#include "clan.h" // -- ARTUS
#include "dg_scripts.h"
#include "quest.h"

/*   external vars  */
extern const char *enhancement_names[];
extern const char *level_bits[];
extern FILE *player_fl;
extern struct room_data *world;
extern struct char_data *character_list;
extern struct obj_data *object_list;
extern struct descriptor_data *descriptor_list;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct zone_data *zone_table;
extern struct attack_hit_type attack_hit_text[];
extern time_t boot_time;
extern zone_rnum top_of_zone_table;
extern int circle_shutdown, circle_reboot;
extern int circle_restrict;
extern int load_into_inventory;
extern int buf_switches, buf_largecount, buf_overflows;
extern mob_rnum top_of_mobt;
extern obj_rnum top_of_objt;
extern int top_of_p_table;
extern int spell_sort_info[NUM_SORT_TYPES][NUM_CLASSES][MAX_SKILLS+1]; 
extern const char *special_ability_bits[];
extern int num_of_houses;
extern struct house_control_rec house_control[];
extern struct event_list events;
extern int num_rooms_burgled;
extern const char *social_ranks[];
/* for chars */
extern const char *pc_class_types[];
extern const char *pc_race_types[];
extern Burglary *burglaries;
extern const char *unused_spellname;

/* extern functions */
int level_exp(struct char_data *ch, int level);
void show_shops(struct char_data * ch, char *value);
void do_start(struct char_data *ch);
void appear(struct char_data *ch);
void reset_zone(zone_rnum zone);
void roll_real_abils(struct char_data *ch);
int parse_class(char *arg);
void remove_class_specials(struct char_data *ch);
void set_class_specials(struct char_data *ch);
void set_race_specials(struct char_data *ch);
void remove_race_specials(struct char_data *ch);
void apply_specials(struct char_data *ch, bool initial);
int parse_race_name(char *arg);
int mag_manacost(struct char_data * ch, int spellnum);
void hcontrol_list_houses(struct char_data * ch, char *arg);
void send_to_zone(const char *msg, zone_rnum zone);
void send_to_not_zone_world(const char *msg, zone_rnum zone);
void list_events_to_char(struct char_data *ch, int specific);
int compute_armor_class(struct char_data *ch, bool divide);
byte saving_throws(struct char_data *ch, int type); 
void generate_zone_data(void);
void perform_remove(struct char_data * ch, int pos);
void remove_mud_event(struct event_data *ev);
ACMD(do_qcomm);


/* local functions */
int perform_set(struct char_data *ch, struct char_data *vict, int mode, char *val_arg);
void perform_immort_invis(struct char_data *ch, int level);
ACMD(do_echo);
ACMD(do_balance);
ACMD(do_debug_cmd);
ACMD(do_send);
room_rnum find_target_room(struct char_data * ch, char *rawroomstr);
ACMD(do_at);
ACMD(do_goto);
ACMD(do_trans);
ACMD(do_teleport);
ACMD(do_vnum);
void do_stat_room(struct char_data * ch);
void do_stat_object(struct char_data * ch, struct obj_data * j);
void do_stat_character(struct char_data * ch, struct char_data * k);
ACMD(do_stat);
ACMD(do_shutdown);
void stop_snooping(struct char_data * ch);
ACMD(do_snoop);
ACMD(do_switch);
ACMD(do_return);
ACMD(do_load);
ACMD(do_vstat);
ACMD(do_purge);
ACMD(do_syslog);
ACMD(do_advance);
ACMD(do_restore);
void perform_immort_vis(struct char_data *ch);
ACMD(do_invis);
ACMD(do_gecho);
ACMD(do_poofset);
ACMD(do_dc);
ACMD(do_wizlock);
ACMD(do_date);
ACMD(do_last);
ACMD(do_force);
ACMD(do_wiznet);
ACMD(do_zreset);
ACMD(do_wizutil);
void print_zone_to_buf(char *bufptr, zone_rnum zone, int level, bool detailed);
ACMD(do_show);
ACMD(do_set);

/* Primal Functions */
void john_in(struct char_data *ch);
void cassandra_in(struct char_data *ch);
void artus_in(struct char_data *ch);
void artus_out(struct char_data *ch);
ACMD(do_demort);
ACMD(do_immort);
ACMD(do_pinch);
ACMD(do_pkset);
ACMD(do_queston);
ACMD(do_questoff);
ACMD(do_skillshow);
ACMD(do_tic);
ACMD(do_whostr);

void do_eq_find(struct char_data *ch, char *argument)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  int where = -1, minlev = 0, maxlev = 100, found = 0, i;
  bool light = false, stab = false;
 
  if (!argument || !*argument)
  {
    send_to_char("Usage: debug eqfind <where> <min-max>\r\n", ch);
    return;
  }
  skip_spaces(&argument);
  half_chop(argument, arg1, arg2);
  if (is_abbrev(arg1, "wield"))		where = ITEM_WEAR_WIELD;
  else if (is_abbrev(arg1, "about"))	where = ITEM_WEAR_ABOUT;
  else if (is_abbrev(arg1, "ankle"))	where = ITEM_WEAR_ANKLE;
  else if (is_abbrev(arg1, "arms"))	where = ITEM_WEAR_ARMS;
  else if (is_abbrev(arg1, "body"))	where = ITEM_WEAR_BODY;
  else if (is_abbrev(arg1, "ear"))	where = ITEM_WEAR_EAR;
  else if (is_abbrev(arg1, "eyes"))	where = ITEM_WEAR_EYE;
  else if (is_abbrev(arg1, "feet"))	where = ITEM_WEAR_FEET;
  else if (is_abbrev(arg1, "finger"))	where = ITEM_WEAR_FINGER;
  else if (is_abbrev(arg1, "hands"))	where = ITEM_WEAR_HANDS;
  else if (is_abbrev(arg1, "head"))	where = ITEM_WEAR_HEAD;
  else if (is_abbrev(arg1, "hold"))	where = ITEM_WEAR_HOLD;
  else if (is_abbrev(arg1, "legs"))	where = ITEM_WEAR_LEGS;
  else if (is_abbrev(arg1, "neck"))	where = ITEM_WEAR_NECK;
  else if (is_abbrev(arg1, "shield"))	where = ITEM_WEAR_SHIELD;
  else if (is_abbrev(arg1, "waist"))	where = ITEM_WEAR_WAIST;
  else if (is_abbrev(arg1, "wrist"))	where = ITEM_WEAR_WRIST;
  else if (is_abbrev(arg1, "light"))
  {
    where = ITEM_WEAR_HOLD;
    light = true;
  } else if (is_abbrev(arg1, "stab")) {
    where = ITEM_WEAR_WIELD;
    stab = true;
  } else {
    send_to_char("Where exactly is that?\r\n", ch);
    return;
  }
  // Artus> Hacky level stuff.
  if (*arg2)
    for (i = 0; i < (int)strlen(arg2); i++)
    {
      if (arg2[i] == '\0')
      {
	minlev = atoi(arg2);
	break;
      }
      if (arg2[i] == '-')
      {
	arg2[i] = '\0';
	if ((i > 0) && is_number(arg2))
	  minlev = atoi(arg2);
	if (is_number(&arg2[i+1]))
	  maxlev = atoi(&arg2[i+1]);
	break;
      }
    }

  send_to_char("Vnum  - Name\r\n", ch);
  // Should be safe to assume we have a wear bit, and a min level.
  for (i = 0; i < top_of_objt; i++)
  {
    if (!CAN_WEAR(&obj_proto[i], where))
      continue;
    if (light && (GET_OBJ_TYPE(&obj_proto[i]) != ITEM_LIGHT))
      continue;
    if ((GET_OBJ_LEVEL(&obj_proto[i]) < minlev) ||
        (GET_OBJ_LEVEL(&obj_proto[i]) > maxlev))
      continue;
    if (stab && (obj_proto[i].obj_flags.value[3] != TYPE_PIERCE - TYPE_HIT))
      continue;
    sprintf(buf, "&c%5d&n -&g %s&n\r\n", obj_index[i].vnum, 
	    obj_proto[i].short_description);
    send_to_char(buf, ch);
    found++;
    if (found >= 100)
    {
      send_to_char("Too many to list, try a smaller level range.\r\n", ch);
      return;
    }
  }
  if (found < 1)
    send_to_char("Couldn't find any objects matching those parameters.\r\n",ch);
}

// Cream pies.
ACMD(do_cream)
{
  struct char_data *vict;
  struct affected_type af;
  one_argument(argument,arg);
  
  if (!(vict = generic_find_char(ch, arg, FIND_CHAR_WORLD)))
  {
    send_to_char("Who is it that you wish to cream?\r\n", ch);
    return;
  }
  if (IS_NPC(vict))
  {
    send_to_char("You can't cream mobs!\r\n", ch);
    return;
  }

  if (GET_LEVEL(vict) > GET_LEVEL(ch))
  {
    send_to_char("You miss!\r\n", ch);
    sprintf(buf, "%s attempts to hit you with a cream pie, but misses completely\r\n", GET_NAME(ch));
    send_to_char(buf, vict);
    return;
  }

  sprintf(buf, "You hit %s in the face with a cream pie!\r\n", GET_NAME(vict));
  send_to_char(buf, ch);

  send_to_char("A cream pie falls from the heavens and hits you in the face!\r\nYick, you've been creamed!\r\nAn evil laugh echoes over the land.\r\n", vict);

  af.type = SPELL_CREAMED;
  af.location = APPLY_HITROLL;
  af.modifier = -4;
  af.duration = 3;
  af.bitvector = AFF_BLIND;
  affect_join(vict, &af, FALSE, FALSE, FALSE, FALSE);
  return;
}


ACMD(do_debug_cmd)
{
  skip_spaces(&argument);
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  void init_gold_rush(void);
  void create_event_happy(struct char_data *ch);
  struct event_data *find_quest_event(void);
  int i, count;

  if(!*argument)
  {
#ifndef IGNORE_DEBUG
    sprintf(buf, "Debug Status : %s\r\n", (GET_DEBUG(ch) ? "On" : "Off"));
#endif
    strcpy(buf, "Debug Options:\r\n");
    strcat(buf, 
#ifndef IGNORE_DEBUG
	        "  &cOn&n        - Enable Debugging\r\n"
		"  &cOff&n       - Disable Debugging\r\n"
#endif
		"  &calevil&n    - Really evil aligned mobs.\r\n"
		"  &calgood&n    - Really good aligned mobs.\r\n"
		"  &cch&n        - Am I on the character list?\r\n"
		"  &cev&n        - Event List\r\n"
		"  &codam&n      - Object Damage (<item> <new dam val>)\r\n"
		"  &cportals&n   - List portals and their destinations.\r\n"
		"  &cqmobact&n   - Active mobs with QUEST bit set.\r\n"
		"  &cqmobproto&n - Mob prototypes with QUEST bit set.\r\n"
		"  &cqobjact&n   - Active objs with QUEST bit set.\r\n"
		"  &cqobjproto&n - Mob prototypes with QUEST bit set.\r\n"
		"  &crmsm&n      - Room's Small Bits\r\n"
		"  &cwentroom&n  - Rooms leading to this room.\r\n"
		"  &cwentgate&n  - Objects leading to this room.\r\n"
		"  &czentroom&n  - Rooms leading to this zone.\r\n"
		"  &czentgate&n  - Objects leading to this zone.\r\n");
    send_to_char(buf, ch);
    return;
  }
  half_chop(argument,arg1,arg2);
#ifndef IGNORE_DEBUG
  if (!str_cmp(arg1, "off"))
  {
    REMOVE_BIT(SMALL_BITS(ch), SMB_DEBUG);
    send_to_char("Debugging Off.\r\n", ch);
    return;
  }
  if (!str_cmp(arg1, "on"))
  {
    SET_BIT(SMALL_BITS(ch), SMB_DEBUG);
    send_to_char("Debugging On.\r\n", ch);
    return;
  }
#endif
  // Artus> EQ :o)
  if (!str_cmp(arg1, "eqfind"))
  {
    do_eq_find(ch, arg2);
    return;
  }
  // Artus> Active mobs with QUEST bit set.
  if (!str_cmp(arg1, "qmobact"))
  {
    count = 0;
    strcpy(buf, "&gRoom  &n- &cVnum  &n- Name\r\n");
    for (struct char_data *k = character_list; k; k = k->next)
      if (IS_NPC(k) && MOB_FLAGGED(k, MOB_QUEST))
      {
	count++;
	sprintf(buf, "%s&g%5d - %5d - %s\r\n", buf, world[IN_ROOM(k)].number,
	        mob_index[k->nr].vnum, GET_NAME(k));
	if (count > 100)
	{
	  strcat(buf, "Too many to list.\r\n");
	  break;
	}
      }
    if (count > 0)
      page_string(ch->desc, buf, TRUE);
    else
      send_to_char("No active quest mobiles found.\r\n", ch);
    return;
  }
  // Artus> Prototype mobs with QUEST bit set.
  if (!str_cmp(arg1, "qmobproto"))
  {
    count = 0;
    strcpy(buf, "&gVNum  &n- Name\r\n");
    for (i = 0; i < top_of_mobt; i++)
      if (MOB_FLAGGED(&mob_proto[i], MOB_QUEST))
      {
	count++;
	sprintf(buf, "%s&g%5d&n - %s\r\n", buf, mob_index[i].vnum,
	        GET_NAME(&mob_proto[i]));
	if (count > 100)
	{
	  strcat(buf, "Too many to list.\r\n");
	  break;
	}
      }
    if (count > 0)
      page_string(ch->desc, buf, TRUE);
    else
      send_to_char("No prototype quest mobiles found. (This is good :o)\r\n",
	           ch);
    return;
  }
  // Artus> Active ITEM_QUEST objects.
  if (!str_cmp(arg1, "qobjact"))
  {
    count = 0;
    strcpy(buf, "&g Vnum &n- Name\r\n");
    for (struct obj_data *o = object_list; o; o = o->next)
      if (GET_OBJ_TYPE(o) == ITEM_QUEST)
      {
	count++;
	sprintf(buf, "%s&g%5d&n - %s\r\n", buf, o->item_number,
	        o->short_description);
	if (count > 100)
	{
	  strcat(buf, "Too many to list.\r\n");
	  break;
	}
      }
    if (count > 0)
      page_string(ch->desc, buf, TRUE);
    else
      send_to_char("No active quest objects found.\r\n", ch);
    return;
  }
  // Artus> Prototype ITEM_QUEST objects.
  if (!str_cmp(arg1, "qobjproto"))
  {
    count = 0;
    strcpy(buf, "&g VNum &n- Name\r\n");
    for (i = 0; i < top_of_objt; i++)
      if (GET_OBJ_TYPE(&obj_proto[i]) == ITEM_QUEST)
      {
	count++;
	sprintf(buf, "%s&g%5d&n - %s\r\n", buf, obj_index[i].vnum,
	        obj_proto[i].short_description);
	if (count > 100)
	{
	  strcat(buf, "Too many to list.\r\n");
	  break;
	}
      }
    if (count > 0)
      page_string(ch->desc, buf, TRUE);
    else
      send_to_char("No prototype quest objects found (This is good).\r\n", ch);
    return;
  }
  // Artus> Rooms exiting to current room.
  if (!str_cmp(arg1, "wentroom"))
  {
    bool found = false;
    strcpy(buf, "Rooms leading here:");
    for (i = 0; i < top_of_world; i++)
      for (int j = 0; j < NUM_OF_DIRS; j++)
	if (W_EXIT(i, j) && (W_EXIT(i, j)->to_room == IN_ROOM(ch)))
	{
	  sprintf(buf, "%s\r\n&c%5d &g%-5s", buf, world[i].number, dirs[j]);
	  found = true;
	}
    if (found)
    {
      strcat(buf, "&n\r\n");
      page_string(ch->desc, buf, TRUE);
    } else {
      send_to_char("Couldn't find any rooms leading here.\r\n", ch);
    }
    return;
  }
  // Artus> Objs exiting to current room.
  if (!str_cmp(arg1, "wentgate"))
  {
    bool found = false;
    room_vnum myvnum = world[IN_ROOM(ch)].number;
    strcpy(buf, "Gateways leading here:\r\n");
    for (i = 0; i < top_of_objt; i++)
      if ((GET_OBJ_TYPE(&obj_proto[i]) == ITEM_GATEWAY) &&
	  (GET_OBJ_VAL(&obj_proto[i], 0) == myvnum))
      {
	found = true;
	sprintf(buf, "%s&c%5d &n(&5%s&n)\r\n", buf, obj_index[i].vnum,
	        obj_proto[i].short_description);
      }
    if (found)
      page_string(ch->desc, buf, TRUE);
    else
      send_to_char("Couldn't find any objects leading here.\r\n", ch);
    return;
  }
  // Artus> Rooms exiting to current ZONE.
  if (!(str_cmp(arg1, "zentroom")))
  {
    bool found = false;
    zone_rnum targzone = world[IN_ROOM(ch)].zone;
    strcpy(buf, "Rooms leading to this zone:");
    for (i = 0; i < top_of_world; i++)
      if (world[i].zone != targzone)
	for (int j = 0; j < NUM_OF_DIRS; j++)
	  if (W_EXIT(i, j) && (W_EXIT(i, j)->to_room > NOWHERE) &&
	      (world[W_EXIT(i, j)->to_room].zone == targzone))
	  {
	    found = true;
	    sprintf(buf, "%s\r\n&c%5d &g%5s&n - &c%5d", buf,
		    world[i].number, dirs[j],
		    world[W_EXIT(i, j)->to_room].number);
	  }
    if (found)
    {
      strcat(buf, "&n\r\n");
      page_string(ch->desc, buf, TRUE);
    } else {
      send_to_char("Couldn't find any rooms leading to this zone.\r\n", ch);
    }
    return;
  }
  // Artus> Objects exiting to current ZONE.
  if (!(str_cmp(arg1, "zentgate")))
  {
    bool found = false;
    room_vnum zone_bottom, zone_top;
    zone_bottom = zone_table[world[IN_ROOM(ch)].zone].number * 100;
    zone_top = zone_table[world[IN_ROOM(ch)].zone].top;
    strcpy(buf, "Objects leading to this zone:\r\n");
    for (i = 0; i < top_of_objt; i++)
      if ((GET_OBJ_TYPE(&obj_proto[i]) == ITEM_GATEWAY) &&
	  ((GET_OBJ_VAL(&obj_proto[i], 0) >= zone_bottom) &&
	   (GET_OBJ_VAL(&obj_proto[i], 0) <= zone_top)))
      {
	found = true;
	sprintf(buf, "%s&c%5d &n- &c%5d &n(&g%s&n)\r\n", buf, obj_index[i].vnum,
	        GET_OBJ_VAL(&obj_proto[i], 0), obj_proto[i].short_description);
      }
    if (found)
      page_string(ch->desc, buf, TRUE);
    else
      send_to_char("Couldn't find any objects leading to this zone.\r\n", ch);
    return;
  }
  // Artus> Good Aligned Mobs.
  if (!str_cmp(arg1, "algood"))
  {
    bool found = false;
    for (i = 0; i < top_of_mobt; i++)
      if (GET_ALIGNMENT(&mob_proto[i]) >= 1000)
      {
	if (!(found))
	{
	  strcpy(buf, "Align -  Vnum - Name\r\n"
	              "------------------------------------------------\r\n");
	  found = true;
	}
	sprintf(buf, "%s%5d   %5d   %s\r\n", buf, GET_ALIGNMENT(&mob_proto[i]),
	        mob_index[i].vnum, GET_NAME(&mob_proto[i]));
      }
    if (found)
    {
      strcat(buf, "------------------------------------------------\r\n");
      page_string(ch->desc, buf, TRUE);
    } else {
      send_to_char("No good mobs found :o(\r\n", ch);
    }
    return;
  }
  // Artus> Evil Aligned Mobs.
  if (!str_cmp(arg1, "alevil"))
  {
    bool found = false;
    for (i = 0; i < top_of_mobt; i++)
      if (GET_ALIGNMENT(&mob_proto[i]) <= -1000)
      {
	if (!(found))
	{
	  strcpy(buf, "Align -  Vnum - Name\r\n"
		      "------------------------------------------------\r\n");
	  found = true;
	}
	sprintf(buf, "%s%5d   %5d   %s\r\n", buf, GET_ALIGNMENT(&mob_proto[i]),
	        mob_index[i].vnum, GET_NAME(&mob_proto[i]));
      }
    if (found)
    {
      strcat(buf, "------------------------------------------------\r\n");
      page_string(ch->desc, buf, TRUE);
    } else {
      send_to_char("No evil mobs found :o(\r\n", ch);
    }
    return;
  }
  // Artus> List Portals.
  if (!str_cmp(arg1, "portals"))
  {
    send_to_char("------------------------------------------------\r\n", ch);
    for (i = 0; i < top_of_objt; i++)
      if (GET_OBJ_TYPE(&obj_proto[i]) == ITEM_GATEWAY)
      {
	sprintf(buf, "&c%5d&n Teleports to &c%5d&n. (Obj Name: &g%s&n)\r\n", 
	        obj_index[i].vnum, GET_OBJ_VAL(&obj_proto[i], 0),
		obj_proto[i].short_description);
	send_to_char(buf, ch);
      }
    send_to_char("------------------------------------------------\r\n", ch);
    return;
  }
  if (is_abbrev(arg1,"ev"))
  {
    sprintf(buf, "&gDBG: Num Events: %d.\r\n", events.num_events);
    send_to_char(buf, ch);
    for (struct event_data *ev = events.list; ev; ev = ev->next)
    {
      sprintf(buf, "DBG: Ev={chID=%ld, time_taken={hours=%d,day=%d,month=%d,year=%d}, room=%d, type=%d, info1=%d, info2=%d, info3=%d, desc=%s, next=%s}\r\n",
	      ev->chID, ev->time_taken.hours, ev->time_taken.day, ev->time_taken.month, ev->time_taken.year, (ev->room) ? ev->room->number : NOWHERE, ev->type, ev->info1, ev->info2, ev->info3, ev->desc, ((ev->next) ? "present" : "absent"));
      send_to_char(buf, ch);
    }
    return;
  }
  if (is_abbrev(arg1,"rmsm"))
  {
    sprintf(buf, "RMSM_FLAGS(IN_ROOM(ch)=%d): %d\r\n", RMSM_FLAGS(IN_ROOM(ch)),
	    world[IN_ROOM(ch)].small_bits);
    send_to_char(buf, ch);
    return;
  }
  if (is_abbrev(arg1,"ch"))
  {
    for (struct char_data *k = character_list; k; k = k->next)
      if (k == ch)
      {
	send_to_char("DBG: It's You!\r\n", ch);
	return;
      }
    send_to_char("DBG: I can't find you.. This is probably bad.\r\n", ch);
    return;
  }
  if (is_abbrev(arg1, "odam"))
  {
    struct obj_data *tobj = NULL;
    struct char_data *tmpch;
    int newamt = 0;
    half_chop(arg2,arg1,argument);
    if (!(*arg1) || !(*argument)) 
    {
      send_to_char("Syntax: debug odam <item name> <damage amount>\r\n", ch);
      return;
    }
    if (!is_number(argument))
    {
      send_to_char("Damage amount must be a number.\r\n", ch);
      return;
    }
//int generic_find(char *arg, bitvector_t bitvector, struct char_data * ch,
//		     struct char_data ** tar_ch, struct obj_data ** tar_obj)
    if (generic_find(arg1, FIND_OBJ_INV, ch, &tmpch, &tobj) == 0)
    {
      sprintf(buf, "You don't seem to have a %s\r\n", arg1);
      send_to_char(buf, ch);
      return;
    }
    newamt = atoi(argument);
    if (newamt < 0)
      newamt = 0;
    GET_OBJ_DAMAGE(tobj) = MIN(GET_OBJ_MAX_DAMAGE(tobj), newamt);
    send_to_char("Done.\r\n", ch);
    return;
  }
  send_to_char("Debug what?!?\r\n", ch);
}

ACMD(do_balance)
{
  balance_world(top_of_mobt, top_of_objt);
  send_to_char("Regenerating Balance Files...\r\n", ch);
}

ACMD(do_echo)
{
  skip_spaces(&argument);

  if (!*argument)
    send_to_char("Yes.. but what?\r\n", ch);
  else {
    if (subcmd == SCMD_EMOTE)
      sprintf(buf, "$n %s", argument);
    else
      strcpy(buf, argument);
    act(buf, FALSE, ch, 0, 0, TO_ROOM);
    if (!IS_NPC(ch)) // Don't Send Anything to Mobs. - ARTUS
    {
      if (PRF_FLAGGED(ch, PRF_NOREPEAT))
	send_to_char(OK, ch);
      else
	act(buf, FALSE, ch, 0, 0, TO_CHAR);
    }
  }
}


ACMD(do_send)
{
  struct char_data *vict;

  half_chop(argument, arg, buf);

  if (!*arg)
  {
    send_to_char("Send what to who?\r\n", ch);
    return;
  }
  if (!(vict = generic_find_char(ch, arg, FIND_CHAR_WORLD)))
  {
    send_to_char(NOPERSON, ch);
    return;
  }
  send_to_char(buf, vict);
  send_to_char("\r\n", vict);
  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char("Sent.\r\n", ch);
  else {
    sprintf(buf2, "You send '%s' to %s.\r\n", buf, GET_NAME(vict));
    send_to_char(buf2, ch);
  }
}



/* take a string, and return an rnum.. used for goto, at, etc.  -je 4/6/93 */
room_rnum find_target_room(struct char_data * ch, char *rawroomstr)
{
  room_vnum tmp;
  room_rnum location;
  struct char_data *target_mob;
  struct obj_data *target_obj;
  char roomstr[MAX_INPUT_LENGTH];

  one_argument(rawroomstr, roomstr);

  if (!*roomstr)
  {
    send_to_char("You must supply a room number or name.\r\n", ch);
    return (NOWHERE);
  }
  if (isdigit(*roomstr) && !strchr(roomstr, '.'))
  {
    tmp = atoi(roomstr);
    if ((location = real_room(tmp)) < 0)
    {
      send_to_char("No room exists with that number.\r\n", ch);
      return (NOWHERE);
    }
  } else if ((tmp = generic_find(roomstr, FIND_CHAR_WORLD | FIND_OBJ_WORLD, ch, 
	                  &target_mob, &target_obj)) < 1)
  {
    send_to_char("No such creature or object around.\r\n", ch);
    return (NOWHERE);
  } else {
    if (tmp == FIND_CHAR_WORLD)
    {
      location = target_mob->in_room;
      if (location == NOWHERE)
      {
	sprintf(buf, "The creature, &6%s&n, is not vailable.\r\n", 
	        PERS(ch, target_mob));
	send_to_char(buf, ch);
	return (NOWHERE);
      }
    } else {
      location = target_obj->in_room;
      if (location == NOWHERE)
      {
	sprintf(buf, "The object, &5%s&n, is not available.\r\n", 
	        OBJS(target_obj, ch));
	send_to_char(buf, ch);
	return (NOWHERE);
      }
    }
  }
  /* a location has been found -- if you're < GRGOD, check restrictions. */
  if (LR_FAIL(ch, LVL_IMPL))
  {
    if (ROOM_FLAGGED(location, ROOM_GODROOM))
    {
      send_to_char("You are not godly enough to use that room!\r\n", ch);
      return (NOWHERE);
    }
    if (ROOM_FLAGGED(location, ROOM_PRIVATE) &&
	world[location].people && world[location].people->next_in_room)
    {
      send_to_char("There's a private conversation going on in that room.\r\n", ch);
      return (NOWHERE);
    }
    if (ROOM_FLAGGED(location, ROOM_HOUSE) &&
	!House_can_enter(ch, GET_ROOM_VNUM(location))) 
    {
      send_to_char("That's private property -- no trespassing!\r\n", ch);
      return (NOWHERE);
    }
  }
  return (location);
}



ACMD(do_at)
{
  char command[MAX_INPUT_LENGTH];
  room_rnum location, original_loc;

  half_chop(argument, buf, command);
  if (!*buf) {
    send_to_char("You must supply a room number or a name.\r\n", ch);
    return;
  }

  if (!*command) {
    send_to_char("What do you want to do there?\r\n", ch);
    return;
  }

  if ((location = find_target_room(ch, buf)) < 0)
    return;

/* stops imms going to reception - Vader */
  if(world[location].number <= 599 && world[location].number >= 500 &&
     LR_FAIL(ch, LVL_IMPL))
  {
    send_to_char("As you fly through time and space towards the reception area\r\n"
               "a black gloved hand grabs you and rips you back to where you came from...\r\n",ch);
    return;
  }

  /* a location has been found. */
  original_loc = ch->in_room;
  char_from_room(ch);
  char_to_room(ch, location);
  command_interpreter(ch, command);

  /* check if the char is still there */
  if (ch->in_room == location)
  {
    char_from_room(ch);
    char_to_room(ch, original_loc);
  }
}


ACMD(do_goto)
{
  room_rnum location;
  struct char_data *target_mob;
  char name_mob[MAX_INPUT_LENGTH];
  extern int allowed_zone(struct char_data * ch,int flag,bool show);
  extern int allowed_room(struct char_data * ch,int flag,bool show);

  // TODO: dont allow goto tag/mortal
  if (PRF_FLAGGED(ch, PRF_MORTALK) && LR_FAIL(ch, LVL_IMPL))
  {
    send_to_char("You cannot goto out of mortalk arena.  Use Recall!\r\n", ch);
    return;
  }
  if (GET_LEVEL(ch) < LVL_IMMORT)
  {
    if (GET_LEVEL(ch) < LVL_CHAMP)
    {
      send_to_char("Hah, you wish!\r\n", ch);
      return;
    }
    one_argument (argument,name_mob);
    
    if (is_number(name_mob))
    { /* Artus - Allow champs to goto their OLC zone */
      if (GET_OLC_ZONE(ch) < 1)
      {
	send_to_char("You can only go to Player Characters.\r\n", ch);
	return;
      }
      if ((location = real_room(atoi(name_mob))) == NOWHERE)
      {
	send_to_char("No room by that number.\r\n", ch);
	return;
      }
      if (zone_table[world[location].zone].number != GET_OLC_ZONE(ch))
      {
	send_to_char("You can only goto rooms within your OLC zone.\r\n", ch);
	return;
      }
      if (POOFOUT(ch))
        sprintf(buf, "&7$n&n %s", POOFOUT(ch));
      else
        strcpy(buf, "&7$n&n disappears in a puff of smoke.");
 
      act(buf, TRUE, ch, 0, 0, TO_ROOM);
      char_from_room(ch);
      char_to_room(ch, location);

      if (POOFIN(ch))
        sprintf(buf, "&7$n&n %s", POOFIN(ch));
      else
        strcpy(buf, "&7$n&n appears with an ear-splitting bang.");
  
      act(buf, TRUE, ch, 0, 0, TO_ROOM);
      look_at_room(ch, 0);
      return;
    }
    // get_char_vis(xxx, xxx, FALSE == GET_CHAR_ROOM) <- chaned from FALSE to
    // FIND_CHAR_WORLD ... <- DM
    if(((target_mob = generic_find_char(ch, name_mob, FIND_CHAR_WORLD)) == NULL)
      || (world[target_mob->in_room].zone == GOD_ROOMS_ZONE)
      || (!same_world(target_mob,ch)))
    {
      send_to_char("That person does not appear to be anywhere!\r\n",ch);
      return;
    }
    if(IS_NPC(target_mob))
    {
      send_to_char("You can only go to Player Characters!\r\n",ch);
      return;
    }
  } 

  if ((location = find_target_room(ch, argument)) < 0)
    return;

/* stops imms going to reception - Vader */
  if(world[location].number <= 599 && world[location].number >= 500 &&
     LR_FAIL(ch, LVL_IMPL))
  {
    send_to_char("As you fly through time and space towards the reception area\r\n"
               "a guardian spirit tells you in a nice kind voice, \"PISS OFF!\"\r\n",ch);
    return;
  }
 
/* stops imms going to clan halls - Hal
 * ARTUS - Modified 16/04/2001 - Clan zone... */
 
  if ((zone_table[world[location].zone].number == CLAN_ZONE) && 
      (LR_FAIL(ch, LVL_CLAN_GOD)))
  {
    send_to_char("A ward placed over the clan zone prevents you entering via arcane means.\r\n", ch);
    return;
  }

  if (!allowed_zone(ch,zone_table[world[location].zone].zflag,TRUE))
    return;
  if (!allowed_room(ch,world[location].room_flags,TRUE))
    return; 

  if (POOFOUT(ch))
  {
    sprintf(buf, "&7$n&n %s", POOFOUT(ch));
    act(buf, TRUE, ch, 0, 0, TO_ROOM);
  } else {
    if (!str_cmp(ch->player.name, "Artus"))
      artus_out(ch);
    else
    {
      strcpy(buf, "&7$n&n disappears in a puff of smoke.");
      act(buf, TRUE, ch, 0, 0, TO_ROOM);
    }
  }
 
  char_from_room(ch);
  char_to_room(ch, location);

  // DM: Make angels and below wait two violence round
  if (GET_LEVEL(ch) <= LVL_ANGEL)
    WAIT_STATE(ch, PULSE_VIOLENCE*2);

  if (POOFIN(ch))
  {
    sprintf(buf, "&7$n&n %s", POOFIN(ch));
    act(buf, TRUE, ch, 0, 0, TO_ROOM);
  } else {
    if (!strcmp(ch->player.name, "John"))
      john_in(ch);
    else if (!strcmp(ch->player.name, "Cassandra"))
      cassandra_in(ch);
    else if (!strcmp(ch->player.name, "Artus"))
      artus_in(ch);
    else 
    {
      strcpy(buf, "&7$n&n appears with an ear-splitting bang.");
      act(buf, TRUE, ch, 0, 0, TO_ROOM);
    }
  }
  look_at_room(ch, 0);
}

ACMD(do_trans)
{
  struct descriptor_data *i;
  struct char_data *victim;

  one_argument(argument, buf);
  if (!*buf)
  {
    send_to_char("Whom do you wish to transfer?\r\n", ch);
  } else if (str_cmp("all", buf)) {
    if (!(victim = generic_find_char(ch, buf, FIND_CHAR_WORLD)))
      send_to_char(NOPERSON, ch);
    else if (victim == ch)
      send_to_char("That doesn't make much sense, does it?\r\n", ch);
    else {
      if ((GET_LEVEL(ch) < GET_LEVEL(victim)) && !IS_NPC(victim)) {
	send_to_char("Go transfer someone your own size.\r\n", ch);
	return;
      }
      act("$n disappears in a mushroom cloud.", FALSE, victim, 0, 0, TO_ROOM);
      char_from_room(victim);
      char_to_room(victim, ch->in_room);
      act("$n arrives from a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
      act("$n has transferred you!", FALSE, ch, 0, victim, TO_VICT);
      look_at_room(victim, 0);
    }
  } else {			/* Trans All */
    if (GET_LEVEL(ch) < LVL_GRGOD)
    {
      send_to_char("I think not.\r\n", ch);
      return;
    }

    for (i = descriptor_list; i; i = i->next)
      if (STATE(i) == CON_PLAYING && i->character && i->character != ch)
      {
	victim = i->character;
	if (GET_LEVEL(victim) >= GET_LEVEL(ch))
	  continue;
	act("$n disappears in a mushroom cloud.", FALSE, victim, 0, 0, TO_ROOM);
	char_from_room(victim);
	char_to_room(victim, ch->in_room);
	act("$n arrives from a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
	act("$n has transferred you!", FALSE, ch, 0, victim, TO_VICT);
	look_at_room(victim, 0);
      }
    send_to_char(OK, ch);
  }
}

ACMD(do_teleport)
{
  struct char_data *victim;
  room_rnum target;

  two_arguments(argument, buf, buf2);

  if (!*buf)
    send_to_char("Whom do you wish to teleport?\r\n", ch);
  else if (!(victim = generic_find_char(ch, buf, FIND_CHAR_WORLD)))
    send_to_char(NOPERSON, ch);
  else if (victim == ch)
    send_to_char("Use 'goto' to teleport yourself.\r\n", ch);
  else if (GET_LEVEL(victim) >= GET_LEVEL(ch))
    send_to_char("Maybe you shouldn't do that.\r\n", ch);
  else if (!*buf2)
    send_to_char("Where do you wish to send this person?\r\n", ch);
  else if ((target = find_target_room(ch, buf2)) >= 0) {
    send_to_char(OK, ch);
    act("$n disappears in a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
    char_from_room(victim);
    char_to_room(victim, target);
    act("$n arrives from a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
    act("$n has teleported you!", FALSE, ch, 0, (char *) victim, TO_VICT);
    look_at_room(victim, 0);
  }
}

ACMD(do_vnum)
{
  int i, number, found = FALSE;
  char larg1[MAX_INPUT_LENGTH], larg2[MAX_INPUT_LENGTH];
  char larg3[MAX_INPUT_LENGTH], larg4[MAX_INPUT_LENGTH];

  larg1[0] = '\0';
  larg2[0] = '\0';
  larg3[0] = '\0';
  larg4[0] = '\0';

  half_chop(argument, buf, buf2);

  if (!*buf || !*buf2 || (!is_abbrev(buf, "mob") && 
                          !is_abbrev(buf, "obj") && !is_abbrev(buf, "list"))) {
    send_to_char("&1Usage: &4vnum [&2list&4] { obj &2[type]&4 | mob &2[type]&4 | &2room&4 } <name|&2zonenumber&4>\r\n", ch);
    return;
  }

  // DM: added list abilities
  if (is_abbrev(buf, "list")) {
    half_chop(buf2, larg1, larg2);

    if (!is_abbrev(larg1, "mob") && !is_abbrev(larg1, "obj") && 
                    !is_abbrev(larg1, "room")) {
      send_to_char("&1Usage: &4vnum list { obj [type] | mob [type] | room } <zonenumber>\r\n", ch);
      return;
    }

    // now we have: vnum list <mob|obj|room> (larg2 -> [type] zonenumber)
    half_chop(larg2, larg3, larg4);

    // so if larg1 is mob|obj, larg3 is either type of mob|obj or zonenumber
    
    // vnum list mob
    if (is_abbrev(larg1, "mob")) {
      for (i = 0; i < NUM_NPC_CLASSES; i++) {
        if (is_abbrev(larg3, npc_class_types[i])) {
          found = TRUE;
          break;
        }
      }
      
      if (found) {
        if (real_zone(atoi(larg4)) == NOWHERE) {
          send_to_char("Invalid virtual zone number.\r\n", ch);
          return;
        }
        list_mobiles(ch, atoi(larg4), i);
      } else {
        if (real_zone(atoi(larg3)) == NOWHERE) {
          send_to_char("Invalid mobile type or virtual zone number.\r\n", ch);
          return;
        }
        list_mobiles(ch, atoi(larg3), NOTHING);
      }

    // vnum list obj
    } else if (is_abbrev(larg1, "obj")) {
      for (i = 0; i < NUM_ITEM_TYPES; i++) {
        if (is_abbrev(larg3, item_types[i])) {
          found = TRUE;
          break;
        }
      }
      
      if (found) {
        if (real_zone(atoi(larg4)) == NOWHERE) {
          send_to_char("Invalid virtual zone number.\r\n", ch);
          return;
        }
        list_objects(ch, atoi(larg4), i);
      } else {
        if (real_zone(atoi(larg3)) == NOWHERE) {
          send_to_char("Invalid object type or virtual zone number.\r\n", ch);
          return;
        }
        list_objects(ch, atoi(larg3), NOTHING);
      }

    // vnum list room 
    } else {
      if (real_zone(atoi(larg3)) == NOWHERE) {
        send_to_char("Invalid virtual zone number.\r\n", ch);
        return;
      } 
      number = atoi(larg3);
      found = 0;
      buf[0] = '\0';
      for (i = 0; i < top_of_world; i++) {
        if (zone_table[world[i].zone].number == number) {
          sprintf(buf2, "%3d. &8[%5d] %s&n\r\n", ++found, 
                  world[i].number, world[i].name);
          strncat(buf, buf2, strlen(buf2));
        }
      }
      if (found) {
        page_string(ch->desc, buf, TRUE);
      }
    }
  }
  

  if (is_abbrev(buf, "mob"))
    if (!vnum_mobile(buf2, ch))
      send_to_char("No mobiles by that name.\r\n", ch);

  if (is_abbrev(buf, "obj"))
    if (!vnum_object(buf2, ch))
      send_to_char("No objects by that name.\r\n", ch);
}



void do_stat_room(struct char_data * ch)
{
  struct extra_descr_data *desc;
  struct room_data *rm = &world[ch->in_room];
  int i, found;
  struct obj_data *j;
  struct char_data *k;
  char sectbase[20], sectatmos[20], secttemp[20], sectgrav[20], sectenviro[20];

  sprintf(buf, "Room name: %s%s%s\r\n", CCCYN(ch, C_NRM), rm->name,
	  CCNRM(ch, C_NRM));
  send_to_char(buf, ch);

  sprinttype(BASE_SECT(rm->sector_type), sector_types[SECT_TYPE_BASE], sectbase);
  sprinttype(ATMOSPHERE(rm->sector_type), sector_types[SECT_TYPE_ATMOS], sectatmos);
  sprinttype(TEMPERATURE(rm->sector_type), sector_types[SECT_TYPE_TEMP], secttemp);
  sprinttype(GRAVITY(rm->sector_type), sector_types[SECT_TYPE_GRAV], sectgrav);
  sprinttype(ENVIRON(rm->sector_type), sector_types[SECT_TYPE_ENVIRO], sectenviro);

  sprintf(buf, "Zone: [%3d], VNum: [%s%5d%s], RNum: [%5d]\r\n",
	  zone_table[rm->zone].number, CCGRN(ch, C_NRM), rm->number,
	  CCNRM(ch, C_NRM), ch->in_room);
  send_to_char(buf, ch); 

  sprintf(buf, "&0Sectors&n:\r\n"
               "&1Base&n        : &c%s&n\r\n"
               "&1Atmosphere&n  : &c%s&n\r\n"
               "&1Temperature&n : &c%s&n\r\n"
               "&1Gravity&n     : &c%s&n\r\n" 
               "&1Environment&n : &c%s&n\r\n",
                  sectbase, sectatmos, secttemp, sectgrav, sectenviro);
  send_to_char(buf,ch);

  sprintbit(rm->room_flags, room_bits, buf2);
  sprintbit(rm->burgle_flags, burgle_rooms, buf1);
  sprintf(buf, "&0SpecProc&n: &c%s\r\n"
               "&0Flags&n: &c%s\r\n"
               "&0Burgle bits: &c%s\r\n",
	  (rm->func == NULL) ? "None" : "Exists", buf2, buf1);
  send_to_char(buf, ch);

  send_to_char("&0Description&n:\r\n", ch);
  if (rm->description)
    send_to_char(rm->description, ch);
  else
    send_to_char("  None.\r\n", ch);

  if (rm->ex_description) {
    sprintf(buf, "Extra descs:%s", CCCYN(ch, C_NRM));
    for (desc = rm->ex_description; desc; desc = desc->next) {
      strcat(buf, " ");
      if (desc->keyword)
	strcat(buf, desc->keyword);
    }
    strcat(buf, CCNRM(ch, C_NRM));
    send_to_char(strcat(buf, "\r\n"), ch);
  }
  sprintf(buf, "&0Chars present&n:%s", CCYEL(ch, C_NRM));
  for (found = 0, k = rm->people; k; k = k->next_in_room) {
    if (!CAN_SEE(ch, k))
      continue;
    // Stupid - I know - cant be bothered rewriting it.
    if (!IS_NPC(k))
      sprintf(buf2, "%s &7%s&n(&7%s&n)", found++ ? "," : "", GET_NAME(k),
	    (!IS_NPC(k) ? "PC" : (!IS_MOB(k) ? "NPC" : "MOB")));
    else
      sprintf(buf2, "%s &6%s&n(&6%s&n)", found++ ? "," : "", GET_NAME(k),
	    (!IS_NPC(k) ? "PC" : (!IS_MOB(k) ? "NPC" : "MOB")));

    strcat(buf, buf2);
    if (strlen(buf) >= 62) {
      if (k->next_in_room)
	send_to_char(strcat(buf, ",\r\n"), ch);
      else
	send_to_char(strcat(buf, "\r\n"), ch);
      *buf = found = 0;
    }
  }

  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);
  send_to_char(CCNRM(ch, C_NRM), ch);

  if (rm->contents) {
    sprintf(buf, "&0Contents&n:%s", CCGRN(ch, C_NRM));
    for (found = 0, j = rm->contents; j; j = j->next_content) {
      if (!CAN_SEE_OBJ(ch, j))
	continue;
      sprintf(buf2, "%s &5%s&n", found++ ? "," : "", j->short_description);
      strcat(buf, buf2);
      if (strlen(buf) >= 62) {
	if (j->next_content)
	  send_to_char(strcat(buf, ",\r\n"), ch);
	else
	  send_to_char(strcat(buf, "\r\n"), ch);
	*buf = found = 0;
      }
    }

    if (*buf)
      send_to_char(strcat(buf, "\r\n"), ch);
    send_to_char(CCNRM(ch, C_NRM), ch);
  }
  for (i = 0; i < NUM_OF_DIRS; i++) {
    if (rm->dir_option[i]) {
      if (rm->dir_option[i]->to_room == NOWHERE)
	sprintf(buf1, " %sNONE%s", CCCYN(ch, C_NRM), CCNRM(ch, C_NRM));
      else
	sprintf(buf1, "%s%5d%s", CCCYN(ch, C_NRM),
		GET_ROOM_VNUM(rm->dir_option[i]->to_room), CCNRM(ch, C_NRM));
      sprintbit(rm->dir_option[i]->exit_info, exit_bits, buf2);
      sprintf(buf, "Exit %s%-5s%s:  To: [%s], Key: [%5d], Keywrd: %s, Type: %s\r\n ",
	      CCCYN(ch, C_NRM), dirs[i], CCNRM(ch, C_NRM), buf1, rm->dir_option[i]->key,
	   rm->dir_option[i]->keyword ? rm->dir_option[i]->keyword : "None",
	      buf2);
      send_to_char(buf, ch);
      if (rm->dir_option[i]->general_description)
	strcpy(buf, rm->dir_option[i]->general_description);
      else
	strcpy(buf, "  No exit description.\r\n");
      send_to_char(buf, ch);
    }
  }
  /* check the room for a script */
  do_sstat_room(ch);
}

// DM - TODO check if we need to add other objects ....
// checked - double check before release
void do_list_obj_values(struct obj_data *j, char * buf)
{
  switch (GET_OBJ_TYPE(j)) {

  case ITEM_LIGHT:
    sprintf(buf, "Color (unused): [&c%d&n], Type (unused): [&c%d&n], Hours: [&c%d&n]",
            GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2));
    break;
  case ITEM_SCROLL:
  case ITEM_POTION:
    sprintf(buf, "Spells Level: &c%d&n, Spells: &g%s&n (&c%d&n), &g%s&n (&c%d&n), &g%s&n (&c%d&n)",
		GET_OBJ_VAL(j, 0),
                skill_name(GET_OBJ_VAL(j, 1)), GET_OBJ_VAL(j, 1), 
		skill_name(GET_OBJ_VAL(j, 2)), GET_OBJ_VAL(j, 2), 
		skill_name(GET_OBJ_VAL(j, 3)), GET_OBJ_VAL(j, 3));
    break;
  case ITEM_WAND:
  case ITEM_STAFF:
    sprintf(buf, "Spell Level: &g%d&n, Max Charges: &c%d&n, Rem Charges: &c%d&n, Spell: &g%s&n (&c%d&n)", 
                GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2), 
                skill_name(GET_OBJ_VAL(j, 3)), GET_OBJ_VAL(j, 3));
    break;
  case ITEM_FIREWEAPON:
  case ITEM_WEAPON:
    sprintf(buf, "Tohit: &c%d&n, Todam: &r%d&nd&r%d&n, Type: &c%d&n", 
	GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2), 
	GET_OBJ_VAL(j, 3));
    if (IS_OBJ_STAT(j, ITEM_MAGIC)) {
      sprintf(buf, "%s\r\nCasts: &g%s&n", buf, 
	  spell_info[GET_OBJ_VAL(j, 0)].name);
    }
    break;
  case ITEM_MISSILE:
    sprintf(buf, "Tohit: &c%d&n, Todam: &c%d&n, Type: &c%d&n", GET_OBJ_VAL(j, 0),
            GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 3));
    break;
  case ITEM_ARMOR:
    sprintf(buf, "AC-apply: [&c%d&n]", GET_OBJ_VAL(j, 0));
    break;
  case ITEM_TRAP:
    sprintf(buf, "Loaded: &g%s&n, Damage: &r%d&nd&r%d&n, Protecting Item: &c%d&n",
      (GET_OBJ_VAL(j, 0) == 0 ? "No" : (GET_OBJ_VAL(j, 0) == 1 ? "Yes" : "Yes, Room")),
      GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 3));
    break; 
  case ITEM_CONTAINER:
    if (!IS_CORPSE(j)) {
      sprintf(buf, "Max-contains: &c%d&n, Locktype: &c%d&n",
              GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1));
    } else {
      sprintf(buf, "Corpse idnum (pc idnum): &c%d&n",
              GET_CORPSEID(j));        
    }
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN: 
    sprinttype(GET_OBJ_VAL(j, 2), drinks, buf2);
    sprintf(buf, "Max-contains: &c%d&n, Contains: &c%d&n, Poisoned: &g%s&n, Liquid: &g%s&n",
            GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1),
            GET_OBJ_VAL(j, 3) ? "Yes" : "No", buf2);
    break;
  case ITEM_NOTE:
    sprintf(buf, "Tongue (unused): &c%d&n", GET_OBJ_VAL(j, 0));
    break;
  case ITEM_KEY:
    sprintf(buf, "Keytype: &c%d&n", GET_OBJ_VAL(j, 0));
    break;
  case ITEM_FOOD:
    sprintf(buf, "Makes full: &c%d&n, Poisoned: &g%s&n",
            GET_OBJ_VAL(j, 0), (GET_OBJ_VAL(j, 3) == 0 ? "No" : "Yes"));
    break;
  case ITEM_MAGIC_EQ:
    sprintf(buf, "Spells: &g%s&n (&c%d&n), &g%s&n (&c%d&n), &g%s&n (&c%d&n), Charge: &c%d&n",
		skill_name(GET_OBJ_VAL(j,0)), GET_OBJ_VAL(j, 0),
                skill_name(GET_OBJ_VAL(j,1)), GET_OBJ_VAL(j, 1), 
		skill_name(GET_OBJ_VAL(j, 2)), GET_OBJ_VAL(j, 2), 
                GET_OBJ_VAL(j,3));
    break;
  case ITEM_JOINABLE:
    sprintf(buf, "Joins with: &c%d&n, Makes: &c%d&n", GET_OBJ_VAL(j,0), GET_OBJ_VAL(j,3));
    break;
  case ITEM_BATTERY:
    sprintf(buf, "Battery Type: &g%s&n, Max Value: &c%d&n, Current Value: &c%d&n, Ratio: &c%d&n:&c1&n",
      battery_types[GET_OBJ_VAL(j,0)], GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 3));
    break;
  case ITEM_GATEWAY:
    sprintf(buf, "Teleports to: &c%d&n, Min Level: &c%d&n, Max Level: &c%d&n, Entry Fee: &c%d&n.",
      GET_OBJ_VAL(j,0), GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2),
      GET_OBJ_VAL(j,3));
    break;
  default:
    sprintf(buf, "Values 0-3: [&c%d&n] [&c%d&n] [&c%d&n] [&c%d&n]",
            GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1),
            GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 3));
    break;
  }
} 

void do_stat_object(struct char_data * ch, struct obj_data * j)
{
  char lr_buf[9];
  int i, found;
  obj_vnum vnum;
  struct obj_data *j2;
  struct extra_descr_data *desc;
  struct timer_type *timer;

  vnum = GET_OBJ_VNUM(j);
  sprintf(buf, "Name: '%s%s%s', Aliases: %s\r\n", CCYEL(ch, C_NRM),
	  ((j->short_description) ? j->short_description : "<None>"),
	  CCNRM(ch, C_NRM), j->name);
  send_to_char(buf, ch);
  sprinttype(GET_OBJ_TYPE(j), item_types, buf1);
  if (GET_OBJ_RNUM(j) >= 0)
    strcpy(buf2, (obj_index[GET_OBJ_RNUM(j)].func ? "Exists" : "None"));
  else
    strcpy(buf2, "None");
  sprintf(buf, "VNum: [%s%5d%s], RNum: [%5d], Type: %s, SpecProc: %s, Damage: &r%d&n/&r%d&n\r\n",
   CCGRN(ch, C_NRM), vnum, CCNRM(ch, C_NRM), GET_OBJ_RNUM(j), buf1, buf2,
   GET_OBJ_DAMAGE(j), GET_OBJ_MAX_DAMAGE(j));
  send_to_char(buf, ch);
  sprintf(buf, "L-Des: %s\r\n", ((j->description) ? j->description : "None"));
  send_to_char(buf, ch);

  if (j->ex_description) {
    sprintf(buf, "Extra descs:%s", CCCYN(ch, C_NRM));
    for (desc = j->ex_description; desc; desc = desc->next) {
      strcat(buf, " ");
      if (desc->keyword)
	strcat(buf, desc->keyword);
    }
    strcat(buf, CCNRM(ch, C_NRM));
    send_to_char(strcat(buf, "\r\n"), ch);
  }
  send_to_char("Can be worn on: ", ch);
  sprintbit(j->obj_flags.wear_flags, wear_bits, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

  send_to_char("Set char bits : ", ch);
  sprintbit(j->obj_flags.bitvector, affected_bits, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

  send_to_char("Extra flags   : ", ch);
  sprintbit(GET_OBJ_EXTRA(j), extra_bits, buf);
  sprintf(lr_buf, " LR_%d", (int)GET_OBJ_LR(j));
  strcat(buf, lr_buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

  if (OBJ_FLAGGED(j, ITEM_RIDDEN)) {
	sprintf(buf, "Ridden by: %s\r\n", (OBJ_RIDDEN(j) ? GET_NAME(OBJ_RIDDEN(j)) : "Noone"));
	send_to_char(buf, ch);
  }

//  sprintf(buf, "Level Restrict: %d\r\n", (int)GET_OBJ_LR(j) );
//  send_to_char(buf, ch);

  sprintf(buf, "Weight: %d, Value: &Y%d&n, Cost/day: &Y%d&n, Timer: %d\r\n",
     GET_OBJ_WEIGHT(j), GET_OBJ_COST(j), GET_OBJ_RENT(j), GET_OBJ_TIMER(j));
  send_to_char(buf, ch);

  strcpy(buf, "In room: ");
  if (j->in_room == NOWHERE)
    strcat(buf, "Nowhere");
  else {
    sprintf(buf2, "%d", GET_ROOM_VNUM(IN_ROOM(j)));
    strcat(buf, buf2);
  }
  /*
   * NOTE: In order to make it this far, we must already be able to see the
   *       character holding the object. Therefore, we do not need CAN_SEE().
   */
  strcat(buf, ", In object: ");
  strcat(buf, j->in_obj ? j->in_obj->short_description : "None");
  strcat(buf, ", Carried by: ");
  strcat(buf, j->carried_by ? GET_NAME(j->carried_by) : "Nobody");
  strcat(buf, ", Worn by: ");
  strcat(buf, j->worn_by ? GET_NAME(j->worn_by) : "Nobody");
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

  do_list_obj_values(j,buf);
  strcat(buf,"\r\n");
  send_to_char(buf, ch);

  /*
   * I deleted the "equipment status" code from here because it seemed
   * more or less useless and just takes up valuable screen space.
   */

  if (j->contains) {
    sprintf(buf, "\r\nContents:%s", CCGRN(ch, C_NRM));
    for (found = 0, j2 = j->contains; j2; j2 = j2->next_content) {
      sprintf(buf2, "%s %s", found++ ? "," : "", j2->short_description);
      strcat(buf, buf2);
      if (strlen(buf) >= 62) {
	if (j2->next_content)
	  send_to_char(strcat(buf, ",\r\n"), ch);
	else
	  send_to_char(strcat(buf, "\r\n"), ch);
	*buf = found = 0;
      }
    }

    if (*buf)
      send_to_char(strcat(buf, "\r\n"), ch);
    send_to_char(CCNRM(ch, C_NRM), ch);
  }
  found = 0;
  send_to_char("Affections:", ch);
  for (i = 0; i < MAX_OBJ_AFFECT; i++)
    if (j->affected[i].modifier) {
      found = 1;
      sprinttype(j->affected[i].location, apply_types, buf2);
      sprintf(buf, "%s %+d to %s", found++ ? "," : "",
	      j->affected[i].modifier, buf2);
      send_to_char(buf, ch);
    }

  if (!found)
    send_to_char(" None", ch);

  send_to_char("\r\n", ch);

  found = 0;
  /* Routine to show what timers an item is affected by */
  send_to_char("Timers:", ch);
  if (j->timers) {
    for (timer = j->timers; timer; timer = timer->next) {
      found = 1;
      sprintf(buf,"\r\nTIM: (%3dhr) %s%-22s%s", timer->duration, 
	  CCCYN(ch, C_NRM), timer_types[timer->type], CCNRM(ch, C_NRM));
      sprintf(buf2,"Uses: (%2d) of max: (%2d)\r\n",timer->uses,timer->max_uses);
      strcat(buf, buf2);
      send_to_char(buf,ch);
    } 
  }

  if (!found)
    send_to_char(" None", ch);



  send_to_char("\r\nMaterials :", ch);
  if (j->materials == NULL) {
    send_to_char(" None", ch);
  } else {
    list<ObjMaterialClass>::iterator itr;
    itr = j->materials->begin();
    strcpy(buf2, "");
    char buf3[255];
    while (itr != j->materials->end()) {
      char *oname = obj_proto[real_object((*itr).vnum)].name;
      sprintf(buf3, " (%s :%d x %d) ",  oname, (*itr).vnum, (*itr).number);
      strcat(buf2, buf3);
      itr++;
    }
    send_to_char(buf2, ch);
  }
  send_to_char("\r\nMakes :", ch);
  if (j->products == NULL) {
    send_to_char(" None", ch);
  } else {
    list<ObjProductClass>::iterator itr;
    itr = j->products->begin();
    strcpy(buf2, "");
    char buf3[255];
    while (itr != j->products->end()) {
      char *oname = obj_proto[real_object((*itr).vnum)].name;
      sprintf(buf3, " (%s :%d  S:%d L:%d) ",  oname, (*itr).vnum, (*itr).skill, (*itr).level);
      strcat(buf2, buf3);
      itr++;
    }
    send_to_char(buf2, ch);
  }
  
    

  send_to_char("\r\n", ch);

  /* check the object for a script */
  do_sstat_object(ch, j);
}


void do_stat_character(struct char_data * ch, struct char_data * k)
{
  int i, i2, found = 0;
  struct obj_data *j;
  struct follow_type *fol;
  struct affected_type *aff;
  struct timer_type *timer;
  char buf3[MAX_STRING_LENGTH];
  int ETERNAL;
#ifdef NO_LOCALTIME
  struct tm lt;
#endif
  struct assisters_type *assisters; 

  ETERNAL = (GET_LEVEL(ch) >= LVL_ETRNL1 && GET_LEVEL(ch) <= LVL_ETRNL9);   

  sprinttype(GET_SEX(k), genders, buf);
  sprintf(buf2, " %s '%s'  IDNum: [%5ld], In room [%5d]",
	  (!IS_NPC(k) ? "PC"  :
	  (!IS_MOB(k) ? "NPC" : "MOB")),
	  GET_NAME(k), GET_IDNUM(k), GET_ROOM_VNUM(IN_ROOM(k)));

  if (!IS_NPC(k))
  {
    if (GET_INVIS_TYPE(k) == INVIS_SPECIFIC)
      sprintf(buf3,", Invis to [%s%s%s]", CCYEL(ch, C_NRM),
	      get_name_by_id(GET_INVIS_LEV(k)), CCNRM(ch,C_NRM));
    else if (GET_INVIS_TYPE(k) == INVIS_SINGLE)
      sprintf(buf3,", Invis to Lvl [%s%ds%s]", CCYEL(ch,C_NRM),
	      GET_INVIS_LEV(k), CCNRM(ch,C_NRM));
    else if (GET_INVIS_TYPE(k) == INVIS_NORMAL)
      sprintf(buf3,", Invis Lvl [%s%d%s]", CCYEL(ch,C_NRM),
	      GET_INVIS_LEV(k), CCNRM(ch,C_NRM));
    else
      sprintf(buf3,", Invis to Lvls [%s%d-%d%s]",CCYEL(ch, C_NRM),
	      GET_INVIS_LEV(k), GET_INVIS_TYPE(ch), CCNRM(ch,C_NRM));
    strcat(buf2,buf3);
  }

  strcat(buf2,"\r\n");
  send_to_char(strcat(buf, buf2), ch);
  if (IS_MOB(k))
  {
    sprintf(buf, "Alias: %s, VNum: [%5d], RNum: [%5d]\r\n",
	    k->player.name, GET_MOB_VNUM(k), GET_MOB_RNUM(k));
    send_to_char(buf, ch);
  }
  sprintf(buf, "Title: %s\r\n", (k->player.title ? k->player.title : "<None>"));
  send_to_char(buf, ch);
  sprintf(buf, "L-Des: %s", (k->player.long_descr ? k->player.long_descr : 
	                    "<None>\r\n"));
  send_to_char(buf, ch);

  if (IS_NPC(k))
  {	/* Use GET_CLASS() macro? */
    sprinttype(GET_CLASS(k), npc_class_types, buf2);
    sprintf(buf, "&nMonster Class: &B%s&n\r\n", buf2);
  } else {
    sprinttype(GET_CLASS(k), pc_class_types, buf2);
    sprinttype(GET_RACE(k), pc_race_types, buf3); 
    sprintf(buf, "Class: &B%s&n, Race: &B%s&n, Exp Modifier: [&R%.3f&n]\r\n", buf2, buf3,GET_MODIFIER(k));
  }
  if (IS_NPC(k))
  {
    sprintf(buf2, "Lev: [%s%2d%s], XP: [%s%8d%s], Align: [%4d]\r\n",
	    CCYEL(ch, C_NRM), GET_LEVEL(k), CCNRM(ch, C_NRM),
	    CCYEL(ch, C_NRM), GET_EXP(k), CCNRM(ch, C_NRM),
	    GET_ALIGNMENT(k));
  } else {
    if (CAN_LEVEL(k))
    {
      sprintf(buf2, "Lev: [%s%3d%s], XP: [%s%8d%s], XP_NL: [%s%8d%s], Align: [%4d]\r\n",
	      CCYEL(ch, C_NRM), GET_LEVEL(k), CCNRM(ch, C_NRM),
	      CCYEL(ch, C_NRM), GET_EXP(k), CCNRM(ch, C_NRM), CCYEL(ch, C_NRM),
	      level_exp(ch,GET_LEVEL(k))-GET_EXP(k), CCNRM(ch, C_NRM),
	      GET_ALIGNMENT(k));
    } else {
      sprintf(buf2, "Lev: [%s%3d%s], XP: [%s%8d%s], Align: [%4d]\r\n",
          CCYEL(ch, C_NRM), GET_LEVEL(k), CCNRM(ch, C_NRM),
          CCYEL(ch, C_NRM), GET_EXP(k), CCNRM(ch, C_NRM),
          GET_ALIGNMENT(k));
    }
  } 
  strcat(buf, buf2);
  send_to_char(buf, ch);
  if (!IS_NPC(k))
  {
#ifndef NO_LOCALTIME
    strcpy(buf1, (char *) asctime(localtime(&(k->player.time.birth))));
    strcpy(buf2, (char *) asctime(localtime(&(k->player.time.logon))));
#else
    if (jk_localtime(&lt, k->player.time.birth))
    {
      basic_mud_log("Error in jk_localtime (birth: %d) [%s:%d]\n",
	            k->player.time.birth, __FILE__, __LINE__);
      strcpy(buf1, "ERROR!");
    } else {
      strcpy(buf1, (char *)asctime(&lt));
    }
    if (jk_localtime(&lt, k->player.time.logon))
    {
      basic_mud_log("Error in jk_localtime (birth: %d) [%s:%d]\n",
	            k->player.time.logon, __FILE__, __LINE__);
      strcpy(buf2, "ERROR!");
    } else {
      strcpy(buf2, (char *)asctime(&lt));
    }
#endif
    buf1[10] = buf2[10] = '\0';
    sprintf(buf, "Created: [%s], Last Logon: [%s], Played [%dh %dm], Age [%d]\r\n",
	    buf1, buf2, k->player.time.played / 3600,
	    ((k->player.time.played % 3600) / 60), age(k)->year);
    send_to_char(buf, ch);
    sprintf(buf, "Hometown: [%d], Speaks: [%d/%d/%d], (STL[%d]/per[%d]/NSTL[%d])",          k->player.hometown, GET_TALK(k, 0), GET_TALK(k, 1), GET_TALK(k, 2),
            GET_PRACTICES(k), int_app[GET_INT(k)].learn,
            wis_app[GET_WIS(k)].bonus);

    /*. Display OLC zone for immorts .*/
    if (GET_LEVEL(k) >= LVL_CHAMP)
      sprintf(buf + strlen(buf), ", OLC[%d]", GET_OLC_ZONE(k));
    strcat(buf, "\r\n");

    send_to_char(buf, ch);
    
    sprintf(buf,"Start Rooms: [%d, %d, %d], Stat Points: [%4d]\r\n",
        ENTRY_ROOM(k,WORLD_MEDIEVAL), ENTRY_ROOM(k,WORLD_WEST), 
        ENTRY_ROOM(k, WORLD_FUTURE), GET_STAT_POINTS(k));
    send_to_char(buf,ch); 
  }
  sprintf(buf, "Str: &C%d/%d&n(&c%d/%d&n) Int: &C%d&n(&c%d&n) Wis: &C%d&n(&c%d&n) Dex: &C%d&n(&c%d&n) Con: &C%d&n(&c%d&n) Cha: &C%d&n(&c%d&n)\r\n",
	  GET_AFF_STR(k), GET_AFF_ADD(k), GET_REAL_STR(k), GET_REAL_ADD(k), 
	  GET_AFF_INT(k), GET_REAL_INT(k), GET_AFF_WIS(k), GET_REAL_WIS(k), 
	  GET_AFF_DEX(k), GET_REAL_DEX(k), GET_AFF_CON(k), GET_REAL_CON(k), 
	  GET_AFF_CHA(k), GET_REAL_CHA(k));
  send_to_char(buf, ch);

  if (!ETERNAL)
  {
    sprintf(buf, "Hit p.:[%s%d/%d+%d%s]  Mana p.:[%s%d/%d+%d%s]  Move p.:[%s%d/%d+%d%s]\r\n",
	    CCGRN(ch, C_NRM), GET_HIT(k), GET_MAX_HIT(k), hit_gain(k),
	    CCNRM(ch, C_NRM), CCGRN(ch, C_NRM), GET_MANA(k), GET_MAX_MANA(k),
	    mana_gain(k), CCNRM(ch, C_NRM), CCGRN(ch, C_NRM), GET_MOVE(k),
	    GET_MAX_MOVE(k), move_gain(k), CCNRM(ch, C_NRM));
    send_to_char(buf, ch);

    sprintf(buf, "Coins: [&Y%9d&n], Bank: [&Y%9d&n] (Total: &Y%d&n)\r\n",
	    GET_GOLD(k), GET_BANK_GOLD(k), GET_GOLD(k) + GET_BANK_GOLD(k));
    send_to_char(buf, ch);

    sprintf(buf, "AC: [&c%d&n], Thac0: [&c%d&n] Hitroll: [&r%2d&n], Damroll: [&r%2d&n], Saving throws: [%d/%d/%d/%d/%d]\r\n",
	    compute_armor_class(k, 0), thaco(k, NULL),
	    k->points.hitroll, k->points.damroll, saving_throws(k, 0),
	    saving_throws(k, 1), saving_throws(k, 2), saving_throws(k, 3),
	    saving_throws(k, 4));
    send_to_char(buf, ch);
  }

  if (!IS_NPC(k))
  {
    sprintf(buf, "Social Points: %ld, Social Rank: %s\r\n", 
	    GET_SOCIAL_POINTS(k), social_ranks[GET_SOCIAL_STATUS(k)]);
    send_to_char(buf, ch);
  }
  sprinttype(GET_POS(k), position_types, buf2);
  sprintf(buf, "Pos: %s, Fighting: %s", buf2,
	  (FIGHTING(k) ? GET_NAME(FIGHTING(k)) : "Nobody"));
  if (MOUNTING(k))
  {
    sprintf(buf2, ", Mounted on: %s", 
	    (IS_NPC(k) ? "Yes" : GET_NAME(MOUNTING(k))));
    strcat(buf, buf2);
  }
  if (MOUNTING_OBJ(k))
  {
    sprintf(buf2, ", Mounted on: %s", MOUNTING_OBJ(k)->short_description);
    strcat(buf, buf2);
  }
  if (IS_NPC(k))
  {
    strcat(buf, ", Attack type: ");
    strcat(buf, attack_hit_text[k->mob_specials.attack_type].singular);
  }
  if (k->desc)
  {
    sprinttype(STATE(k->desc), connected_types, buf2);
    strcat(buf, ", Connected: ");
    strcat(buf, buf2);
  }
  send_to_char(strcat(buf, "\r\n"), ch);

  strcpy(buf, "Default position: ");
  sprinttype((k->mob_specials.default_pos), position_types, buf2);
  strcat(buf, buf2);

  sprintf(buf2, ", Idle Timer (in tics) [%d]\r\n", k->char_specials.timer);
  strcat(buf, buf2);
  send_to_char(buf, ch);
  if (IS_NPC(k))
  {
    sprintbit(MOB_FLAGS(k), action_bits, buf2);
    sprintf(buf, "NPC flags: %s%s%s\r\n", CCCYN(ch, C_NRM), buf2, 
	    CCNRM(ch, C_NRM));
    send_to_char(buf, ch);
  } else {
    sprintbit(PLR_FLAGS(k), player_bits, buf2);
    sprintf(buf, "PLR: %s%s%s\r\n", CCCYN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
    send_to_char(buf, ch);
    sprintbit(PRF_FLAGS(k), preference_bits, buf2);
    sprintf(buf, "PRF: %s%s%s\r\n", CCGRN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
    send_to_char(buf, ch);
    sprintbit(EXT_FLAGS(k), extended_bits, buf2);
    sprintf(buf, "EXT: %s%s%s\r\n", CCGRN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
    send_to_char(buf, ch);
    sprintbit(GET_SPECIALS(k), special_ability_bits, buf2);
    sprintf(buf, "ABL: %s%s%s\r\n", CCGRN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
    send_to_char(buf, ch);

    /* Punishment Bits - ARTUS */
    i2 = 0;
    sprintf(buf, "PUN:");
    for (i = 0; i < NUM_PUNISHES; i++)
      if (PUN_FLAGGED(k, i))
      {
        sprintf(buf, "%s %s[%d]", buf, punish_types[i], PUN_HOURS(k, i));
        i2 = 1;
      }

    if (i2 == 0)
      strcat(buf, " None.");
    strcat(buf, "\r\n");
    send_to_char(buf, ch);

    /* Offence Counts - ARTUS */
    i2 = 0;
    sprintf(buf, "OFF:");
    for (i = 0; i < NUM_OFFENCES; i++)
      if (HAS_OFFENDED(k,i) > 0)
      {
        sprintf(buf, "%s %s[&g%d&n]", buf, offence_types[i], HAS_OFFENDED(k,i));
        i2 = 1;
      }
    if (i2 == 0)
      strcat(buf, " None.");
    strcat(buf, "\r\n");
    send_to_char(buf, ch);

    /* Clan Rank, Clan Name - ARTUS */
    sprintf(buf, "Clan:&g %d&n (&g%s&n) Rank: &g%d&n of&g %d&n\r\n",
	    GET_CLAN(k), 
	    ((GET_CLAN(k) > 0) ? clan[find_clan_by_id(GET_CLAN(k))].name :
	     "none"), GET_CLAN_RANK(k), 
	    ((GET_CLAN(k) > 0) ? clan[find_clan_by_id(GET_CLAN(k))].ranks : 0));
    send_to_char(buf, ch);

    /* Remort Levels - ARTUS */
    sprintf(buf, "Remort Levels:  One[&g%3d&n] Two[&g%3d&n] Max[&g%3d&n] Total[&g%3d&n]\r\n", GET_REM_ONE(k), GET_REM_TWO(k), GET_MAX_LVL(k), 
	      (GET_REM_ONE(k) + GET_REM_TWO(k) + GET_LEVEL(k)));
    send_to_char(buf, ch);

    /* Kill Counts - Artus */ // ... You want to get stats off the target, Artus
    sprintf(buf, "Kills: Imm[&g%ld&n] By Imm[&g%ld&n] Mob[&g%ld&n] By Mob[&g%ld&n] PC[&g%ld&n] By PC[&g%ld&n]; Unholiness: %d\r\n", GET_IMMKILLS(k), 
	    GET_KILLSBYIMM(k), GET_MOBKILLS(k), GET_KILLSBYMOB(k),
	    GET_PCKILLS(k), GET_KILLSBYPC(k), GET_UNHOLINESS(k));
    send_to_char(buf, ch);

/*    sprintf(buf, "TIMERS: [");
    for (i=0; i < MAX_TIMERS; i++) {
      if (i != (MAX_TIMERS - 1))
        sprintf(buf2," %d,", TIMER(k,i));
      else
        sprintf(buf2," %d]\r\n", TIMER(k,i));
      strcat(buf,buf2);
    } 
    send_to_char(buf, ch); */
   
  }
  if (!IS_NPC(k) && IS_SET(GET_SPECIALS(k), SPECIAL_DISGUISE))
  {
    sprintf(buf, "Mob vnum memorised: %ld, Disguised: %s.\r\n",
	    CHAR_MEMORISED(k), CHAR_DISGUISED(k) == 0 ? "No" : "Yes");
    send_to_char(buf, ch);
  }
  if (IS_MOB(k))
  {
    sprintf(buf, "Mob Spec-Proc: %s, NPC Bare Hand Dam: %dd%d\r\n",
	    (mob_index[GET_MOB_RNUM(k)].func ? "Exists" : "None"),
	    k->mob_specials.damnodice, k->mob_specials.damsizedice);
    send_to_char(buf, ch);
  }
  sprintf(buf, "Carried: weight: %d, items: %d; ",
	  IS_CARRYING_W(k), IS_CARRYING_N(k));

  for (i=0, j=k->carrying; j; j=j->next_content, i++);
  sprintf(buf + strlen(buf), "Items in: inventory: %d, ", i);

  for (i = 0, i2 = 0; i < NUM_WEARS; i++)
    if (GET_EQ(k, i))
      i2++;
  sprintf(buf2, "eq: %d\r\n", i2);
  strcat(buf, buf2);
  send_to_char(buf, ch);

  if (!IS_NPC(k))
  {
    sprintf(buf, "Hunger: %d, Thirst: %d, Drunk: %d\r\n",
	    GET_COND(k, FULL), GET_COND(k, THIRST), GET_COND(k, DRUNK));
    send_to_char(buf, ch);
  }

  sprintf(buf, "Master is: %s, Followers are:",
	  ((k->master) ? GET_NAME(k->master) : "<none>"));
  for (fol = k->followers; fol; fol = fol->next)
  {
    sprintf(buf2, "%s %s", found++ ? "," : "", PERS(fol->follower, ch));
    strcat(buf, buf2);
    if (strlen(buf) >= 62)
    {
      if (fol->next)
	send_to_char(strcat(buf, ",\r\n"), ch);
      else
	send_to_char(strcat(buf, "\r\n"), ch);
      *buf = found = 0;
    }
  }

  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);

  sprintf(buf, "Autoassisting: %s, Autoassisters are:",
          (AUTOASSIST(k) ? GET_NAME(AUTOASSIST(k)) : "<none>"));
  found=0;
  for (assisters=k->autoassisters; assisters; assisters=assisters->next)
  {
    sprintf(buf2, "%s %s", found++ ? "," : "", PERS(assisters->assister, ch));
    strcat(buf, buf2);
    if (strlen(buf) >= 62)
    {
      if (assisters->next)
        send_to_char(strcat(buf, ",\r\n"), ch);
      else
        send_to_char(strcat(buf, "\r\n"), ch);
      *buf = found = 0;
    }
  }
 
  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);

  /* Showing the bitvector */
  sprintbit(AFF_FLAGS(k), affected_bits, buf2);
  sprintf(buf, "AFF: %s%s%s\r\n", CCYEL(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
  send_to_char(buf, ch);

  /* Routine to show what spells a char is affected by */
  if (k->affected)
  {
    for (aff = k->affected; aff; aff = aff->next)
    {
      *buf2 = '\0';
      if(aff->duration == CLASS_ABILITY)
      {
        sprintf(buf, "ABL: (Unlim) &c%-21s &n ", skill_name(aff->type));
        if (aff->modifier)
	{
          sprintf(buf2, "%+d to %s", aff->modifier, 
	          apply_types[(int)aff->location]);
          strcat(buf, buf2);
        }
      } else if (aff->duration == CLASS_ITEM) {
	sprintf(buf, "OBJ: (Unlim) &c%-21s &n ", skill_name(aff->type));
	if (aff->modifier)
	{
	  sprintf(buf2, "%+d to %s", aff->modifier, 
	          apply_types[(int)aff->location]);
	  strcat(buf, buf2);
	}
      } else {
        // ROD - here make Unlim for perm spells from eq
        // It appears the affect is removed when time is 1,
        // spell affects from magic eq are given with time 0
        // for abilities they are given time -1
 
        // I hate this dodgy code of vaders ....
        // ok go through the eq list and find if the affect is given by eq

        // This code is DUPLICATED in act.informative.c for affects
	/* Artus> This is now redundant.
        bool found = FALSE;
        for (int i = 0; i < NUM_WEARS; i++) {
          if (GET_EQ(ch, i) && GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_MAGIC_EQ) {
            for (int j = 0; j < 3; j++) {
              if (GET_OBJ_VAL(GET_EQ(ch, i), j) == aff->type) {
                found = TRUE;
                break;
              }
            }
          }
        }         

        if (found) {
          sprintf(buf, "SPL: (Unlim) %s%-21s%s ", CCCYN(ch, C_NRM),
              skill_name(aff->type), CCNRM(ch, C_NRM));
        } else { */
          sprintf(buf, "SPL: (%3dhr) %s%-21s%s ", aff->duration + 1,
              CCCYN(ch, C_NRM), skill_name(aff->type), CCNRM(ch, C_NRM));
        // }    
        if (aff->modifier)
	{
          sprintf(buf2, "%+d to %s", aff->modifier, 
	          apply_types[(int) aff->location]);
          strcat(buf, buf2);
        }
      }      
      if (aff->bitvector)
      {
	if (*buf2)
	  strcat(buf, ", sets ");
	else
	  strcat(buf, "sets ");
	sprintbit(aff->bitvector, affected_bits, buf2);
	strcat(buf, buf2);
      }
      send_to_char(strcat(buf, "\r\n"), ch);
    }
  }

  /* Routine to show what timers a char is affected by */
  if (k->timers)
  {
    for (timer = k->timers; timer; timer = timer->next)
    {

      sprintf(buf, "TIM: (%3dhr) %s%-22s%s", timer->duration, CCCYN(ch, C_NRM),
	      timer_types[timer->type], CCNRM(ch, C_NRM));
      sprintf(buf+strlen(buf), "Uses: (%2d) of max: (%2d)\r\n", timer->uses,
	      timer->max_uses);
      send_to_char(buf,ch);
    } 
  }

  /* check mobiles for a script */
  if (IS_NPC(k))
  {
    do_sstat_character(ch, k);
    if (SCRIPT_MEM(k))
    {
      struct script_memory *mem = SCRIPT_MEM(k);
      send_to_char("Script memory:\r\n  Remember             Command\r\n", ch);
      while (mem)
      {
        struct char_data *mc = find_char(mem->id);
        if (!mc)
	  send_to_char("  ** Corrupted!\r\n", ch);
        else {
          if (mem->cmd)
	    sprintf(buf, "  %-20.20s%s\r\n",GET_NAME(mc),mem->cmd);
          else
	    sprintf(buf,"  %-20.20s <default>\r\n",GET_NAME(mc));
          send_to_char(buf, ch);
        }
        mem = mem->next;
      }
    }
  } else {
    /* this is a PC, display their global variables */
    if (k->script && k->script->global_vars)
    {
      struct trig_var_data *tv;
      char name[MAX_INPUT_LENGTH];
      void find_uid_name(char *uid, char *name);

      send_to_char("Global Variables:\r\n", ch);

      /* currently, variable context for players is always 0, so it is */
      /* not displayed here. in the future, this might change */
      for (tv = k->script->global_vars; tv; tv = tv->next)
      {
        if (*(tv->value) == UID_CHAR)
	{
          find_uid_name(tv->value, name);
          sprintf(buf, "    %10s:  [UID]: %s\r\n", tv->name, name);
        } else
          sprintf(buf, "    %10s:  %s\r\n", tv->name, tv->value);

        send_to_char(buf, ch);
      }
    }
  }
}


ACMD(do_stat)
{
  struct char_data *victim;
  struct obj_data *object;
  struct char_file_u tmp_store;
  int ETERNAL, tmp;

  if (IS_NPC(ch))
    return;

  half_chop(argument, buf1, buf2);

  ETERNAL = (GET_LEVEL(ch) >= LVL_ETRNL1 && GET_LEVEL(ch) <= LVL_ETRNL9);
  if (!*buf1)
  {
    send_to_char("Stats on who or what?\r\n", ch);
    return;
  } 
  if(ETERNAL)
  {
    if((victim = generic_find_char(ch,buf1,FIND_CHAR_ROOM)))
      do_stat_character(ch,victim);
    else 
      send_to_char("That person does not appear to be here.\r\n",ch);
    return;
  } 
  if (is_abbrev(buf1, "room"))
  {
    do_stat_room(ch);
    return;
  } 
  if (is_abbrev(buf1, "mob"))
  {
    if (!*buf2)
      send_to_char("Stats on which mobile?\r\n", ch);
    else
    {
      if ((victim = generic_find_char(ch, buf2, FIND_CHAR_WORLD)) != NULL)
	do_stat_character(ch, victim);
      else
	send_to_char("No such mobile around.\r\n", ch);
    }
    return;
  } 
  if (is_abbrev(buf1, "player"))
  {
    if (!*buf2)
      send_to_char("Stats on which player?\r\n", ch);
    else
    {
      if ((victim = get_player_online(ch, buf2, FIND_CHAR_WORLD)) != NULL)
	do_stat_character(ch, victim);
      else
	send_to_char("No such player around.\r\n", ch);
    }
    return;
  }
  if (is_abbrev(buf1, "file"))
  {
    if (!*buf2)
      send_to_char("Stats on which player?\r\n", ch);
    else
    {
      CREATE(victim, struct char_data, 1);
      clear_char(victim);
      if (load_char(buf2, &tmp_store) > -1) {
	store_to_char(&tmp_store, victim);
	victim->player.time.logon = tmp_store.player_specials_primalsaved.last_logon;
	char_to_room(victim, 0);
	if (GET_LEVEL(victim) > GET_LEVEL(ch))
	  send_to_char("Sorry, you can't do that.\r\n", ch);
	else
	  do_stat_character(ch, victim);
	extract_char(victim);
      } else {
	send_to_char("There is no such player.\r\n", ch);
	free(victim);
      }
    }
    return;
  } 
  if (is_abbrev(buf1, "object"))
  {
    if (!*buf2)
      send_to_char("Stats on which object?\r\n", ch);
    else
    {
      if ((object = generic_find_obj(ch, buf2, FIND_OBJ_WORLD)) != NULL)
	do_stat_object(ch, object);
      else
	send_to_char("No such object around.\r\n", ch);
    }
    return;
  }
  // Artus> Everything else.
  tmp = generic_find(buf1, FIND_CHAR_ROOM | FIND_CHAR_WORLD | FIND_OBJ_INV |
                           FIND_OBJ_EQUIP | FIND_OBJ_ROOM | FIND_OBJ_WORLD,
		     ch, &victim, &object);
  switch (tmp)
  {
    case FIND_CHAR_ROOM:
    case FIND_CHAR_WORLD:
      do_stat_character(ch, victim);
      break;
    case FIND_OBJ_EQUIP:
    case FIND_OBJ_ROOM:
    case FIND_OBJ_WORLD:
    case FIND_OBJ_INV:
      do_stat_object(ch, object);
      break;
    default:
      send_to_char("Nothing around by that name.\r\n", ch);
  }
  return;
}


ACMD(do_shutdown)
{
  char *confirm = buf;

  if (subcmd != SCMD_SHUTDOWN) {
    send_to_char("If you want to shut something down, say so!\r\n", ch);
    return;
  }

  confirm = one_argument(argument, arg);
  skip_spaces(&confirm);

  if (files_need_saving() && str_cmp(confirm, "really") ) {
    send_to_char("OLC files need saving.\r\n"
            "Use &4shutdown <option> really&n if you want to shutdown.\r\n",ch);
    return;
  }
  if (!*arg) {
    basic_mud_log("(GC) Shutdown by %s.", GET_NAME(ch));
    send_to_all("Shutting down.\r\n");
    circle_shutdown = 1;
  } else if (!str_cmp(arg, "now")) {
    basic_mud_log("(GC) Shutdown NOW by %s.", GET_NAME(ch));
    send_to_all("Rebooting.. come back in about 10 seconds. [Chars NOT Saved]\r\n");
    circle_shutdown = 1;
    circle_reboot = 2;
  } else if (!str_cmp(arg, "reboot")) {
    basic_mud_log("(GC) Reboot by %s.", GET_NAME(ch));
    send_to_all("Rebooting.. come back in about 10 seconds. [Chars Saved]\r\n");
    touch(FASTBOOT_FILE);
    circle_shutdown = circle_reboot = 1;
  } else if (!str_cmp(arg, "die")) {
    basic_mud_log("(GC) Shutdown by %s.", GET_NAME(ch));
    send_to_all("Shutting down for maintenance.\r\n");
    touch(KILLSCRIPT_FILE);
    circle_shutdown = 1;
  } else if (!str_cmp(arg, "pause")) {
    basic_mud_log("(GC) Shutdown by %s.", GET_NAME(ch));
    send_to_all("Shutting down for maintenance.\r\n");
    touch(PAUSE_FILE);
    circle_shutdown = 1;
  } else
    send_to_char("Unknown shutdown option.\r\n", ch);

  // DM - TODO - check if command below is needed (not in original circle code)
  House_save_all(); 
}


void stop_snooping(struct char_data * ch)
{
  if (!ch->desc->snooping)
    send_to_char("You aren't snooping anyone.\r\n", ch);
  else {
    send_to_char("You stop snooping.\r\n", ch);
    ch->desc->snooping->snoop_by = NULL;
    ch->desc->snooping = NULL;
  }
}


ACMD(do_snoop)
{
  struct char_data *victim, *tch;

  if (!ch->desc)
    return;

  one_argument(argument, arg);

  if (!*arg)
    stop_snooping(ch);
  else if (!(victim = generic_find_char(ch, arg, FIND_CHAR_WORLD)))
    send_to_char("No such person around.\r\n", ch);
  else if (!victim->desc)
    send_to_char("There's no link.. nothing to snoop.\r\n", ch);
  else if (victim == ch)
    stop_snooping(ch);
  /* only IMPS can snoop players in private rooms BM 3/95 */
  else if (GET_LEVEL(ch) < LVL_IMPL && 
                  IS_SET(world[victim->in_room].room_flags, ROOM_HOUSE))
    send_to_char("That player is in a private room, sorry!\n",ch);
  else if (victim->desc->snoop_by)
    send_to_char("Busy already. \r\n", ch);
  else if (victim->desc->snooping == ch->desc)
    send_to_char("Don't be stupid.\r\n", ch);
  else {
    if (victim->desc->original)
      tch = victim->desc->original;
    else
      tch = victim;

    if (GET_LEVEL(tch) >= GET_LEVEL(ch)) {
      send_to_char("You can't.\r\n", ch);
      return;
    }
    send_to_char(OK, ch);

    if (ch->desc->snooping)
      ch->desc->snooping->snoop_by = NULL;

    ch->desc->snooping = victim->desc;
    victim->desc->snoop_by = ch->desc;
  }
}



ACMD(do_switch)
{
  SPECIAL(shop_keeper);  
  struct char_data *victim;

  one_argument(argument, arg);

  if (ch->desc->original)
    send_to_char("You're already switched.\r\n", ch);
  else if (!*arg)
    send_to_char("Switch with who?\r\n", ch);
  else if (!(victim = generic_find_char(ch, arg, 
					FIND_CHAR_ROOM | FIND_CHAR_WORLD)))
    send_to_char("No such character.\r\n", ch);
  else if (ch == victim)
    send_to_char("Hee hee... we are jolly funny today, eh?\r\n", ch);
/*  // DM - stop char switching
  else if (!IS_NPC(victim)) 
    send_to_char("No you will not switch into playing characters!\r\n", ch); */
  // Artus - I think this does it better :o)
  else if ((GET_LEVEL(ch) < GET_LEVEL(victim)) || (!IS_NPC(victim) && GET_IDNUM(victim) <= 3))
    send_to_char("Their mind is too strong, you cannot takeover their body.\r\n", ch);
  else if (victim->desc)
    send_to_char("You can't do that, the body is already in use!\r\n", ch);
  else if ((GET_LEVEL(ch) < LVL_IMPL) && !IS_NPC(victim))
    send_to_char("You aren't holy enough to use a mortal's body.\r\n", ch);
  else if (GET_LEVEL(ch) < LVL_GRGOD && ROOM_FLAGGED(IN_ROOM(victim), ROOM_GODROOM))
    send_to_char("You are not godly enough to use that room!\r\n", ch);
  else if (GET_LEVEL(ch) < LVL_GRGOD && ROOM_FLAGGED(IN_ROOM(victim), ROOM_HOUSE)
		&& !House_can_enter(ch, GET_ROOM_VNUM(IN_ROOM(victim))))
    send_to_char("That's private property -- no trespassing!\r\n", ch);
  else if ((GET_LEVEL(ch) < LVL_GOD)&&(GET_MOB_SPEC(victim) == shop_keeper))
        send_to_char("Switching into Shopkeepers in NOT ALLOWED!\r\n", ch);
  else {
    send_to_char(OK, ch);

    ch->desc->character = victim;
    ch->desc->original = ch;

    victim->desc = ch->desc;
    ch->desc = NULL;
  }
}


ACMD(do_return)
{
  if (ch->desc && ch->desc->original) {
    send_to_char("You return to your original body.\r\n", ch);

    /*
     * If someone switched into your original body, disconnect them.
     *   - JE 2/22/95
     *
     * Zmey: here we put someone switched in our body to disconnect state
     * but we must also NULL his pointer to our character, otherwise
     * close_socket() will damage our character's pointer to our descriptor
     * (which is assigned below in this function). 12/17/99
     */
    if (ch->desc->original->desc) {
      ch->desc->original->desc->character = NULL;
      STATE(ch->desc->original->desc) = CON_DISCONNECT;
    }

    /* Now our descriptor points to our original body. */
    ch->desc->character = ch->desc->original;
    ch->desc->original = NULL;

    /* And our body's pointer to descriptor now points to our descriptor. */
    ch->desc->character->desc = ch->desc;
    ch->desc = NULL;
  }
}



ACMD(do_load)
{
  struct char_data *mob;
  struct obj_data *obj;
  mob_vnum number;
  mob_rnum r_num;

  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2 || !isdigit(*buf2)) {
    send_to_char("&1Usage: &4load { obj | mob } <number>\r\n", ch);
    return;
  }
  if ((number = atoi(buf2)) < 0) {
    send_to_char("A NEGATIVE number??\r\n", ch);
    return;
  }
  if (is_abbrev(buf, "mob")) {
    if ((r_num = real_mobile(number)) < 0) {
      send_to_char("There is no monster with that number.\r\n", ch);
      return;
    // DM - allow zone owners to load mobiles of their zone
    } else if (GET_LEVEL(ch) < LVL_GOD && (GET_OLC_ZONE(ch) != 0 &&
          mob_index[r_num].vznum != GET_OLC_ZONE(ch))) {
      send_to_char("Sorry, you can only load mobiles of your zone.\r\n", ch);
      return; 
    }
    mob = read_mobile(r_num, REAL);
    char_to_room(mob, ch->in_room);

    act("$n makes a quaint, magical gesture with one hand.", TRUE, ch,
	0, 0, TO_ROOM);
    act("$n has created $N!", FALSE, ch, 0, mob, TO_ROOM);
    act("You create $N.", FALSE, ch, 0, mob, TO_CHAR);
    load_mtrigger(mob);
  } else if (is_abbrev(buf, "obj")) {
    if ((r_num = real_object(number)) < 0) {
      send_to_char("There is no object with that number.\r\n", ch);
      return;
    // DM - allow zone owners to load objects of their zone
    } else if (GET_LEVEL(ch) < LVL_GOD && (GET_OLC_ZONE(ch) != 0 && 
          obj_index[r_num].vznum != GET_OLC_ZONE(ch))) {
      send_to_char("Sorry, you can only load objects of your zone.\r\n", ch);
      return; 
    }
    obj = read_object(r_num, REAL);
    if (load_into_inventory)
      obj_to_char(obj, ch, __FILE__, __LINE__);
    else
      obj_to_room(obj, ch->in_room);
    act("$n makes a strange magical gesture.", TRUE, ch, 0, 0, TO_ROOM);
    act("$n has created $p!", FALSE, ch, obj, 0, TO_ROOM);
    act("You create $p.", FALSE, ch, obj, 0, TO_CHAR);
    load_otrigger(obj);
    load_otrigger(obj);
  } else
    send_to_char("That'll have to be either 'obj' or 'mob'.\r\n", ch);
}

ACMD(do_vstat)
{
  struct char_data *mob;
  struct obj_data *obj;
  mob_vnum number;	/* or obj_vnum ... */
  mob_rnum r_num;	/* or obj_rnum ... */

  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2 || !isdigit(*buf2)) {
    send_to_char("&1Usage: &4vstat { obj | mob } <vnum>&n\r\n", ch);
    return;
  }

  if ((number = atoi(buf2)) < 0) {
    send_to_char("A NEGATIVE number??\r\n", ch);
    return;
  }
  if (is_abbrev(buf, "mob")) {
    if ((r_num = real_mobile(number)) < 0) {
      send_to_char("There is no monster with that number.\r\n", ch);
      return;
    }
    mob = read_mobile(r_num, REAL);
    char_to_room(mob, 0);
    do_stat_character(ch, mob);
    extract_char(mob);
  } else if (is_abbrev(buf, "obj")) {
    if ((r_num = real_object(number)) < 0) {
      send_to_char("There is no object with that number.\r\n", ch);
      return;
    }
    obj = read_object(r_num, REAL);
    do_stat_object(ch, obj);
    extract_obj(obj);
  } else
    send_to_char("That'll have to be either 'obj' or 'mob'.\r\n", ch);
}




/* clean a room of all mobiles and objects */
ACMD(do_purge)
{
  struct char_data *vict, *next_v;
  struct obj_data *obj, *next_o;

  one_argument(argument, buf);

  if (*buf)
  {			/* argument supplied. destroy single object
				 * or char */
    if ((vict = generic_find_char(ch, buf, FIND_CHAR_ROOM)) != NULL)
    {
      if (!IS_NPC(vict) && (GET_LEVEL(ch) <= GET_LEVEL(vict)))
      {
	send_to_char("Fuuuuuuuuu!\r\n", ch);
	return;
      }
      act("$n disintegrates $N.", FALSE, ch, 0, vict, TO_NOTVICT);

      if (!IS_NPC(vict))
      {
	sprintf(buf, "(GC) %s has purged %s.", GET_NAME(ch), GET_NAME(vict));
	mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
	if (vict->desc)
	{
	  STATE(vict->desc) = CON_CLOSE;
	  vict->desc->character = NULL;
	  vict->desc = NULL;
	}
      }
      extract_char(vict);
    } else if ((obj = find_obj_list(ch, buf, world[ch->in_room].contents)) != NULL) {
      act("$n destroys $p.", FALSE, ch, obj, 0, TO_ROOM);
      extract_obj(obj);
    } else {
      send_to_char("Nothing here by that name.\r\n", ch);
      return;
    }

    send_to_char(OK, ch);
  } else {			/* no argument. clean out the room */
    act("$n gestures... You are surrounded by scorching flames!",
	FALSE, ch, 0, 0, TO_ROOM);
    send_to_room("The world seems a little cleaner.\r\n", ch->in_room);

    for (vict = world[ch->in_room].people; vict; vict = next_v)
    {
      next_v = vict->next_in_room;
      if (IS_NPC(vict) && !MOUNTING(vict))
	extract_char(vict);
    }

    for (obj = world[ch->in_room].contents; obj; obj = next_o)
    {
      next_o = obj->next_content;
      extract_obj(obj);
    }
  }
}



const char *logtypes[] = {
  "off", "brief", "normal", "complete", "\n"
};

ACMD(do_syslog)
{
  int tp;

  one_argument(argument, arg);

  if (!*arg) {
    tp = ((PRF_FLAGGED(ch, PRF_LOG1) ? 1 : 0) +
	  (PRF_FLAGGED(ch, PRF_LOG2) ? 2 : 0));
    sprintf(buf, "Your syslog is currently %s.\r\n", logtypes[tp]);
    send_to_char(buf, ch);
    return;
  }
  if (((tp = search_block(arg, logtypes, FALSE)) == -1)) {
    send_to_char("&1Usage: &4syslog { Off | Brief | Normal | Complete }\r\n", ch);
    return;
  }
  REMOVE_BIT(PRF_FLAGS(ch), PRF_LOG1 | PRF_LOG2);
  SET_BIT(PRF_FLAGS(ch), (PRF_LOG1 * (tp & 1)) | (PRF_LOG2 * (tp & 2) >> 1));

  sprintf(buf, "Your syslog is now %s.\r\n", logtypes[tp]);
  send_to_char(buf, ch);
}



ACMD(do_advance)
{
  struct char_data *victim;
  char reasonString[MAX_INPUT_LENGTH];
  char *name = arg, *level = buf2, *reason = reasonString;
  int newlevel, oldlevel;

  reasonString[0] = '\0';
  reason = two_arguments(argument, name, level);

  if (*reason)
    reason++;

  sprintf(buf, "reason: '%s'\r\n", reason);
  send_to_char(buf, ch);

  if (*name)
  {
    if (!(victim = generic_find_char(ch, name, FIND_CHAR_ROOM | FIND_CHAR_WORLD)))
    {
      send_to_char("That player is not here.\r\n", ch);
      return;
    }
  } else {
    send_to_char("Advance who?\r\n", ch);
    return;
  }

  if (GET_LEVEL(ch) <= GET_LEVEL(victim))
  {
    send_to_char("Maybe that's not such a great idea.\r\n", ch);
    return;
  }
  if (IS_NPC(victim))
  {
    send_to_char("NO!  Not on NPC's.\r\n", ch);
    return;
  }
  if (!*level || (newlevel = atoi(level)) <= 0)
  {
    send_to_char("That's not a level!\r\n", ch);
    return;
  }
  if (newlevel > LVL_IMPL)
  {
    sprintf(buf, "%d is the highest possible level.\r\n", LVL_IMPL);
    send_to_char(buf, ch);
    return;
  }
  if (newlevel > GET_LEVEL(ch))
  {
    send_to_char("Yeah, right.\r\n", ch);
    return;
  }
  if (newlevel == GET_LEVEL(victim))
  {
    send_to_char("They are already at that level.\r\n", ch);
    return;
  }
  if (!*reason || (*reason && (strlen(reason) < 10)))
  {
    send_to_char("Please supply a reason of no less than 10 characters.\r\n",
                    ch);
    return;
  }
  oldlevel = GET_LEVEL(victim);
  if (newlevel < GET_LEVEL(victim))
  {
    send_to_char("You have been demoted!!!. Serves you RIGHT!\r\n", victim);
    demote_level(victim, newlevel, reason);
    /* DM_exp */
    GET_EXP(victim)=0;
    return;
  } else {
    act("$n makes some strange gestures.\r\n"
	"A strange feeling comes upon you,\r\n"
	"Like a giant hand, light comes down\r\n"
	"from above, grabbing your body, that\r\n"
	"begins to pulse with colored lights\r\n"
	"from inside.\r\n\r\n"
	"Your head seems to be filled with demons\r\n"
	"from another plane as your body dissolves\r\n"
	"to the elements of time and space itself.\r\n"
	"Suddenly a silent explosion of light\r\n"
	"snaps you back to reality.\r\n\r\n"
	"You feel slightly different.", FALSE, ch, 0, victim, TO_VICT);
  }

  send_to_char(OK, ch);

//  if (newlevel < oldlevel)
//    basic_mud_log("(GC) %s demoted %s from level %d to %d.",
//		GET_NAME(ch), GET_NAME(victim), oldlevel, newlevel);
//  else
//    basic_mud_log("(GC) %s has advanced %s to level %d (from %d)",
//		GET_NAME(ch), GET_NAME(victim), newlevel, oldlevel);

  gain_exp_regardless(victim, newlevel); // level_exp(victim, newlevel) - GET_EXP(victim)); 
  save_char(victim, NOWHERE);
}



ACMD(do_restore)
{
  struct char_data *vict;
  int i;

  one_argument(argument, buf);
  if (!*buf)
    send_to_char("Whom do you wish to restore?\r\n", ch);
  else if (!(vict = generic_find_char(ch, buf, FIND_CHAR_ROOM | FIND_CHAR_WORLD)))
    send_to_char(NOPERSON, ch);
  else {
    GET_HIT(vict) = GET_MAX_HIT(vict);
    GET_MANA(vict) = GET_MAX_MANA(vict);
    GET_MOVE(vict) = GET_MAX_MOVE(vict);
    
    if (!IS_NPC(vict)) {
      // Remove any 'bad' affects ... 
      if (affected_by_spell(vict, SPELL_POISON))
        mag_unaffects(0, ch, vict, SPELL_REMOVE_POISON, 0);         // poison
      if (affected_by_spell(vict, SPELL_PARALYZE))
        mag_unaffects(0, ch, vict, SPELL_REMOVE_PARA, 0);           // paralyze
      if (affected_by_spell(vict, SPELL_CURSE))
        mag_unaffects(0, ch, vict, SPELL_GREATER_REMOVE_CURSE, 0);  // curses
      if (IS_SET(AFF_FLAGS(vict), AFF_BLIND))
        mag_unaffects(0, ch, vict, SPELL_HEAL, 0);                  // blindness
      if (IS_GHOST(vict))
	REMOVE_BIT(EXT_FLAGS(vict), EXT_GHOST);

      if ((GET_LEVEL(ch) >= LVL_GRGOD) && (GET_LEVEL(vict) >= LVL_ANGEL)) {
        for (i = 1; i <= MAX_SKILLS; i++)
	  SET_SKILL(vict, i, 100);

        if (GET_LEVEL(vict) >= LVL_GRGOD) {
	  vict->real_abils.str_add = 100;
	  vict->real_abils.intel = 25;
	  vict->real_abils.wis = 25;
	  vict->real_abils.dex = 25;
	  vict->real_abils.str = 25;
	  vict->real_abils.con = 25;
	  vict->real_abils.cha = 25;
        }
        vict->aff_abils = vict->real_abils;
      }
    }
    update_pos(vict);
    send_to_char(OK, ch);
    act("You have been fully healed by $N!", FALSE, vict, 0, ch, TO_CHAR);
  }
}


void perform_immort_vis(struct char_data *ch)
{
  struct descriptor_data *d;
 
  if (GET_INVIS_LEV(ch) == 0 && !AFF_FLAGGED(ch, AFF_HIDE | AFF_INVISIBLE)) {
    send_to_char("You are already fully visible.\r\n", ch);
    return;
  }
 
  sprintf(buf, "You feel privilidged as %s materialises nearby.\r\n",
        GET_NAME(ch) );
 
  for( d = descriptor_list; d; d = d->next )
    if (d->character)
        if( (d->character->in_room == ch->in_room) && (d->character != ch))
           if( !CAN_SEE(d->character, ch) )
                send_to_char(buf, d->character);
 
  GET_INVIS_LEV(ch) = 0;
  GET_INVIS_TYPE(ch) = INVIS_NORMAL;
  send_to_char("You are now fully visible.\r\n", ch);
}


void perform_immort_invis(struct char_data *ch, int level)
{
  struct char_data *tch;
 
  if (IS_NPC(ch))
    return;
 
  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (tch == ch)
      continue;
 
    if (GET_LEVEL(tch) >= GET_INVIS_LEV(ch) && GET_LEVEL(tch) < level) {
 
       // character specific invis?
       if( GET_INVIS_TYPE(ch) == INVIS_SPECIFIC ) {
          if( GET_IDNUM(tch) == GET_INVIS_LEV(ch)) {
            if( GET_LEVEL(ch) > GET_LEVEL(tch) )
               act("You blink and realise that $n is gone.", FALSE, ch, 0, tch, TO_VICT);
            else {
                send_to_char("You can't go invis to that person!\r\n", ch);
                GET_INVIS_TYPE(ch) = 0;
                GET_INVIS_LEV(ch) = 0;
                return;
            }
          }
 
        }
        else
       // Standard invis?
       if( GET_INVIS_TYPE(ch) == INVIS_NORMAL )
          act("You blink and suddenly realize that $n is gone.", FALSE, ch, 0, tch, TO_VICT);
       else {
          // Specific invis?
          if ( GET_INVIS_TYPE(ch) == INVIS_SINGLE && GET_LEVEL(tch) == level - 1 )
               act("You blink and suddenly realize that $n is gone.", FALSE, ch, 0, tch, TO_VICT);
          else {
             // They are in a range invis
             if ( GET_LEVEL(tch) >= level && GET_LEVEL(tch) <= GET_INVIS_TYPE(ch) ) {
                  act("You blink and suddenly realize that $n is gone.", FALSE, ch, 0, tch, TO_VICT); 
             }
          }
       }
    }
    if (GET_LEVEL(tch) < GET_INVIS_LEV(ch) && GET_LEVEL(tch) >= level)
           act("You suddenly realize that $n is standing beside you.", FALSE, ch, 0,tch, TO_VICT);
 
  }
 
  if( GET_INVIS_TYPE(ch) == INVIS_SPECIFIC ) {
        sprintf(buf, "You are now invisible to %s.\r\n",
                get_name_by_id(GET_INVIS_LEV(ch)) );
        send_to_char(buf, ch);
        return;
  }
 
  GET_INVIS_LEV(ch) = level;
  if (GET_INVIS_TYPE(ch) == INVIS_SINGLE)
     sprintf(buf2, "s.");
  else if (GET_INVIS_TYPE(ch) == INVIS_NORMAL)
     sprintf(buf2, ".");
  else
    sprintf(buf2, " - %d.", GET_INVIS_TYPE(ch));
 
  sprintf(buf, "Your invisibility level is %d%s\r\n", level, buf2);
  send_to_char(buf, ch);
}     


ACMD(do_invis)
{
  int level, toplevel;
  long pid;     // player id
  struct char_file_u tmp;
  struct char_data *tch;
 
  if (IS_NPC(ch)) {
    send_to_char("You can't do that!\r\n", ch);
    return;
  }
 
  two_arguments(argument, arg, buf1);
 
  if (!*arg) {
    if (GET_INVIS_LEV(ch) > 0)
      perform_immort_vis(ch);
    else
      perform_immort_invis(ch, GET_LEVEL(ch));
  } else {
    // invis to a person?
    if( !isdigit(arg[0]) ) {
        if( (pid = get_id_by_name(arg)) < 0 ) {
          send_to_char("No such player exists.\r\n", ch);
          return;
        }
 
        if( pid == GET_IDNUM(ch) ) {
          send_to_char("You put your hands over your eyes and hide.\r\n",ch);
          return;
        }
        // Load player
        CREATE(tch, struct char_data, 1);
        load_char(arg, &tmp);
        clear_char(tch);
        store_to_char(&tmp, tch);
	tch->player.time.logon = tmp.player_specials_primalsaved.last_logon;
        char_to_room(tch, 0);
        if( GET_LEVEL(ch) <= GET_LEVEL(tch) ) {
            send_to_char("You can't go invisible to that person!\r\n",ch); 
            extract_char(tch);
            return;
        }
        extract_char(tch);
        GET_INVIS_LEV(ch) = get_id_by_name(arg);
        GET_INVIS_TYPE(ch) = INVIS_SPECIFIC;
        perform_immort_invis(ch, GET_LEVEL(ch));
        return;
    }
 
    level = atoi(arg);
 
    if ( level > GET_LEVEL(ch)  )
      send_to_char("You can't go invisible above your own level.\r\n", ch);
    else if (level < 1)
      perform_immort_vis(ch);
    else {
      // If there is a second argument, evaluate it
      if (*buf1) {
        // Are they specifying a range?
        if (isdigit(buf1[0])) {
          toplevel = atoi(buf1);
          if (toplevel <= level || toplevel >= GET_LEVEL(ch)) {
            send_to_char("The level range is invalid.\r\n", ch);
            return;
          } // Valid range?
          else {
            GET_INVIS_TYPE(ch) = toplevel;
          }
        /* Specified a particular invisibility level? */
        } else if (is_abbrev(buf1, "single")) {
            GET_INVIS_TYPE(ch) = INVIS_SINGLE;
        // Invalid second arg ...
        } else {
          send_to_char("Invalid 2nd argument. Expecting 'single' or "
              "<high range level>\r\n", ch);
          return;
        }
      }
      else // No second argument
         GET_INVIS_TYPE(ch) = INVIS_NORMAL;
 
      perform_immort_invis(ch, level); 
    }
  }
}   


ACMD(do_gecho)
{
  struct descriptor_data *pt;

  skip_spaces(&argument);
  delete_doubledollar(argument);

  if (!*argument)
    send_to_char("That must be a mistake...\r\n", ch);
  else {
    sprintf(buf, "%s\r\n", argument);
    for (pt = descriptor_list; pt; pt = pt->next)
      if (STATE(pt) == CON_PLAYING && pt->character && pt->character != ch)
	send_to_char(buf, pt->character);
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else
      send_to_char(buf, ch);
  }
}


ACMD(do_poofset)
{
  char **msg;

  switch (subcmd) {
  case SCMD_POOFIN:    msg = &(POOFIN(ch));    break;
  case SCMD_POOFOUT:   msg = &(POOFOUT(ch));   break;
  default:    return;
  }

  skip_spaces(&argument);

  if (strlen(argument) > POOF_LENGTH) {
    sprintf(buf,"Poof length exceded %d char's, not changed\r\n", POOF_LENGTH);
    send_to_char(buf,ch);
    return;
  } 

  if (*msg)
    free(*msg);

  if (!*argument)
    *msg = NULL;
  else
    *msg = str_dup(argument);
/*  else
    switch (subcmd) {
       case SCMD_POOFIN:     strcpy(POOFIN(ch),argument);    break;
       case SCMD_POOFOUT:    strcpy(POOFOUT(ch),argument);   break;
       default:      return;
    } 
 */
//  save_char(ch, NOWHERE);
  send_to_char(OK, ch);
}



ACMD(do_dc)
{
  struct descriptor_data *d;
  int num_to_dc;

  one_argument(argument, arg);
  if (!(num_to_dc = atoi(arg))) {
    send_to_char("&4Usage: &1dc <user number>&n (type USERS for a list)\r\n", ch);
    return;
  }
  for (d = descriptor_list; d && d->desc_num != num_to_dc; d = d->next);

  if (!d) {
    send_to_char("No such connection.\r\n", ch);
    return;
  }
  if (d->character && GET_LEVEL(d->character) >= GET_LEVEL(ch)) {
    if (!CAN_SEE(ch, d->character))
      send_to_char("No such connection.\r\n", ch);
    else
      send_to_char("Umm.. maybe that's not such a good idea...\r\n", ch);
    return;
  }

  /* We used to just close the socket here using close_socket(), but
   * various people pointed out this could cause a crash if you're
   * closing the person below you on the descriptor list.  Just setting
   * to CON_CLOSE leaves things in a massively inconsistent state so I
   * had to add this new flag to the descriptor. -je
   *
   * It is a much more logical extension for a CON_DISCONNECT to be used
   * for in-game socket closes and CON_CLOSE for out of game closings.
   * This will retain the stability of the close_me hack while being
   * neater in appearance. -gg 12/1/97
   *
   * For those unlucky souls who actually manage to get disconnected
   * by two different immortals in the same 1/10th of a second, we have
   * the below 'if' check. -gg 12/17/99
   */
  if (STATE(d) == CON_DISCONNECT || STATE(d) == CON_CLOSE)
    send_to_char("They're already being disconnected.\r\n", ch);
  else {
    /*
     * Remember that we can disconnect people not in the game and
     * that rather confuses the code when it expected there to be
     * a character context.
     */
    if (STATE(d) == CON_PLAYING)
      STATE(d) = CON_DISCONNECT;
    else
      STATE(d) = CON_CLOSE;

    sprintf(buf, "Connection #%d closed.\r\n", num_to_dc);
    send_to_char(buf, ch);
    basic_mud_log("(GC) Connection closed by %s.", GET_NAME(ch));
  }
}



ACMD(do_wizlock)
{
  int value;
  const char *when;

  one_argument(argument, arg);
  if (*arg) {
    value = atoi(arg);
    if (value < 0 || value > GET_LEVEL(ch)) {
      send_to_char("Invalid wizlock value.\r\n", ch);
      return;
    }
    circle_restrict = value;
    when = "now";
  } else
    when = "currently";

  switch (circle_restrict) {
  case 0:
    sprintf(buf, "The game is %s completely open.\r\n", when);
    break;
  case 1:
    sprintf(buf, "The game is %s closed to new players.\r\n", when);
    break;
  default:
    sprintf(buf, "Only level %d and above may enter the game %s.\r\n",
	    circle_restrict, when);
    break;
  }
  send_to_char(buf, ch);
}


ACMD(do_date)
{
  char *tmstr;
  int d, h, m;
  time_t mytime;
#ifndef NO_LOCALTIME

  if (subcmd == SCMD_DATE)
    mytime = time(0);
  else
    mytime = boot_time;
  tmstr = (char *) asctime(localtime(&mytime));
  *(tmstr + strlen(tmstr) - 1) = '\0';
#else
  struct tm lt;
  if (subcmd == SCMD_DATE)
    mytime = time(0);
  else
    mytime = boot_time;

  if (jk_localtime(&lt, mytime))
  {
    send_to_char("Bug! Please report.\r\n", ch);
    basic_mud_log("Error in jk_localtime (mytime: %ld) [%s:%d]", mytime, __FILE__, __LINE__);
      return;
  }
  tmstr = asctime(&lt);
  tmstr[strlen(tmstr) - 1] = '\0';
#endif

  if (subcmd == SCMD_DATE)
    sprintf(buf, "Current machine time: %s\r\n", tmstr);
  else {
    mytime = time(0) - boot_time;
    d = mytime / 86400;
    h = (mytime / 3600) % 24;
    m = (mytime / 60) % 60;

    sprintf(buf, "Up since %s: %d day%s, %d:%02d\r\n", tmstr, d,
	    ((d == 1) ? "" : "s"), h, m);
  }

  send_to_char(buf, ch);
}



ACMD(do_last)
{
  struct char_file_u chdata;

  one_argument(argument, arg);
  if (!*arg) {
    send_to_char("For whom do you wish to search?\r\n", ch);
    return;
  }
  if (load_char(arg, &chdata) < 0) {
    send_to_char("There is no such player.\r\n", ch);
    return;
  }
  if ((chdata.level > GET_LEVEL(ch)) && (GET_LEVEL(ch) < LVL_IMPL)) {
    send_to_char("You are not sufficiently godly for that!\r\n", ch);
    return;
  }
  sprintf(buf, "[%5ld] [%3d %s] %-12s : %-18s : %s",
	  chdata.char_specials_saved.idnum, (int) chdata.level,
	  class_abbrevs[(int) chdata.chclass], chdata.name, 
          chdata.player_specials_primalsaved.host,
	  asctime(localtime(&chdata.player_specials_primalsaved.last_logon)));
//	  ctime(&chdata.player_specials_primalsaved.last_logon));
  send_to_char(buf, ch);
  sprintf(buf, "%17s%-12s : %-18s : %s",
          "", "Unsuccessful", 
          chdata.player_specials_primalsaved.lastUnsuccessfulHost, 
	  (chdata.player_specials_primalsaved.lastUnsuccessfulLogon < 1) ?  "None\r\n" : asctime(localtime(&chdata.player_specials_primalsaved.lastUnsuccessfulLogon)));
	  // ctime(&chdata.player_specials_primalsaved.lastUnsuccessfulLogon));
  send_to_char(buf, ch);
}

ACMD(do_laston)
{
  struct char_file_u chdata;
 
  one_argument(argument, arg);
  if (!*arg) {
    send_to_char("For whom do you wish to search?\r\n", ch);
    return;
  }
  if (load_char(arg, &chdata) < 0) {
    send_to_char("There is no such player.\r\n", ch);
    return;
  }
  if (((chdata.level >= LVL_IS_GOD) && (GET_LEVEL(ch) != LVL_IMPL)) ||
((chdata.level >= LVL_ISNOT_GOD) && (GET_LEVEL(ch) < LVL_ISNOT_GOD)))
  {
    send_to_char("Sorry that player has a CLASSIFIED account!.\r\n", ch);
    return;
  }
  sprintf(buf, "%s was last on: %s\r\n",chdata.name,
    asctime(localtime(&chdata.player_specials_primalsaved.last_logon)));
    //ctime(&chdata.player_specials_primalsaved.last_logon));
  send_to_char(buf, ch);
} 

ACMD(do_force)
{
  struct descriptor_data *i, *next_desc;
  struct char_data *vict, *next_force;
  char to_force[MAX_INPUT_LENGTH + 2];

#define CAN_FORCE_PC(ch, vict)	((GET_LEVEL(ch) >= LVL_GRGOD) && \
                                 (GET_LEVEL(ch) >= GET_LEVEL(vict)))
#define CAN_FORCE_NPC(ch, vict)	((GET_LEVEL(ch) >= LVL_GRGOD) || \
                                 ((GET_OLC_ZONE(ch) > 0) && \
				  (GET_MOB_VZNUM(vict) == GET_OLC_ZONE(ch)) && \
				  (zone_table[world[IN_ROOM(vict)].zone].number == GET_OLC_ZONE(ch))))
#define CAN_FORCE(ch, vict)	((!IS_NPC(vict) && CAN_FORCE_PC(ch, vict)) || \
                                 (IS_NPC(vict) && CAN_FORCE_NPC(ch, vict)))

  half_chop(argument, arg, to_force);

  sprintf(buf1, "$n has forced you to '%s'.", to_force);

  if (!*arg || !*to_force)
  {
    send_to_char("Whom do you wish to force do what?\r\n", ch);
    return;
  }
  if ((GET_LEVEL(ch) < LVL_GRGOD) || 
      (str_cmp("all", arg) && str_cmp("room", arg))) 
  {
    if (!(vict = generic_find_char(ch, arg, FIND_CHAR_ROOM | FIND_CHAR_WORLD)))
    {
      send_to_char(NOPERSON, ch);
      return;
    } 
    if (vict == ch)
    {
      send_to_char("Your other personality doesn't listen to you.\r\n", ch);
      return;
    }
    if (!IS_NPC(vict)) 
    {
      if (!(vict->desc) || (STATE(vict->desc) != CON_PLAYING))
      {
	send_to_char("They are in no state to do much of anything.\r\n", ch);
	return;
      } else if (!CAN_FORCE_PC(ch, vict)) {
	send_to_char("You are not holy enough to force them!\r\n", ch);
	return;
      }
    } else if (!CAN_FORCE_NPC(ch, vict)) {
      send_to_char("You can only force mobs from your zone, in your zone.\r\n", ch);
      return;
    } // Can force pc/npc checks.
    send_to_char(OK, ch);
    act(buf1, TRUE, ch, NULL, vict, TO_VICT);
    sprintf(buf, "(GC) %s forced %s to %s", GET_NAME(ch), GET_NAME(vict), to_force);
    mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
    command_interpreter(vict, to_force);
    return;
  } // Individual Victim Only...
  if (!str_cmp("room", arg)) 
  {
    send_to_char(OK, ch);
    sprintf(buf, "(GC) %s forced room %d to %s",
		GET_NAME(ch), GET_ROOM_VNUM(IN_ROOM(ch)), to_force);
    mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);

    for (vict = world[ch->in_room].people; vict; vict = next_force) {
      next_force = vict->next_in_room;
      if (!CAN_FORCE(ch, vict) || (vict == ch))
	continue;
      act(buf1, TRUE, ch, NULL, vict, TO_VICT);
      command_interpreter(vict, to_force);
    }
    return;
  } // Room...
  if (!strcmp("all", arg))
  {
    send_to_char(OK, ch);
    sprintf(buf, "(GC) %s forced all to %s", GET_NAME(ch), to_force);
    mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
    for (i = descriptor_list; i; i = next_desc) 
    {
      next_desc = i->next;
      if (STATE(i) != CON_PLAYING || !(vict = i->character) || IS_NPC(vict) || (!CAN_FORCE_PC(ch, vict)) || (vict == ch))
	continue;
      act(buf1, TRUE, ch, NULL, vict, TO_VICT);
      command_interpreter(vict, to_force);
    }
  } // All...
}


#define LVL_IMMNET LVL_ETRNL1

ACMD(do_wiznet)
{
  struct descriptor_data *d; 
  char emote = FALSE;
  char any = FALSE;
  int level = LVL_GOD;
  int LVL = LVL_GOD;
 
  if(subcmd == SCMD_IMMNET)
    level = LVL = LVL_IMMNET;
  if(subcmd == SCMD_ANGNET)
    level = LVL = LVL_ANGEL;
 
  skip_spaces(&argument);
  delete_doubledollar(argument);
 
  if (!*argument) {
    if(subcmd == SCMD_IMMNET) {
      send_to_char("&1Usage: &4immnet <text> | #<level> <text> | *<emotetext> |\r\n"
                   "       &4immnet @@<level> *<emotetext> | imm @@\r\n",ch);
    } else {
    send_to_char("Usage: wiznet <text> | #<level> <text> | *<emotetext> |\r\n"
                 "       wiznet @@<level> *<emotetext> | wiz @@\r\n", ch);
    }
    return;
  }
  switch (*argument) {
  case '*':
    emote = TRUE;
  case '#':
    one_argument(argument + 1, buf1);
    if (is_number(buf1)) {
      half_chop(argument+1, buf1, argument);
      level = MAX(atoi(buf1), LVL);
      if (level > GET_MAX_LVL(ch)) {
        send_to_char("You can't wizline above your own level.\r\n", ch);
        return;
      }         
    } else if (emote)
      argument++;
    break;
  case '@@':
    for (d = descriptor_list; d; d = d->next) {
     if (STATE(d) == CON_PLAYING && GET_LEVEL(d->character) >= LVL &&
          ((!PRF_FLAGGED(d->character, PRF_NOWIZ) && subcmd != SCMD_IMMNET) ||
          (subcmd == SCMD_IMMNET && !PRF_FLAGGED(d->character,PRF_NOIMMNET))) &&
          (CAN_SEE(ch, d->character) || GET_LEVEL(ch) == LVL_IMPL)) {
        if (!any) {
          strcpy(buf1, "Gods online:\r\n");
          any = TRUE;
        }
        sprintf(buf1 + strlen(buf1), "  %s", GET_NAME(d->character));
        if (PLR_FLAGGED(d->character, PLR_WRITING))
          strcat(buf1, " (Writing)\r\n");
        else if (PLR_FLAGGED(d->character, PLR_MAILING))
          strcat(buf1, " (Writing mail)\r\n");
        else if (PLR_FLAGGED(d->character, PLR_REPORTING))
          strcat(buf1, " (Reporting)\r\n");
        else
          strcat(buf1, "\r\n");   
      }
    }
    any = FALSE;
    for (d = descriptor_list; d; d = d->next) {
      if (STATE(d) == CON_PLAYING && GET_LEVEL(d->character) >= LVL &&
        ((PRF_FLAGGED(d->character, PRF_NOWIZ) && subcmd != SCMD_IMMNET) ||
          (subcmd == SCMD_IMMNET && PRF_FLAGGED(d->character,PRF_NOIMMNET))) &&
          CAN_SEE(ch, d->character)) {
        if (!any) {
          strcat(buf1, "Gods offline:\r\n");
          any = TRUE;
        }
        sprintf(buf1 + strlen(buf1), "  %s\r\n", GET_NAME(d->character));
      }
    }
    send_to_char(buf1, ch);
    return; 
    break;
  case '\\':
    ++argument;
    break;
  default:
    break;
  }
  if ((PRF_FLAGGED(ch, PRF_NOWIZ) && subcmd != SCMD_IMMNET) ||
      (subcmd == SCMD_IMMNET && PRF_FLAGGED(ch, PRF_NOIMMNET))) {
    send_to_char("You are offline!\r\n", ch);
    return;
  }
  skip_spaces(&argument);
 
  if (!*argument) {
    send_to_char("Don't bother the gods like that!\r\n", ch);
    return;
  }
  if (level > LVL) {
    if(subcmd == SCMD_IMMNET) {
      sprintf(buf1, "(%d) %s> %s%s\r\n", level, GET_NAME(ch),
              emote ? "<--- " : "", argument);
      sprintf(buf2, "(%d) Someone> %s%s\r\n", level, emote ? "<--- " : "",
              argument);
    } else if(subcmd == SCMD_ANGNET) {
      sprintf(buf1, "(%d:%s) %s%s\r\n", level, GET_NAME(ch),
              emote ? "<--- " : "", argument);
      sprintf(buf2, "(%d:Someone) %s%s\r\n", level, emote ? "<--- " : "",
              argument);
    } else {
      sprintf(buf1, "<%d> %s: %s%s\r\n", level, GET_NAME(ch),
              emote ? "<--- " : "", argument);
      sprintf(buf2, "<%d> Someone: %s%s\r\n", level, emote ? "<--- " : "",
              argument);
      }
  } else {
    if(subcmd == SCMD_IMMNET) {
      sprintf(buf1, "%s> %s%s\r\n", GET_NAME(ch), emote ? "<--- " : "",
              argument);
      sprintf(buf2, "Someone> %s%s\r\n", emote ? "<--- " : "", argument);
    } else if(subcmd == SCMD_ANGNET) {
      sprintf(buf1, "(%s) %s%s\r\n", GET_NAME(ch), emote ? "<--- " : "", 
      argument);
      sprintf(buf2, "(Someone) %s%s\r\n", emote ? "<--- " : "", argument);
    } else {
      sprintf(buf1, "%s: %s%s\r\n", GET_NAME(ch), emote ? "<--- " : "",
              argument);
      sprintf(buf2, "Someone: %s%s\r\n", emote ? "<--- " : "", argument);
      }
  }
 
  for (d = descriptor_list; d; d = d->next)
  {
    if ((STATE(d) == CON_PLAYING) && !LR_FAIL_MAX(d->character, level) &&
        ((!PRF_FLAGGED(d->character, PRF_NOWIZ) && subcmd != SCMD_IMMNET) ||
        (subcmd == SCMD_IMMNET && !PRF_FLAGGED(d->character,PRF_NOIMMNET))) &&
        (!PLR_FLAGGED(d->character, PLR_WRITING | PLR_MAILING | PLR_REPORTING))
        && (d != ch->desc || !(PRF_FLAGGED(d->character, PRF_NOREPEAT)))) {
      if(subcmd == SCMD_IMMNET)
        send_to_char(CCBMAG(d->character, C_NRM), d->character);
      else if(subcmd == SCMD_ANGNET)
        send_to_char(CCCYN(d->character, C_NRM), d->character);
      else
        send_to_char(CCBCYN(d->character, C_NRM), d->character);
      if (CAN_SEE(d->character, ch))
        send_to_char(buf1, d->character);
      else
        send_to_char(buf2, d->character);
      send_to_char(CCNRM(d->character, C_NRM), d->character);
    }
  }
 
  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
}



ACMD(do_zreset)
{
  zone_rnum i;
  zone_vnum j;

  one_argument(argument, arg);
  if (!*arg) {
    send_to_char("You must specify a zone.\r\n", ch);
    return;
  }
  if (*arg == '*' && GET_LEVEL(ch) >= LVL_GOD) {
    for (i = 0; i <= top_of_zone_table; i++)
      reset_zone(i);
    send_to_char("Reset world.\r\n", ch);
    sprintf(buf, "(GC) %s reset entire world.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_GRGOD, GET_INVIS_LEV(ch)), TRUE);
    return;
  } else if (*arg == '.')
    i = world[ch->in_room].zone;
  else {
    j = atoi(arg);
    for (i = 0; i <= top_of_zone_table; i++)
      if (zone_table[i].number == j)
	break;
  }
  if (i >= 0 && i <= top_of_zone_table) {
    // DM - allow zone owners to reset their zone.
    if (GET_LEVEL(ch) < LVL_GOD && (GET_OLC_ZONE(ch) != 0 && GET_OLC_ZONE(ch)
          != zone_table[i].number)) {
      send_to_char("Sorry, you can only reset your zone.\r\n", ch);
      return;
    }
    reset_zone(i);
    sprintf(buf, "Reset zone %d (#%d): %s.\r\n", i, zone_table[i].number,
	    zone_table[i].name);
    send_to_char(buf, ch);
    sprintf(buf, "(GC) %s reset zone %d (%s)", GET_NAME(ch), i, zone_table[i].name);
    mudlog(buf, NRM, MAX(LVL_GRGOD, GET_INVIS_LEV(ch)), TRUE);
  } else
    send_to_char("Invalid zone number.\r\n", ch);
}


/*
 *  General fn for wizcommands of the sort: cmd <player>
 */

ACMD(do_wizutil)
{
  struct char_data *vict;
  struct affected_type *affect;
  long result=0;
  char reasonString[MAX_INPUT_LENGTH], *reason = reasonString;

  reasonString[0] = '\0';
  reason = one_argument(argument, arg);

  // remove leading space
  reason++;

  if (!*arg)
  {
    send_to_char("Yes, but for whom?!?\r\n", ch);
    return;
  }
  if (!(vict = generic_find_char(ch, arg, FIND_CHAR_ROOM | FIND_CHAR_WORLD)))
  {
    send_to_char("There is no such player.\r\n", ch);
    return;
  }
  if (IS_NPC(vict))
  {
    send_to_char("You can't do that to a mob!\r\n", ch);
    return;
  }
  if (GET_LEVEL(vict) > GET_LEVEL(ch))
  {
    send_to_char("Hmmm...you'd better not.\r\n", ch);
    return;
  }
  switch (subcmd)
  {
    case SCMD_REROLL:
      send_to_char("Rerolled...\r\n", ch);
      roll_real_abils(vict);
      basic_mud_log("(GC) %s has rerolled %s.", GET_NAME(ch), GET_NAME(vict));
      sprintf(buf, "New stats: Str %d/%d, Int %d, Wis %d, Dex %d, Con %d, Cha %d\r\n",
	      GET_STR(vict), GET_ADD(vict), GET_INT(vict), GET_WIS(vict),
	      GET_DEX(vict), GET_CON(vict), GET_CHA(vict));
      send_to_char(buf, ch);
      break;
    case SCMD_PARDON:
      if (!PLR_FLAGGED(vict, PLR_THIEF | PLR_KILLER))
      {
	send_to_char("Your victim is not flagged.\r\n", ch);
	return;
      }
      REMOVE_BIT(PLR_FLAGS(vict), PLR_THIEF | PLR_KILLER);
      send_to_char("Pardoned.\r\n", ch);
      send_to_char("You have been pardoned by the Gods!\r\n", vict);
      sprintf(buf, "(GC) %s pardoned by %s", GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      break;
    case SCMD_NOTITLE:
      result = PLR_TOG_CHK(vict, PLR_NOTITLE);
      if (result && (!*reason || (strlen(reason) < 10)))
      {
	PLR_TOG_CHK(vict, PLR_NOTITLE);
	send_to_char("Please supply a reason of no less than 10 characters.\r\n" , ch);
	return;
      }
      sprintf(buf, "(GC) Notitle %s for %s by %s.", ONOFF(result),
	      GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      strcat(buf, "\r\n");
      send_to_char(buf, ch);
      if (result)
      {
	sprintf(buf, "&7%s&g has had title privilleges removed for %s",
		GET_NAME(vict), reason);
	mudlog(buf, NRM, 0, FALSE);
      }
      break;
    case SCMD_SQUELCH:
      result = PUN_TOG_CHK(vict, PUN_MUTE);
      if (result && (!*reason || (strlen(reason) < 10)))
      {
	PUN_TOG_CHK(vict, PUN_MUTE);
	send_to_char("Please supply a reason of no less than 10 characters.\r\n" , ch);
	return;
      }
      sprintf(buf, "(GC) Squelch %s for %s by %s.", ONOFF(result),
	      GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      strcat(buf, "\r\n");
      send_to_char(buf, ch);
      if (result)
      {
	sprintf(buf, "&7%s&g has been muted for %s", GET_NAME(vict), reason);
	mudlog(buf, NRM, 0, FALSE);
      }
      break;
    case SCMD_FREEZE:
      if (ch == vict)
      {
	send_to_char("Oh, yeah, THAT'S real smart...\r\n", ch);
	return;
      }
      if (PUN_FLAGGED(vict, PUN_FREEZE))
      {
	send_to_char("Your victim is already pretty cold.\r\n", ch);
	return;
      }
      if (!*reason || (strlen(reason) < 10))
      {
	send_to_char("Please supply a reason of no less than 10 characters.\r\n" , ch);
	return;
      }
//      SET_BIT(PLR_FLAGS(vict), PLR_FROZEN);
      SET_BIT(PUN_FLAGS(vict), (1 << PUN_FREEZE));
      PUN_HOURS(vict, PUN_FREEZE) = -1;
      GET_FREEZE_LEV(vict) = GET_LEVEL(ch);
      send_to_char("A bitter wind suddenly rises and drains every erg of heat from your body!\r\nYou feel frozen!\r\n", vict);
      send_to_char("Frozen.\r\n", ch);
      act("A sudden cold wind conjured from nowhere freezes $n!", FALSE, vict, 0, 0, TO_ROOM);
      sprintf(buf, "(GC) %s frozen by %s.", GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      if (result)
      {
	sprintf(buf, "&7%s&g has been frozen for %s", GET_NAME(vict), reason);
	mudlog(buf, NRM, 0, FALSE);
      }
      break;
    case SCMD_THAW:
//      if (!PLR_FLAGGED(vict, PLR_FROZEN)) { Replaced with PUN_ -- ARTUS
      if (!PUN_FLAGGED(vict, PUN_FREEZE))
      {
	send_to_char("Sorry, your victim is not morbidly encased in ice at the moment.\r\n", ch);
	return;
      }
      if (GET_FREEZE_LEV(vict) > GET_LEVEL(ch))
      {
	sprintf(buf, "Sorry, a level %d God froze %s... you can't unfreeze %s.\r\n", GET_FREEZE_LEV(vict), GET_NAME(vict), HMHR(vict));
	send_to_char(buf, ch);
	return;
      }
      sprintf(buf, "(GC) %s un-frozen by %s.", GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      REMOVE_BIT(PUN_FLAGS(vict), (1 << PUN_FREEZE));
      PUN_HOURS(vict, PUN_FREEZE) = 0;
      send_to_char("A fireball suddenly explodes in front of you, melting the ice!\r\nYou feel thawed.\r\n", vict);
      send_to_char("Thawed.\r\n", ch);
      act("A sudden fireball conjured from nowhere thaws $n!", FALSE, vict, 0, 0, TO_ROOM);
      break;
    case SCMD_UNAFFECT:
      if (vict->affected)
      {
	for (affect = vict->affected; affect; affect = affect->next)
	{
	//while (vict->affected)
	  if (vict->affected->duration != -1)
	    affect_remove(vict, vict->affected);
	}
	send_to_char("There is a brief flash of light!\r\n"
		     "You feel slightly different.\r\n", vict);
	send_to_char("All spells removed.\r\n", ch);
      } else {
	send_to_char("Your victim does not have any affections!\r\n", ch);
	return;
      }
      break;
    default:
      basic_mud_log("SYSERR: Unknown subcmd %d passed to do_wizutil (%s)", subcmd, __FILE__);
      break;
  }
  save_char(vict, NOWHERE);
}

/* single zone printing fn used by "show zone" so it's not repeated in the
   code 3 times ... -je, 4/6/93 */

void print_zone_to_buf(char *bufptr, zone_rnum zone, int level, bool detailed)
{
// DM - TODO - color this in ...
  extern const char *zone_flagbits[];
  char bufstr[80];
  sprintbit(zone_table[zone].zflag, zone_flagbits, bufstr);

  sprintf(bufptr, "%s&B%3d&n %-20.20s &gAge&n: &y%3d&n; &gReset&n: &y%3d&n &b(&r%1d&b)&n; &gTop&n: &c%5d&n &gFlags&n: %s\r\n", bufptr, zone_table[zone].number, zone_table[zone].name,
          zone_table[zone].age, zone_table[zone].lifespan,
          zone_table[zone].reset_mode, zone_table[zone].top,bufstr);


  if (detailed) {

    // TODO - shouldnt need generate once working
    //generate_zone_data();

    //sprintf(bufptr, "%s&RSTILL FIXING&n:\r\n", bufptr); 
    sprintf(bufptr, "%sNumber of rooms: %3d\r\n", 
        bufptr, zone_table[zone].nowlds);
    sprintf(bufptr, "%sNumber of trigs: %3d\r\n", 
        bufptr, zone_table[zone].notrgs);
    sprintf(bufptr, "%sNumber of shops: %3d\r\n", 
        bufptr, zone_table[zone].noshps);
    sprintf(bufptr, "%sNumber of mobs:  %3d\r\n", 
        bufptr, zone_table[zone].nomobs);
    sprintf(bufptr, "%sNumber of objs:  %3d\r\n", 
        bufptr, zone_table[zone].noobjs);
    sprintf(bufptr, "%sNumber of hints: %3d\r\n",
	bufptr, zone_table[zone].nohnts);
    // ARTUS> Show OLC Users for that zone.
    if (level >= LVL_GRGOD)
    {
      bool found = FALSE;
      int i;
      extern struct player_index_element *player_table;
      strcat(bufptr, "OLC Players: ");
      for (i = 0; i <= top_of_p_table; i++)
      {
	struct char_file_u chdata;
	load_char(player_table[i].name, &chdata);
	if (chdata.player_specials_saved.olc_zone == zone_table[zone].number)
	{
	  if (found) strcat(bufptr, ", ");
	  found = TRUE;
	  strcat(bufptr, chdata.name);
	}
      }
      if (!found) strcat(bufptr, "None");
      strcat(bufptr, ".\r\n");
    }
  }
//  sprintf(bufptr, "%s%3d %-30.30s Age: %3d; Reset: %3d (%1d); Top: %5d\r\n",
//	  bufptr, zone_table[zone].number, zone_table[zone].name,
//	  zone_table[zone].age, zone_table[zone].lifespan,
//	  zone_table[zone].reset_mode, zone_table[zone].top);
}


ACMD(do_show)
{
  struct char_file_u vbuf;
  int i, j, k, l, con;		/* i, j, k to specifics? */
  zone_rnum zrn;
  zone_vnum zvn;
  char self = 0;
  struct char_data *vict;
  struct obj_data *obj;
  struct descriptor_data *d;
  extern struct hunt_data *hunt_list;
  char field[MAX_INPUT_LENGTH], value[MAX_INPUT_LENGTH];

  struct show_struct
  {
    const char *cmd;
    const char level;
  } fields[] = {
    { "nothing",	0  },				/* 0 */
    { "zones",		LVL_ETRNL6 },			/* 1 */
    { "player",		LVL_GOD },
    { "rent",		LVL_GOD },
    { "stats",		LVL_ETRNL8 },
    { "errors",		LVL_IMPL },			/* 5 */
    { "death",		LVL_ANGEL },
    { "godrooms",	LVL_ANGEL },
    { "shops",		LVL_ETRNL7 },
    { "houses",		LVL_GOD },
    { "snoop",		LVL_IMPL },			/* 10 */
    { "events",         LVL_GOD }, 
    { "hunts",		LVL_GOD },
    { "\n", 0 }
  };

  skip_spaces(&argument);

  if (!*argument) {
    strcpy(buf, "Show options:\r\n");
    for (j = 0, i = 1; fields[i].level; i++)
      if (fields[i].level <= GET_LEVEL(ch))
	sprintf(buf + strlen(buf), "%-15s%s", fields[i].cmd, (!(++j % 5) ? "\r\n" : ""));
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
    return;
  }

  strcpy(arg, two_arguments(argument, field, value));

  for (l = 0; *(fields[l].cmd) != '\n'; l++)
    if (!strncmp(field, fields[l].cmd, strlen(field)))
      break;

  if (GET_IDNUM(ch) > 3) {
    if (GET_LEVEL(ch) < fields[l].level) {
      send_to_char("You are not godly enough for that!\r\n", ch);
      return;
    }
  }

  if (!strcmp(value, "."))
    self = 1;
  buf[0] = '\0';
  switch (l) {
  case 1:			/* zone */
    /* tightened up by JE 4/6/93 */
    if (self)
      print_zone_to_buf(buf, world[ch->in_room].zone, GET_LEVEL(ch), TRUE);
    else if (*value && is_number(value)) {
      for (zvn = atoi(value), zrn = 0; zone_table[zrn].number != zvn && zrn <= top_of_zone_table; zrn++);
      if (zrn <= top_of_zone_table)
	print_zone_to_buf(buf, zrn, GET_LEVEL(ch), TRUE);
      else {
	send_to_char("That is not a valid zone.\r\n", ch);
	return;
      }
    } else
      for (zrn = 0; zrn <= top_of_zone_table; zrn++)
	print_zone_to_buf(buf, zrn, GET_LEVEL(ch), FALSE);
    page_string(ch->desc, buf, TRUE);
    break;
  case 2:			/* player */
    if (!*value) {
      send_to_char("A name would help.\r\n", ch);
      return;
    }

    if (load_char(value, &vbuf) < 0) {
      send_to_char("There is no such player.\r\n", ch);
      return;
    }
    sprintf(buf, "Player: %-12s (%s) [%2d %s]\r\n", vbuf.name,
      genders[(int) vbuf.sex], vbuf.level, class_abbrevs[(int) vbuf.chclass]);
    sprintf(buf + strlen(buf),
	 "Au: %-8d  Bal: %-8d  Exp: %-8d  Align: %-5d  Lessons: %-3d\r\n",
	    vbuf.points.gold, vbuf.points.bank_gold, vbuf.points.exp,
	    vbuf.char_specials_saved.alignment,
	    vbuf.player_specials_saved.spells_to_learn);
    sprintf(buf + strlen(buf),
	    "Started: %-20.16s  Last: %-20.16s  Played: %3dh %2dm\r\n",
	    asctime(localtime(&vbuf.birth)),
	    asctime(localtime(&vbuf.player_specials_primalsaved.last_logon)), 
//	    ctime(&vbuf.birth),
//	    ctime(&vbuf.player_specials_primalsaved.last_logon), 
            (int) (vbuf.played / 3600),
	    (int) (vbuf.played / 60 % 60));
    send_to_char(buf, ch);
    break;
  case 3:
    if (!*value) {
      send_to_char("A name would help.\r\n", ch);
      return;
    }
    Crash_listrent(ch, value);
    break;
  case 4:
    i = 0;
    j = 0;
    k = 0;
    con = 0;
    for (vict = character_list; vict; vict = vict->next) {
      if (IS_NPC(vict))
	j++;
      else if (CAN_SEE(ch, vict)) {
	i++;
	if (vict->desc)
	  con++;
      }
    }
    for (obj = object_list; obj; obj = obj->next)
      k++;

// DM - TODO - color in
    strcpy(buf, "&1Current stats:&n\r\n");
    sprintf(buf + strlen(buf), "  %5d players in game  %5d connected\r\n",
		i, con);
    sprintf(buf + strlen(buf), "  %5d registered\r\n",
		top_of_p_table + 1);
    sprintf(buf + strlen(buf), "  %5d mobiles          %5d prototypes\r\n",
		j, top_of_mobt + 1);
    sprintf(buf + strlen(buf), "  %5d objects          %5d prototypes\r\n",
		k, top_of_objt + 1);
    sprintf(buf + strlen(buf), "  %5d rooms            %5d zones\r\n",
		top_of_world + 1, top_of_zone_table + 1);
    sprintf(buf + strlen(buf), "  %5d large bufs\r\n",
		buf_largecount);
    sprintf(buf + strlen(buf), "  %5d buf switches     %5d overflows\r\n",
		buf_switches, buf_overflows);
    sprintf(buf +strlen(buf),  "  %5d burgled rooms    %5d events\r\n",
		num_rooms_burgled, events.num_events); 
    send_to_char(buf, ch);
    break;
  case 5:
    strcpy(buf, "&1Errant Rooms\r\n------------&n\r\n");
    for (i = 0, k = 0; i <= top_of_world; i++)
      for (j = 0; j < NUM_OF_DIRS; j++)
	if (world[i].dir_option[j] && world[i].dir_option[j]->to_room == 0)
	  sprintf(buf + strlen(buf), "%2d: [%5d] %s\r\n", ++k, GET_ROOM_VNUM(i),
		  world[i].name);
    page_string(ch->desc, buf, TRUE);
    break;
  case 6:
    strcpy(buf, "&1Death Traps\r\n-----------&n\r\n");
    for (i = 0, j = 0; i <= top_of_world; i++)
      if (ROOM_FLAGGED(i, ROOM_DEATH))
	sprintf(buf + strlen(buf), "%2d: [%5d] %s\r\n", ++j,
		GET_ROOM_VNUM(i), world[i].name);
    page_string(ch->desc, buf, TRUE);
    break;
  case 7:
    strcpy(buf, "&1Godrooms\r\n--------------------------&n\r\n");
    for (i = 0, j = 0; i <= top_of_world; i++)
    if (ROOM_FLAGGED(i, ROOM_GODROOM))
      sprintf(buf + strlen(buf), "%2d: [%5d] %s\r\n",
		++j, GET_ROOM_VNUM(i), world[i].name);
    page_string(ch->desc, buf, TRUE);
    break;
  case 8:
    show_shops(ch, value);
    break;
  case 9:
    hcontrol_list_houses(ch, NULL);
    break;
  case 10:
    *buf = '\0';
    send_to_char("&1People currently snooping:\r\n", ch);
    send_to_char("&1--------------------------&n\r\n", ch);
    for (d = descriptor_list; d; d = d->next)
    {
      if (d->snooping == NULL || d->character == NULL)
	continue;
      if (STATE(d) != CON_PLAYING || GET_LEVEL(ch) < GET_LEVEL(d->character))
	continue;
      if (!CAN_SEE(ch, d->character) || IN_ROOM(d->character) == NOWHERE)
	continue;
      sprintf(buf + strlen(buf), "&7%-10s&n - snooped by &7%s&n.\r\n",
               GET_NAME(d->snooping->character), GET_NAME(d->character));
    }
    send_to_char(*buf ? buf : "No one is currently snooping.\r\n", ch);
    break; /* snoop */
  case 11:
    list_events_to_char(ch, -1);
    break;
  case 12: /* Hunting */
    send_to_char("&1People currently hunting:\r\n"
	         "&1-------------------------&n\r\n", ch);
    *buf = '\0';
    for (struct hunt_data *hcur = hunt_list; hcur; hcur = hcur->next)
    {
      if (CAN_SEE(ch, hcur->hunter) && CAN_SEE(ch, hcur->victim))
      {
	sprintf(buf + strlen(buf), "&7%s&n [&8%d&n] is hunting &7%s&n [&8%d&n]\r\n",            GET_NAME(hcur->hunter), world[IN_ROOM(hcur->hunter)].number,
	        GET_NAME(hcur->victim), world[IN_ROOM(hcur->victim)].number);
      }
    }
    if (*buf)
      send_to_char(buf, ch);
    else
      send_to_char("No one is currently hunting.\r\n", ch);
    break; /* Hunting */
  default:
    send_to_char("Sorry, I don't understand that.\r\n", ch);
    break;
  }
}


void show_specials_to_char(struct char_data *ch)
{
  send_to_char("\r\n &0Specials available:&n\r\n", ch);
  send_to_char("&y1 &n - Permanant invisibility\r\n", ch);
  send_to_char("&y2 &n - Permanant sneak\r\n", ch);
  send_to_char("&y3 &n - Multiple weapon usage\r\n", ch);
  send_to_char("&y4 &n - Greater spell power in forests\r\n", ch);
  send_to_char("&y5 &n - Forest allies\r\n", ch);
  send_to_char("&y6 &n - Healer (more effective healing spells)\r\n", ch);
  send_to_char("&y7 &n - Priest (charge for spell casting)\r\n", ch);
  send_to_char("&y8 &n - Backstab during battle\r\n", ch);
  send_to_char("&y9 &n - Battlemage (more melee and spell damage)\r\n", ch);
  send_to_char("&y10&n - Mana thief (drain mana during battle)\r\n", ch);
  send_to_char("&y11&n - Holy warrior (destroy undead)\r\n", ch);
  send_to_char("&y12&n - Disguise (changling ability)\r\n", ch);
  send_to_char("&y13&n - Escape (can find nearest outdoors)\r\n", ch);
  send_to_char("&y14&n - Permanant infravision\r\n", ch);
  send_to_char("&y15&n - Dwarf (bonus to battle while indoors)\r\n", ch);
  send_to_char("&y16&n - Permanant group sneak\r\n", ch);
  send_to_char("&y17&n - Thief (enhanced thief ability)\r\n", ch);
  send_to_char("&y18&n - Gore (extra horn damage in battle)\r\n", ch);
  send_to_char("&y19&n - Minotaur (+5% to damroll)\r\n", ch);
  send_to_char("&y20&n - Charmer (auto charm demi humans)\r\n", ch);
  send_to_char("&y21&n - Superman (+2% damroll, AC bonus, 21str, 21con)\r\n", ch);
  send_to_char("&y22&n - Permanant fly\r\n", ch);
  send_to_char("&y23&n - Elf (bonus to battle in forests)\r\n", ch);
  send_to_char("&y24&n - Tracker (Can track through !TRACK rooms)\r\n", ch);

}

/***************** The do_set function ***********************************/

#define PC   1
#define NPC  2
#define BOTH 3

#define MISC	0
#define BINARY	1
#define NUMBER	2

#define SET_OR_REMOVE(flagset, flags) { \
	if (on) SET_BIT(flagset, flags); \
	else if (off) REMOVE_BIT(flagset, flags); }

#define RANGE(low, high) (value = MAX((low), MIN((high), (value))))


/* The set options available */
  struct set_struct {
    const char *cmd;
    const int level;
    const char pcnpc;
    const char type;
    const char *help;	// Some brief help for the command
  } set_fields[] = {
   { "brief",		LVL_GOD, 	PC, 	BINARY, "On or Off"},  /* 0*/
   { "invstart", 	LVL_GOD, 	PC, 	BINARY, "Level to start invis at"},  /* 1 */
   { "title",		LVL_GOD, 	PC, 	MISC , 	"Target's new title" },
   { "nosummon", 	LVL_GRGOD, 	PC, 	BINARY, "On or Off"},
   { "maxhit",		LVL_GRGOD, 	BOTH, 	NUMBER, "Maximum hit points" },
   { "maxmana", 	LVL_GRGOD, 	BOTH, 	NUMBER, "Maximum mana points" },  /* 5 */
   { "maxmove", 	LVL_GRGOD, 	BOTH, 	NUMBER, "Maximum movement points" },
   { "hit", 		LVL_GRGOD, 	BOTH, 	NUMBER, "Current hit points" },
   { "mana",		LVL_GRGOD, 	BOTH, 	NUMBER, "Current mana points" },
   { "move",		LVL_GRGOD, 	BOTH, 	NUMBER, "Current movement points" },
   { "align",		LVL_GOD, 	BOTH, 	NUMBER, "Alignment (-1k -> 1k)" },  /* 10 */
   { "str",		LVL_GRGOD, 	BOTH, 	NUMBER, "Strength (3->21 or 25)" },
   { "stradd",		LVL_GRGOD, 	BOTH, 	NUMBER, "Strength percent (for Str 18)" },
   { "int", 		LVL_GRGOD, 	BOTH, 	NUMBER, "Intelligence (3->21 or 25)" },
   { "wis", 		LVL_GRGOD, 	BOTH, 	NUMBER, "Wisdom (3->21 or 25)" },
   { "dex", 		LVL_GRGOD, 	BOTH, 	NUMBER, "Dexterity (3->21 or 25)" },  /* 15 */
   { "con", 		LVL_GRGOD, 	BOTH, 	NUMBER, "Constitution (3->21 or 25)" },
   { "cha",		LVL_GRGOD, 	BOTH, 	NUMBER, "Charisma (3->21 or 25)" },
   { "ac", 		LVL_GRGOD, 	BOTH, 	NUMBER, "Armour Class (-ve = better)" },
   { "gold",		LVL_GOD, 	BOTH, 	NUMBER, "Gold on hand" },
   { "bank",		LVL_GOD, 	PC, 	NUMBER, "Gold in bank" },  /* 20 */
   { "exp", 		LVL_GRGOD, 	BOTH, 	NUMBER, "Experience earnt current level" },
   { "hitroll", 	LVL_GRGOD, 	BOTH, 	NUMBER, "Hitroll bonus" },
   { "damroll", 	LVL_GRGOD, 	BOTH, 	NUMBER, "Damroll bonus" },
   { "invis",		LVL_IMPL, 	PC, 	NUMBER, "Invisibility level" },
   { "nohassle", 	LVL_GRGOD, 	PC, 	BINARY, "On or Off" },  /* 25 */
   { "frozen",		LVL_FREEZE, 	PC, 	BINARY, "On or Off" },
   { "practices", 	LVL_GRGOD, 	PC, 	NUMBER, "Number of practices" },
   { "lessons", 	LVL_GRGOD, 	PC, 	NUMBER, "Number of practices" },
   { "drunk",		LVL_GRGOD, 	BOTH, 	MISC, 	"State (0->24) or Off" },
   { "hunger",		LVL_GRGOD, 	BOTH, 	MISC, 	"State (0->24) or Off" },    /* 30 */
   { "thirst",		LVL_GRGOD, 	BOTH, 	MISC, 	"State (0->24) or Off" },
   { "killer",		LVL_GOD, 	PC, 	BINARY, "On or Off" },
   { "thief",		LVL_GOD, 	PC, 	BINARY, "On or Off" },
   { "level",		LVL_IMPL, 	BOTH, 	NUMBER, "New level within class" },
   { "room",		LVL_IMPL, 	BOTH, 	NUMBER, "Room vnum to put target in" },  /* 35 */
   { "roomflag", 	LVL_GRGOD, 	PC, 	BINARY, "On or Off" },
   { "siteok",		LVL_GRGOD, 	PC, 	BINARY, "On or Off" },
   { "deleted", 	LVL_IMPL, 	PC, 	BINARY, "On or Off" },
   { "class",		LVL_GRGOD, 	BOTH, 	MISC, 	"First few letters of class" },
   { "nowizlist", 	LVL_GOD, 	PC, 	BINARY, "On or Off" },  /* 40 */
   { "quest",		LVL_GOD, 	PC, 	BINARY, "On or Off" },
   { "loadroom", 	LVL_GRGOD, 	PC, 	MISC, 	"Room to load player at (vnum) or 'defaults'" },
   { "color",		LVL_GOD, 	PC, 	BINARY, "On or Off" },
   { "idnum",		LVL_IMPL, 	PC, 	NUMBER, "Set NPC's ID (Why?)" },
   { "passwd",		LVL_IMPL, 	PC, 	MISC, 	"Set player's password" },    /* 45 */
   { "nodelete", 	LVL_GOD, 	PC, 	BINARY, "On or Off" },
   { "sex", 		LVL_GRGOD, 	BOTH, 	MISC, 	"Male/Female/Neutral" },
   { "age",		LVL_GRGOD,	BOTH,	NUMBER, "New age (3->199)" },
   { "height",		LVL_GOD,	BOTH,	NUMBER, "New height" },
   { "weight",		LVL_GOD,	BOTH,	NUMBER, "New weight" },  /* 50 */
   { "olc",             LVL_IMPL,       PC,     NUMBER, "OLC Zone (0: all access, -1: no access, N: only for zone N)" },

// Primal set commands
   { "timer",           LVL_IMPL,       PC,     NUMBER, "Targets timer value" },
   { "holylight",       LVL_GRGOD,      PC,     BINARY, "On or Off" },  
   { "infection",       LVL_GRGOD,      PC,     MISC, 	"Werewolf/Vampire/None" },
   { "tag",             LVL_GOD,        PC,     BINARY, "On or Off" },  /* 55 */
   { "palign",          LVL_GOD,        PC,     BINARY, "Display Alignment prompt (On or Off)" },
   { "noignore",        LVL_CLAN_GOD,   PC,     BINARY, "On or Off" },
   { "clan",            LVL_GOD,        PC,     NUMBER, "Clan Number"   },  
   { "fix",             LVL_IMPL,       PC,     BINARY, "Bullshit" },
   { "clanrank",        LVL_CLAN_GOD,   PC,     NUMBER, "Clan Rank Number" },    /* 60 */
   { "autogold",        LVL_GOD,        PC,     BINARY, "On or Off" },
   { "autoloot",        LVL_GOD,        PC,     BINARY, "On or Off" },
   { "autoassist",      LVL_GOD,        PC,     MISC, 	"Off or player to autoassist"   },   
   { "autoassisters",   LVL_GOD,        BOTH,   MISC, 	"Off"  },
   { "autosplit",       LVL_GOD,        BOTH,   MISC, 	"On or Off" },    /* 65 */ 
   { "race", 		LVL_GOD, 	PC,   	MISC, 	"First few letters of race name" },
   { "special",         LVL_GRGOD,      PC,   	MISC, 	"Special # to set On or Off or 'list'" },
   { "nohints",         LVL_GOD,        PC,   	BINARY, "On or Off" },
   { "statpoints",     	LVL_GOD,        PC,   	NUMBER, "Stat Points" }, 
   { "pkill",           LVL_GOD,        PC,   	BINARY, "On of Off" }, /* 70 */
   { "whostring",       LVL_GRGOD,	PC,	MISC, 	"Targets Who String (Max 20 Chars)" },
   { "remortlev1",	LVL_IMPL,	PC, 	NUMBER, "First remort level" },
   { "remortlev2",	LVL_IMPL,	PC,	NUMBER,	"Second remort level" },
   { "debug",		LVL_IMPL,	PC,	BINARY, "On or Off" },
   { "unholiness",	LVL_GRGOD,	PC,	NUMBER, "Unholy kill counter" },
   { "\n", 0, BOTH, MISC }
  };


int perform_set(struct char_data *ch, struct char_data *vict, int mode,
		char *val_arg)
{
  int i, on = 0, off = 0, value = 0;
  room_rnum rnum;
  room_vnum rvnum;
  char output[MAX_STRING_LENGTH];
  void add_to_immlist(char *name, long idnum, long immkills, ubyte unholiness);

  /* Check to make sure all the levels are correct */
  if (GET_LEVEL(ch) < LVL_OWNER)
  {
    if (!IS_NPC(vict) && GET_LEVEL(ch) <= GET_LEVEL(vict) && vict != ch)
    {
      send_to_char("Maybe that's not such a great idea...\r\n", ch);
      return (0);
    }
  }
  if (GET_IDNUM(ch) > 3)
  {
    if (GET_LEVEL(ch) < set_fields[mode].level)
    {
      send_to_char("You are not godly enough for that!\r\n", ch);
      return (0);
    }
  }

  /* Make sure the PC/NPC is correct */
  if (IS_NPC(vict) && !(set_fields[mode].pcnpc & NPC))
  {
    send_to_char("You can't do that to a beast!\r\n", ch);
    return (0);
  } else if (!IS_NPC(vict) && !(set_fields[mode].pcnpc & PC)) {
    send_to_char("That can only be done to a beast!\r\n", ch);
    return (0);
  }

  /* Find the value of the argument */
  if (set_fields[mode].type == BINARY) {
    if (!strcmp(val_arg, "on") || !strcmp(val_arg, "yes"))
      on = 1;
    else if (!strcmp(val_arg, "off") || !strcmp(val_arg, "no"))
      off = 1;
    if (!(on || off)) {
      send_to_char("Value must be 'on' or 'off'.\r\n", ch);
      return (0);
    }
    sprintf(output, "%s %s for %s.", set_fields[mode].cmd, ONOFF(on),
	    GET_NAME(vict));
  } else if (set_fields[mode].type == NUMBER) {
    value = atoi(val_arg);
    sprintf(output, "%s's %s set to %d.", GET_NAME(vict),
	    set_fields[mode].cmd, value);
  } else {
    strcpy(output, "Okay.");  /* can't use OK macro here 'cause of \r\n */
  }

  switch (mode) {
  case 0:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_BRIEF);
    break;
  case 1:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_INVSTART);
    break;
  case 2:
    set_title(vict, val_arg);
    sprintf(output, "%s's title is now: %s", GET_NAME(vict), GET_TITLE(vict));
    break;
  case 3:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_SUMMONABLE);
    sprintf(output, "Nosummon %s for %s.\r\n", ONOFF(!on), GET_NAME(vict));
    break;
  case 4:
    vict->points.max_hit = RANGE(1, 32768);
    affect_total(vict);
    break;
  case 5:
    vict->points.max_mana = RANGE(1, 32768);
    affect_total(vict);
    break;
  case 6:
    vict->points.max_move = RANGE(1, 32768);
    affect_total(vict);
    break;
  case 7:
    vict->points.hit = RANGE(-9, vict->points.max_hit);
    affect_total(vict);
    break;
  case 8:
    vict->points.mana = RANGE(0, vict->points.max_mana);
    affect_total(vict);
    break;
  case 9:
    vict->points.move = RANGE(0, vict->points.max_move);
    affect_total(vict);
    break;
  case 10:
    GET_ALIGNMENT(vict) = RANGE(-5000, 5000);
    affect_total(vict);
    break;
  case 11:
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 25);
    else
      RANGE(3, 21);
    vict->real_abils.str = value;
    vict->real_abils.str_add = 0;
    affect_total(vict);
    break;
  case 12:
    vict->real_abils.str_add = RANGE(0, 100);
    if (value > 0)
      vict->real_abils.str = 18;
    affect_total(vict);
    break;
  case 13:
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 25);
    else
      RANGE(3, 21);
    vict->real_abils.intel = value;
    affect_total(vict);
    break;
  case 14:
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 25);
    else
      RANGE(3, 21);
    vict->real_abils.wis = value;
    affect_total(vict);
    break;
  case 15:
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 25);
    else
      RANGE(3, 21);
    vict->real_abils.dex = value;
    affect_total(vict);
    break;
  case 16:
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 25);
    else
      RANGE(3, 21);
    vict->real_abils.con = value;
    affect_total(vict);
    break;
  case 17:
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 25);
    else
      RANGE(3, 21);
    vict->real_abils.cha = value;
    affect_total(vict);
    break;
  case 18:
    vict->points.armor = RANGE(-200, 200);
    affect_total(vict);
    break;
  case 19:
    GET_GOLD(vict) = RANGE(0, 1000000000);
    break;
  case 20:
    GET_BANK_GOLD(vict) = RANGE(0, 1000000000);
    break;
  case 21:
    vict->points.exp = RANGE(0, level_exp(vict,GET_LEVEL(vict)));
    break;
  case 22:
    vict->points.hitroll = RANGE(0, 1000000);
    affect_total(vict);
    break;
  case 23:
    vict->points.damroll = RANGE(0, 1000000);
    affect_total(vict);
    break;
  case 24:
    if (GET_LEVEL(ch) < LVL_IMPL && ch != vict) {
      send_to_char("You aren't godly enough for that!\r\n", ch);
      return (0);
    }
    GET_INVIS_LEV(vict) = RANGE(0, GET_LEVEL(vict));
    break;
  case 25:
    if (GET_LEVEL(ch) < LVL_IMPL && ch != vict) {
      send_to_char("You aren't godly enough for that!\r\n", ch);
      return (0);
    }
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_NOHASSLE);
    break;
  case 26:
    if (ch == vict && on) {
      send_to_char("Better not -- could be a long winter!\r\n", ch);
      return (0);
    }
    SET_OR_REMOVE(PUN_FLAGS(vict), PUN_FREEZE);
    if (PUN_FLAGGED(vict, PUN_FREEZE))
      PUN_HOURS(vict, PUN_FREEZE) = -1;
    else
      PUN_HOURS(vict, PUN_FREEZE) = 0;
    break;
  case 27:
  case 28:
    GET_PRACTICES(vict) = RANGE(0, 1000);
    break;
  case 29:
  case 30:
  case 31:
    if (!str_cmp(val_arg, "off")) {
      GET_COND(vict, (mode - 29)) = (char) -1; /* warning: magic number here */
      sprintf(output, "%s's %s now off.", GET_NAME(vict), set_fields[mode].cmd);
    } else if (is_number(val_arg)) {
      value = atoi(val_arg);
      RANGE(0, 24);
      GET_COND(vict, (mode - 29)) = (char) value; /* and here too */
      sprintf(output, "%s's %s set to %d.", GET_NAME(vict),
	      set_fields[mode].cmd, value);
    } else {
      send_to_char("Must be 'off' or a value from 0 to 24.\r\n", ch);
      return (0);
    }
    break;
  case 32:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_KILLER);
    break;
  case 33:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_THIEF);
    break;
  case 34:
    if (value <= 0 || value > LVL_OWNER)
    {
      send_to_char("Invalid level.\r\n", ch);
      return (0);
    }
    if (GET_IDNUM(ch) > 3)
    {
      if (GET_LEVEL(ch) < GET_LEVEL(vict) || value > GET_LEVEL(ch) || 
          value > LVL_OWNER)
      {
        send_to_char("You can't do that.\r\n", ch);
        return (0);
      }
    }
    vict->player.level = (byte) value;
    vict->player.level = RANGE(1, LVL_OWNER);
    if ((GET_CLASS(vict) == CLASS_MASTER) && (GET_LEVEL(vict) >= LVL_CHAMP) &&
	(GET_LEVEL(vict) < LVL_ANGEL))
      add_to_immlist(GET_NAME(vict), GET_IDNUM(vict), GET_IMMKILLS(vict),
	             GET_UNHOLINESS(vict));
    break;
  case 35:
    if ((rnum = real_room(value)) < 0) {
      send_to_char("No room exists with that number.\r\n", ch);
      return (0);
    }
    if (IN_ROOM(vict) != NOWHERE)	/* Another Eric Green special. */
      char_from_room(vict);
    char_to_room(vict, rnum);
    break;
  case 36:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_ROOMFLAGS);
    break;
  case 37:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_SITEOK);
    break;
  case 38:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_DELETED);
    break;
  case 39:
    if ((i = parse_class(val_arg)) == CLASS_UNDEFINED) {
      send_to_char("That is not a class.\r\n", ch);
      return (0);
    }
    remove_class_specials(ch);
    GET_CLASS(vict) = i;
    set_class_specials(vict);
    apply_specials(vict, FALSE);
    calc_modifier(ch);
    break;
  case 40:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NOWIZLIST);
    break;
  case 41:
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_QUEST);
    break;

  /**
   * DM: Determine the world for the given vnum, and set the entry room for
   * that world. It is possible to set an entry room for each world simply by
   * passing the vnum of a room in each world.
   * 
   * The entry rooms are cleared when the given argument is an abbreviation of
   * "defaults", indicating that the default world_start_rooms are to be used. 
   */
  case 42:
    if (is_abbrev(val_arg, "defaults")) {
      for (int i = 0; i < NUM_WORLDS; i++) {
        ENTRY_ROOM(vict, i) = NOWHERE; 
      }
    } else if (is_number(val_arg)) {
      rvnum = atoi(val_arg);
      if (real_room(rvnum) != NOWHERE) {
        ENTRY_ROOM(vict, get_world(real_room(rvnum))) = rvnum;
	sprintf(output, "%s will enter %s at room #%d.", 
                GET_NAME(vict),
		world_names[get_world(real_room(rvnum))], 
                ENTRY_ROOM(vict, get_world(real_room(rvnum))));
      } else {
	send_to_char("That room does not exist!\r\n", ch);
	return (0);
      }
    } else {
      send_to_char("Must be 'defaults' or a room's virtual number.\r\n", ch);
      return (0);
    }
    break;

  case 43:
    SET_OR_REMOVE(PRF_FLAGS(vict), (PRF_COLOR_1 | PRF_COLOR_2));
    break;
  case 44:
    if (!IS_NPC(vict))
      return (0);
    GET_IDNUM(vict) = value;
    break;
  case 45:
/*  // Artus> This was already commented out, Guess it was while debugging
    if (GET_IDNUM(ch) > 1) {
      send_to_char("Please don't use this command, yet.\r\n", ch);
      return (0);
    }
*/
/*
  if (GET_LEVEL(vict) >= LVL_GRGOD) {
      send_to_char("You cannot change that.\r\n", ch);
      return (0);
    }
*/
    // Artus> Changed to this..
    if ((GET_LEVEL(vict) >= GET_LEVEL(ch)) && (GET_IDNUM(ch) != 1))
    {
      send_to_char("You can't do that, perhaps you better see a higher power!\r\n", ch);
      return(0);
    }
    strncpy(GET_PASSWD(vict), CRYPT(val_arg, GET_NAME(vict)), MAX_PWD_LENGTH);
    *(GET_PASSWD(vict) + MAX_PWD_LENGTH) = '\0';
    sprintf(output, "Password changed to '%s'.", val_arg);
    break;
  case 46:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NODELETE);
    break;
  case 47:
    if ((i = search_block(val_arg, genders, FALSE)) < 0) {
      send_to_char("Must be 'male', 'female', or 'neutral'.\r\n", ch);
      return (0);
    }
    GET_SEX(vict) = i;
    break;
  case 48:	/* set age */
    if (value < 2 || value > 200) {	/* Arbitrary limits. */
      send_to_char("Ages 2 to 200 accepted.\r\n", ch);
      return (0);
    }
    /*
     * NOTE: May not display the exact age specified due to the integer
     * division used elsewhere in the code.  Seems to only happen for
     * some values below the starting age (17) anyway. -gg 5/27/98
     */
    vict->player.time.birth = time(0) - ((value - 17) * SECS_PER_MUD_YEAR);
    break;

  case 49:	/* Blame/Thank Rick Glover. :) */
    GET_HEIGHT(vict) = value;
    affect_total(vict);
    break;

  case 50:
    GET_WEIGHT(vict) = value;
    affect_total(vict);
    break;

  case 51:
    GET_OLC_ZONE(vict) = value;
    break;

// Primal set commands:

  case 52: // Timer
    vict->char_specials.timer=value;
    break; 

  case 53: // Holylight
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_HOLYLIGHT);
    break;

  case 54: // Infection
      if(!str_cmp(val_arg,"werewolf")) {
        REMOVE_BIT(PRF_FLAGS(vict),PRF_VAMPIRE);
        SET_BIT(PRF_FLAGS(vict),PRF_WOLF);
      } else if(!str_cmp(val_arg,"vampire")) {
        REMOVE_BIT(PRF_FLAGS(vict),PRF_WOLF);
        SET_BIT(PRF_FLAGS(vict),PRF_VAMPIRE);
      } else if(!str_cmp(val_arg,"none")) {
        REMOVE_BIT(PRF_FLAGS(vict),PRF_WOLF | PRF_VAMPIRE);
      } else {
        send_to_char("Must be 'werewolf', 'vampire', or 'none'.\r\n",ch);
        return (0);
        }
      break;
 
  case 55: // Tag
    SET_OR_REMOVE(PRF_FLAGS(vict),PRF_TAG);
    break;

  case 56: // Palign
    SET_OR_REMOVE(PRF_FLAGS(vict),PRF_DISPALIGN);
    break;

  case 57: // Noignore
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NOIGNORE );
    if (!str_cmp(val_arg, "on") )
    {
      for (i = 0; i < MAX_IGNORE; i++) {
        GET_IGNORE(vict, i) = 0;
        GET_IGNORE_ALL(vict, i) = TRUE;
        GET_IGN_LVL(vict) = 0;
        GET_IGN_LVL_ALL(vict) = FALSE;
      }
    }
    break;

  case 58: // Clan
    if ((value < 0) || (value > MAX_CLANS)) {
      sprintf(buf, "Value must be between 0 and %d.\r\n", MAX_CLANS);
      send_to_char(buf, ch);
      return (0);
    }
    if (value == 0)
      GET_CLAN_RANK(vict) = 0;
 
    if ((find_clan_by_id(value) < 0) && (value != 0)) {
      send_to_char("That clan doesn't seem to exist.\r\n", ch);
      return (0);
    }

    GET_CLAN(vict) = value;

    if (GET_CLAN_RANK(vict) > clan[find_clan_by_id(value)].ranks)
      GET_CLAN_RANK(vict) = clan[find_clan_by_id(value)].ranks;

    sprintf(output, "Clan changed to %d (%s).", GET_CLAN(vict), ((find_clan_by_id(GET_CLAN(vict)) >= 0) ? clan[find_clan_by_id(GET_CLAN(vict))].name : "Undefined"));
    break;

  case 59: // Fix
    // REMOVE_BIT(PRF_FLAGS(vict), PRF_FIX);
    break;

  case 60: // Clanrank
    if (value < 0) {
      send_to_char("Clan rank cannot be less than 0.\r\n", ch);
      return (0);
    }
    if (find_clan_by_id(GET_CLAN(vict)) >= 0) {
      if (value > clan[find_clan_by_id(GET_CLAN(vict))].ranks) {
        send_to_char("Clan rank cannot exceed clans maximum rank.\r\n", ch);
        return (0);
      }
    }
    GET_CLAN_RANK(vict) = value;
    sprintf(output, "Clan rank changed to %d.", GET_CLAN_RANK(vict));
    break;

  case 61: // Autogold
    SET_OR_REMOVE(EXT_FLAGS(vict), EXT_AUTOGOLD);
    break;

  case 62: // Autoloot
    SET_OR_REMOVE(EXT_FLAGS(vict), EXT_AUTOLOOT);
    break;

  case 63: // Autoassist
    if (!str_cmp(val_arg,"off")) {
      if (AUTOASSIST(vict)) {
        sprintf(buf, "%s is no longer autoassisting %s.", 
		GET_NAME(vict),GET_NAME(AUTOASSIST(vict)));
        stop_assisting(vict);
      } else {
        sprintf(buf,"And who is %s autoassisting?.",GET_NAME(vict));
        send_to_char(buf,ch);
        return (0);
      }
    } else {
      send_to_char("Options: OFF\r\n",ch);
      return (0);
    }
    break;

  case 64: // Autoassisters
    if (!str_cmp(val_arg,"off")) {
      if (vict->autoassisters) {
        sprintf(buf, "%s is no longer being autoassisted.", GET_NAME(vict));
        stop_assisters(vict);
      } else {
        sprintf(buf,"And who autoassisting %s?.",GET_NAME(vict));
        send_to_char(buf,ch);
        return (0);
      }
    } else {
      send_to_char("Options: OFF\r\n",ch);
      return (0);
    }
    break;

  case 65: // Autosplit
    SET_OR_REMOVE(EXT_FLAGS(vict), EXT_AUTOSPLIT);
    break;

  case 66:
    if ((i = parse_race_name(val_arg)) == RACE_UNDEFINED) {
      send_to_char("That is not a race.\r\n", ch);
      return (0);
    }
    remove_race_specials(vict);
    GET_RACE(vict) = i;
   set_race_specials(vict); 
    GET_MODIFIER(vict) = race_modifiers[i] + 
                 class_modifiers[(int)GET_CLASS(vict)] + 
		 special_modifier(vict) + elitist_modifier(vict);
   break;

  case 67:
    if (strcmp(val_arg, "list") ==  0 )
    {
      show_specials_to_char(ch);
      return (0);
    }
    if (!isdigit(val_arg[0]))
    {
      send_to_char("You must specify the value of the special.\r\n Use &4set <player> special list&n to see specials available.\r\n", ch);
      return (0);
    }
    if (atoi(val_arg) <= 0 || atoi(val_arg) > MAX_SPECIALS)
    {
      send_to_char("That's not a valid option!\r\nUser &4set <player> special list&n to see options.\r\n", ch);
      return (0);
    } else {
      if (IS_SET(GET_SPECIALS(vict), (1 << atoi(val_arg) - 1)))
      {
        REMOVE_BIT(GET_SPECIALS(vict), (1 << atoi(val_arg) - 1));
	// Artus> Reroll str/con after removing superman.
	if (atoi(val_arg) == 21)
	{
	  GET_REAL_STR(vict) = 13 + number(1, 5);
	  GET_REAL_CON(vict) = 13 + number(1, 5);
	}
      } else
        SET_BIT(GET_SPECIALS(vict), (1 << atoi(val_arg) - 1));
    }
    sprintf(buf, "&g%s&n toggled &4%s&n for %s.\r\n", 
            special_ability_bits[atoi(val_arg)-1], 
	    IS_SET(GET_SPECIALS(vict), (1 << atoi(val_arg) -1)) ? "on" : "off",
	    GET_NAME(vict));
    send_to_char(buf, ch);
    apply_specials(vict, FALSE);
    // Recalc the players modifier
    GET_MODIFIER(vict) = race_modifiers[GET_RACE(vict)] + 
                         class_modifiers[(int)GET_CLASS(vict)] +
	 		 special_modifier(vict) +
			 elitist_modifier(vict) +
			 unholiness_modifier(ch);
  
    break;
  // Nohints
  case 68:
    SET_OR_REMOVE(EXT_FLAGS(vict), EXT_NOHINTS);
    break;

  // Quest Points
  case 69:
    GET_STAT_POINTS(vict) = RANGE(1, 10000);
    break;
    
  // PKill Flag
  case 70:
    SET_OR_REMOVE(EXT_FLAGS(vict), EXT_PKILL);
    break;

  // Who String
  case 71:
    if (strlen(val_arg) > 19)
    {
      send_to_char("WhoString must not be longer than 19 chars.\r\n", ch);
      return (0);
    }
    sprintf(GET_WHO_STR(vict), "%s", val_arg);
    break;

  // First remort level
  case 72:
    if (value < 0 || value > LVL_OWNER) {
      send_to_char("Invalid level.\r\n", ch);
      return (0);
    }
    if (GET_IDNUM(ch) > 3) {
      if (GET_LEVEL(ch) < GET_LEVEL(vict) || value > GET_LEVEL(ch) ||
          value > LVL_OWNER) {
        send_to_char("You can't do that.\r\n", ch);
        return (0);
      }
    }
    GET_REM_ONE(vict) = (byte) value;
    GET_REM_ONE(vict) = RANGE(0, LVL_OWNER);
    break;

  // Second remort level
  case 73:
    if (value < 0 || value > LVL_OWNER) {
      send_to_char("Invalid level.\r\n", ch);
      return (0);
    }
    if (GET_IDNUM(ch) > 3) {
      if (GET_LEVEL(ch) < GET_LEVEL(vict) || value > GET_LEVEL(ch) ||
          value > LVL_OWNER) {
        send_to_char("You can't do that.\r\n", ch);
        return (0);
      }
    }
    GET_REM_TWO(vict) = (byte) value;
    GET_REM_TWO(vict) = RANGE(0, LVL_OWNER);
    break;

  // Debug Flag.
  case 74:
    SET_OR_REMOVE(SMALL_BITS(vict), SMB_DEBUG);
    break;

  // Unholiness
  case 75:
    if (value < 0 || value > 250)
    {
      send_to_char("Outside Range (0-250)\r\n", ch);
      return (0);
    }
    if (GET_LEVEL(ch) < GET_LEVEL(vict))
    {
      send_to_char("You can't do that.\r\n", ch);
      return (0);
    }
    GET_UNHOLINESS(vict) = (byte) value;
    calc_modifier(ch);
    break;

  default:
    send_to_char("Can't set that!\r\n", ch);
    return (0);
  }

  strcat(output, "\r\n");
  send_to_char(CAP(output), ch);
//  -- What is this supposed to do? All we have at this point
//    to log is 'on' or 'off' or something equally ambgious.
//    I added the log to 'do_set' instead.
//  sprintf(buf, "(GC) %s: %s", GET_NAME(ch), val_arg);
//  mudlog(buf, NRM, GET_LEVEL(ch) , TRUE);
//
  return (1);
}

void set_list(struct char_data *ch)
{
  int j, i = 0;
 
   for (j = 0,i = 1; set_fields[i].level; i++)
      if (set_fields[i].level <= GET_LEVEL(ch))
	sprintf(buf + strlen(buf), "&g%-10s&n - %s\r\n", set_fields[i].cmd, set_fields[i].help);
    strcat(buf, "\r\n");
    page_string(ch->desc, buf, TRUE);
}


ACMD(do_set)
{
  struct char_data *vict = NULL, *cbuf = NULL;
  struct char_file_u tmp_store;
  char field[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH],
	val_arg[MAX_INPUT_LENGTH];
  int mode, len, player_i = 0, retval;
  char is_file = 0, is_player = 0;

  if (IS_NPC(ch))
    return;

  half_chop(argument, name, buf);

  if (!strcmp(name, "file"))
  {
    is_file = 1;
    half_chop(buf, name, buf);
  } else if (!str_cmp(name, "player")) {
    is_player = 1;
    half_chop(buf, name, buf);
  } else if (!str_cmp(name, "mob")) {
    half_chop(buf, name, buf);
  } 

  half_chop(buf, field, buf);
  strcpy(val_arg, buf);

  if (!*name || !*field)
  {
    send_to_char("&1Usage: &4set <victim> <field> <value>&n\r\n", ch);
    set_list(ch);
    return;
  }

  /* find the target */
  if (!is_file)
  {
    if (is_player)
    {
      if (!(vict = get_player_online(ch, name, FIND_CHAR_WORLD)))
      {
	send_to_char("There is no such player.\r\n", ch);
	return;
      }
    } else { /* is_mob */
      if (!(vict = generic_find_char(ch, name, FIND_CHAR_ROOM | FIND_CHAR_WORLD)))
      {
	send_to_char("There is no such creature.\r\n", ch);
	return;
      }
    }
  } else if (is_file) {
    /* try to load the player off disk */
    CREATE(cbuf, struct char_data, 1);
    clear_char(cbuf);
    if ((player_i = load_char(name, &tmp_store)) > -1) {
      store_to_char(&tmp_store, cbuf);
      if (GET_LEVEL(cbuf) >= GET_LEVEL(ch)) {
	free_char(cbuf);
	send_to_char("Sorry, you can't do that.\r\n", ch);
	return;
      }
      vict = cbuf;
    } else {
      free(cbuf);
      send_to_char("There is no such player.\r\n", ch);
      return;
    }
  }

  /* find the command in the list */
  len = strlen(field);
  for (mode = 0; *(set_fields[mode].cmd) != '\n'; mode++)
    if (!strncmp(field, set_fields[mode].cmd, len))
      break;

  /* perform the set */
  retval = perform_set(ch, vict, mode, val_arg);

  /* Log the operation */
  if (retval) {
    sprintf(buf, "SET: %s '%s%s'", GET_NAME(ch), arg, argument);
    mudlog(buf, CMP, MAX(LVL_GOD, GET_LEVEL(ch)), TRUE);
  }

  /* save the character if a change was made */
  if (retval) {
    if (!is_file && !IS_NPC(vict))
      save_char(vict, NOWHERE);
    if (is_file) {
      char_to_store(vict, &tmp_store);
      fseek(player_fl, (player_i) * sizeof(struct char_file_u), SEEK_SET);
      fwrite(&tmp_store, sizeof(struct char_file_u), 1, player_fl);
      fflush(player_fl);
      send_to_char("Saved in file.\r\n", ch);
    }
  }

  /* free the memory if we allocated it earlier */
  if (is_file)
    free_char(cbuf);
}


// do_global_set: Process the arguments and perform the setting and saving
//                of global variables.
ACMD(do_global_set)
{
  char field[MAX_INPUT_LENGTH], val_arg[MAX_INPUT_LENGTH];

  send_to_char(argument,ch);
  half_chop(argument, field, val_arg);

  sprintf(buf,"field: %s, value: %s\r\n",field,val_arg);
  send_to_char(buf,ch);

//  if (!*field) {
    send_to_char("&1Usage: &4global <field> <value>&n\r\n", ch);
    return;
//  }

  /* perform the set */
//  retval = globals.setVariable(field, val_arg);

  /* save the global vars file if a change was made 
  if (retval)
    globals.SaveAll();
  else {
    send_to_char("Field not found. Type &4global&n to see a list of fields.\r\n");
    return;
  } */
}

ACMD(do_deimmort)
{
  struct char_data *vict;
 
  one_argument(argument,arg);
 
  if (!(vict = get_player_online(ch, arg, FIND_CHAR_WORLD)))
  {
    send_to_char("I cannot seem to find that person!!!\r\n", ch);
    return;
  }
  if (IS_NPC(vict))
  {
    send_to_char("DEMOTE A MONSTER!!!!.... Go find something more productive to do!\r\n", ch);
    return;
  }
  if (GET_LEVEL(vict) != LVL_ANGEL)
  {
    send_to_char("You can only demote ANGELS!!\r\n", ch);
    return;
  }
  GET_LEVEL(vict) = LVL_CHAMP + MIN(5, GET_UNHOLINESS(vict));
  send_to_char("You have DEMOTED them!.\r\n", ch);
  send_to_char("You have been demoted!!!.  You become a fallen angel!\r\nServes you RIGHT!\r\n", vict);
} 

ACMD(do_immort)
{
  struct char_data *vict;
  int i;
 
  if (IS_NPC(ch))
    return;

  one_argument(argument,arg);
 
  if (!(vict = get_player_online(ch, arg, FIND_CHAR_ROOM)))
  {
     send_to_char("I cannot seem to find that person!!!\r\n", ch);
     return;
  }
  if (IS_NPC(vict))
  {
    send_to_char("You want to immort a monster!!!!!. YOU MUST BE BORED!\r\n", ch);
    return;
  }
  if (GET_LEVEL(vict) < LVL_IMMORT)
  {
    send_to_char("They are not an IMMORTAL!!.  Can't do it!\r\n", ch);
    return;
  }
  if (GET_LEVEL(vict) == LVL_ANGEL)
  {
    send_to_char("They are already angel silly!\r\n", ch);
    return;
  }
  if (GET_LEVEL(vict) > LVL_ANGEL)
  {
    send_to_char("Yer right get serious!!!\r\n", ch);
    return;
  }

  for (i = 0; i < 3; i++)
    GET_COND(vict, i) = (char) -1;

  GET_LEVEL(vict) = LVL_ANGEL;
  send_to_char("Done...\r\n", ch);
  send_to_char("You are touched by the hand of god. You soul shivers for a second.\r\n", vict);
  send_to_char("You feel like an ANGEL!.\r\n", vict);
} 

ACMD(do_pkset)
{
  char buff[120];
  half_chop(argument, arg, buf);
 
  if (!*arg)
  {
     if (IS_SET(zone_table[world[ch->in_room].zone].zflag , ZN_PK_ALLOWED))
     sprintf(arg,"on");
     else sprintf(arg,"off");
     sprintf(buff,"In this zone, Player Killing is %s.", arg);
     send_to_char(buff,ch);
     return;
  }
  if (!strcmp(arg, "on"))
     SET_BIT(zone_table[world[ch->in_room].zone].zflag , ZN_PK_ALLOWED);
  else if (!strcmp(arg, "off"))
     REMOVE_BIT(zone_table[world[ch->in_room].zone].zflag , ZN_PK_ALLOWED);
  sprintf(buff,"Player Killing in this zone is now %s.", arg);
  send_to_char(buff,ch);
}  

/* Change your whostring. */
ACMD(do_whostr)
{
  if (IS_NPC(ch))
    return;
  if (!(*argument))
  {
    send_to_char("Just what did you want to set it to ('none' will remove it)?\r\n", ch);
    return;
  }
  skip_spaces(&argument);
  if (strlen(argument) >= 20)
  {
    send_to_char("Whostring cannot exceed 19 characters.\r\n", ch);
    return;
  }
  if (!str_cmp(argument, "none"))
  {
    strcpy(GET_WHO_STR(ch), "");
    send_to_char("Whostring removed.\r\n", ch);
    return;
  }
  // Don't allow players to fake level strings.
  if (GET_LEVEL(ch) < LVL_IS_GOD)
    for (unsigned int i = 0; i < strlen(argument); i++)
      if (argument[i] == '/')
      {
	send_to_char("Whostring cannot contain '/' characters.\r\n", ch);
	return;
      }
  strncpy(GET_WHO_STR(ch), argument, 20);
  GET_WHO_STR(ch)[19] = '\0';
  sprintf(buf, "Whostring set to '%s&n'.\r\n", GET_WHO_STR(ch));
  send_to_char(buf, ch);
}

/* this is a must! clock over one mud hour */
ACMD(do_tic)
{
  extern int pulse;
  pulse=-1;
  send_to_char("Time moves forward one hour.\r\n",ch);
} 

/* skillshow - display the spell/skill  */
ACMD(do_skillshow)
{
  extern struct spell_info_type spell_info[];
  int i, sortpos, mana, is_file = FALSE;
  struct char_data *vict, *cbuf=NULL;
  struct char_file_u tmp_store;
  int class_index;

  if (IS_NPC(ch))
    return;
  
  one_argument(argument,arg);
 
  if (!*arg)
  {
    vict=ch;
    basic_mud_log("skillshow: no arg, vict=ch");
  } else if(!(vict = get_player_online(ch,arg,FIND_CHAR_WORLD))) {
    /* try to load the player off disk */
    CREATE(cbuf, struct char_data, 1);
    clear_char(cbuf);
    if (load_char(arg, &tmp_store) > -1)
    {
      store_to_char(&tmp_store, cbuf);
      basic_mud_log("skillshow: loaded player %s from disk", GET_NAME(cbuf));
      if (GET_LEVEL(cbuf) > GET_LEVEL(ch))
      {
        free_char(cbuf);
        send_to_char("Sorry, you can't do that.\r\n", ch);
        return;
      }
      vict = cbuf;
      is_file = TRUE;
    } else {
      basic_mud_log("skillshow: no player found");
      send_to_char(NOPERSON,ch);
      return;
    }
  }
 
  sprintf(buf, "&1Spell/Skill abilities for: &B%s&n\r\n",GET_NAME(vict));
  sprintf(buf, "%s&1Practice Sessions: &M%d&n\r\n\r\n",buf,GET_PRACTICES(vict));
 
  sprintf(buf, "%s%-20s %-10s\r\n",buf,"&1Spell/Skill","Ability Mana&n");
  strcpy(buf2, buf);

  class_index = GET_CLASS(vict); 

  for (sortpos = 1; sortpos < MAX_SKILLS; sortpos++) {
    i = spell_sort_info[SORT_ALPHA][0][sortpos];
    if (strlen(buf2) >= MAX_STRING_LENGTH - 32) {
      strcat(buf2, "**OVERFLOW**\r\n");
      break;
    }
    if (GET_LEVEL(vict) >= spell_info[i].min_level[(int) GET_CLASS(vict)]) {
      mana = mag_manacost(vict, i);
      sprintf(buf, "%-20s %-3d %-3d ", 
                      spell_info[i].name, GET_SKILL(vict, i), mana);
      strncat(buf2, buf, strlen(buf)); 

      /* Display the stat requirements */ 
      if (spell_info[i].str[class_index]!=0){
        if (GET_REAL_STR(vict) >= spell_info[i].str[class_index])
          sprintf(buf,"%sStr: %s%2d%s ",CCGRN(ch,C_NRM),CCCYN(ch,C_NRM),spell_info[i].str[class_index],CCNRM(ch,C_NRM));
        else
          sprintf(buf,"%sStr: %s%2d%s ",CCGRN(ch,C_NRM),CCRED(ch,C_NRM),spell_info[i].str[class_index],CCNRM(ch,C_NRM));
 
        strncat(buf2, buf, strlen(buf));
      }
 
      if (spell_info[i].intl[class_index]!=0){
        if (GET_REAL_INT(vict) >= spell_info[i].intl[class_index])
          sprintf(buf,"%sInt: %s%2d%s ",CCGRN(ch,C_NRM),CCCYN(ch,C_NRM),spell_info[i].intl[class_index],CCNRM(ch,C_NRM));
        else
          sprintf(buf,"%sInt: %s%2d%s ",CCGRN(ch,C_NRM),CCRED(ch,C_NRM),spell_info[i].intl[class_index],CCNRM(ch,C_NRM));
 
        strncat(buf2, buf, strlen(buf));
      }
 
      if (spell_info[i].wis[class_index]!=0){
        if (GET_REAL_WIS(vict) >= spell_info[i].wis[class_index])
          sprintf(buf,"%sWis: %s%2d%s ",CCGRN(ch,C_NRM),CCCYN(ch,C_NRM),spell_info[i].wis[class_index],CCNRM(ch,C_NRM));
        else
          sprintf(buf,"%sWis: %s%2d%s ",CCGRN(ch,C_NRM),CCRED(ch,C_NRM),spell_info[i].wis[class_index],CCNRM(ch,C_NRM));
 
        strncat(buf2, buf, strlen(buf));
      }
 
      if (spell_info[i].dex[class_index]!=0){
        if (GET_REAL_DEX(vict) >= spell_info[i].dex[class_index])
          sprintf(buf,"%sDex: %s%2d%s ",CCGRN(ch,C_NRM),CCCYN(ch,C_NRM),spell_info[i].dex[class_index],CCNRM(ch,C_NRM));
        else
          sprintf(buf,"%sDex: %s%2d%s ",CCGRN(ch,C_NRM),CCRED(ch,C_NRM),spell_info[i].dex[class_index],CCNRM(ch,C_NRM));   
        strncat(buf2, buf, strlen(buf));
      }
 
      if (spell_info[i].con[class_index]!=0){
        if (GET_REAL_CON(vict) >= spell_info[i].con[class_index])
          sprintf(buf,"%sCon: %s%2d%s ",CCGRN(ch,C_NRM),CCCYN(ch,C_NRM),spell_info[i].con[class_index],CCNRM(ch,C_NRM));
        else
          sprintf(buf,"%sCon: %s%2d%s ",CCGRN(ch,C_NRM),CCRED(ch,C_NRM),spell_info[i].con[class_index],CCNRM(ch,C_NRM));
 
        strncat(buf2, buf, strlen(buf));
      }
      if (spell_info[i].cha[class_index]!=0){
        if (GET_REAL_CHA(vict) >= spell_info[i].cha[class_index])
          sprintf(buf,"%sCha: %s%2d%s ",CCGRN(ch,C_NRM),CCCYN(ch,C_NRM),spell_info[i].cha[class_index],CCNRM(ch,C_NRM));
        else
          sprintf(buf,"%sCha: %s%2d%s ",CCGRN(ch,C_NRM),CCRED(ch,C_NRM),spell_info[i].cha[class_index],CCNRM(ch,C_NRM));
 
        strncat(buf2, buf, strlen(buf));
      }
 
      sprintf(buf,"\r\n");
      strncat(buf2, buf, strlen(buf));
    }
  }
 
  page_string(ch->desc, buf2, 1);

  /* free the memory if we allocated it earlier */
  if (is_file)
    free_char(cbuf);
}  

/* Vulcan Neck Pinch - basically just stuns the victim - Vader */
/* this was gunna be a skill but i didnt no if it fit :)       */
ACMD(do_pinch)
{
  struct char_data *vict;
 
  one_argument(argument,arg);
 
  if(!(vict = generic_find_char(ch,arg,FIND_CHAR_ROOM)))
  {
    if(FIGHTING(ch))
      vict = FIGHTING(ch);
    else
    {
      send_to_char("Upon whom do you wish to perform the Vulcan neck pinch??\r\n",ch);
      return;
    }
  }
 
  if(!AWAKE(vict))
  {
    send_to_char("It appears that your victim is already incapacitated...\r\n",ch);
    return;
  }
 
  if(vict == ch)
  {
    send_to_char("You reach up and perform the Vulcan neck pinch on yourself and pass out...\r\n",ch);
    act("$n calmly reaches up and performs the Vulcan neck pinch on $mself before passing out...",FALSE,ch,0,0,TO_ROOM);
    GET_POS(ch) = POS_STUNNED;
    return;
  }
 
  if(GET_LEVEL(vict) >= GET_LEVEL(ch))
  {
    send_to_char("It is not logical to incapacitate your fellow Gods...\r\n",ch);
    return;
  }
 
  act("You skillfully perform the Vulcan neck pinch on $N who instantly falls to the ground.",FALSE,ch,0,vict,TO_CHAR);
  act("$n gently puts $s hand on your shoulder and Vulcan neck pinches you! You pass out instantly...",FALSE,ch,0,vict,TO_VICT);
  act("$n skillfully performs the Vulcan neck pinch on $N who falls to the ground, stunned.",FALSE,ch,0,vict,TO_NOTVICT);
 
  stop_fighting(vict);
  GET_POS(vict) = POS_STUNNED;
} 

void john_in(struct char_data *ch)
{
  int fp;
  int nread;
 
  fp = open("/primal/lib/text/john.poofin", O_RDONLY);
  if (fp == -1)
    strcpy(buf, "***********John Has Arrived*************\n\n");
  else
  {
    nread = read(fp, buf, MAX_STRING_LENGTH);
    buf[nread] = '\0';
    close(fp);
  }
 
  act(buf, TRUE, ch, 0, 0, TO_ROOM);
}
 
void cassandra_in(struct char_data *ch)
{
  int fp;
  int nread;
 
  fp = open("/home/mud/live/lib/text/cassandra.poofin", O_RDONLY);
  if (fp == -1)
    strcpy(buf, "***********Cassandra Has Arrived*************\n\n");
  else
  {
    nread = read(fp, buf, MAX_STRING_LENGTH);
    buf[nread] = '\0';
    close(fp);
  }
 
  act(buf, TRUE, ch, 0, 0, TO_ROOM);
} 

void artus_out(struct char_data *ch)
{
  sprintf(buf, "You feel a deep sense of loss, as &[&7%s&] fades away before you.", GET_NAME(ch));
  for (struct char_data *k = world[IN_ROOM(ch)].people; k; k = k->next_in_room)
  {
    if ((IS_NPC(k)) || (k == ch) || (!CAN_SEE(k, ch)) || (!k->desc))
      continue;
    send_to_char(buf, k);
  }
}

void artus_in(struct char_data *ch)
{
  for (struct char_data *k = world[IN_ROOM(ch)].people; k; k = k->next_in_room)
  {
    if ((IS_NPC(k)) || (k == ch) || (!CAN_SEE(k, ch)) || (!k->desc))
      continue;
    act("You bow deeply in awe, as $n materialises before you.", TRUE, ch,
	NULL, k, TO_VICT);
    act("$N bows deeply before $n, awestruck.", TRUE, ch, NULL, k, TO_NOTVICT);
    if (GET_SEX(k) == SEX_FEMALE)
    {
      act("You try and get a little closer to $n.", TRUE, ch, NULL, k, TO_VICT);
      act("$N tries to push passed you to be closer to $n.", TRUE, ch, NULL, k,
	  TO_NOTVICT);
    }
  }
}

struct obj_data *get_obj_from(struct obj_data *list, long objID, int itemNumber) {

  struct obj_data *obj;
  int counter = 1;

  for( obj = list; obj; obj = obj->next ) {
	if (GET_OBJ_VNUM(obj) == objID && counter == itemNumber ) 
		return obj;
	else
		counter++;
  }

  return NULL;
}

bool race_has_stats_for_skill(int race_index, int class_index, int spellnum, int statNum)
{
  int statVal, i;
  extern struct spell_info_type spell_info[];

  if (!(race_index >= 0 && race_index < MAX_RACES && 
                  spellnum >= 0 && spellnum < TOP_SPELL_DEFINE &&
                  class_index >= 0 && class_index < NUM_CLASSES)) {
    basic_mud_log("SYSERR: invalid race (%d) class (%d) spellnum (%d) to "
             "race_has_stats_for_skill", race_index, class_index, spellnum);
    return (false);
  }

  if (!str_cmp(spell_info[spellnum].name, unused_spellname)) {
    basic_mud_log("SYSERR: unused spellnum (%d) passed to " 
             "race_has_stats_for_skill", spellnum);
    return (false);
    
  }

  // Specific Stat - only check one given
  if (statNum >= 0 && statNum < STAT_HIT) {
    if (class_index >= 0 && class_index < NUM_CLASSES) {
      statVal = pc_max_race_stats[race_index][statNum];
      if (class_index == CLASS_MASTER) statVal = 21;
      switch (statNum) {

      case STAT_STR:
        return (statVal >= spell_info[spellnum].str[class_index]);
      case STAT_INT:
        return (statVal >= spell_info[spellnum].intl[class_index]);
      case STAT_WIS:
        return (statVal >= spell_info[spellnum].wis[class_index]);
      case STAT_DEX:
        return (statVal >= spell_info[spellnum].dex[class_index]);
      case STAT_CON:
        return (statVal >= spell_info[spellnum].con[class_index]);
      case STAT_CHA:
        return (statVal >= spell_info[spellnum].cha[class_index]);
      }
    }
  }

  // Non-Specific Stat - check all stats
  for (i = 0; i < STAT_HIT; i++) {
    statVal = pc_max_race_stats[race_index][i];
    if (class_index == CLASS_MASTER) statVal = 21;
    switch (i) {
    
    case STAT_STR:
      if (statVal < spell_info[spellnum].str[class_index])
        return (FALSE);
      break;

    case STAT_INT:
      if (statVal < spell_info[spellnum].intl[class_index])
        return (FALSE);
      break;
      
    case STAT_WIS:
      if (statVal < spell_info[spellnum].wis[class_index])
        return (FALSE);
      break;

    case STAT_DEX:
      if (statVal < spell_info[spellnum].dex[class_index])
        return (FALSE);
      break;

    case STAT_CON:
      if (statVal < spell_info[spellnum].con[class_index])
        return (FALSE);
      break;

    case STAT_CHA:
      if (statVal < spell_info[spellnum].cha[class_index])
        return (FALSE);
      break;
    }
  }
  return (TRUE);
}

void print_spells(struct char_data *ch, int class_index, int race_index, int sort_type) {
  bool race = FALSE;
  char info[MAX_STRING_LENGTH];
  int spell_index, spellnum;
  extern struct spell_info_type spell_info[];

  if (sort_type < 0 || sort_type > NUM_SORT_TYPES) {
    basic_mud_log("SYSERR: invalid sort_type passed to print_spells");
    return;
  }

  if (class_index == -1 && race_index == -1) {
    basic_mud_log("SYSERR: no class or race index to print_spells");
    return;
  }

  // class only
  if (class_index >= 0 && class_index < NUM_CLASSES && race_index == -1) {
    sprintf(info, "&1Spells and Skills for the &B%s&1 sorted &b%s&n\r\n\r\n", 
        CLASS_NAME(class_index), sort_names[sort_type]);
  // class and race
  } else if (race_index >= 0 && race_index < MAX_RACES && 
             class_index >= 0 && class_index < NUM_CLASSES) {
    race = TRUE;
    sprintf(info, "&1Spells and Skills for the &B%s&1, &B%s&1 sorted &b%s&n"
                 "\r\n\r\n", 
                 CLASS_NAME(class_index), pc_race_types[race_index], 
                 sort_names[sort_type]);
  // invalid
  } else {
    basic_mud_log("SYSERR: Invalid race (%d) or class (%d) passed to print_spells", 
                    race_index, class_index);
    return;
  }


  sprintf(info, "%s&1%-20s %-3s %s&n\r\n",
                      info, "Spell/Skill", "Lvl", "Requirements");

  for (spell_index = 1; spell_index < MAX_SKILLS; spell_index++) {
    if (sort_type == SORT_ALPHA)
      spellnum = spell_sort_info[SORT_ALPHA][0][spell_index];
    else 
      spellnum = spell_sort_info[sort_type][class_index][spell_index];

    if (spell_info[spellnum].min_level[class_index] == LVL_OWNER+1) 
      continue;

    // spellname - colour green if available, red otherwise
    if (!race || 
         race_has_stats_for_skill(race_index, class_index, spellnum, -1)) {
      sprintf(info, "%s&g", info);
    } else {
      sprintf(info, "%s&r", info);
    }

    sprintf(info, "%s%-20s&n", info, spell_info[spellnum].name);
    sprintf(info, "%s%-3d ", info, spell_info[spellnum].min_level[class_index]);
 
    /* Display the stat requirements */
    if (spell_info[spellnum].str[class_index] != 0) {
      sprintf(info, "%s&gStr: %s%2d%s ", info, 
          (!race || race_has_stats_for_skill(race_index, class_index, spellnum, STAT_STR)) ? 
            "&c" : "&r",
          spell_info[spellnum].str[class_index], CCNRM(ch,C_NRM));
    }
 
    if (spell_info[spellnum].intl[class_index] != 0) {
      sprintf(info, "%s&gInt: %s%2d%s ", info,
          (!race || race_has_stats_for_skill(race_index, class_index, spellnum, STAT_INT)) ? 
            "&c" : "&r",
          spell_info[spellnum].intl[class_index], CCNRM(ch,C_NRM));
    }
 
    if (spell_info[spellnum].wis[class_index] != 0) {
      sprintf(info, "%s&gWis: %s%2d%s ", info,
          (!race || race_has_stats_for_skill(race_index, class_index, spellnum, STAT_WIS)) ? 
            "&c" : "&r",
          spell_info[spellnum].wis[class_index], CCNRM(ch,C_NRM));
    }
 
    if (spell_info[spellnum].dex[class_index] != 0) {
      sprintf(info, "%s&gDex: %s%2d%s ", info, 
          (!race || race_has_stats_for_skill(race_index, class_index, spellnum, STAT_DEX)) ? 
            "&c" : "&r",
          spell_info[spellnum].dex[class_index], CCNRM(ch,C_NRM));
    }
 
    if (spell_info[spellnum].con[class_index] != 0) {
      sprintf(info, "%s&gCon: %s%2d%s ", info,
          (!race || race_has_stats_for_skill(race_index, class_index, spellnum, STAT_CON)) ? 
            "&c" : "&r",
          spell_info[spellnum].con[class_index], CCNRM(ch,C_NRM));
    }

    if (spell_info[spellnum].cha[class_index] != 0) {
      sprintf(info, "%s&gCha: %s%2d%s ", info,
          (!race || race_has_stats_for_skill(race_index, class_index, spellnum, STAT_CHA)) ? 
            "&c" : "&r",
          spell_info[spellnum].cha[class_index], CCNRM(ch,C_NRM));
    }

    sprintf(info, "%s\r\n", info);
  }
  page_string(ch->desc, info, TRUE);
}

void print_spell_info(struct char_data *ch, int spellnum, int race_index) {

  bool race = FALSE;
  int class_index;
  char info[MAX_STRING_LENGTH];
  extern struct spell_info_type spell_info[];

  if (spellnum <= 0 || spellnum > TOP_SPELL_DEFINE) {
    basic_mud_log("SYSERR: Invalid spellnum (%d) passed to print_spell_info", 
                    spellnum);
    return;
  }

  if (!str_cmp(spell_info[spellnum].name, unused_spellname)) {
    basic_mud_log("SYSERR: Unused spellnum (%d) passed to print_spell_info", 
                    spellnum);
    return;
  }

  if (race_index > MAX_RACES) {
    basic_mud_log("SYSERR: Invalid race number (%d) passed to print_spell_info", 
                    race_index);
    return;
  }

  if (race_index >= 0 && race_index < MAX_RACES)
    race = TRUE;

  sprintf(info, "Spell Name: &B%s&n", spell_info[spellnum].name);
  if (race) {
    sprintf(info, "%s for Race: &B%s&n (&rred&n is unmatched requirements)\r\n", 
                    info, pc_race_types[race_index]);  
  } else { 
    strcat(info, "\r\n");
  }

  for (class_index = 0; class_index < NUM_CLASSES; class_index++) {
    if (spell_info[spellnum].min_level[class_index] != LVL_OWNER+1) {

      if ((race_index < 0) || (race_index >= 0 && 
          race_has_stats_for_skill(race_index, class_index, spellnum, -1))) {
        sprintf(info, "%s&g", info);
      } else {
        sprintf(info, "%s&r", info);
      }

      sprintf(info, "%s%s:&n\r\nLevel: &M%d&n Mana_min: &G%d&n "
                    "Mana_max: &G%d&n Mana_change: &G%d&n\r\n",
              info, pc_class_types[class_index], 
              spell_info[spellnum].min_level[class_index],  
	      spell_info[spellnum].mana_min[class_index],  
	      spell_info[spellnum].mana_max[class_index],  
	      spell_info[spellnum].mana_change[class_index]);

      /* Display the stat requirements */
      if (spell_info[spellnum].str[class_index] != 0) {
        sprintf(info, "%s&gStr: %s%2d%s ", info, 
            (!race || race_has_stats_for_skill(race_index, class_index, spellnum, STAT_STR)) ? 
              "&c" : "&r",
            spell_info[spellnum].str[class_index], CCNRM(ch,C_NRM));
      }
 
      if (spell_info[spellnum].intl[class_index] != 0) {
        sprintf(info, "%s&gInt: %s%2d%s ", info,
            (!race || race_has_stats_for_skill(race_index, class_index, spellnum, STAT_INT)) ? 
              "&c" : "&r",
            spell_info[spellnum].intl[class_index], CCNRM(ch,C_NRM));
      }
 
      if (spell_info[spellnum].wis[class_index] != 0) {
        sprintf(info, "%s&gWis: %s%2d%s ", info,
            (!race || race_has_stats_for_skill(race_index, class_index, spellnum, STAT_WIS)) ? 
              "&c" : "&r",
            spell_info[spellnum].wis[class_index], CCNRM(ch,C_NRM));
      }
 
      if (spell_info[spellnum].dex[class_index] != 0) {
        sprintf(info, "%s&gDex: %s%2d%s ", info, 
            (!race || race_has_stats_for_skill(race_index, class_index, spellnum, STAT_DEX)) ? 
              "&c" : "&r",
            spell_info[spellnum].dex[class_index], CCNRM(ch,C_NRM));
      }
 
      if (spell_info[spellnum].con[class_index] != 0) {
        sprintf(info, "%s&gCon: %s%2d%s ", info,
            (!race || race_has_stats_for_skill(race_index, class_index, spellnum, STAT_CON)) ? 
              "&c" : "&r",
            spell_info[spellnum].con[class_index], CCNRM(ch,C_NRM));
      }

      if (spell_info[spellnum].cha[class_index] != 0) {
        sprintf(info, "%s&gCha: %s%2d%s ", info,
            (!race || race_has_stats_for_skill(race_index, class_index, spellnum, STAT_CHA)) ? 
              "&c" : "&r",
            spell_info[spellnum].cha[class_index], CCNRM(ch,C_NRM));
      }

      sprintf(info, "%s&n", info);

      sprintf(info, "%s\r\nClass Effeciency: &R%d&n%% "
                    "Class Mana Percentage: &R%d&n%%&n\r\n\r\n",
              info, 
	      spell_info[spellnum].spell_effec[class_index],
	      spell_info[spellnum].mana_perc[class_index]);
    }
  }
  page_string(ch->desc, info, TRUE); 
}

void print_sort_types(struct char_data *ch) {

  int i;
  char sorttypes[MAX_INPUT_LENGTH];

  sorttypes[0] = '\0';

  for (i = 0; i < NUM_SORT_TYPES; i++) {
    sprintf(sorttypes, "%s%s ", sorttypes, sort_names[i]);
  }
  send_to_char(sorttypes, ch);
}

// DM - TODO - fix for user levels
ACMD(do_spellinfo)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  char arg3[MAX_INPUT_LENGTH], rest[MAX_INPUT_LENGTH];
  char spellname[MAX_INPUT_LENGTH];
  int spellnum, i;
  int class_index, sort_type, race_index = -1;

  spellname[0] = '\0';
  arg1[0] = '\0';
  arg2[0] = '\0';
  arg3[0] = '\0';
  rest[0] = '\0';

  //s = strtok(argument, "'");
 
  //if (s == NULL) {
  if (!*argument)
  {
    if (LR_FAIL(ch, LVL_IMMORT))
      sprintf(buf,"&1Usage: &4%s &n<classname> [racename] [ <sort type> ]\r\n",
              CMD_NAME);
    else
      sprintf(buf,"&1Usage: &4%s &n { '<spellname>' | <classname> }\r\n"
                  "                 [racename] [ <sort type> ]\r\n", CMD_NAME);
    send_to_char(buf,ch);
    return;
  }

  skip_spaces(&argument);

  /* get: blank, spell name, target name */
  if (argument[0] == '\'')
  {
    *argument++;
    i = 0;
    do
    {
      spellname[i++] = *argument++;
    } while (!(*argument == '\0' || *argument == '\'')); 
    *argument++;
    spellname[i++] = '\0';
  }

  //s = strtok(NULL, "'");
  //if (s == NULL) {
  if (spellname[0] == '\0')
  {
    half_chop(argument, arg1, rest);
    class_index = search_block_case_insens(arg1, pc_class_types, FALSE);
    if (class_index >= 0)
    {
      half_chop(rest, arg2, rest);
      // spellinfo classname
      if (!*arg2)
        sort_type = SORT_ALPHA; 
      else if ((race_index = search_block_case_insens(arg2, pc_race_types, FALSE)) >= 0)
      { // spellinfo classname racename
        half_chop(rest, arg3, rest);
        if (!*arg3) // spellinfo classname racename sorttype
          sort_type = SORT_ALPHA;
        else if ((sort_type = search_block_case_insens(arg3, sort_names, FALSE)) < 0)
	{
          send_to_char("Invalid sort type. Valid types are: ", ch);
          print_sort_types(ch);
          return;
        }
      // spellinfo classname sorttype
      } else if ((sort_type = search_block_case_insens(arg2, sort_names, FALSE)) < 0)
      {
        send_to_char("Invalid race or sort type. Valid sort types are: ", ch);
        print_sort_types(ch);
        return;
      }
      print_spells(ch, class_index, race_index, sort_type);
      return;
    } else {
      send_to_char("Invalid Class Name.\r\n",ch);
      return;
    }
  } else {
    if (LR_FAIL(ch, LVL_IMMORT))
    {
      sprintf(buf,"&1Usage: &4%s &n<classname> [ <sort type> ]\r\n", CMD_NAME);
      send_to_char(buf,ch);
      return;
    }
    if ((spellnum = find_skill_num(spellname)) == -1)
    { 
      send_to_char("Spell/Skill name not found.\r\n",ch);
      return;
    }
    half_chop(argument, arg2, rest);
    if (*arg2)
    {
      race_index = search_block_case_insens(arg2, pc_race_types, FALSE);
      if (race_index < 0)
        send_to_char("Ignoring invalid race ...\r\n", ch);
    }
    print_spell_info(ch, spellnum, race_index);
  }
}



                
extern int num_rooms_burgled;
extern int vote_level;
/* extern functions */
void add_mud_event(struct event_data *ev);
int check_for_event(int event, zone_rnum zone);

/* local functions */
ACMD(do_event);

void destroy_event_election(struct char_data *ch, struct event_data *ev)
{
  if (ev->type != EVENT_ELECTION)
  {
    mudlog("SYSERR: Non election event passed to destroy_event_election().",
	   NRM, LVL_IMPL, TRUE);
    return;
  }
  send_to_all("&gThe election has ended. Polling results.&n\r\n");
  sprintf(buf, "Election ended by %s (Results: #1: %d, #2: %d, #3: %d)",
	  ((ch) ? GET_NAME(ch) : "timeout"), ev->info1, ev->info2, ev->info3);
  mudlog(buf, NRM, LVL_GOD, TRUE);
  sprintf(buf, "Official results of election - #1: %d, #2: %d, #3: %d.\r\n",
	  ev->info1, ev->info2, ev->info3);
  send_to_all(buf);
  ev->type=EVENT_OVER;
  remove_mud_event(ev);
  return;
}

void destroy_event_curfew(struct char_data *ch, struct event_data *ev)
{
  if (ev->type != EVENT_CURFEW)
  {
    mudlog("SYSERR: Non curfew event passed to destroy_event_curfew().", 
	   BRF, LVL_IMPL, TRUE);
    return;
  }
  sprintf(buf, "Curfew in %s lifted by %s.",
	  zone_table[ev->room->zone].name, ((ch) ? GET_NAME(ch) : "timeout"));
  send_to_zone("\r\n&b[ Curfew has been lifted! ]&n\r\n", ev->room->zone);
  mudlog(buf, BRF, LVL_GOD, TRUE);
  ev->type = EVENT_OVER;
  remove_mud_event(ev);
  return;
}

// Destroy and Clean Up after a goldrush.
void destroy_event_goldrush(struct char_data *ch, struct event_data *ev)
{
  struct obj_data *gold, *next_gold;
  if (ev->type != EVENT_GOLD_RUSH)
  {
    mudlog("SYSERR: Non goldrush event passed to destroy_event_goldrush().", 
	   BRF, LVL_IMPL, TRUE);
    return;
  }
  for (gold=object_list; gold; gold=next_gold)
  {
    next_gold = gold->next;
    if ((GET_OBJ_VNUM(gold) == GOLD_OBJ_VNUM) &&
	(gold->in_room >= 0) &&
	world[gold->in_room].zone == ev->room->zone)
      extract_obj(gold);
  }
  send_to_zone("\r\n&y[ The gold rush has ended. ]&n\r\n", ev->room->zone);
  sprintf(buf, "&WYou stop hearing of gold findings at %s.&n\r\n",
	  zone_table[ev->room->zone].name);
  send_to_not_zone_world(buf, ev->room->zone);
  sprintf(buf, "Goldrush in %s ended by %s.",
	  zone_table[ev->room->zone].name, ((ch) ? GET_NAME(ch) : "timeout"));
  mudlog(buf, NRM, LVL_GOD, TRUE);
  ev->type = EVENT_OVER;
  remove_mud_event(ev);
  return;
}

void destroy_event_happy(struct char_data *ch, struct event_data *ev)
{
  if (ev->type != EVENT_HAPPY_HR)
  {
    mudlog("SYSERR: Non happy hour event passed to destroy_event_happy().", 
	   NRM, LVL_IMPL, TRUE);
    return;
  }
  send_to_all("&WHappy hour is over now, kiddies.&n\r\n");
  sprintf(buf, "Happy hour ended by %s.", 
	  ((ch) ? GET_NAME(ch) : "grumpiness."));
  mudlog(buf, NRM, LVL_GOD, TRUE);
  ev->type = EVENT_OVER;
  remove_mud_event(ev);
}

void destroy_event_fire(struct char_data *ch, struct event_data *ev)
{
  if (ev->type != EVENT_FIRE)
  {
    mudlog("SYSERR: Non fire event passed to destroy_event_fire().",
	   BRF, LVL_IMPL, TRUE);
    return;
  }
  send_to_zone("&yThe fire is finally under control.&n\r\n", ev->room->zone);
  sprintf(buf, "&WYou hear rumours that the fire at %s has been"
	       "extinguished.&n\r\n", zone_table[ev->room->zone].name);
  send_to_not_zone_world(buf, ev->room->zone);
  sprintf(buf, "Fire in %s ended by %s.", zone_table[ev->room->zone].name, 
	  ((ch) ? GET_NAME(ch) : "lack of fuel."));
  mudlog(buf, NRM, LVL_GOD, TRUE);
  for (room_rnum room = 0; room <= top_of_world; room++)
    if (world[room].zone == ev->room->zone)
      REMOVE_BIT(RMSM_FLAGS(room), RMSM_BURNED);
  ev->type = EVENT_OVER;
  remove_mud_event(ev);
}

void perform_event_destroy(struct char_data *ch, char *arg)
{
  int evcount = 0, evno = 0;
  struct event_data *ev;
  
  if ((!*arg) || !is_number(arg))
  {
    send_to_char("Syntax: event destroy <event #> (Use &4event list&n for a list.\r\n", ch);
    return;
  }
  evno = atoi(arg);
  for (ev = events.list; ev; ev=ev->next)
  {
    evcount++;
    if (evcount == evno)
      switch (ev->type)
      {
	case EVENT_QUEST:
	  send_to_char("Use quest end, rather than destroy event.\r\n", ch);
	  return;
	case EVENT_CURFEW:    destroy_event_curfew(ch, ev);   return;
	case EVENT_GOLD_RUSH: destroy_event_goldrush(ch, ev); return;
	case EVENT_FIRE:      destroy_event_fire(ch, ev);     return;
	case EVENT_ELECTION:  destroy_event_election(ch, ev); return;
	case EVENT_HAPPY_HR:  destroy_event_happy(ch, ev);    return;
	case EVENT_BURGLARY:
	case EVENT_BOUNTY_HUNT:
	case EVENT_OVER:
	  send_to_char("That type of event cannot be destroyed.\r\n", ch);
	  return;
	default:
	  mudlog("SYSERR: Default case reached in perform_event_destroy().",
	         BRF, LVL_IMPL, FALSE);
	  return;
      }
  }
  send_to_char("Destroy which event? (&4event list&n for a list.)\r\n", ch);
}
void create_event_election(struct char_data *ch, char *arg)
{

  struct event_data *ev = NULL;
  struct descriptor_data *d;
  
  if (check_for_event(EVENT_ELECTION, -1))
  {
    send_to_char("There's already an election going on. Wait for the poll.\r\n",ch);
    return;
  }

  // Every player currently online, may vote
  for (d = descriptor_list; d; d = d->next)
  {
    if( STATE(d) != CON_PLAYING)
      continue;

    GET_VOTED(d->character) = FALSE;
  }

  CREATE(ev, struct event_data, 1);
  ev->chID = GET_IDNUM(ch);
  ev->room = NULL;
  ev->type = EVENT_ELECTION;
  ev->info1 = 0;
  ev->info2 = 0;
  ev->info3 = 0;

  add_mud_event(ev);

  if (*arg)
  {
    sprintf(buf1, "&G-ELECTION NOTICE-&g\r\n%s\r\n", arg); 
    send_to_all(buf1);
  }	
  sprintf(buf, "&gThe election has begun.\r\n&nType 'vote <number>' to register your vote.\r\n");
  send_to_all(buf);
  sprintf(buf, "Election initiated by %s", GET_NAME(ch));
  mudlog(buf, BRF, LVL_GOD, TRUE);
}

void create_event_curfew(struct char_data *ch, char *arg)
{

  struct event_data *ev = NULL;
  zone_rnum zone = world[ch->in_room].zone;

  if (check_for_event(EVENT_CURFEW, zone))
  {
    send_to_char("Curfew has already been imposed on this part of the land.\r\n",ch);
    return;
  }

  CREATE(ev, struct event_data, 1);
  ev->chID = GET_IDNUM(ch);
  ev->type = EVENT_CURFEW;
  ev->room = &world[ch->in_room];
  ev->info3 = get_id_by_name(GET_NAME(ch));

  add_mud_event(ev);

  // Let those in the zone know
  if (*arg)
  {
    sprintf(buf1, "&G-CURFEW NOTICE-&g\r\n%s\r\n", arg);
    send_to_zone(buf1, zone);
  }
  send_to_zone("&R\r\n[ Curfew has been imposed in this area. Seek shelter at night. ]&n\r\n", zone);
  // Log the event
  sprintf(buf, "Curfew imposed by %s within %s.", GET_NAME(ch), zone_table[zone].name);
  mudlog(buf, BRF, LVL_GOD, TRUE); 
}

void create_event_happy(struct char_data *ch)
{
  struct event_data *ev;

  if (check_for_event(EVENT_HAPPY_HR, -1))
  {
    if (ch && ch->desc)
      send_to_char("Happy hour is already happening!\r\n", ch);
    return;
  }
  CREATE(ev, struct event_data, 1);
  ev->type = EVENT_HAPPY_HR;
  ev->info1 = 3600;
  if (ch)
  {
    ev->chID = GET_IDNUM(ch);
    ev->room = &world[IN_ROOM(ch)];
    sprintf(buf, "(GC) Happy hour initiated by %s.", GET_NAME(ch));
  } else {
    ev->chID = NOBODY;
    ev->room = NULL;
    sprintf(buf, "Happy hour initiated by Haven's residents.");
  }
  mudlog(buf, NRM, LVL_GOD, TRUE); 
  add_mud_event(ev);
  send_to_all("&WHappy hour has been declared! DOUBLE EXP!!!&n\r\n");
}


void create_event_fire(struct char_data *ch, char *arg)
{
  struct event_data *ev;
  zone_rnum zone = world[IN_ROOM(ch)].zone;

  if (check_for_event(EVENT_FIRE, zone))
  {
    send_to_char("There's already a fire in this part of the land!\r\n", ch);
    return;
  }
  if (SECT(IN_ROOM(ch)) > SECT_MOUNTAIN)
  {
    send_to_char("There's no way you're going to burn anything here!\r\n", ch);
    return;
  }
  if (world[IN_ROOM(ch)].number == 1200)
  {
    send_to_char("This room seems to be impervious to fire!\r\n", ch);
    return;
  }
  CREATE(ev, struct event_data, 1);
  ev->chID = GET_IDNUM(ch);
  ev->type = EVENT_FIRE;
  ev->room = &world[IN_ROOM(ch)];
  add_mud_event(ev);

  sprintf(buf, "&Y[ Look out!! %s is on FIRE! ]&n\r\n", zone_table[zone].name);
  send_to_zone(buf, zone);
  sprintf(buf, "&WYou hear of a fire in %s!&n\r\n", zone_table[zone].name);
  send_to_not_zone_world(buf, zone);
  sprintf(buf, "Fire initiated by %s at %s.", GET_NAME(ch), zone_table[zone].name);
  mudlog(buf, BRF, LVL_GOD, TRUE);
}

void create_event_goldrush(struct char_data *ch, char *arg) 
{
  struct event_data *ev;

  zone_rnum zone = world[ch->in_room].zone;

  if(check_for_event(EVENT_GOLD_RUSH, zone))
  {
    send_to_char("There's already a gold rush in this part of the land.\r\n",ch);
    return;
  }

  CREATE(ev, struct event_data, 1);
  ev->chID = GET_IDNUM(ch);
  ev->type = EVENT_GOLD_RUSH;
  ev->room = &world[ch->in_room];

  add_mud_event(ev);
	
  // Register the event
  sprintf(buf, "&Y[ A GOLD RUSH has just started in %s! ]&n\r\n", zone_table[zone].name);
  send_to_zone(buf, zone);
  sprintf(buf, "&WYou hear rumours of a gold rush at %s!&n\r\n", zone_table[zone].name);
  send_to_not_zone_world(buf, zone);
  sprintf(buf, "Gold rush initiated by %s at %s.", GET_NAME(ch), zone_table[zone].name);
  mudlog(buf, BRF, LVL_GOD, TRUE);
}

void list_events_to_char(struct char_data *ch, int specific) 
{
  struct event_data *ev;
  char *target, *type, *info1, *info2, *info3, *roomdesc, *room;
  int evcounter = 0, found = FALSE;

  for (ev = events.list; ev; ev = ev->next)
  {
    evcounter++;
    if (specific != evcounter && specific != -1)
      continue;
    if (specific != -1)
      found = TRUE;
    if( ev->type == EVENT_OVER )
      continue;

    switch(ev->type)
    {
      case EVENT_BURGLARY:
	target = "Burglar: ";
	type = "&rBurglary&n";
	roomdesc = "First room: ";
	room = ev->room->name;
	info1 = "Codes: ";
	info2 = "Direction: ";
	info3 = "Loot so far: ";
	break;
      case EVENT_BOUNTY_HUNT:
	target = "Victim: ";
	type = "&bBounty Hunt&n";
	roomdesc = "Return to: ";
	room = ev->room->name;
	info1 = "Reward: ";
	info2 = "Bounty ID: ";
	info3 = "Initiator ID: ";
	break;
      case EVENT_GOLD_RUSH:
	target = "Initiator: ";
	type = "&yGold rush&n";
	roomdesc = "Sampled room: ";
	room = ev->room->name;
	info1 = "Secs Running: ";
	info2 = "Chunks Made: ";
	info3 = "Unused: ";
	break;
      case EVENT_FIRE:
	target = "Firebug: ";
	type = "&rFIRE!&n";
	roomdesc = "Sampled room: ";
	room = ev->room->name;
	info3 = info2 = info1 = "Unused: ";
	break;
      case EVENT_CURFEW:
	target = "Initiated by: ";
	type = "&RCurfew&n";
	roomdesc = "Sampled room: ";
	room = ev->room->name;
	info1 = info2 = "Unused: ";
	info3 = "Initiator ID: ";
	break;
      case EVENT_ELECTION:
	target = "Initiated by: ";
	type = "&BElection &n";
	roomdesc = "Room: ";
	room = "N/A";
	info1 = "Votes for #1: ";
	info2 = "Votes for #2: ";
	info3 = "Votes for #3: ";
	break;
      case EVENT_QUEST:
	target = "Created by: ";
	type = "&GQuest&n";
	roomdesc = "Sampled room: ";
	room = ev->room->name;
	info1 = "Quest Type: ";
	info2 = "Sample: ";
	info3 = "Reward: ";
	break;
      case EVENT_HAPPY_HR:
	target = "Created By: ";
	type = "&GHappy Hour&n";
	roomdesc = "Room: ";
	room = "N/A";
	info1 = "Seconds Remaining: ";
	info3 = info2 = "Unused: ";
	break;
      default:
	target = "Character: ";
	type = "Other";
	roomdesc = "Roomname: ";
	if (ev->room != NULL)
	  room = ev->room->name;
	else
	  room = "N/A";
	info1 = "Info1: ";
	info2 = "Info2: ";
	info3 = "Info3: "; 
	break;				
    }

    sprintf(buf, "&g(%2d)&n %s\r\n"
		 "     %s%s\r\n"
		 "     %s%d - %s\r\n"
		 "     %s%d, %s%d, %s%d\r\n",
	    evcounter, type, 
	    target, (ev->chID != -1 ? get_name_by_id(ev->chID) : "Noone"),
	    roomdesc, ev->room != NULL ? ev->room->number : -1, room,
	    info1, ev->info1, info2, ev->info2, info3, ev->info3); 			    
    send_to_char(buf, ch);
  }

  // Sort out an appropriate message 
  if (specific != -1)
  {
    if (!found)
      sprintf(buf, "That event does not exist!\r\n");
    else
      sprintf(buf, "&gEvent found.&n\r\n");
  } else if( evcounter != 0 ) {
    sprintf(buf, "&g%d event%s listed.&n\r\n", evcounter, evcounter == 1 ? "" : "s");
  } else {
    sprintf(buf, "No events exist.\r\n");
  }
  send_to_char(buf, ch);		
	
  if (burglaries != NULL)
    send_to_char("&RBurglaries-&n\r\n", ch);
  // List burglaries 
  Burglary *tmpBurglary = burglaries;
  while (tmpBurglary != NULL)
  {
    tmpBurglary->DescribeSelf(ch);
    tmpBurglary = tmpBurglary->next;
  }
}

/* Command to control events as well as list them */
ACMD(do_event)
{
  if (IS_NPC(ch)) 
    return;

  half_chop(argument, arg, buf1);
  //two_arguments(argument, arg, buf1);
	
  if (!*arg)
  {
    send_to_char("Usage: event <list [event #] | create | destroy>\r\n", ch);
    return;
  }

  arg[0] = LOWER(arg[0]);

  if (is_abbrev(arg, "list")) 
  {
    if (!*buf1) 
    {
      list_events_to_char(ch, -1);
      return;
    } else if(!isdigit(buf1[0])) {
      send_to_char("You may either list a single event, or all.\r\n"
		   "Usage: event <list | list #>\r\n", ch);
      return;
    }
    if (atoi(buf1) < 1)
    {
      send_to_char("You must specify a positive event number!\r\n", ch);
      return;
    }
    list_events_to_char(ch, atoi(buf1));
    return;
  }

  if (is_abbrev(arg, "create")) 
  {
    half_chop(buf1, arg, buf2);
    if (!*arg) 
    {
      send_to_char("Usage: event create <curfew | goldrush"
		   " | election | fire | happyhr>\r\n",ch);
      return;
    }
    if (is_abbrev(arg, "curfew"))
    {
      create_event_curfew(ch, buf2);			
      return;
    }
    if (is_abbrev(arg, "goldrush"))
    {
      create_event_goldrush(ch, buf2);
      return;
    }
    if(is_abbrev(arg, "election"))
    {
      create_event_election(ch, buf2);
      return;
    }
    if (is_abbrev(arg, "fire")) 
    {
      create_event_fire(ch, buf2);
      return;
    }
    if (is_abbrev(arg, "happyhr"))
    {
      create_event_happy(ch);
      return;
    }
    send_to_char("Usage: event create <curfew | goldrush |"
		 " election | fire> <statement(optional)>\r\n",ch);
    return;
  }

  if (is_abbrev(arg, "destroy")) 
  {
    half_chop(buf1, arg, buf2);
    perform_event_destroy(ch, arg);
    return;
  }
  
  send_to_char("That is NOT a valid option!\r\n", ch);
  return;
/*
    half_chop(buf1, arg, buf2);
    if (!*arg)
    {
      send_to_char("Usage: event destroy <curfew | goldrush |" 
		   " quest | election | fire>\r\n",ch);
      return;
    }
    if (is_abbrev(arg, "curfew")) 
    {
      destroy_event_curfew(ch);
      return;
    }
    if (is_abbrev(arg, "goldrush"))
    {
      destroy_event_goldrush(ch);
      return;
    }
    if (is_abbrev(arg, "happyhr"))
    {
      destroy_event_happy(ch);
      return;
    }
    if (is_abbrev(arg, "quest"))
    {
      destroy_event_quest(ch, buf2);
      return;
    }
    if (is_abbrev(arg, "election"))
    {
      destroy_event_election(ch);
      return;
    }
    if (is_abbrev(arg, "fire"))
    {
      destroy_event_fire(ch, world[IN_ROOM(ch)].zone);
      return;
    }
    send_to_char("Usage: event destroy <curfew | goldrush |"
		 " quest | election | fire>\r\n",ch);
    return;
  }
  send_to_char("That is NOT a valid option!\r\n", ch);
*/
}
@


1.110
log
@Artus> Modifier calculations are now handled by calc_modifier().
@
text
@d164 1
a164 1
  bool light = false;
d194 3
d232 2
@


1.109
log
@Artus> Fixed set special routine to calculate unholiness modifier also.
@
text
@d4326 1
a4326 2
    GET_MODIFIER(vict) = race_modifiers[GET_RACE(vict)] + class_modifiers[i] +
	special_modifier(vict) + elitist_modifier(vict); 
d4698 1
@


1.108
log
@Artus> artus_out().
@
text
@d4618 3
a4620 1
			 elitist_modifier(vict);
@


1.107
log
@Artus> Added Toll amount to gateway stat.
@
text
@d149 1
a920 1
//  if(world[location].number >= 103 && world[location].number <= 150 && GET_LEVEL(ch) < LVL_GOD)
d926 1
a926 1
  }  
d934 1
d936 10
a945 2
  else
    strcpy(buf, "&7$n&n disappears in a puff of smoke.");
a946 1
  act(buf, TRUE, ch, 0, 0, TO_ROOM);
d954 1
a954 7
  if (!strcmp(ch->player.name, "John"))
    john_in(ch);
  else if (!strcmp(ch->player.name, "Cassandra"))
    cassandra_in(ch);
  else if (!strcmp(ch->player.name, "Artus"))
    artus_in(ch);
  else
d956 11
a966 3
    if (POOFIN(ch))
      sprintf(buf, "&7$n&n %s", POOFIN(ch));
    else
d969 1
d5207 11
@


1.106
log
@Artus> Removed event debug info.
       Added whostring command (do_whostr)
       Modified goto, so that LVL_CHAMP thru LVL_IMMORT-1 can goto players,
       anyone >= LVL_IMMORT has full goto.
@
text
@d1369 3
a1371 2
    sprintf(buf, "Teleports to: &c%d&n, Min Level: &c%d&n, Max Level: &c%d&n",
      GET_OBJ_VAL(j,0), GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2));
@


1.105
log
@Artus> Removed some debug stuff.
@
text
@d157 1
d845 1
a845 1
  if (GET_LEVEL(ch) >= LVL_ETRNL1 && GET_LEVEL(ch) <= LVL_IMMORT)
d847 5
d854 4
a857 2
    if (is_number(name_mob)) { /* Artus - Allow champs to goto their OLC zone */
      if (GET_OLC_ZONE(ch) < 1) {
d861 2
a862 1
      if ((location = real_room(atoi(name_mob))) == NOWHERE) {
d866 2
a867 1
      if (zone_table[world[location].zone].number != GET_OLC_ZONE(ch)) {
a897 1

a962 2


d1587 2
a1588 1
	  (!IS_NPC(k) ? "PC" : (!IS_MOB(k) ? "NPC" : "MOB")),
d1591 11
a1601 7
  if (!IS_NPC(k)) {
    if( GET_INVIS_TYPE(k) == INVIS_SPECIFIC )
      sprintf(buf3,", Invis to [%s%s%s]",CCYEL(ch, C_NRM),get_name_by_id(GET_INVIS_LEV(k)),CCNRM(ch,C_NRM));
    else if( GET_INVIS_TYPE(k) == INVIS_SINGLE )
      sprintf(buf3,", Invis to Lvl [%s%ds%s]",CCYEL(ch,C_NRM),GET_INVIS_LEV(k),CCNRM(ch,C_NRM));
    else if( GET_INVIS_TYPE(k) == INVIS_NORMAL )
      sprintf(buf3,", Invis Lvl [%s%d%s]",CCYEL(ch,C_NRM),GET_INVIS_LEV(k),CCNRM(ch,C_NRM));
d1603 2
a1604 3
      sprintf(buf3,", Invis to Lvls [%s%d-%d%s]",CCYEL(ch,
            C_NRM),GET_INVIS_LEV(k),GET_INVIS_TYPE(ch), CCNRM(ch,C_NRM));
 
d1610 2
a1611 2

  if (IS_MOB(k)) {
a1615 1

d1618 2
a1619 2

  sprintf(buf, "L-Des: %s", (k->player.long_descr ? k->player.long_descr : "<None>\r\n"));
d1622 3
a1624 2
  if (IS_NPC(k)) {	/* Use GET_CLASS() macro? */
    sprinttype(/*k->player.class*/GET_CLASS(k), npc_class_types, buf2);
d1631 2
a1632 3


  if (IS_NPC(k)) {
d1634 3
a1636 3
          CCYEL(ch, C_NRM), GET_LEVEL(k), CCNRM(ch, C_NRM),
          CCYEL(ch, C_NRM), GET_EXP(k), CCNRM(ch, C_NRM),
          GET_ALIGNMENT(k));
d1638 2
a1639 1
    if (GET_LEVEL(k) < LVL_IMMORT) {
d1641 4
a1644 4
          CCYEL(ch, C_NRM), GET_LEVEL(k), CCNRM(ch, C_NRM),
          CCYEL(ch, C_NRM), GET_EXP(k), CCNRM(ch, C_NRM),
          CCYEL(ch, C_NRM), level_exp(ch,GET_LEVEL(k))-GET_EXP(k), CCNRM(ch, C_NRM),
          GET_ALIGNMENT(k));
a1651 1

d1654 2
a1655 2

  if (!IS_NPC(k)) {
a1677 1

d1682 1
a1682 3

    sprintf(buf, "Hometown: [%d], Speaks: [%d/%d/%d], (STL[%d]/per[%d]/NSTL[%d])",
         k->player.hometown, GET_TALK(k, 0), GET_TALK(k, 1), GET_TALK(k, 2),
d1687 1
a1687 1
    if (GET_LEVEL(k) >= LVL_IMMORT)
d1698 1
a1698 2
  sprintf(buf, "Str: &C%d/%d&n(&c%d/%d&n) Int: &C%d&n(&c%d&n) Wis: &C%d&n(&c%d&n) "
	  "Dex: &C%d&n(&c%d&n) Con: &C%d&n(&c%d&n) Cha: &C%d&n(&c%d&n)\r\n",
d1700 2
a1701 4
	  GET_AFF_INT(k), GET_REAL_INT(k), 
	  GET_AFF_WIS(k), GET_REAL_WIS(k), 
	  GET_AFF_DEX(k), GET_REAL_DEX(k), 
	  GET_AFF_CON(k), GET_REAL_CON(k), 
d1705 2
a1706 1
  if (!ETERNAL) {
d1708 4
a1711 3
	  CCGRN(ch, C_NRM), GET_HIT(k), GET_MAX_HIT(k), hit_gain(k), CCNRM(ch, C_NRM),
	  CCGRN(ch, C_NRM), GET_MANA(k), GET_MAX_MANA(k), mana_gain(k), CCNRM(ch, C_NRM),
	  CCGRN(ch, C_NRM), GET_MOVE(k), GET_MAX_MOVE(k), move_gain(k), CCNRM(ch, C_NRM));
d1715 1
a1715 1
	  GET_GOLD(k), GET_BANK_GOLD(k), GET_GOLD(k) + GET_BANK_GOLD(k));
d1719 4
a1722 3
	  compute_armor_class(k, 0), thaco(k, NULL),
	  k->points.hitroll, k->points.damroll, saving_throws(k, 0), saving_throws(k, 1), 
	  saving_throws(k, 2), saving_throws(k, 3), saving_throws(k, 4));
d1728 2
a1729 2
    sprintf(buf, "Social Points: %ld, Social Rank: %s\r\n", GET_SOCIAL_POINTS(k),
	social_ranks[GET_SOCIAL_STATUS(k)]);
a1731 1

d1735 5
a1739 4

  if (MOUNTING(k)) {
	sprintf(buf2, ", Mounted on: %s", (IS_NPC(k) ? "Yes" : GET_NAME(MOUNTING(k))) );
	strcat(buf, buf2);
d1741 4
a1744 3
  if (MOUNTING_OBJ(k)) {
	sprintf(buf2, ", Mounted on: %s", MOUNTING_OBJ(k)->short_description);
	strcat(buf, buf2);
d1746 2
a1747 1
  if (IS_NPC(k)) {
d1751 2
a1752 1
  if (k->desc) {
d1766 2
a1767 2

  if (IS_NPC(k)) {
d1769 2
a1770 1
    sprintf(buf, "NPC flags: %s%s%s\r\n", CCCYN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
d1790 2
a1791 1
      if (PUN_FLAGGED(k, i)) {
d1805 2
a1806 1
      if (HAS_OFFENDED(k,i) > 0) {
d1816 5
a1820 1
    sprintf(buf, "Clan:&g %d&n (&g%s&n) Rank: &g%d&n of&g %d&n\r\n", GET_CLAN(k), ((GET_CLAN(k) > 0) ? clan[find_clan_by_id(GET_CLAN(k))].name : "none"), GET_CLAN_RANK(k), ((GET_CLAN(k) > 0) ? clan[find_clan_by_id(GET_CLAN(k))].ranks : 0));
d1824 2
a1825 1
    sprintf(buf, "Remort Levels:  One[&g%3d&n] Two[&g%3d&n] Max[&g%3d&n] Total[&g%3d&n]\r\n", GET_REM_ONE(k), GET_REM_TWO(k), GET_MAX_LVL(k), (GET_REM_ONE(k) + GET_REM_TWO(k) + GET_LEVEL(k)));
d1829 3
a1831 4
    sprintf(buf, "Kills: Imm[&g%ld&n] By Imm[&g%ld&n] Mob[&g%ld&n] By Mob[&g%ld&n] PC[&g%ld&n] By PC[&g%ld&n]; Unholiness: %d\r\n", 
	GET_IMMKILLS(k), GET_KILLSBYIMM(k), GET_MOBKILLS(k), 
	GET_KILLSBYMOB(k), GET_PCKILLS(k), GET_KILLSBYPC(k),
	GET_UNHOLINESS(k));
d1845 5
a1849 4
  if (!IS_NPC(k) && IS_SET(GET_SPECIALS(k), SPECIAL_DISGUISE)) {
	sprintf(buf, "Mob vnum memorised: %ld, Disguised: %s.\r\n", CHAR_MEMORISED(k), 
		CHAR_DISGUISED(k) == 0 ? "No" : "Yes");
	send_to_char(buf, ch);
d1851 2
a1852 1
  if (IS_MOB(k)) {
d1861 1
a1861 1
  for (i = 0, j = k->carrying; j; j = j->next_content, i++);
d1871 2
a1872 1
  if (!IS_NPC(k)) {
d1874 1
a1874 1
	  GET_COND(k, FULL), GET_COND(k, THIRST), GET_COND(k, DRUNK));
d1880 2
a1881 2

  for (fol = k->followers; fol; fol = fol->next) {
d1884 2
a1885 1
    if (strlen(buf) >= 62) {
d1900 2
a1901 2
 
  for (assisters=k->autoassisters; assisters; assisters=assisters->next) {
d1904 2
a1905 1
    if (strlen(buf) >= 62) {
a1916 15
  /* DM - clan info  -- Removed, ARTUS 
  if (!IS_NPC(k)) {
    int c;
    i = GET_CLAN(k);
    c = find_clan_by_id(i);
    if (GET_LEVEL(ch) >= LVL_ANGEL)
      if (c >= 0) {
        sprintf(buf, "Clan: &B%s&n, Rank: &B%s&n\r\n",
            clan[c].name, clan[c].rank_name[GET_CLAN_RANK(k)]);
        send_to_char(buf,ch);
      }
  }
  */

  
d1975 4
a1978 3

        if (aff->modifier) {
          sprintf(buf2, "%+d to %s", aff->modifier, apply_types[(int) aff->location]);
d1982 2
a1983 1
      if (aff->bitvector) {
d1996 4
a1999 7
  if (k->timers) {
    for (timer = k->timers; timer; timer = timer->next) {

      sprintf(buf,"TIM: (%3dhr) %s%-22s%s", timer->duration, CCCYN(ch, C_NRM), timer_types[timer->type], CCNRM(ch, C_NRM));
      sprintf(buf2,"Uses: (%2d) of max: (%2d)\r\n",timer->uses, timer->max_uses);

      strcat(buf, buf2);
d2001 4
d2010 2
a2011 1
  if (IS_NPC(k)) {
d2013 2
a2014 1
    if (SCRIPT_MEM(k)) {
d2017 2
a2018 1
      while (mem) {
d2020 2
a2021 1
        if (!mc) send_to_char("  ** Corrupted!\r\n", ch);
d2023 4
a2026 2
          if (mem->cmd) sprintf(buf,"  %-20.20s%s\r\n",GET_NAME(mc),mem->cmd);
          else sprintf(buf,"  %-20.20s <default>\r\n",GET_NAME(mc));
d2034 2
a2035 1
    if (k->script && k->script->global_vars) {
d2044 4
a2047 2
      for (tv = k->script->global_vars; tv; tv = tv->next) {
        if (*(tv->value) == UID_CHAR) {
d4282 1
a4282 1
    if ((GET_CLASS(vict) == CLASS_MASTER) && (GET_LEVEL(vict) >= LVL_IMMORT) &&
d4625 1
a4625 1
    if (strlen(val_arg) > 20)
d4627 1
a4627 1
      send_to_char("WhoString must not be longer than 20 chars.\r\n", ch);
d4857 2
a4858 2
     send_to_char("I cannot seem to find that person!!!\r\n", ch);
     return;
d4862 2
a4863 2
        send_to_char("DEMOTE A MONSTER!!!!.... Go find something more productive to do!\r\n", ch);
        return;
d4865 1
a4865 1
  if (GET_LEVEL(vict)!=LVL_ANGEL)
d4867 2
a4868 2
        send_to_char("You can only demote ANGELS!!\r\n", ch);
        return;
d4870 1
a4870 2
 
  GET_LEVEL(vict)=LVL_IMMORT;
d4895 1
a4895 1
  if (GET_LEVEL(vict)<LVL_IMMORT)
d4900 1
a4900 1
  if (GET_LEVEL(vict)==LVL_ANGEL)
d4905 1
a4905 1
  if (GET_LEVEL(vict)>LVL_ANGEL)
d4925 2
a4926 1
  if (!*arg) {
d4942 36
d5558 2
a5559 1
  if (!*argument) {
d5573 2
a5574 1
  if (argument[0] == '\'') {
d5577 2
a5578 1
    do {
d5587 2
a5588 2
  if (spellname[0] == '\0') {

d5591 2
a5592 2

    if (class_index >= 0) {
a5593 1

d5595 1
a5595 1
      if (!*arg2) {
d5597 2
a5598 5

      // spellinfo classname racename
      } else 
        if ((race_index = search_block_case_insens(arg2, pc_race_types, FALSE)) 
                        >= 0) {
d5600 1
a5600 3

        // spellinfo classname racename sorttype
        if (!*arg3) {
d5602 2
a5603 3
        } else 
            if ((sort_type = search_block_case_insens(arg3, sort_names, FALSE))
                        < 0) {
d5609 2
a5610 2
      } else if ((sort_type = search_block_case_insens(arg2, sort_names, FALSE))
                      < 0) {
a5614 1

a5620 3

    //send_to_char("Spell names must be enclosed in the Holy Magic Symbols: '\r\n", ch);
    //return;
a5621 2
  //t = strtok(NULL, "\0");

a5627 1

a5632 1

d5634 2
a5635 2

    if (*arg2) {
d5637 1
a5637 1
      if (race_index < 0) {
a5638 1
      }
a5639 1

a5657 3
  sprintf(buf, "DBG: Count: %d Ev={chID=%ld, time_taken={hours=%d,day=%d,month=%d,year=%d}, room=%d, type=%d, info1=%d, info2=%d, info3=%d, desc=%s, next=%s}",
	  events.num_events, ev->chID, ev->time_taken.hours, ev->time_taken.day, ev->time_taken.month, ev->time_taken.year, (ev->room) ? ev->room->number : NOWHERE, ev->type, ev->info1, ev->info2, ev->info3, ev->desc, ((ev->next) ? "present" : "absent"));
  mudlog(buf, DBG, LVL_IMPL, TRUE);
a5677 3
  sprintf(buf, "DBG: Count: %d Ev={chID=%ld, time_taken={hours=%d,day=%d,month=%d,year=%d}, room=%d, type=%d, info1=%d, info2=%d, info3=%d, desc=%s, next=%s}",
	  events.num_events, ev->chID, ev->time_taken.hours, ev->time_taken.day, ev->time_taken.month, ev->time_taken.year, (ev->room) ? ev->room->number : NOWHERE, ev->type, ev->info1, ev->info2, ev->info3, ev->desc, ((ev->next) ? "present" : "absent"));
  mudlog(buf, DBG, LVL_IMPL, TRUE);
a5696 4
  sprintf(buf, "DBG: Count: %d Ev={chID=%ld, time_taken={hours=%d,day=%d,month=%d,year=%d}, room=%d, type=%d, info1=%d, info2=%d, info3=%d, desc=%s, next=%s}",
	  events.num_events, ev->chID, ev->time_taken.hours, ev->time_taken.day, ev->time_taken.month, ev->time_taken.year, ev->room->number, ev->type, ev->info1, ev->info2, ev->info3, ev->desc, ((ev->next) ? "present" : "absent"));
  mudlog(buf, DBG, LVL_IMPL, TRUE);

a5724 3
  sprintf(buf, "DBG: Count: %d Ev={chID=%ld, time_taken={hours=%d,day=%d,month=%d,year=%d}, room=%d, type=%d, info1=%d, info2=%d, info3=%d, desc=%s, next=%s}",
	  events.num_events, ev->chID, ev->time_taken.hours, ev->time_taken.day, ev->time_taken.month, ev->time_taken.year, (ev->room) ? ev->room->number : NOWHERE, ev->type, ev->info1, ev->info2, ev->info3, ev->desc, ((ev->next) ? "present" : "absent"));
  mudlog(buf, DBG, LVL_IMPL, TRUE);
a5740 3
  sprintf(buf, "DBG: Count: %d Ev={chID=%ld, time_taken={hours=%d,day=%d,month=%d,year=%d}, room=%d, type=%d, info1=%d, info2=%d, info3=%d, desc=%s, next=%s}",
	  events.num_events, ev->chID, ev->time_taken.hours, ev->time_taken.day, ev->time_taken.month, ev->time_taken.year, ev->room->number, ev->type, ev->info1, ev->info2, ev->info3, ev->desc, ((ev->next) ? "present" : "absent"));
  mudlog(buf, DBG, LVL_IMPL, TRUE);
@


1.104
log
@Artus> Changed immlist to keep a list in memory instead of reading from disk.
@
text
@a288 4
  void dbg_managain_calc(struct char_data *ch, char *arg);
  int old_mana_gain(struct char_data *ch);
  int old_hit_gain(struct char_data *ch);
  int old_move_gain(struct char_data * ch);
a289 1
  extern struct imm_list_element *immlist_table;
a305 4
		"  &chitgain&n   - Hitpoitn Regeneration\r\n"
		"  &cimmlist&n   - Internal Champ List\r\n"
		"  &cmanagain&n  - Mana Regeneration\r\n"
		"  &cmovegain&n  - Move Regeneration\r\n"
a340 38
  // Artus> Hit Gain
  if (!str_cmp(arg1, "hitgain"))
  {
    sprintf(buf, "[DBG] Old System: %d, New System: %d\r\n", old_hit_gain(ch),
	    hit_gain(ch));
    send_to_char(buf, ch);
    return;
  }
  // Artus> Immlist.
  if (!str_cmp(arg1, "immlist"))
  {
    strcpy(buf, "[DBG] Immlist:\r\n");
    for (struct imm_list_element *immbit = immlist_table; immbit;
	 immbit = immbit->next)
    {
      sprintf(buf1, "  %-20s   %3ld   %3d\r\n", immbit->name, immbit->kills,
	      immbit->unholiness);
      strcat(buf, buf1);
    }
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
    return;
  }
  // Artus> Mana Gain.
  if (!str_cmp(arg1, "managain"))
  {
    dbg_managain_calc(ch, arg2);
    sprintf(buf, "[DBG] Old System: %d\r\n", old_mana_gain(ch));
    send_to_char(buf, ch);
    return;
  }
  // Artus> Move Gain.
  if (!str_cmp(arg1, "movegain"))
  {
    sprintf(buf, "[DBG] Old System: %d, New System: %d\r\n", old_move_gain(ch),
	    move_gain(ch));
    send_to_char(buf, ch);
  }
@


1.103
log
@Artus> When removing superman special, strength and constitution are now
       rerolled.
       Remort levels can now be set to zero.
@
text
@d294 1
d312 1
d358 15
d4072 1
d4075 4
a4078 2
  if (GET_LEVEL(ch) < LVL_OWNER) {
    if (!IS_NPC(vict) && GET_LEVEL(ch) <= GET_LEVEL(vict) && vict != ch) {
d4083 4
a4086 2
  if (GET_IDNUM(ch) > 3) {
    if (GET_LEVEL(ch) < set_fields[mode].level) {
d4093 2
a4094 1
  if (IS_NPC(vict) && !(set_fields[mode].pcnpc & NPC)) {
d4294 2
a4295 1
    if (value <= 0 || value > LVL_OWNER) {
d4299 2
a4300 1
    if (GET_IDNUM(ch) > 3) {
d4302 2
a4303 1
          value > LVL_OWNER) {
d4310 4
@


1.102
log
@Artus> Changed regen calculations.
@
text
@d3911 2
a3912 2
void show_specials_to_char(struct char_data *ch) {

d4567 23
a4589 19
   if (strcmp(val_arg, "list") ==  0 ) {
     show_specials_to_char(ch);
     return (0);
   }
   if( !isdigit(val_arg[0]) ) {
	send_to_char("You must specify the value of the special.\r\n Use &4set <player> special list&n to see specials available.\r\n", ch);
   	return (0);
   }
   
   if( atoi(val_arg) <= 0 || atoi(val_arg) > MAX_SPECIALS ) {
	send_to_char("That's not a valid option!\r\nUser &4set <player> special list&n to see options.\r\n", ch);
   	return (0);
   }
   else {
	if (IS_SET(GET_SPECIALS(vict), (1 << atoi(val_arg) - 1))) {
		REMOVE_BIT(GET_SPECIALS(vict), (1 << atoi(val_arg) - 1));
	}	
	else {
		SET_BIT(GET_SPECIALS(vict), (1 << atoi(val_arg) - 1));
d4591 15
a4605 13
   }

   sprintf(buf, "&g%s&n toggled &4%s&n for %s.\r\n", special_ability_bits[atoi(val_arg)-1], 
	IS_SET(GET_SPECIALS(vict), (1 << atoi(val_arg) -1)) ? "on" : "off", GET_NAME(vict));
   send_to_char(buf, ch);
   apply_specials(vict, FALSE);
   // Recalc the players modifier
   GET_MODIFIER(vict) = race_modifiers[GET_RACE(vict)] + 
                        class_modifiers[(int)GET_CLASS(vict)] +
			special_modifier(vict) +
			elitist_modifier(vict);
   break;
  
d4645 1
a4645 1
    GET_REM_ONE(vict) = RANGE(1, LVL_OWNER);
d4662 1
a4662 1
    GET_REM_TWO(vict) = RANGE(1, LVL_OWNER);
@


1.101
log
@Artus> Added cream pie command back in \;o)
@
text
@d289 4
d310 3
d348 23
@


1.100
log
@Artus> Required changes for new find_xxx functions.
       Moved the questlog stuff to quest.c.
@
text
@d241 41
d3358 1
a3358 1
        send_to_char(CCBBLU(d->character, C_NRM), d->character);
@


1.99
log
@Artus> Aggro changes, Debug Eqfind.
@
text
@d647 2
a648 1
  if (!*arg) {
d652 2
a653 1
  if (!(vict = get_char_vis(ch, arg, FIND_CHAR_WORLD))) {
d693 17
a709 4
  } else if ((target_mob = get_char_vis(ch, roomstr, FIND_CHAR_WORLD)) != NULL)
    location = target_mob->in_room;
  else if ((target_obj = get_obj_vis(ch, roomstr)) != NULL) {
    if (target_obj->in_room != NOWHERE)
d711 7
a717 3
    else {
      send_to_char("That object is not available.\r\n", ch);
      return (NOWHERE);
a718 3
  } else {
    send_to_char("No such creature or object around.\r\n", ch);
    return (NOWHERE);
a719 1

d840 1
a840 1
    if(((target_mob = get_char_vis(ch, name_mob, FIND_CHAR_WORLD)) == NULL)
d925 1
a925 1
    if (!(victim = get_char_vis(ch, buf, FIND_CHAR_WORLD)))
d974 1
a974 1
  else if (!(victim = get_char_vis(ch, buf, FIND_CHAR_WORLD)))
d2013 2
a2014 1
  if (!*buf1) {
d2017 4
a2020 2
  } else if(ETERNAL) {
    if((victim = get_char_room_vis(ch,buf1)))
d2022 6
a2027 2
    else send_to_char("That person does not appear to be here.\r\n",ch);
  } else if (is_abbrev(buf1, "room")) {
d2029 4
a2032 1
  } else if (is_abbrev(buf1, "mob")) {
d2035 3
a2037 2
    else {
      if ((victim = get_char_vis(ch, buf2, FIND_CHAR_WORLD)) != NULL)
d2042 5
a2046 2
  } else if (is_abbrev(buf1, "player")) {
    if (!*buf2) {
d2048 3
a2050 2
    } else {
      if ((victim = get_player_vis(ch, buf2, FIND_CHAR_WORLD)) != NULL)
d2055 5
a2059 2
  } else if (is_abbrev(buf1, "file")) {
    if (!*buf2) {
d2061 2
a2062 1
    } else {
d2079 4
a2082 1
  } else if (is_abbrev(buf1, "object")) {
d2085 3
a2087 2
    else {
      if ((object = get_obj_vis(ch, buf2)) != NULL)
d2092 10
a2101 6
  } else {
    if ((object = get_object_in_equip_vis(ch, buf1, ch->equipment, &tmp)) != NULL)
      do_stat_object(ch, object);
    else if ((object = get_obj_in_list_vis(ch, buf1, ch->carrying)) != NULL)
      do_stat_object(ch, object);
    else if ((victim = get_char_vis(ch, buf1, FIND_CHAR_ROOM)) != NULL)
d2103 5
a2107 1
    else if ((object = get_obj_in_list_vis(ch, buf1, world[ch->in_room].contents)) != NULL)
d2109 2
a2110 5
    else if ((victim = get_char_vis(ch, buf1, FIND_CHAR_WORLD)) != NULL)
      do_stat_character(ch, victim);
    else if ((object = get_obj_vis(ch, buf1)) != NULL)
      do_stat_object(ch, object);
    else
d2113 1
d2189 1
a2189 1
  else if (!(victim = get_char_vis(ch, arg, FIND_CHAR_WORLD)))
d2236 2
a2237 1
  else if (!(victim = get_char_vis(ch, arg, FIND_CHAR_WORLD)))
d2410 2
a2411 1
  if (*buf) {			/* argument supplied. destroy single object
d2413 4
a2416 2
    if ((vict = get_char_vis(ch, buf, FIND_CHAR_ROOM)) != NULL) {
      if (!IS_NPC(vict) && (GET_LEVEL(ch) <= GET_LEVEL(vict))) {
d2422 2
a2423 1
      if (!IS_NPC(vict)) {
d2426 2
a2427 1
	if (vict->desc) {
d2434 1
a2434 1
    } else if ((obj = get_obj_in_list_vis(ch, buf, world[ch->in_room].contents)) != NULL) {
d2448 2
a2449 1
    for (vict = world[ch->in_room].people; vict; vict = next_v) {
d2455 2
a2456 1
    for (obj = world[ch->in_room].contents; obj; obj = next_o) {
d2511 4
a2514 2
  if (*name) {
    if (!(victim = get_char_vis(ch, name, FIND_CHAR_WORLD))) {
d2523 2
a2524 1
  if (GET_LEVEL(ch) <= GET_LEVEL(victim)) {
d2528 2
a2529 1
  if (IS_NPC(victim)) {
d2533 2
a2534 1
  if (!*level || (newlevel = atoi(level)) <= 0) {
d2538 2
a2539 1
  if (newlevel > LVL_IMPL) {
d2544 2
a2545 1
  if (newlevel > GET_LEVEL(ch)) {
d2549 2
a2550 1
  if (newlevel == GET_LEVEL(victim)) {
d2554 2
a2555 1
  if (!*reason || (*reason && (strlen(reason) < 10))) {
d2561 2
a2562 1
  if (newlevel < GET_LEVEL(victim)) {
d2606 1
a2606 1
  else if (!(vict = get_char_vis(ch, buf, FIND_CHAR_WORLD)))
d3113 1
a3113 1
    if (!(vict = get_char_vis(ch, arg, FIND_CHAR_WORLD)))
d3395 1
d3397 4
a3400 1
  else if (!(vict = get_char_vis(ch, arg, FIND_CHAR_WORLD)))
d3402 4
a3405 1
  else if (IS_NPC(vict))
d3407 4
a3410 1
  else if (GET_LEVEL(vict) > GET_LEVEL(ch))
d3412 4
a3415 2
  else {
    switch (subcmd) {
d3426 2
a3427 1
      if (!PLR_FLAGGED(vict, PLR_THIEF | PLR_KILLER)) {
d3441 3
a3443 4
        PLR_TOG_CHK(vict, PLR_NOTITLE);
        send_to_char("Please supply a reason of no less than 10 characters.\r\n"
                        , ch);
        return;
d3452 3
a3454 3
        sprintf(buf, "&7%s&g has had title privilleges removed for %s",
                        GET_NAME(vict), reason);
        mudlog(buf, NRM, 0, FALSE);
d3459 5
a3463 5
      if (result && (!*reason || (strlen(reason) < 10))) {
        PUN_TOG_CHK(vict, PUN_MUTE);
        send_to_char("Please supply a reason of no less than 10 characters.\r\n"
                        , ch);
        return;
d3470 4
a3473 4
      if (result) {
        sprintf(buf, "&7%s&g has been muted for %s",
                        GET_NAME(vict), reason);
        mudlog(buf, NRM, 0, FALSE);
d3477 2
a3478 1
      if (ch == vict) {
d3482 2
a3483 1
      if (PUN_FLAGGED(vict, PUN_FREEZE)) {
d3487 4
a3490 4
      if (!*reason || (strlen(reason) < 10)) {
        send_to_char("Please supply a reason of no less than 10 characters.\r\n"
                        , ch);
        return;
a3494 1
	    
d3501 4
a3504 4
      if (result) {
        sprintf(buf, "&7%s&g has been frozen for %s",
                        GET_NAME(vict), reason);
        mudlog(buf, NRM, 0, FALSE);
d3509 2
a3510 2
      if (!PUN_FLAGGED(vict, PUN_FREEZE)) {

d3514 3
a3516 3
      if (GET_FREEZE_LEV(vict) > GET_LEVEL(ch)) {
	sprintf(buf, "Sorry, a level %d God froze %s... you can't unfreeze %s.\r\n",
	   GET_FREEZE_LEV(vict), GET_NAME(vict), HMHR(vict));
a3523 1

d3529 4
a3532 2
      if (vict->affected) {
        for (affect = vict->affected; affect; affect = affect->next) {
d3534 1
a3534 1
          if (vict->affected->duration != -1) {
d3536 1
a3536 2
          }
        }
a3547 2
    }
    save_char(vict, NOWHERE);
d3549 1
a3551 1

d4650 2
a4651 1
  if (!strcmp(name, "file")) {
d4664 2
a4665 1
  if (!*name || !*field) {
d4672 6
a4677 3
  if (!is_file) {
    if (is_player) {
      if (!(vict = get_player_vis(ch, name, FIND_CHAR_WORLD))) {
d4682 2
a4683 1
      if (!(vict = get_char_vis(ch, name, FIND_CHAR_WORLD))) {
d4776 2
a4777 1
  if (!(vict = get_char_vis(ch, arg, FIND_CHAR_ROOM))){
d4781 2
a4782 2
 
  if (IS_NPC(vict)){
d4786 2
a4787 2
 
  if (GET_LEVEL(vict)!=LVL_ANGEL){
d4807 2
a4808 1
  if (!(vict = get_char_vis(ch, arg, FIND_CHAR_ROOM))){
d4812 4
a4815 4
 
  if (IS_NPC(vict)){
        send_to_char("You want to immort a monster!!!!!. YOU MUST BE BORED!\r\n", ch);
        return;
d4817 4
a4820 3
  if (GET_LEVEL(vict)<LVL_IMMORT){
        send_to_char("They are not an IMMORTAL!!.  Can't do it!\r\n", ch);
        return;
d4822 4
a4825 3
  if (GET_LEVEL(vict)==LVL_ANGEL){
        send_to_char("They are already angel silly!\r\n", ch);
        return;
d4827 4
a4830 3
  if (GET_LEVEL(vict)>LVL_ANGEL){
        send_to_char("Yer right get serious!!!\r\n", ch);
        return;
d4880 1
a4880 1
  if (IS_NPC(ch)) {
a4881 1
  }
d4885 2
a4886 1
  if (!*arg) {
d4889 1
a4889 1
  } else if(!(vict = get_char_vis(ch,arg,FIND_CHAR_WORLD))) {
d4893 2
a4894 1
    if (load_char(arg, &tmp_store) > -1) {
d4897 2
a4898 1
      if (GET_LEVEL(cbuf) > GET_LEVEL(ch)) {
d5005 3
a5007 2
  if(!(vict = get_char_room_vis(ch,arg))) {
    if(FIGHTING(ch)) {
d5009 2
a5010 1
    } else {
a5012 1
      }
d5014 1
d5016 2
a5017 1
  if(!AWAKE(vict)) {
d5020 1
a5020 1
    }
d5022 2
a5023 1
  if(vict == ch) {
d5028 1
a5028 1
    }
d5030 2
a5031 1
  if(GET_LEVEL(vict) >= GET_LEVEL(ch)) {
d5034 1
a5034 1
    }
d5113 1
a5113 185
void enhance_quest_item(struct obj_data *qitem, struct char_data *ch, int itemnumber) { 
	
	int i, j, k, l;

	for( i = 0; i < MAX_QUEST_ITEMS; i++ ) 
	{
		if( GET_QUEST_ITEM(ch, i) == 0 )
		{
			continue;
		}

		if( GET_QUEST_ITEM(ch, i) == GET_OBJ_VNUM(qitem))
		{
			itemnumber--;	
		}

		// We have the item to enhance (i = item)
		if(itemnumber == 0 ) 
		{
		  // For every available enhancement
		  for( j = 0; j < MAX_NUM_ENHANCEMENTS; j++ ) 
		  {
			// If enhancement j for item i = 0
			if( GET_QUEST_ENHANCEMENT(ch, i, j) == 0 )
				continue;	
		
			// For every actual value (k) on enhancement j
			for( k = 0; k < MAX_ENHANCEMENT_VALUES; k++ ) 
			{
			   if (GET_QUEST_ENHANCEMENT_VALUE(ch, i, j, k) == 0)
				continue;

 			   int found = 0;
			   // for every affect on the object
			   for( l = 0; l < MAX_OBJ_AFFECT; l++ ) 
			   {
			      if(qitem->affected[l].location == GET_QUEST_ENHANCEMENT(ch, i, j) )
			      {
			  	qitem->affected[l].modifier += GET_QUEST_ENHANCEMENT_VALUE(ch,i,j, k);
				found = 1;
				break;
			      }
			    }

			    if( !found ) 
			    { // New affect
			       for( l = 0 ; l < MAX_OBJ_AFFECT; l++ )
			       {
			         if( qitem->affected[l].location == APPLY_NONE ) 
				 {
				    qitem->affected[l].modifier = GET_QUEST_ENHANCEMENT_VALUE(ch, i, j, k);
				    qitem->affected[l].location = GET_QUEST_ENHANCEMENT(ch, i, j);
				    break;
				}
			       } 
			    } // If not found
		        } // For every enhancement value
		    } // For every enhancement
		} // If this is the enhancement we want
	} // For every quest item

}

void apply_quest_enhancements(struct char_data *ch) {

  struct obj_data *itemList[2048], *tmp;
  int itemcount, enhanced = 0, megacount = 0, i, j, k;

  // Create the inv/eq/house item megalist
  for( tmp = ch->carrying; tmp; tmp = tmp->next_content) {   // Inventory
	itemList[megacount] = tmp;
	megacount++;
  }
 
  for ( i = 0; i < NUM_WEARS; i++ ) {
	if ( GET_EQ(ch, i) != NULL) {
	 itemList[megacount] = ch->equipment[i];
	 megacount++;
	}
  }

  for( i = 0; i < num_of_houses; i++ ) {
 	if ( house_control[i].owner == get_id_by_name(GET_NAME(ch)) )  {
          for( tmp = world[real_room(house_control[i].vnum)].contents; tmp; tmp = tmp->next) {
		itemList[megacount] = tmp;
		megacount++;
	  } 
	}
  }

  // Go through each quest item
  for( i = 0; i < MAX_QUEST_ITEMS; i++ ) {
	if (GET_QUEST_ITEM(ch, i) == 0 )
		continue;

	itemcount = 0;
	// Count the number of instances of enhancements on this item
	for( j = 0; j < MAX_QUEST_ITEMS; j++ ) 
	   if (GET_QUEST_ITEM(ch, j) == GET_QUEST_ITEM(ch, i) )
		itemcount++;

	// Find all items of this type, enhance them
	if( itemcount >= 1 ) {
	  for( k = 0; k < megacount; k++ ) {

		if ( GET_OBJ_VNUM(itemList[k]) == GET_QUEST_ITEM(ch, i) ) {
		   if (itemcount <= 0  ) 
			break;
		   // Replace this item with a freshly loaded one, to remove
		   // previous enhancements and enhancement replication
		   extract_obj(itemList[k]);
		   itemList[k] = NULL;
		   enhanced++;
		   RECREATE(itemList[k], struct obj_data, 1);
		   itemList[k] = read_object(GET_QUEST_ITEM(ch, i), VIRTUAL);
		   enhance_quest_item(itemList[k], ch, enhanced);
                   // Give it back to the player, if it was in their house, bad luck
		   obj_to_char(itemList[k], ch, __FILE__, __LINE__);
		   itemcount--;  
		}
		   
	  }
	}
  }  

  if (enhanced) {
	sprintf(buf, "%d enhancement%s applied.\r\n", enhanced, enhanced == 1 ? "" : "s");
	send_to_char(buf, ch);
  }
  else
	send_to_char("Failed to apply enhancement.\r\n", ch);

}

void show_enhancements_to_player(struct char_data *ch) {

  send_to_char("&1Quest Item Enhancements:&n\r\n", ch);
  send_to_char( "&y1&n  - Strength\r\n"
		"&y2&n  - Dexterity\r\n"
		"&y3&n  - Intelligence\r\n"
		"&y4&n  - Wisdom\r\n"
		"&y5&n  - Constitution\r\n"
		"&y6&n  - Charisma\r\n"
		"&y7&n  - Class      (Not used)\r\n"
		"&y8&n  - Level      (Not used)\r\n"
		"&y9&n  - Age\r\n"
		"&y10&n - Weight\r\n"
		"&y11&n - Height\r\n"
		"&y12&n - Mana\r\n"
		"&y13&n - Hit\r\n"
		"&y14&n - Move\r\n"
		"&y15&n - Gold       (Not used)\r\n"
		"&y16&n - Experience (Not used)\r\n"
		"&y17&n - Armour Class\r\n"
		"&y18&n - Hitroll\r\n"
		"&y19&n - Damroll\r\n"
		"&y20&n - Save vs Paralysation\r\n"
		"&y21&n - Save vs Rod, Staff, Wand\r\n"
		"&y22&n - Save vs Petrification\r\n"
		"&y23&n - Save vs Breath Weapon\r\n"
		"&y24&n - Save vs Spells\r\n", ch);

}

void remove_enhancement(struct char_data *ch, struct char_data *vict, int itemno, int enhno) {
	
	int i = 0;

	sprintf(buf, "Quest item enhancement (set on %s) for &7%s&n removed.\r\n",
		enhancement_names[GET_QUEST_ENHANCEMENT(vict, itemno, enhno)], GET_NAME(ch));
	send_to_char(buf, ch);

	for( i = 0; i < MAX_ENHANCEMENT_VALUES; i++ )
		GET_QUEST_ENHANCEMENT_VALUE(vict, itemno, enhno, i) = 0;
	GET_QUEST_ENHANCEMENT(vict, itemno, enhno) = 0; 

	
}


// DM - TODO - add clear (clear all of the array)..., nicen the output & messages, 
// DM - TODO - log it, add something like OBJ_IS_QUEST(struct obj_data *obj) and check for it ...
// TALI - Added enhancement capability for quest EQ and STAT'ing so we can see what their
//        quest eq is looking like after enhancements
ACMD(do_quest_log)
a5114 554
  struct obj_data *obj, *itemList[2048], *tmp; 
  struct char_data *vict, *cbuf = NULL;
  struct char_file_u tmp_store;
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  char arg3[MAX_INPUT_LENGTH], rest[MAX_INPUT_LENGTH];
  obj_rnum rnum, objnum;
  int j, k, is_file=0, player_i = 0, found = 0, qsearch, value, 
	enhancement =0, foundEnh = 0, counter = 1, megacount = 0;
  unsigned int i;
  bool playerInGame = FALSE;
  bool mortal = (LR_FAIL(ch, LVL_GOD)) ? TRUE : FALSE;

  subcmd=-1;
 
  if (IS_NPC(ch))
    return;
 
  skip_spaces(&argument);
  half_chop(argument, arg1, rest);
 
  if (!str_cmp(arg1,"list"))
    subcmd = SCMD_QUEST_LIST;
  if (!str_cmp(arg1,"add"))
    subcmd = SCMD_QUEST_ADD;
  if (!str_cmp(arg1,"del"))
    subcmd = SCMD_QUEST_DELETE;
  if (!str_cmp(arg1,"enhance"))
     subcmd = SCMD_QUEST_ENHANCE;
  if (!str_cmp(arg1,"stat"))
     subcmd = SCMD_QUEST_STAT;
 
  if (mortal) {
    subcmd = SCMD_QUEST_LIST;
  } else if (subcmd == -1) {
    send_to_char("That'll either be &4list&n/&4add&n/&4del&n/&4enhance&n/&4stat&n.\r\n",ch);
    return;
  }           
 
  half_chop(rest, arg2, rest);
 
  if (!*arg2) {
    switch (subcmd) {
      case SCMD_QUEST_LIST:
	//send_to_char("Usage: &4questlog list <player>&n\r\n", ch);
	break;
      case SCMD_QUEST_ADD:
        //send_to_char("&1Usage: &4questlog add <player> &c<obj vnum>&n\r\n",ch);
        break;
      case SCMD_QUEST_DELETE:
        //send_to_char("&1Usage: &4questlog del <player> &c<obj vnum>&n\r\n",ch);
        break;
      case SCMD_QUEST_ENHANCE:
	show_enhancements_to_player(ch);
        return;
      case SCMD_QUEST_STAT:
        //send_to_char("&1Usage: questlog stat <player> [<x>.]<obj vnum>\r\n", ch);
        break;
      default:
        send_to_char("On whom?\r\n",ch);
        return;
    }
  }
 
  if (mortal) {
    vict = ch;
  } else if (!(vict = get_player_vis(ch, arg2, FIND_CHAR_WORLD))) {
    /* try to load the player off disk */
    CREATE(cbuf, struct char_data, 1);
    clear_char(cbuf);
    if ((player_i = load_char(arg2, &tmp_store)) > -1) {
      store_to_char(&tmp_store, cbuf);
      if (GET_LEVEL(cbuf) > GET_LEVEL(ch)) {
        free_char(cbuf);
        send_to_char("Sorry, you can't do that.\r\n", ch);
        return;
      }
      vict = cbuf;
      is_file = 1;
    } else {
      free(cbuf);
      // See if they want to list the quest enhancements
      if (strcmp(arg2, "list") != 0 && (subcmd != SCMD_QUEST_ENHANCE) ) {
         send_to_char("There is no such player.\r\n", ch);
         return;
      }
    }
  } else {
    playerInGame = TRUE;
  }
 
  strcpy(buf,"");
 
  switch(subcmd) {
  case SCMD_QUEST_LIST:
    for (i=0; i < MAX_QUEST_ITEMS; i++) {
      if (GET_QUEST_ITEM(vict,i) > 0) {  
        if ( (rnum = real_object(GET_QUEST_ITEM(vict,i) )) >=0) {
          obj = read_object(rnum, REAL);
 
          // problem loading the obj?? lets clear the space.
          if (!obj) {
            GET_QUEST_ITEM(vict,i) = 0;
            GET_QUEST_ITEM_NUMB(vict,i) = 0;
            continue;
          }
          foundEnh = 0;
          // Check object for enhancements
          for( j = 0; j < MAX_NUM_ENHANCEMENTS; j++ )
                if (GET_QUEST_ENHANCEMENT(vict, i, j) != 0 )
                        foundEnh = 1;
          found = 1;
          sprintf(buf2, "&c[%5d]&n %s (&Rx%d&n) Enhanced: &y%s&n\r\n",
                GET_OBJ_VNUM(obj), obj->name, GET_QUEST_ITEM_NUMB(vict,i),
                foundEnh == 1 ? "Yes" : "No");
          extract_obj(obj);
 
          strcat(buf,buf2);
        } else {
          sprintf(buf2,"Quest Log Error: object %d belonging to %s no longer exits. Removed",
                GET_QUEST_ITEM(vict,i),GET_NAME(vict));
          GET_QUEST_ITEM(vict,i) = 0;
          GET_QUEST_ITEM_NUMB(vict,i) = 0;
          mudlog(buf2, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
        }
      }
    }
 
    if (found) {
      if (mortal) {
        sprintf(buf2,"Your quest items include:\r\n");
      } else {
        sprintf(buf2,"Quest items for &7%s&n:\r\n",GET_NAME(vict));
      }
      strcat(buf2,buf);
      send_to_char(buf2,ch);
    } else {      
      if (mortal) {
        send_to_char("Nope, you have no quest items.\r\n",ch);
      } else {
        send_to_char("They have no quest items.\r\n",ch);
      }
    }
  break;
 
  case SCMD_QUEST_ADD:
 
    half_chop(rest, arg3, rest);
 
    if (!(isdigit(*arg3))) {
      send_to_char("&1Usage: &4questlog add <player> &c<obj vnum>&n\r\n",ch);
      break;
    }
 
    if (!(objnum = atoi(arg3))) {
      send_to_char("Thats not a vnum.\r\n",ch);
      break;
    }
 
    if ((rnum = real_object(objnum)) < 0) {
      send_to_char("There is no object with that number.\r\n", ch);
      break;
    } 
 /*  -- Tal - I dont want to allow this. Easier (for me) to just list all items separately --
    // first parse check to see if the object already exists ...
    for (i=0; (i < MAX_QUEST_ITEMS) && (!found); i++) {
      if (GET_QUEST_ITEM(vict,i) == objnum) {
        found = 1;
        GET_QUEST_ITEM_NUMB(vict,i) += 1;
      }
    }
  */ 
    // find first available space ...
    for (i=0; (i < MAX_QUEST_ITEMS) && (!found); i++) {
      if (GET_QUEST_ITEM(vict,i) <= 0) {
        found = 1;
        GET_QUEST_ITEM(vict,i) = objnum;
        GET_QUEST_ITEM_NUMB(vict,i) = 1;
      }
    }
 
    if (found) {
      send_to_char("Object Added.\r\n",ch);
    } else {
      send_to_char("Maximum number of objects exceeded.\r\n",ch);
    }
 
  break;
 
  case SCMD_QUEST_DELETE:
 
    half_chop(rest, arg3, rest);
 
    if (!(isdigit(*arg3))) {
      send_to_char("&1Usage: &4questlog del <player> &c<obj vnum>&n\r\n",ch);
      break;
    }
 
    // Get either the <x>. or the rnum
    qsearch = atoi(arg3);
    strcpy(arg2, arg3);
 
    // See if they are looking for a particular instance
    i = 0;
    while( (arg3[i] != '.') && (arg3[i] != ' ') && (i < strlen(arg3)) )
        i++;
 
    // Allocate the rnum, will be 0 if there was no <x>.<rnum>
    objnum = atoi(&arg3[i+1]);
    // Check if there was no . in the arg
    if (objnum == 0 ) {
        objnum = qsearch;         // QSearch is holding the rnum then
        qsearch = 1;            // Set to first occurance
    }
 
    // If it's still 0, they haven't set a vnum
    if ( objnum == 0 ) {
        send_to_char("You must specify an object vnum.\r\n", ch);
        break;
    }

    for (i=0; i < MAX_QUEST_ITEMS; i++) {
      if (GET_QUEST_ITEM(vict,i) == objnum) {
        if (qsearch == 1) {
           found = 1;
           GET_QUEST_ITEM(vict, i) = 0;
	   // ahh what about the enhancements tali???
	   for (int j = 0; j < MAX_NUM_ENHANCEMENTS; j++) {
             GET_QUEST_ENHANCEMENT(ch, i, j) = 0;
	     for (int k = 0; k < MAX_ENHANCEMENT_VALUES; k++) {
	       GET_QUEST_ENHANCEMENT_VALUE(ch, i, j, k) = 0;
	     }
	   }
	   // do an ingame check
           break;
        }
        else
	  qsearch--;
      }

/* -- Tal - Removed GET_QUEST_NUMB capability --
        GET_QUEST_ITEM_NUMB(vict,i) -= 1;
        if (GET_QUEST_ITEM_NUMB(vict,i) <= 0) {
          GET_QUEST_ITEM(vict,i) = 0;
          GET_QUEST_ITEM_OBJ(vict, i) = NULL;
        } 
  */
      }
       
 
    if (found) {
      send_to_char("Object Removed.\r\n",ch);

      if (playerInGame) {
        for (int i = 0; i < NUM_WEARS; i++) {
          if (GET_EQ(vict, i) && GET_OBJ_VNUM(GET_EQ(vict, i)) == objnum) {
	    perform_remove(vict, i);
	  }
	}
      }
    } else {
      send_to_char("Object not found in list.\r\n",ch);
    }
 
  break;
  
  /** QUEST ITEM ENHANCING **/ 
  
  // Usage: qlog enhance <person> <x>.<vnum> <enhancement #> <value>
  case SCMD_QUEST_ENHANCE:
    // See if there's no player to enhance, it means they want to list the enhancements
    if( vict == NULL ) {
	show_enhancements_to_player(ch);
	break;
    }

    half_chop(rest, arg3, rest);
    if( !*arg3 ) {
	send_to_char("&1Enhancement usage: &4questlog enhance <player> <x>.<obj vnum> <enh #> <val>\r\n"
		     "       &1Optionally: &4questlog enhance <player> <list | apply | delete>\r\n", ch);
        break;
    }

    // If they're not enhancing they can list, apply or delete
    found = 0;
    if (!(isdigit(*arg3))) {
      // Apply enhancements to players items
      if (strcmp(arg3, "apply") == 0) {
	apply_quest_enhancements(vict);
	break;
      }
      else
      // Delete
      if( strcmp(arg3, "delete") == 0 ) {
	    half_chop(rest, arg3, rest);
	    if (!isdigit(*arg3)) {
		if (strcmp(arg3, "all") == 0) {
		   for( i = 0; i < MAX_QUEST_ITEMS; i++ )
		       if( GET_QUEST_ITEM(ch, i) != 0 )
		         for( j = 0; j < MAX_NUM_ENHANCEMENTS; j++)
		           if(GET_QUEST_ENHANCEMENT(vict, i, j) != 0 )
				remove_enhancement(ch, vict, i, j); 
		  break;
		}
		else {
		  send_to_char("Deletion of enhancements must be either 'all' or a number.\r\n",ch);
		  break;
		}	
	     }
	     else {
	       found = 0;
	       for ( i = 0; i < MAX_QUEST_ITEMS; i++ )
		   if( GET_QUEST_ITEM(ch, i) != 0 )
	             for( j = 0; j < MAX_NUM_ENHANCEMENTS; j++ )
			if (GET_QUEST_ENHANCEMENT(ch, i, j) != 0 ) {
			   if( counter == atoi(arg3)) {
			     remove_enhancement(ch, vict, i, j);
			     found = 1; 
			     break;
			   }
			   counter++;
			}	
		if( !found )
		  send_to_char("That enhancement doesn't exist!\r\n", ch);
		break;
	     }
	    
      } // end of delete enhancement
      else
      // Are they listing?
      if( strcmp(arg3, "list") == 0 )
      {
	// Prepare the list
	sprintf(buf, "Quest item enhancements for &7%s&n:\r\n", GET_NAME(vict));
	for( i = 0; i < MAX_QUEST_ITEMS; i++) 
	{
		if( GET_QUEST_ITEM(vict, i) != 0 ) 
		{
		   found++;
		   for( j = 0; j < MAX_NUM_ENHANCEMENTS; j++ ) 
		   {
                     if (GET_QUEST_ENHANCEMENT(vict, i, j) != 0 ){ 
			for( k = 0; k < MAX_ENHANCEMENT_VALUES; k++ ) 
			  if( GET_QUEST_ENHANCEMENT_VALUE(vict, i, j, k) != 0 ){ 
			     foundEnh++;
			     sprintf(buf + strlen(buf), "  Item #&c%2d&n(&C%5d&n) Enh #&g%d&n - adds &y%s&n with value &W%d&n\r\n",
		  		i+1, GET_QUEST_ITEM(vict, i), j + 1,
				enhancement_names[GET_QUEST_ENHANCEMENT(vict, i, j)],
				GET_QUEST_ENHANCEMENT_VALUE(vict, i, j, k));
			  }
		     } 
		   }
		}
	} 
	if( !found )
		send_to_char("They have no quest items..\r\n", ch);
	else if( !foundEnh )
		send_to_char("They have no enhancements on their items.\r\n", ch);
	else
	       send_to_char(buf, ch);
	break;
      } 
      else {
        send_to_char("&1Usage: &4questlog enhance <name> <num in list>.<obj vnum> <enh #> <val>\r\n",ch);
        break;
      }
    }
 
    // Get either the <x>. or the rnum
    qsearch = atoi(arg3);
    strcpy(arg2, arg3);
 
    // See if they are looking for a particular instance
    i = 0;
    while( (arg3[i] != '.') && (arg3[i] != ' ') && (i < strlen(arg3)) )
        i++;
 
    // Allocate the rnum, will be 0 if there was no <x>.<rnum>
    rnum = atoi(&arg3[i+1]);
    // Check if there was no . in the arg
    if (rnum == 0 ) {
        rnum = qsearch;         // QSearch is holding the rnum then
        qsearch = 1;            // Set to first occurance
    }
 
    // If it's still 0, they haven't set a vnum
    if ( rnum == 0 ) {
        send_to_char("You must specify an object vnum.\r\n", ch);
        break;
    }
 
    // Get the enhancement
    half_chop(rest, arg3, rest);
    if( !isdigit(*arg3) ) {
        send_to_char("The enhancement must be an integer value, 1 to 24.\r\n", ch);
        break;
    }
    enhancement = atoi(arg3);
 
    if( enhancement == 0 ) {
        send_to_char("You must specify a valid enhancement number and value.\r\n" , ch);
        break;
    }
 
    // Get the value
    half_chop(rest, arg3, rest);
    if( !isdigit(*arg3) && atoi(arg3) >= 0) {
        send_to_char("The value must be an integer value.\r\n", ch);
        break;
    }
    value = atoi(arg3);
 
    if( (value == 0) || (value < -125) || (value > 125) ) {
        send_to_char("You must provide a valid value for the enhancement.\r\n", ch);
        break;
    }
 
    sprintf(buf, "Seeking to enhance item number %d with vnum %d.\r\n", qsearch, rnum);
    send_to_char(buf, ch);
	
    found = 0;
    // OKay, we have all values, do enhancement 
    for (i = 0; i < MAX_QUEST_ITEMS; i++)
    {
	// If this quest item has the rnum we're looking for
	if( GET_QUEST_ITEM(vict, i) == rnum ) {
		if( qsearch != 1 ) {
			qsearch--;
			continue;
		}
	}
	else
		continue;

	found = 1;
	// rnum and qsearch are now valid, so set the quest item enhancement
	GET_QUEST_ITEM(vict, i) = rnum;
	GET_QUEST_ITEM_OBJ(vict, i) = 0;	// Not sure if i'm going to use this yet
	// Search for an enhancement slot, either with same enhancement, or blank
	for( j = 0; j < MAX_NUM_ENHANCEMENTS; j ++ )
	   if( (GET_QUEST_ENHANCEMENT(vict, i, j) == 0) || 
	       (GET_QUEST_ENHANCEMENT(vict, i, j) == enhancement) ) 
		break;

	if( j >= MAX_NUM_ENHANCEMENTS ) {
		send_to_char("Item already has as many enhancements as possible.\r\n", ch);	
		break;
	}
	
	GET_QUEST_ENHANCEMENT(vict, i, j) = enhancement;
	// Look for a free slot to place the value in
	for(k = 0; k < MAX_ENHANCEMENT_VALUES; k++)
		if( GET_QUEST_ENHANCEMENT_VALUE(vict, i, j, k) == 0 )
			break;

	if( k >= MAX_ENHANCEMENT_VALUES ) {
		sprintf(buf, "That item already has as many boosts to %s as possible.\r\n",
			enhancement_names[GET_QUEST_ENHANCEMENT(ch, i, j)]);
		send_to_char(buf, ch);
		break;
	}

	GET_QUEST_ENHANCEMENT_VALUE(vict, i, j, k) = value;

	sprintf(buf, "Quest item #&c%d&n(&c%d&n) for &b%s&n was enhanced by &W%d&n on &y%s&n.\r\n", 
		qsearch, rnum, GET_NAME(vict), value, enhancement_names[enhancement]);
	send_to_char(buf, ch);
	break;
    }

    if( !found ) 
	send_to_char("Could not locate that quest item in the log!\r\n",ch);
   
    break;
  case SCMD_QUEST_STAT:
    // Usage: qlod stat <person> <x>.<vnum>
    half_chop(rest, arg3, rest);
    if( !*arg3 ) {
      send_to_char("&1Usage: questlog stat <player> [<x>.]<obj vnum>\r\n", ch);
      break;
    }
    if (!isdigit(*arg3)) {
	send_to_char("The quest item id must be a vnum.\r\n", ch);
	break;
    }
    // Get either the <x>. or the rnum
    qsearch = atoi(arg3);
    strcpy(arg2, arg3);
    
    // See if they are looking for a particular instance
    i = 0;
    while( (arg3[i] != '.') && (arg3[i] != ' ') && (i < strlen(arg3)) )
	i++;
    // Allocate the rnum, will be 0 if there was no <x>.<rnum>
    rnum = atoi(&arg3[i+1]);
    // Check if there was no . in the arg
    if (rnum == 0 ) {
	rnum = qsearch;		// QSearch is holding the rnum then
	qsearch = 1;		// Set to first occurance
    // If it's still 0, they haven't set a vnum
    if ( rnum == 0 ) {
	send_to_char("You must specify an object vnum.\r\n", ch);
	break;
    }
   
    // Create a list of all their items
    // Create the inv/eq/house item megalist
    for( tmp = ch->carrying; tmp; tmp = tmp->next_content) {   // Inventory
	itemList[megacount] = tmp;
	megacount++;
    }
 
    for ( i = 0; i < NUM_WEARS; i++ ) {
	if ( GET_EQ(ch, i) != NULL) {
	 itemList[megacount] = ch->equipment[i];
	 megacount++;
	}
    }
    for( i = 0; (int)i < num_of_houses; i++ ) {
 	if ( house_control[i].owner == get_id_by_name(GET_NAME(ch)) )  {
          for( tmp = world[real_room(house_control[i].vnum)].contents; tmp; tmp = tmp->next) {
		itemList[megacount] = tmp;
		megacount++;
	  } 
	}
    }
    
    // Go through the list, finding the instance of the object they're after
    found = 0;
    for (i = 0; (int)i < megacount; i++) {
	if (GET_OBJ_VNUM(itemList[i]) == rnum  ) {
		if( qsearch != 1 ) {
			qsearch--;
			continue;
		}
        	do_stat_object(ch, itemList[i]);
		found = 1;
		break;
        }
    }    

    if( !found ) 
	send_to_char("They don't have that item on them.\r\n", ch);	

    break;

  }

  /* free the memory if we allocated it earlier */
  if (is_file)
    free_char(cbuf);
}                                                                            
}                                        

bool race_has_stats_for_skill(int race_index, int class_index, int spellnum, int statNum) {
@


1.98
log
@Artus> Fixed bug in do_debug_cmd.
@
text
@d158 83
d294 6
@


1.97
log
@Artus> Added in more debug options specific to quest items/mobs.
@
text
@d172 2
a173 1
    strcat(buf, "Debug Options:\r\n"
@


1.96
log
@Artus> Just some cleaning up, this time.
@
text
@d165 1
d174 2
a175 2
	        "  &cOn&n       - Enable Debugging\r\n"
		"  &cOff&n      - Disable Debugging\r\n"
d177 15
a191 11
		"  &calevil&n   - Really evil aligned mobs.\r\n"
		"  &calgood&n   - Really good aligned mobs.\r\n"
		"  &cch&n       - Am I on the character list?\r\n"
		"  &cev&n       - Event List\r\n"
		"  &codam&n     - Object Damage (odam <item> <new dam val>)\r\n"
		"  &cportals&n  - List portals and their destinations.\r\n"
		"  &crmsm&n     - Room's Small Bits\r\n"
		"  &cwentroom&n - Rooms leading to this room.\r\n"
		"  &cwentgate&n - Objects leading to this room.\r\n"
		"  &czentroom&n - Rooms leading to this zone.\r\n"
		"  &czentgate&n - Objects leading to this zone.\r\n");
d197 1
a197 1
  if (str_cmp(arg1, "off"))
d210 93
d308 1
a308 1
    for (int i = 0; i < top_of_world; i++)
d330 1
a330 1
    for (int i = 0; i < top_of_objt; i++)
d350 1
a350 1
    for (int i = 0; i < top_of_world; i++)
d378 1
a378 1
    for (int i = 0; i < top_of_objt; i++)
a392 1

d397 1
a397 1
    for (int i = 0; i < top_of_mobt; i++)
d422 1
a422 1
    for (int i = 0; i < top_of_mobt; i++)
d447 1
a447 1
    for (int i = 0; i < top_of_objt; i++)
@


1.95
log
@Artus> More and less debug command options.
@
text
@d720 1
d722 1
a722 1
  else if (str_cmp("all", buf)) {
d740 2
a741 1
    if (GET_LEVEL(ch) < LVL_GRGOD) {
d747 2
a748 1
      if (STATE(i) == CON_PLAYING && i->character && i->character != ch) {
a762 2


@


1.94
log
@Artus> Moved all the quest event stuff to quest.[ch].
       Added trivia quest type.
@
text
@a163 4
  struct event_data *ev;
  struct itemhunt_data *qev;
  struct quest_score_data *player;
  bool found = false;
d176 6
d183 4
a186 4
		"  &cgr&n       - Generate \"Random\" Gold Rush\r\n"
		"  &chh&n       - Generate \"Random\" Happy Hour\r\n"
		"  &cev&n       - Event List\r\n"
		"  &codam&n     - Object Damage (odam <item> <new dam val>)\r\n");
d192 1
a192 1
  if (is_abbrev(arg1, "off"))
d198 98
a345 42
  // Artus> ItemHunt Details.
  if (!str_cmp(arg1, "itemhunt"))
  {
    ev = find_quest_event();
    if (!ev)
    {
      send_to_char("No quest is currently in progress.\r\n", ch);
      return;
    }
    if (ev->info1 != QUEST_ITEM_HUNT)
    {
      send_to_char("No item hunts are currently in progress.\r\n", ch);
      return;
    }
    qev = (struct itemhunt_data *)ev->info2;
    if (!(qev))
    {
      send_to_char("Could not read itemhunt information. Doh!\r\n", ch);
      return;
    }
    if ((!(qev->ev) || (qev->ev != ev)))
    {
      send_to_char("Itemhunt does not link back to event. This is bad(tm)\r\n",
	           ch);
      return;
    }
    send_to_char("------------------------------------------------\r\n", ch);
    sprintf(buf, "Created &5%3d&n of &8%5d&n - &5%s&n\r\n", qev->itemsmade,
	    qev->itemvnum, obj_proto[qev->itemrnum].short_description);
    send_to_char(buf, ch);
    for (player = qev->players; player; player = player->next)
    {
      found = true;
      sprintf(buf, "&7%-20s&n - &5%d&n Items.\r\n", player->name, 
	      player->score);
      send_to_char(buf, ch);
    }
    if (!(found))
      send_to_char("!(found)\r\n", ch);
    send_to_char("------------------------------------------------\r\n", ch);
    return;
  }
a360 24
  if (is_abbrev(arg1, "on"))
  {
    SET_BIT(SMALL_BITS(ch), SMB_DEBUG);
    send_to_char("Debugging On.\r\n", ch);
    return;
  }
#endif
  if (is_abbrev(arg1,"rmsm"))
  {
    sprintf(buf, "RMSM_FLAGS(IN_ROOM(ch)=%d): %d\r\n", RMSM_FLAGS(IN_ROOM(ch)),
	    world[IN_ROOM(ch)].small_bits);
    send_to_char(buf, ch);
    return;
  }
  if (is_abbrev(arg1,"gr"))
  {
    init_gold_rush();
    return;
  }
  if (is_abbrev(arg1,"hh"))
  {
    create_event_happy(NULL);
    return;
  }
d373 7
@


1.93
log
@Artus> Fixed bug in add_to_quest().
@
text
@d38 1
a97 1
struct event_data *find_quest_event(void);
d168 1
a168 1

a4549 150
// Artus> Remove a player from a quest.
bool remove_from_quest(struct event_data *ev, struct char_data *ch)
{
  struct quest_score_data *qs;
  struct itemhunt_data *qev = (struct itemhunt_data *)ev->info2;

  if (IS_NPC(ch) || (ev->type != EVENT_QUEST))
    return false;
  if (!PRF_FLAGGED(ch, PRF_QUEST))
    return false;
  switch (ev->info1)
  {
    case QUEST_ITEM_HUNT:
      if (!(qev) || (qev->ev != ev))
	break;
      for (qs = qev->players; qs; qs = qs->next)
	if (qs->chID == GET_IDNUM(ch))
	  do_qcomm(ch, "$n &Yhas left the quest!", CMD_NONE, SCMD_QECHO);
      break;
  
  }
  REMOVE_BIT(PRF_FLAGS(ch), PRF_QUEST);
  return true;
}

// Artus> Add a player to a quest.
bool add_to_quest(struct event_data *ev, struct char_data *ch)
{
  struct quest_score_data *qs;
  struct itemhunt_data *qev = (struct itemhunt_data *)ev->info2;

  // No Mobs!
  if (IS_NPC(ch) || (ev->type != EVENT_QUEST))
    return false;
  switch (ev->info1)
  {
    case QUEST_ITEM_HUNT:
      if (!(qev) || (qev->ev != ev))
	return false;
      for (qs = qev->players; qs; qs = qs->next)
	if (qs->chID == GET_IDNUM(ch))
	{
	  if (!PRF_FLAGGED(ch, PRF_QUEST))
	  {
	    SET_BIT(PRF_FLAGS(ch), PRF_QUEST);
	    do_qcomm(ch, "$n&Y has rejoined the quest!&n", 
		     CMD_NONE, SCMD_QECHO);
	    return true;
	  }
	  return false;
	}
      CREATE(qs, struct quest_score_data, 1);
      memset(qs->name, 0, MAX_NAME_LENGTH+1);
      qs->chID = GET_IDNUM(ch);
      strncpy(qs->name, GET_NAME(ch), MAX_NAME_LENGTH);
      qs->score = 0;
      qs->next = qev->players;
      qev->players = qs;
      if (GET_LEVEL(ch) < qev->lowlevel)
	qev->lowlevel = GET_LEVEL(ch);
      SET_BIT(PRF_FLAGS(ch), PRF_QUEST);
      do_qcomm(ch, "$n&Y has joined the quest!&n", CMD_NONE, SCMD_QECHO);
      return true;
  }
  return false;
}

ACMD(do_queston)
{
  struct char_data *vict;
  char buff[120];

  half_chop(argument, arg, buf);
 
  if (!*arg)
  {
    send_to_char("Quest On for who, or \"list\" participants?\r\n", ch);
    return;
  }
  if (!str_cmp(arg, "list"))
  {
    bool found=false;
    strcpy(buf, "Who                  - Lvl Cl - Where\r\n"
	        "-----------------------------------------------------------------------------\r\n");
    for (vict = character_list; vict; vict = vict->next)
    {
      if (IS_NPC(vict) || !(PRF_FLAGGED(vict, PRF_QUEST)) ||
	  !CAN_SEE(ch, vict))
	continue;
      sprintf(buf, "%s&7%-20s&n - %3d %2s - [&8%5d&n] %s\r\n", buf, 
	      GET_NAME(vict), GET_LEVEL(vict), 
	      class_abbrevs[(int)GET_CLASS(vict)],
	      world[IN_ROOM(vict)].number, world[IN_ROOM(ch)].name);
      found = true;
    }
    if (found)
    {
      strcat(buf, "-----------------------------------------------------------------------------\r\n");
      send_to_char(buf, ch);
    } else {
      send_to_char("There is currently noone in the quest.\r\n", ch);
    }
    return;
  }
  if (!(vict = get_char_vis(ch, arg,FIND_CHAR_WORLD)))
  {
    send_to_char(NOPERSON, ch);
    return;
  }
  SET_BIT(PRF_FLAGS(vict),PRF_QUEST);
  sprintf(buff,"%s is now in the quest.\r\n",vict->player.name);
  send_to_char(buff,ch);
}
 
ACMD(do_questoff)
{
  struct char_data *vict;
  char buff[120];
  half_chop(argument, arg, buf);
 
  if (!*arg)
  {
    send_to_char("Quest Off for who?\r\n", ch);
    return;
  }
  if (!str_cmp(arg, "all"))
  {
    int found = 0;
    for (vict = character_list; vict; vict=vict->next)
    {
      if (IS_NPC(vict) || (GET_LEVEL(vict) >= GET_LEVEL(ch)) ||
	  !PRF_FLAGGED(vict, PRF_QUEST))
	continue;
      act("$N is no longer in the quest.", FALSE, ch, 0, vict, TO_CHAR);
      REMOVE_BIT(PRF_FLAGS(vict), PRF_QUEST);
      found++;
    }
    if (found < 1) 
      send_to_char("Noone to remove from the quest.\r\n", ch);
    return;
  }
  if (!(vict = get_char_vis(ch, arg,FIND_CHAR_WORLD)))
  {
    send_to_char(NOPERSON, ch);
    return;
  }            REMOVE_BIT(PRF_FLAGS(vict),PRF_QUEST);
  sprintf(buff,"%s is no longer in the quest.\r\n",vict->player.name);
  send_to_char(buff,ch);
} 

@


1.92
log
@Artus> Chagned range of set alignment.
@
text
@d4610 1
@


1.91
log
@Artus> Implemented QUEST_ITEM_HUNT
       Removed QUEST_PANDORAS_BOX
@
text
@d3766 1
a3766 1
    GET_ALIGNMENT(vict) = RANGE(-1000, 1000);
@


1.90
log
@Artus> Queston List.
@
text
@d97 2
d162 1
a162 1
  void init_gold_rush();
d164 5
d196 92
d4550 66
d4620 1
d4623 2
a4624 1
  if (!*arg) {
a6242 36
char *getQuestName(int nQuestType)
{
  switch(nQuestType)
  {
    case QUEST_ITEM_HUNT:		return "Item hunt";
    case QUEST_PANDORAS_BOX:		return "Pandoras box";
    default:				return "unknown";
  }
}

void destroy_event_quest(struct char_data *ch, struct event_data *ev)
{
  sprintf(buf, "DBG: Count: %d Ev={chID=%ld, time_taken={hours=%d,day=%d,month=%d,year=%d}, room=%d, type=%d, info1=%d, info2=%d, info3=%d, desc=%s, next=%s}",
	  events.num_events, ev->chID, ev->time_taken.hours, ev->time_taken.day, ev->time_taken.month, ev->time_taken.year, ev->room->number, ev->type, ev->info1, ev->info2, ev->info3, ev->desc, ((ev->next) ? "present" : "absent"));
  mudlog(buf, DBG, LVL_IMPL, TRUE);

  if (ev->type != EVENT_QUEST)
  {
    mudlog("SYSERR: Non-quest event passed to destroy_event_quest().",
	   NRM, LVL_IMPL, TRUE);
    return;
  }
  if (GET_NAME(ch))
  {
    send_to_char("You end the quest.\r\n", ch);
    sprintf(buf, "(GC) Quest '%s' ended by %s.", getQuestName(ev->info1), GET_NAME(ch));
  } else
    sprintf(buf, "Quest '%s' has ended.", getQuestName(ev->info1));
  mudlog(buf, BRF, LVL_GOD, TRUE);
  sprintf(buf, "&G- QUEST END '&g%s&G' -\r\n", getQuestName(ev->info1));
  send_to_all(buf);
  ev->type = EVENT_OVER;
  remove_mud_event(ev);
  return;
}

d6260 3
a6262 1
	case EVENT_QUEST:     destroy_event_quest(ch, ev);    return;
a6445 78
void create_quest_item_hunt(struct char_data *ch, char *arg)
{
  obj_vnum objv;
  struct event_data *ev;

  if (!*arg)
  {
    send_to_char("Just what item should the players be questing for!\r\n", ch);
    return;
  }
  if( !isdigit(arg[0]))
  {
    send_to_char("You must specify the vnum of the item to quest for.\r\n", ch);
    return;
  }

  half_chop(arg, buf1, buf2);
  objv = atoi(buf1);

  CREATE(ev, struct event_data, 1);
  ev->chID = GET_IDNUM(ch);
  ev->type = EVENT_QUEST;
  ev->room = &world[ch->in_room];
  ev->info1 = QUEST_ITEM_HUNT;
  ev->info2 = objv;

  add_mud_event(ev);

  if (!*buf2)
    sprintf(buf2, "Location: %s", zone_table[ev->room->zone].name);
  sprintf(buf1, "&G- QUEST NOTICE '&gItem hunt&G' -&g\r\n%s\r\n", buf2);
  send_to_all(buf1);
  sprintf(buf, "Item Hunt Quest initiated by %s.", GET_NAME(ch));
  mudlog(buf, BRF, LVL_GOD, TRUE);
  send_to_char("&GYou begin an item hunt quest.&n\r\n", ch);
}

void create_quest_pandoras_box(struct char_data *ch, char *arg)
{
  struct event_data *ev;

  CREATE(ev, struct event_data, 1);
  ev->chID = GET_IDNUM(ch);
  ev->type = EVENT_QUEST;
  ev->room = &world[ch->in_room];
  ev->info1 = QUEST_PANDORAS_BOX;
  
  add_mud_event(ev);

  if (!*buf2)
    sprintf(buf2, "Location: %s", zone_table[ev->room->zone].name);
  sprintf(buf1, "&G- QUEST NOTICE '&gPandoras Box&G' -&g\r\n Details: %s\r\n", buf2);
  send_to_all(buf1);

  sprintf(buf, "Pandoras Box Quest initiated by %s.", GET_NAME(ch));
  mudlog(buf, BRF, LVL_GOD, TRUE);
  send_to_char("&GYou begin a pandoras box quest.&n\r\n", ch);
}

void create_event_quest(struct char_data *ch, char *arg)
{
  //send_to_char("&r\r\nWarning : In progress.&n\r\n\r\n", ch);
  if (!*arg)
  {
    send_to_char("Quests currently available:\r\n"
		 "  - itemhunt\r\n"
		 "  - pandorasbox\r\n", ch);
    return;
  }	
  half_chop(arg, buf1, buf2);
  if(strcmp(buf1, "itemhunt") == 0)
    create_quest_item_hunt(ch, buf2);
  else if(strcmp(buf1, "pandorasbox") == 0)
    create_quest_pandoras_box(ch, buf2);
  else
    send_to_char("What kind of a quest is that?!\r\n", ch);
}

d6625 1
a6625 1
		   " | quest | election | fire | happyhr>\r\n",ch);
a6637 5
    if (is_abbrev(arg, "quest"))
    {
      create_event_quest(ch, buf2);
      return;
    }
d6654 1
a6654 1
		 " quest | election | fire> <statement(optional)>\r\n",ch);
@


1.89
log
@Artus> Debug Portals.
@
text
@d4458 1
a4458 1
    send_to_char("Quest On for who?\r\n", ch);
d4461 27
a4487 1
  if (!(vict = get_char_vis(ch, arg,FIND_CHAR_WORLD))) {
@


1.88
log
@Artus> Unholiness.
@
text
@d189 15
@


1.87
log
@Artus> Questoff All now actually removes the bit.
@
text
@d1412 1
a1412 1
    sprintf(buf, "Kills: Imm[&g%ld&n] By Imm[&g%ld&n] Mob[&g%ld&n] By Mob[&g%ld&n] PC[&g%ld&n] By PC[&g%ld&n]\r\n", 
d1414 2
a1415 1
	GET_KILLSBYMOB(k), GET_PCKILLS(k), GET_KILLSBYPC(k));
d3556 1
d4177 15
@


1.86
log
@Artus> Questoff All.
@
text
@d4449 1
a4449 1
  if (is_abbrev(arg, "all"))
d4458 1
@


1.85
log
@Artus> Cleanup.
@
text
@d4444 2
a4445 1
  if (!*arg) {
d4449 17
a4465 1
  if (!(vict = get_char_vis(ch, arg,FIND_CHAR_WORLD))) {
@


1.84
log
@Artus> Added "show hunts".
@
text
@d3020 2
a3021 1
      if (result && (!*reason || (strlen(reason) < 10))) {
d3032 2
a3033 1
      if (result) {
@


1.83
log
@Artus> Changes for object spells.
@
text
@d3205 1
d3208 2
a3209 1
  struct show_struct {
d3225 1
d3381 2
a3382 1
    for (d = descriptor_list; d; d = d->next) {
d3395 19
a3413 2
	list_events_to_char(ch, -1);
	break;
@


1.82
log
@Artus> Fixed colour bleed, removed excess brackets.
@
text
@d1516 4
a1519 2
  if (k->affected) {
    for (aff = k->affected; aff; aff = aff->next) {
d1521 2
a1522 1
      if( aff->duration == -1 ) {
d1524 4
a1527 2
        if (aff->modifier) {
          sprintf(buf2, "%+d to %s", aff->modifier, apply_types[(int) aff->location]);
d1530 9
a1538 2
      }
      else {
d1548 1
a1548 1
 
d1564 1
a1564 1
        } else {
d1567 1
a1567 1
        }    
@


1.81
log
@Artus> Now warning free :o)
@
text
@d5955 1
a5955 1
  sprintf(buf, "[ Fire in %s ended by %s. ]", zone_table[ev->room->zone].name, 
d6136 1
a6136 1
  send_to_all("&WHappy hour has been declared! DOUBLE EXP!!!\r\n");
@


1.80
log
@Artus> Fixed bugs in automated happy hours.
@
text
@d198 1
a198 1
    sprintf(buf, "RMSM_FLAGS(IN_ROOM(ch)): %d\r\n", RMSM_FLAGS(IN_ROOM(ch)),
d1322 1
a1322 1
    sprintf(buf, "Social Points: %d, Social Rank: %s\r\n", GET_SOCIAL_POINTS(k),
d1412 1
a1412 1
    sprintf(buf, "Kills: Imm[&g%d&n] By Imm[&g%d&n] Mob[&g%d&n] By Mob[&g%d&n] PC[&g%d&n] By PC[&g%d&n]\r\n", 
a2613 1
  char timestr[27] = "";
a2645 1
  char timestr[27] = "";
d2967 1
a2967 1
  long result;
d3153 1
a3153 1
	bufptr, zone_table[zone].hints);
d3193 1
a3193 1
  char field[MAX_INPUT_LENGTH], value[MAX_INPUT_LENGTH], birth[80];
a3530 1
  int cnum;
d4037 3
a4039 2
    GET_MODIFIER(vict) = race_modifiers[i] + class_modifiers[GET_CLASS(vict)]
	+ special_modifier(vict) + elitist_modifier(vict);
d4071 1
a4071 1
                        class_modifiers[GET_CLASS(vict)] +
a4271 2
  int mode, len, player_i = 0, retval;
  char is_file = 0, is_player = 0;
a4431 1
  extern char *spells[];
d4433 2
a4434 2
  int i, sortpos, spellnum, mana, is_file = FALSE;
  struct char_data *vict, *cbuf;
a4666 1
	struct obj_data *tmp;
d4729 2
a4730 3
  struct obj_data *qitem, *itemList[2048], *tmp;
  long qitemID;
  int itemcount, enhanced = 0, megacount = 0, i, j, k, found = 0;
d4851 1
a4851 1
  struct char_data *vict, *cbuf;
d4856 1
a4856 1
  int i, j, k, is_file=0, player_i = 0, found = 0, dot_mode, qsearch, value, 
d4858 1
d5367 1
a5367 1
    for( i = 0; i < num_of_houses; i++ ) {
d5378 1
a5378 1
    for (i = 0; i < megacount; i++) {
d5622 1
a5622 1
    sprintf(info, " for Race: &B%s&n (&rred&n is unmatched requirements)\r\n", 
d5625 1
a5625 1
    sprintf(info, "%s\r\n", info);
d5721 1
a5721 1
  int sort_index, class_index, sort_type, race_index = -1;
d5856 1
a5856 1
  sprintf(buf, "Election ended by %s (Results: #1: %d, #2: %d, #3: %ld)",
d5859 1
a5859 1
  sprintf(buf, "Official results of election - #1: %d, #2: %d, #3: %ld.\r\n",
a6176 1
  obj_vnum goldno;
d6383 1
a6383 1
		 "     %s%d, %s%d, %s%ld\r\n",
@


1.79
log
@Artus> Conditionals for IGNORE_DEBUG().
       Modifications to artus_in().
@
text
@d161 1
d175 1
d208 5
d220 1
a220 1
	      ev->chID, ev->time_taken.hours, ev->time_taken.day, ev->time_taken.month, ev->time_taken.year, ev->room->number, ev->type, ev->info1, ev->info2, ev->info3, ev->desc, ((ev->next) ? "present" : "absent"));
d5930 1
a5930 1
	  events.num_events, ev->chID, ev->time_taken.hours, ev->time_taken.day, ev->time_taken.month, ev->time_taken.year, ev->room->number, ev->type, ev->info1, ev->info2, ev->info3, ev->desc, ((ev->next) ? "present" : "absent"));
d6117 1
a6117 1
void create_event_happy(struct char_data *ch, char *arg)
a6119 1
  zone_rnum zone = world[IN_ROOM(ch)].zone;
d6128 2
d6132 2
a6134 1
    ev->chID = GET_IDNUM(ch);
d6136 2
a6138 1
    ev->chID = -1;
d6140 1
a6140 3
  ev->type = EVENT_HAPPY_HR;
  ev->info1 = 3600;
  ev->room = &world[IN_ROOM(ch)];
a6142 1
  mudlog(buf, NRM, LVL_GOD, TRUE); 
d6392 1
a6392 1
	    target, (ev->chID != -1 ? get_name_by_id(ev->chID) : "None"),
d6496 1
a6496 1
      create_event_happy(ch, buf2);
@


1.78
log
@Artus> Changed do_debug_cmd. Got rid of a bunch of obsolete options, added the
       ability to modify item damage for items in inventory.
@
text
@d164 1
d166 1
d168 1
d171 1
d180 1
d193 1
d4130 1
a4130 1
  // PKill Flag
d4633 1
a4633 7
    if ((IS_NPC(k)) || (k == ch) || (!CAN_SEE(k, ch)))
      continue;
    if (GET_LEVEL(k) < GET_LEVEL(ch))
    {
      GET_POS(k) = POS_SITTING;
      send_to_char("You kneel in awe as Artus materialises before you.\r\n",k);
      update_pos(k);
d4635 8
a4643 1
    send_to_char("You act unimpressed as Artus materialises before you.\r\n",k);
d6117 2
a6118 1
    send_to_char("Happy hour is already happening!\r\n", ch);
d6122 8
a6129 1
  ev->chID = GET_IDNUM(ch);
a6134 1
  sprintf(buf, "Happy hour initiated by %s.", GET_NAME(ch));
@


1.77
log
@Artus> Fixed crash bug in election end.
@
text
@d165 7
a171 1
    strcat(buf, "Debug Options: On, Off, AC, Stats\r\n");
d188 1
a188 14
  if (is_abbrev(arg1,"stats"))
  {
    sprintf(buf, "Str: &C%d/%d&n(&c%d/%d&n) Int: &C%d&n(&c%d&n) Wis: &C%d&n(&c%d&n) "
	  "Dex: &C%d&n(&c%d&n) Con: &C%d&n(&c%d&n) Cha: &C%d&n(&c%d&n)\r\n",
	  GET_AFF_STR(ch), GET_AFF_ADD(ch), GET_REAL_STR(ch), GET_REAL_ADD(ch), 
	  GET_AFF_INT(ch), GET_REAL_INT(ch), 
	  GET_AFF_WIS(ch), GET_REAL_WIS(ch), 
	  GET_AFF_DEX(ch), GET_REAL_DEX(ch), 
	  GET_AFF_CON(ch), GET_REAL_CON(ch), 
	  GET_AFF_CHA(ch), GET_REAL_CHA(ch));
    send_to_char(buf, ch);
    return;
  }
  if (is_abbrev(arg1,"sm"))
a199 7
  if (is_abbrev(arg1,"chsize"))
  {
    sprintf(buf, "&gDBG: sizes): %d/%d\r\n", sizeof(struct char_data), 
	    sizeof(struct char_file_u));
    send_to_char(buf, ch);
    return;
  }
d223 1
a223 3
#if 0
  // Artus> Temp stuff to find all obselete room flags.
  if (is_abbrev(arg1,"obs"))
d225 10
a234 2
    int found = 0;
    for (int i = 0; i <= top_of_world; i++)
d236 10
a245 37
      int tmpfl = world[i].room_flags;
      if (IS_SET(tmpfl, ROOM_LR_5))
      {
	sprintf(buf, "Room #%d has LR_5.\r\n", world[i].number);
	send_to_char(buf, ch);
	found++;
      }
      if (IS_SET(tmpfl, ROOM_LR_10))
      {
	sprintf(buf, "Room #%d has LR_10.\r\n", world[i].number);
	send_to_char(buf, ch);
	found++;
      }
      if (IS_SET(tmpfl, ROOM_LR_15))
      {
	sprintf(buf, "Room #%d has LR_15.\r\n", world[i].number);
	send_to_char(buf, ch);
	found++;
      }
      if (IS_SET(tmpfl, ROOM_LR_20))
      {
	sprintf(buf, "Room #%d has LR_20.\r\n", world[i].number);
	send_to_char(buf, ch);
	found++;
      }
      if (IS_SET(tmpfl, ROOM_LR_25))
      {
	sprintf(buf, "Room #%d has LR_25.\r\n", world[i].number);
	send_to_char(buf, ch);
	found++;
      }
      if (IS_SET(tmpfl, ROOM_LR_30))
      {
	sprintf(buf, "Room #%d has LR_30.\r\n", world[i].number);
	send_to_char(buf, ch);
	found++;
      }
d247 5
a251 29
    sprintf(buf, "Found %d buggy flags.\r\n", found);
    send_to_char(buf, ch);
    return;
  }
#endif
  if (is_abbrev(arg1,"ac"))
  {
    int armorclass = GET_AC(ch);
    send_to_char("Debugging: AC\r\n", ch);
    sprintf(buf, "%d (%s:%d)\n", armorclass, __FILE__, __LINE__);
    send_to_char(buf, ch);
    if (AWAKE(ch))
      armorclass += dex_app[GET_DEX(ch)].defensive;
    sprintf(buf, "%d (%s:%d)\n", armorclass, __FILE__, __LINE__);
    send_to_char(buf, ch);

    // Bonus to Armour Class if special  is set
    if ( !IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_SUPERMAN))
	armorclass -= (int)(armorclass * 0.10);
    sprintf(buf, "%d (%s:%d)\n", armorclass, __FILE__, __LINE__);
    send_to_char(buf, ch);

    armorclass = MAX(-200, armorclass);      /* -100 is lowest */
    sprintf(buf, "%d (%s:%d)\n", armorclass, __FILE__, __LINE__);
    send_to_char(buf, ch);
    armorclass += 5;
    armorclass /= 10;     /* -20 is lowest  */
    sprintf(buf, "%d (%s:%d)\n", armorclass, __FILE__, __LINE__);
    send_to_char(buf, ch);
@


1.76
log
@Artus> LR_FAIL -> !LR_FAIL .. Doh.
@
text
@d5898 1
a5898 1
	  events.num_events, ev->chID, ev->time_taken.hours, ev->time_taken.day, ev->time_taken.month, ev->time_taken.year, ev->room->number, ev->type, ev->info1, ev->info2, ev->info3, ev->desc, ((ev->next) ? "present" : "absent"));
d5921 1
a5921 1
	  events.num_events, ev->chID, ev->time_taken.hours, ev->time_taken.day, ev->time_taken.month, ev->time_taken.year, ev->room->number, ev->type, ev->info1, ev->info2, ev->info3, ev->desc, ((ev->next) ? "present" : "absent"));
@


1.75
log
@Artus> Immnet is now displayed correctly to remorts.
@
text
@d2939 1
a2939 1
    if ((STATE(d) == CON_PLAYING) && LR_FAIL_MAX(d->character, level) &&
@


1.74
log
@Artus> Added chsize option to debug command.
@
text
@d2937 3
a2939 2
  for (d = descriptor_list; d; d = d->next) {
    if ((STATE(d) == CON_PLAYING) && (GET_LEVEL(d->character) >= level) &&
@


1.73
log
@Added BACKWARD roomflag
Added DISPAIR environ flag
Added code for objects which make objects
@
text
@d207 7
d237 50
@


1.72
log
@\Artus> Mainly debug fixes.
@
text
@d18 2
d1108 37
@


1.71
log
@Artus> Added debug ev for events list, added debug syslog for finish of events.
@
text
@d5802 1
a5802 1
  mudlog(buf, DBG, 0, TRUE);
d5825 1
a5825 1
  mudlog(buf, DBG, 0, TRUE);
d5847 1
a5847 1
  mudlog(buf, DBG, 0, TRUE);
d5879 1
a5879 1
  mudlog(buf, DBG, 0, TRUE);
d5898 1
a5898 1
  mudlog(buf, DBG, 0, TRUE);
d5933 1
a5933 1
  mudlog(buf, DBG, 0, TRUE);
@


1.70
log
@Artus> Changed display of goldrush to include seconds running and bars
       generated.
@
text
@d200 5
d207 8
a214 1
    init_gold_rush();
d5800 3
d5823 3
d5828 2
a5829 2
    mudlog("Non curfew event passed to destroy_event_curfew().", NRM, LVL_IMPL,
	   TRUE);
d5845 4
d5851 2
a5852 2
    mudlog("Non goldrush event passed to destroy_event_goldrush().", NRM,
	   LVL_IMPL, TRUE);
d5877 3
d5896 3
d5931 4
@


1.69
log
@Artus> More massive changes to events.
@
text
@d6237 3
a6239 1
	info3 = info2 = info1 = "Unused: ";
@


1.68
log
@Artus> Changed set passwd to allow setting of anyone < your level, or anyone
       for ID 1.
       Added happy hour!
@
text
@d94 1
d5786 19
a5804 1
void destroy_event_election(struct char_data *ch) {
d5806 15
a5820 43
	struct event_data *ev;
	
	if( !check_for_event(EVENT_ELECTION, -1) ) {
		send_to_char("There is no election currently in progress.\r\n", ch);
		return;
	}

	for( ev = events.list; ev; ev = ev->next ) {
		if( ev->type != EVENT_ELECTION )
			continue;

		ev->type = EVENT_OVER;
		send_to_all("&gThe election has ended. Polling results.&n\r\n");
		sprintf(buf, "Election ended by %s ( #1: %d, #2: %d, #3: %ld ) ",
			GET_NAME(ch), ev->info1, ev->info2, ev->info3 );
		mudlog(buf, BRF, LVL_GOD, TRUE);
		break;
	}

	sprintf(buf, "Official results of election - #1: %d, #2: %d, #3: %ld.\r\n",
		ev->info1, ev->info2, ev->info3 );
	send_to_all(buf);
}

void destroy_event_curfew(struct char_data *ch) {

	struct event_data *ev;
	zone_rnum zone = world[ch->in_room].zone;

	for( ev = events.list; ev; ev=ev->next) {
		if( ev->type == EVENT_CURFEW ) {
			if( zone == ev->room->zone ){
				ev->type = EVENT_OVER;
				send_to_zone("\r\n&b[ Curfew has been lifted! ]&n\r\n", zone);
				sprintf(buf, "Curfew in %s lifted by %s.",
					zone_table[zone].name, GET_NAME(ch));
				mudlog(buf, BRF, LVL_GOD, TRUE);
				return;
			}
		}
	}

	send_to_char("No curfews have been imposed on this area.\r\n",ch);
d5823 2
a5824 1
void destroy_event_goldrush(struct char_data *ch)
d5826 25
a5850 17
  struct event_data *ev;
  zone_rnum zone = world[ch->in_room].zone;

  for (ev = events.list; ev; ev=ev->next)
    if ((ev->type == EVENT_GOLD_RUSH) && (zone == ev->room->zone))
    {
      ev->type = EVENT_OVER;
      send_to_zone("\r\n&y[ The gold rush has ended. ]&n\r\n", zone);
      sprintf(buf, "&WYou hear rumours that the gold rush at %s has "
		   "ended.&n\r\n", zone_table[zone].name);
      send_to_not_zone_world(buf, zone);
      sprintf(buf, "Goldrush in %s ended by %s.",
	      zone_table[zone].name, GET_NAME(ch));
      mudlog(buf, NRM, LVL_GOD, TRUE);
      return;
    }
  send_to_char("No goldrushes found to end.\r\n", ch);
d5853 1
a5853 1
void destroy_event_happy(struct char_data *ch)
d5855 12
a5866 10
  struct event_data *ev;
  for (ev = events.list; ev; ev=ev->next)
    if (ev->type == EVENT_HAPPY_HR)
    {
      ev->type = EVENT_OVER;
      send_to_all("&WHappy hour is now over, kiddies.&n\r\n");
      sprintf(buf, "Happy hour ended by %s.", 
	      ((ch) ? GET_NAME(ch) : "grumpiness."));
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
d5869 1
a5869 2

void destroy_event_fire(struct char_data *ch, zone_rnum zone)
d5871 13
a5883 13
  struct event_data *ev;
  for (ev = events.list; ev; ev=ev->next)
    if ((ev->type == EVENT_FIRE) && (zone == ev->room->zone))
    {
      ev->type = EVENT_OVER;
      send_to_zone("&y[ The fire is finally under control. ]&n\r\n", zone);
      sprintf(buf, "&WYou hear rumours that the fire at %s has been"
		   "extinguished.&n\r\n", zone_table[zone].name);
      send_to_not_zone_world(buf, zone);
      sprintf(buf, "Fire in %s ended by %s.",
	      zone_table[zone].name, ((ch) ? GET_NAME(ch) : "lack of fuel."));
      mudlog(buf, NRM, LVL_GOD, TRUE);
    }
d5885 1
a5885 1
    if (world[room].zone == zone)
d5887 2
d5893 6
a5898 6
	switch(nQuestType)
	{
		case QUEST_ITEM_HUNT:			return "Item hunt";
		case QUEST_PANDORAS_BOX:		return "Pandoras box";
		default:				return "unknown";
	}
d5901 21
a5921 1
void destroy_event_quest(struct char_data *ch, char *buf2) {
d5923 35
a5957 31
	struct event_data *ev;
	int questnum, ncounter = 0, nFound = 0;

	if (!isdigit(buf2[0]))
	{
		send_to_char("You need to specify which quest number to destroy.\r\n", ch);
		return;
	}

	questnum = atoi(buf2);

	for( ev = events.list; ev; ev=ev->next) {
		if( ev->type == EVENT_QUEST ) {
			ncounter++;
			if (ncounter == questnum)
			{
				nFound = 1;
				ev->type = EVENT_OVER;
				send_to_char("You end the quest.\r\n", ch);
				sprintf(buf, "Quest #%d ended by %s.", questnum, GET_NAME(ch));
				mudlog(buf, BRF, LVL_GOD, TRUE);
				sprintf(buf, "&G- QUEST END '&g%s&G' -\r\n", getQuestName(ev->info1));
				send_to_all(buf);
				return;
			}
		}
	}
	
	if (nFound == 0)
		send_to_char("That quest does not exist.\r\n", ch);
	
d5959 2
d5962 8
a5969 1
void create_event_election(struct char_data *ch, char *arg) {
d5971 5
a5975 7
	struct event_data *ev = NULL;
	struct descriptor_data *d;
	
	if( check_for_event(EVENT_ELECTION, -1) ) {
		send_to_char("There's already an election going on. Wait for the poll.\r\n",ch);
		return;
	}
d5977 2
a5978 4
	// Every player currently online, may vote
	for( d = descriptor_list; d; d = d->next ) {
		if( STATE(d) != CON_PLAYING)
			continue;
d5980 7
a5986 2
		GET_VOTED(d->character) = FALSE;
	}
d5988 1
a5988 7
	CREATE(ev, struct event_data, 1);
	ev->chID = GET_IDNUM(ch);
	ev->room = NULL;
	ev->type = EVENT_ELECTION;
	ev->info1 = 0;
	ev->info2 = 0;
	ev->info3 = 0;
d5990 9
a5998 11
	add_mud_event(ev);

	if (*arg)
	{
	    sprintf(buf1, "&G-ELECTION NOTICE-&g\r\n%s\r\n", arg); 
	    send_to_all(buf1);
	}	
	sprintf(buf, "&gThe election has begun.\r\n&nType 'vote <number>' to register your vote.\r\n");
	send_to_all(buf);
	sprintf(buf, "Election initiated by %s", GET_NAME(ch) );
	mudlog(buf, BRF, LVL_GOD, TRUE);
d6001 2
a6002 1
void create_event_curfew(struct char_data *ch, char *arg) {
d6004 2
a6005 2
	struct event_data *ev = NULL;
	zone_rnum zone = world[ch->in_room].zone;
d6007 5
a6011 4
	if( check_for_event(EVENT_CURFEW, zone) ) {
		send_to_char("Curfew has already been imposed on this part of the land.\r\n",ch);
		return;
	}
d6013 5
a6017 5
	CREATE(ev, struct event_data, 1);
	ev->chID = GET_IDNUM(ch);
	ev->type = EVENT_CURFEW;
	ev->room = &world[ch->in_room];
	ev->info3 = get_id_by_name(GET_NAME(ch));
d6019 1
a6019 1
	add_mud_event(ev);
d6021 10
a6030 11
	// Let those in the zone know
	if (*arg)
	{
	    sprintf(buf1, "&G-CURFEW NOTICE-&g\r\n%s\r\n", arg);
	    send_to_zone(buf1, zone);
	}
	send_to_zone("&R\r\n[ Curfew has been imposed in this area. Seek shelter at night. ]&n\r\n", zone);
	// Log the event
	sprintf(buf, "Curfew imposed by %s within %s.", GET_NAME(ch), zone_table[zone].name);
	mudlog(buf, BRF, LVL_GOD, TRUE); 
	
d6092 2
d6120 2
a6121 2
	obj_vnum objv;
	struct event_data *ev;
d6123 10
a6132 4
	if (!*arg) {
		send_to_char("Just what item should the players be questing for!\r\n", ch);
		return;
	}
d6134 2
a6135 4
	if( !isdigit(arg[0])) {
		send_to_char("You must specify the vnum of the item to quest for.\r\n", ch);
		return;
	}
d6137 6
a6142 3
	half_chop(arg, buf1, buf2);
	
	objv = atoi(buf1);
d6144 1
a6144 6
	CREATE(ev, struct event_data, 1);
	ev->chID = GET_IDNUM(ch);
	ev->type = EVENT_QUEST;
	ev->room = &world[ch->in_room];
	ev->info1 = QUEST_ITEM_HUNT;
	ev->info2 = objv;
d6146 7
a6152 12
	add_mud_event(ev);

	if (!*buf2)
	{
		sprintf(buf2, "Location: %s", zone_table[ev->room->zone].name);
	}
	sprintf(buf1, "&G- QUEST NOTICE '&gItem hunt&G' -&g\r\n%s\r\n", buf2);
	send_to_all(buf1);
	sprintf(buf, "Item Hunt Quest initiated by %s.", GET_NAME(ch));
	mudlog(buf, BRF, LVL_GOD, TRUE);
	send_to_char("&GYou begin an item hunt quest.&n\r\n", ch);
	
d6157 1
a6157 1
	struct event_data *ev;
d6159 7
a6165 7
	CREATE(ev, struct event_data, 1);
	ev->chID = GET_IDNUM(ch);
	ev->type = EVENT_QUEST;
	ev->room = &world[ch->in_room];
	ev->info1 = QUEST_PANDORAS_BOX;
	
	add_mud_event(ev);
d6167 4
a6170 10
	if (!*buf2)
	{
		sprintf(buf2, "Location: %s", zone_table[ev->room->zone].name);
	}
	sprintf(buf1, "&G- QUEST NOTICE '&gPandoras Box&G' -&g\r\n Details: %s\r\n", buf2);
	send_to_all(buf1);

	sprintf(buf, "Pandoras Box Quest initiated by %s.", GET_NAME(ch));
	mudlog(buf, BRF, LVL_GOD, TRUE);
	send_to_char("&GYou begin a pandoras box quest.&n\r\n", ch);
d6172 3
d6177 17
a6193 21
void create_event_quest(struct char_data *ch, char *arg) {

	//send_to_char("&r\r\nWarning : In progress.&n\r\n\r\n", ch);

	if (!*arg)
	{
		send_to_char("Quests currently available:\r\n"
			"  - itemhunt\r\n"
			"  - pandorasbox\r\n", ch);
		return;
	}	

	half_chop(arg, buf1, buf2);
	
	if(strcmp(buf1, "itemhunt") == 0)
		create_quest_item_hunt(ch, buf2);
	else if(strcmp(buf1, "pandorasbox") == 0)
		create_quest_pandoras_box(ch, buf2);
	else
		send_to_char("What kind of a quest is that?!\r\n", ch);
	
d6198 13
a6210 12
	struct event_data *ev;
	char *target, *type, *info1, *info2, *info3, *roomdesc, *room;
	int evcounter = 0, found = FALSE;

	for( ev = events.list; ev; ev = ev->next ) {
		evcounter++;
		if( specific != evcounter && specific != -1 )
			continue;
		if( specific != -1 )
			found = TRUE;
		if( ev->type == EVENT_OVER )
			continue;
d6212 81
a6292 85
		switch(ev->type) {
			case EVENT_BURGLARY:
				target = "Burglar: ";
				type = "&rBurglary&n";
				roomdesc = "First room: ";
				room = ev->room->name;
				info1 = "Codes: ";
				info2 = "Direction: ";
				info3 = "Loot so far: ";
				break;
			case EVENT_BOUNTY_HUNT:
				target = "Victim: ";
				type = "&bBounty Hunt&n";
				roomdesc = "Return to: ";
				room = ev->room->name;
				info1 = "Reward: ";
				info2 = "Bounty ID: ";
				info3 = "Initiator ID: ";
				break;
			case EVENT_GOLD_RUSH:
				target = "Initiator: ";
				type = "&yGold rush&n";
				roomdesc = "Sampled room: ";
				room = ev->room->name;
				info1 = "Unused: ";
				info2 = info1;
				info3 = info2;
				break;
			case EVENT_FIRE:
				target = "Firebug: ";
				type = "&rFIRE!&n";
				roomdesc = "Sampled room: ";
				room = ev->room->name;
				info1 = "Unused: ";
				info2 = info1;
				info3 = info2;
				break;
			case EVENT_CURFEW:
				target = "Initiated by: ";
				type = "&RCurfew&n";
				roomdesc = "Sampled room: ";
				room = ev->room->name;
				info1 = info2 = "Unused: ";
				info3 = "Initiator ID: ";
				break;
			case EVENT_ELECTION:
				target = "Initiated by: ";
				type = "&BElection &n";
				roomdesc = "Room: ";
				room = "N/A";
				info1 = "Votes for #1: ";
				info2 = "Votes for #2: ";
				info3 = "Votes for #3: ";
				break;
			case EVENT_QUEST:
				target = "Created by: ";
				type = "&GQuest&n";
				roomdesc = "Sampled room: ";
				room = ev->room->name;
				info1 = "Quest Type: ";
				info2 = "Sample: ";
				info3 = "Reward: ";
				break;
			case EVENT_HAPPY_HR:
				target = "Created By: ";
				type = "&GHappy Hour&n";
				roomdesc = "Room: ";
				room = "N/A";
				info1 = "Seconds Remaining: ";
				info2 = "Unused: ";
				info3 = info2;
				break;
			default:
				target = "Character: ";
				type = "Other";
				roomdesc = "Roomname: ";
				if( ev->room != NULL )
					room = ev->room->name;
				else
					room = "N/A";
				info1 = "Info1: ";
				info2 = "Info2: ";
				info3 = "Info3: "; 
				break;				
		}
d6294 10
a6303 10
		sprintf(buf, "&g(%2d)&n %s\r\n"
			"     %s%s\r\n"
			"     %s%d - %s\r\n"
			"     %s%d, %s%d, %s%ld\r\n",
			evcounter, type, 
			target, (ev->chID != -1 ? get_name_by_id(ev->chID) : "None"),
			roomdesc, ev->room != NULL ? ev->room->number : -1, room,
			info1, ev->info1, info2, ev->info2, info3, ev->info3); 			    
		send_to_char(buf, ch);
	}
d6305 13
a6317 12
	// Sort out an appropriate message 
	if( specific != -1 )
		if( !found )
			sprintf(buf, "That event does not exist!\r\n");
		else
			sprintf(buf, "&gEvent found.&n\r\n");
	else
		if( evcounter != 0 )
          		sprintf(buf, "&g%d event%s listed.&n\r\n", evcounter, evcounter == 1 ? "" : "s");
		else
			sprintf(buf, "No events exist.\r\n");
	send_to_char(buf, ch);		
d6319 9
a6327 9
 	if (burglaries != NULL)
	  send_to_char("&RBurglaries-&n\r\n", ch);
	// List burglaries 
	Burglary *tmpBurglary = burglaries;
	while (tmpBurglary != NULL)
	{
	   tmpBurglary->DescribeSelf(ch);
	   tmpBurglary = tmpBurglary->next;
	}
d6333 1
a6333 1
  if(IS_NPC(ch)) 
d6339 1
a6339 1
  if(!*arg)
d6347 1
a6347 1
  if(is_abbrev(arg, "list")) 
d6349 1
a6349 1
    if( !*buf1 ) 
d6358 1
a6358 1
    if( atoi(buf1) < 1 )
d6367 1
a6367 1
  if(is_abbrev(arg, "create")) 
d6370 1
a6370 1
    if( !*arg ) 
d6376 1
a6376 1
    if(is_abbrev(arg, "curfew"))
d6381 1
a6381 1
    if(is_abbrev(arg, "goldrush"))
d6386 1
a6386 1
    if(is_abbrev(arg, "quest"))
d6411 1
a6411 1
  if(is_abbrev(arg, "destroy")) 
d6414 8
d6463 1
a6464 1

@


1.67
log
@Artus> Debug ch, mod to artus_in.
@
text
@d3777 1
a3777 1
/*
d3782 3
a3784 1
 */ if (GET_LEVEL(vict) >= LVL_GRGOD) {
d3788 7
d5779 1
a5779 1
void add_event(struct event_data *ev);
d5847 1
a5847 1
      mudlog(buf, BRF, LVL_GOD, TRUE);
d5853 15
d5881 1
a5881 1
      mudlog(buf, BRF, LVL_GOD, TRUE);
d5959 1
a5959 1
	add_event(ev);
d5988 1
a5988 1
	add_event(ev);
d6003 22
d6049 1
a6049 1
  add_event(ev);
d6075 1
a6075 1
  add_event(ev);
d6112 1
a6112 1
	add_event(ev);
d6136 1
a6136 1
	add_event(ev);
d6252 9
d6353 1
a6353 1
		   " | quest | election | fire>\r\n",ch);
d6381 5
d6410 5
@


1.66
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d204 11
d4572 2
a4573 1
      send_to_char("You kneel in awe as Artus arrives before you.\r\n",k);
@


1.65
log
@Artus> Moving stuff across to live.

act.informative.c:
  Info on it's own will now display the info file. Use me or self to see your
own info.
  Score and Exp now both show gained and remaining exp.
  Gold value is now to a max of 30000. (60000 in lvl 40+ zones, 120 in 70+)
  Gold rushes no longer occur in !GOLDRUSH zones, city sectors, etc.

act.other.c:
  Mana retained on remort is now floored at 100 instead of 50.
  Added elitist bonus for chars who play past the earliest remort point(s).

act.wizard.c:
  Gold rush events are now only advertised within the world they occur.

genolc.h:
  Added special #defines for different OLC levels whether running live or test.
  (Noted by compiling with -DPRIMAL_LIVE)

interpreter.c:
  Aliases will now be saved automatically, when added or remoed.
  Added elitist_modifier() to modifier calculation.
  Replaced Huh?!? with HUH.

limits.c:
  NPC corpses are no longer emptied before they are purged. Too much clutter.

spells.c:
  Reduced the amount of weight applied by create water to 1/3 of what it was.

comm.c:       Added send_to_not_zone_world()
db.c:         Added elitist_modifier() to modifier calculation.
dg_mobcmd.c:  Replaced Huh?!? with the define, HUH.
dg_scripts.h: Changed version string so it will fit on one line :o)
fight.c:      Eq should no longer be damaged when a hit fails.
handler.c:    Now, when the sleep spell wears of an NPC, it will wake up.
structs.h:    Added HUH define.
utils.c:      Added elitist_modifier() calculation.
utils.h:      Added elitist_modifier() prototype.
@
text
@d143 1
d192 7
d299 2
a300 1
  if (!*roomstr) {
d304 2
a305 1
  if (isdigit(*roomstr) && !strchr(roomstr, '.')) {
d307 2
a308 1
    if ((location = real_room(tmp)) < 0) {
d327 4
a330 2
  if (GET_LEVEL(ch) < LVL_GRGOD) {
    if (ROOM_FLAGGED(location, ROOM_GODROOM)) {
d335 2
a336 1
	world[location].people && world[location].people->next_in_room) {
d341 2
a342 1
	!House_can_enter(ch, GET_ROOM_VNUM(location))) {
d372 4
a375 3
  if(world[location].number >= 500 && world[location].number <= 599 &&
     GET_LEVEL(ch) < LVL_GOD) {
  send_to_char("As you fly through time and space towards the reception area\r\n"
d378 1
a378 2
    }
         
d387 2
a388 1
  if (ch->in_room == location) {
d404 4
a407 3
  if (PRF_FLAGGED(ch, PRF_MORTALK) && GET_LEVEL(ch)<LVL_GOD){
        send_to_char("You cannot goto out of mortalk arena.  Use Recall!\r\n", ch);
        return;
d465 4
a468 3
  if(world[location].number >= 500 && world[location].number <= 599 &&
     GET_LEVEL(ch) < LVL_GOD) {
  send_to_char("As you fly through time and space towards the reception area\r\n"
d471 1
a471 1
    }
d477 2
a478 1
  if ((zone_table[world[location].zone].number == CLAN_ZONE) && (GET_LEVEL(ch) < LVL_CLAN_GOD))
d499 1
a499 1
  if (GET_LEVEL(ch) <= LVL_ANGEL) {
a500 1
  }
d504 4
d509 5
a513 9
    if (!strcmp(ch->player.name, "Cassandra"))
      cassandra_in(ch);
    else { 

      if (POOFIN(ch))
        sprintf(buf, "&7$n&n %s", POOFIN(ch));
      else
        strcpy(buf, "&7$n&n appears with an ear-splitting bang.");
  
d515 1
a515 1
    }
d2723 1
a2723 1
      if (level > GET_LEVEL(ch)) {
d4539 1
a4539 1
  fp = open("/primal/lib/text/cassandra.poofin", O_RDONLY);
d4552 16
d4780 1
a4780 1
  bool mortal = (GET_LEVEL(ch) < LVL_GOD) ? TRUE : FALSE;
d5653 4
a5656 1
    if (GET_LEVEL(ch) >= LVL_IMMORT) {
d5658 1
a5658 5
                   "                 [racename] [ <sort type> ]\r\n", CMD_NAME);
    } else {
      sprintf(buf,"&1Usage: &4%s &n<classname> [racename] [ <sort type> ]\r\n",
                      CMD_NAME);
    }
d5726 2
a5727 1
    if (GET_LEVEL(ch) < LVL_IMMORT) {
d5733 2
a5734 1
    if ((spellnum = find_skill_num(spellname)) == -1) { 
d5811 4
a5814 1
void destroy_event_goldrush(struct char_data *ch) {
d5816 15
a5830 2
	struct event_data *ev;
	zone_rnum zone = world[ch->in_room].zone;
d5832 18
a5849 17
	for( ev = events.list; ev; ev=ev->next) {
		if( ev->type == EVENT_GOLD_RUSH ) {
			if( zone == ev->room->zone ){
				ev->type = EVENT_OVER;
				send_to_zone("\r\n&y[ The gold rush has ended. ]&n\r\n", zone);
				sprintf(buf, "&WYou hear rumours that the gold rush at %s has "
					     "ended.&n\r\n", zone_table[zone].name);
				send_to_not_zone_world(buf, zone);
				sprintf(buf, "Goldrush in %s ended by %s.",
					zone_table[zone].name, GET_NAME(ch));
				mudlog(buf, BRF, LVL_GOD, TRUE);
				return;
			}
		}
	}

	send_to_char("No goldrushes found to end.\r\n", ch);
d5967 4
a5970 1
void create_event_goldrush(struct char_data *ch, char *arg) {
d5972 33
a6004 2
	struct event_data *ev;
	zone_rnum zone = world[ch->in_room].zone;
d6006 5
a6010 4
	if( check_for_event(EVENT_GOLD_RUSH, zone) ) {
		send_to_char("There's already a gold rush in this part of the land.\r\n",ch);
		return;
	}
d6012 4
a6015 4
	CREATE(ev, struct event_data, 1);
	ev->chID = GET_IDNUM(ch);
	ev->type = EVENT_GOLD_RUSH;
	ev->room = &world[ch->in_room];
d6017 1
a6017 1
	add_event(ev);
d6019 7
a6025 7
	// Register the event
	sprintf(buf, "&Y[ A GOLD RUSH has just started in %s! ]&n\r\n", zone_table[zone].name);
	send_to_zone(buf, zone);
	sprintf(buf, "&WYou hear rumours of a gold rush at %s!&n\r\n", zone_table[zone].name);
	send_to_not_zone_world(buf, zone);
	sprintf(buf, "Gold rush initiated by %s at %s.", GET_NAME(ch), zone_table[zone].name);
	mudlog(buf, BRF, LVL_GOD, TRUE);
d6116 2
a6117 2
void list_events_to_char(struct char_data *ch, int specific) {

d6159 9
d6244 4
a6247 1
ACMD(do_event) {
d6249 2
a6250 5
	if( IS_NPC(ch) ) 
		return;

	half_chop(argument, arg, buf1);
	//two_arguments(argument, arg, buf1);
d6252 5
a6256 4
	if( !*arg ) {
		send_to_char("Usage: event <list [event #] | create | destroy>\r\n", ch);
		return;
	}
d6258 1
a6258 1
	arg[0] = LOWER(arg[0]);
d6260 19
a6278 8
	if(is_abbrev(arg, "list")) {
		if( !*buf1 ) {
		   list_events_to_char(ch, -1);
		   return;
		}
		else if( ! isdigit(buf1[0]) ) {
			send_to_char("You may either list a single event, or all.\r\n"
				     "Usage: event <list | list #>\r\n", ch);
d6280 38
a6317 9
			return;
		}
		if( atoi(buf1) < 1 ) {
			send_to_char("You must specify a positive event number!\r\n", ch);
			return;
		}
		list_events_to_char(ch, atoi(buf1));
		return;
	}
d6319 39
a6357 56
	if(is_abbrev(arg, "create")) {
		half_chop(buf1, arg, buf2);
		if( !*arg ) {
			send_to_char("Usage: event create <curfew | goldrush"
			" | quest | election>\r\n",ch);
			return;
		}
		if(is_abbrev(arg, "curfew")) {
			create_event_curfew(ch, buf2);			
			return;
		}
		if(is_abbrev(arg, "goldrush")) {
			create_event_goldrush(ch, buf2);
			return;
		}
		if(is_abbrev(arg, "quest")) {
			create_event_quest(ch, buf2);
			return;
		}
		if(is_abbrev(arg, "election")) {
			create_event_election(ch, buf2);
			return;
		}
		send_to_char("Usage: event create <curfew | goldrush |"
			    " quest | election> <statement(optional)>\r\n",ch);
		return;
  	}

	if(is_abbrev(arg, "destroy")) {
		half_chop(buf1, arg, buf2);
		if( !*arg ) {
			send_to_char("Usage: event destroy <curfew | goldrush |" 
				     " quest | election>\r\n",ch);
			return;
		}
		if(is_abbrev(arg, "curfew")) {
			destroy_event_curfew(ch);
			return;
		}
		if(is_abbrev(arg, "goldrush")) {
			destroy_event_goldrush(ch);
			return;
		}
		if(is_abbrev(arg, "quest")) {
			destroy_event_quest(ch, buf2);
			return;
		}
		if(is_abbrev(arg, "election")) {
			destroy_event_election(ch);
			return;
		}
		send_to_char("Usage: event destroy <curfew | goldrush |"
			     " quest | election>\r\n",ch);
		return;
	}
	send_to_char("That is NOT a valid option!\r\n", ch);
@


1.64
log
@Artus>
\r\n appended to gold rush message: act.informative.c

Imms no longer affected by underwater: act.movement.c, limits.c

Changed remort some more.. New special, tracker (SPECIAL_TRACKER):
act.other.c, act.wizard.c, constants.c, graph.c, structs.h, utils.c

Object and Room triggers can now %send% <room vnum> <message>:
dg_objcmd.c, dg_wldcmd.c

%self.direction% now has a vnum subfield to return the exit room's vnum.
(Eg: %self.north(vnum)%): dg_scripts.c

%actor.hisher%, %actor.himher%, %actor.heshe% implemented: dg_scripts.c

vnum, name, can_see, can_see_me added to %actor.next_in_room%, returning char
vnum, char name, if actor can see char, and if char can see actor respectively:
dg_scripts.c

Changed "do not know that spell" to "do not know of that spell": spell_parser.c

Changed "do not of know that skill/spell" to "do not know of..": utils.c

SECT_UNDERWATER and SECT_INSIDE now checked in OUTSIDE() macro: utils.h
@
text
@d88 1
a88 1
void send_to_not_zone(const char *msg, zone_rnum zone);
d156 2
d191 5
d1752 1
a1752 1
  else if ((GET_LEVEL(ch) < GET_LEVEL(victim)) || (!IS_NPC(victim) && GET_IDNUM(victim) == 1))
d3141 1
a3141 1
  if (GET_IDNUM(ch) != 1) {
d3449 1
a3449 1
  if (GET_IDNUM(ch) != 1) {
d3661 1
a3661 1
    if (GET_IDNUM(ch) >= 3) {
d3699 1
a3699 1
	special_modifier(vict); 
d3743 1
a3743 1
    if (GET_IDNUM(ch) != 1 || !IS_NPC(vict))
d3939 1
a3939 1
	+ special_modifier(vict);
d3972 2
a3973 1
			special_modifier(vict);
d4007 1
a4007 1
    if (GET_IDNUM(ch) < 3) {
d4024 1
a4024 1
    if (GET_IDNUM(ch) < 3) {
d5788 1
a5788 1
				send_to_not_zone(buf, zone);
d5936 1
a5936 1
	send_to_not_zone(buf, zone);
@


1.63
log
@Artus> Imms no longer affected by hot/cold/etc.
       Debug no longer available to mortals, can be set though.
       Fixed buffer overflow in proc_color.
       Stops processing get_from_container when arms full.
       Changed the way remort abilities are listed.
@
text
@d3316 1
@


1.62
log
@Artus> Changed remort, in particular, list remort abilities to char.. Also,
       spellsword was incorrectly being listed as a possible path for a
       warrior.

       Replaced #ifdef USE_LOCALTIME with #ifndef NO_LOCALTIME..

       Added define NOTELL_SOUNDPROOF .. Define this to stop people telling
       to/from soundproof rooms.

       Removed extraneous level checking from do_wear.. This is handled
       better by perform_wear.
@
text
@d3420 1
d4026 5
@


1.61
log
@Artus>
---
drop_otrigger takes an extra paramater for subcmd. With drop triggers you can
now specify whether the trigger is for drop, junk, donate and put. Specify
in the argument either/combination of 'junk', 'drop', 'donate', 'put'. No
argument means any type will be triggered:

act.item.c, dg_scripts.h, dg_triggers.c, interpreter.h
---
fixed colour bleed in dc:

act.wizard.c
---
Not reapplying empty timers in char_to_store:
Not calling object triggers from char_to_store:

db.c
---
Modified hunt so that with special_elf you can track through !TRACK rooms
(Modifier for Elf has been increased from 0.02 to 0.07%):

graph.c, utils.c
---
Timers should only show remove messages when being removed because they're
wearing off (duration = 0):

handler.c
---
Not calling object triggers when auto_equipping.

objsave.c
---
#defined around love_ring specproc. What a joke. define DRAX_IS_TEH_SUXOR if
you want it back ;o)

spec_assign.c, spec_procs.c
---
@
text
@d1073 1
a1073 1
#ifndef USE_LOCALTIME
d1148 1
a1148 1
#ifdef USE_LOCALTIME
d2470 1
a2470 1
#ifdef USE_LOCALTIME
@


1.60
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@d2379 1
a2379 1
    send_to_char("&4Usage: &1dc <user number> (type USERS for a list)\r\n", ch);
@


1.59
log
@Artus>>
Breakin: him/her -> he/she.
Remort: Now updates wimpy.
Show Snoop: Fixed colour bleed.
do_simple_move: Now displays failure messages.
House_boot: Now subtracts subtracts objects from obj_index.number when loading
            objs into houses.. Fixes issue where objs in houses were preventing
	    that obj from being created in the game where zone command Max: 1.
@
text
@d1154 2
a1155 2
      log("Error in jk_localtime (birth: %d) [%s:%d]\n", k->player.time.birth,
	  __FILE__, __LINE__);
d1162 2
a1163 2
      log("Error in jk_localtime (birth: %d) [%s:%d]\n", k->player.time.logon,
	  __FILE__, __LINE__);
d1636 1
a1636 1
    log("(GC) Shutdown by %s.", GET_NAME(ch));
d1640 1
a1640 1
    log("(GC) Shutdown NOW by %s.", GET_NAME(ch));
d1645 1
a1645 1
    log("(GC) Reboot by %s.", GET_NAME(ch));
d1650 1
a1650 1
    log("(GC) Shutdown by %s.", GET_NAME(ch));
d1655 1
a1655 1
    log("(GC) Shutdown by %s.", GET_NAME(ch));
d2069 1
a2069 1
//    log("(GC) %s demoted %s from level %d to %d.",
d2072 1
a2072 1
//    log("(GC) %s has advanced %s to level %d (from %d)",
d2426 1
a2426 1
    log("(GC) Connection closed by %s.", GET_NAME(ch));
d2488 1
a2488 1
    log("Error in jk_localtime (mytime: %ld) [%s:%d]", mytime, __FILE__, __LINE__);
d2891 1
a2891 1
      log("(GC) %s has rerolled %s.", GET_NAME(ch), GET_NAME(vict));
d3015 1
a3015 1
      log("SYSERR: Unknown subcmd %d passed to do_wizutil (%s)", subcmd, __FILE__);
d4334 1
a4334 1
    log("skillshow: no arg, vict=ch");
d4341 1
a4341 1
      log("skillshow: loaded player %s from disk", GET_NAME(cbuf));
d4350 1
a4350 1
      log("skillshow: no player found");
d5281 1
a5281 1
    log("SYSERR: invalid race (%d) class (%d) spellnum (%d) to "
d5287 1
a5287 1
    log("SYSERR: unused spellnum (%d) passed to " 
d5363 1
a5363 1
    log("SYSERR: invalid sort_type passed to print_spells");
d5368 1
a5368 1
    log("SYSERR: no class or race index to print_spells");
d5386 1
a5386 1
    log("SYSERR: Invalid race (%d) or class (%d) passed to print_spells", 
d5471 1
a5471 1
    log("SYSERR: Invalid spellnum (%d) passed to print_spell_info", 
d5477 1
a5477 1
    log("SYSERR: Unused spellnum (%d) passed to print_spell_info", 
d5483 1
a5483 1
    log("SYSERR: Invalid race number (%d) passed to print_spell_info", 
@


1.58
log
@Artus> Doesn't seem to make much difference whether we use localtime() or
       not anymore... At least now, commands like date aren't crashing with
       localtime defined..

       Have moved all of the ctime_r() calls to asctime(localtime())...

       Doubt this will fix the prob... But I haven't had it happen since
       changing it...
@
text
@d3267 1
a3267 1
    send_to_char("&1--------------------------\r\n", ch);
d3275 1
a3275 1
      sprintf(buf + strlen(buf), "%-10s - snooped by %s.\r\n",
@


1.57
log
@Artus> Major bugfix in char_can_enter() -- Was using room flags instead of
       zone flags..

       Also major bugfix in do_go() -- Was preventing level > 0 entering when
       level max was set to 0..

       Added sanity checking to a couple of dgscript functions which were
       passing a pointer to strcat() and not first checking whether the
       pointer was valid..
@
text
@d2534 2
a2535 1
	  ctime_r(&chdata.player_specials_primalsaved.last_logon, timestr));
d2540 2
a2541 1
	  (chdata.player_specials_primalsaved.lastUnsuccessfulLogon < 1) ?  "None\r\n" : ctime_r(&chdata.player_specials_primalsaved.lastUnsuccessfulLogon, timestr));
d2566 2
a2567 1
    ctime_r(&chdata.player_specials_primalsaved.last_logon, timestr));
a3178 1
    ctime_r(&vbuf.birth, birth);
d3181 4
a3184 2
	    ctime_r(&vbuf.birth, birth),
	    ctime(&vbuf.player_specials_primalsaved.last_logon), 
@


1.56
log
@Artus> Changes to do_simple_move().
       Added char_can_enter() -- Tests room levels, zone levels, water/fly/etc.

       Changes to die(): Exp lost is now whichever is lesser of half earned
       exp and quater max exp. When autocorpse, instead of doubling it, we
       multiply by 1.5.

       pc killed by char now logged in die(), with lost_exp display.

       gain_exp now returns the amount of exp that was gained rather than void.
@
text
@d738 2
a739 1
      strcat(buf, desc->keyword);
d942 2
a943 1
      strcat(buf, desc->keyword);
d2546 1
d2564 1
a2564 1
    ctime(&chdata.player_specials_primalsaved.last_logon));
d3176 1
a3176 1
    strcpy(birth, ctime(&vbuf.birth));
d3179 2
a3180 1
	    birth, ctime(&vbuf.player_specials_primalsaved.last_logon), 
@


1.55
log
@Artus> Sorry, Dish.. Another bastard change..

       has_stats_for_skill now takes an extra arg (bool) to determine whether
       or not to display messages.

       new routine: has_stats_for_prac.. Basically the same as
       has_stas_for_skill, without GET_SKILL(ch, i) == 0 check..

       Force is now restricted for <GRGOD.

       Score no longer displays punishment lines twice.

       New macro: IS_SKILL(skillnum) .. Used to determine whether skillnum is
                  a skill.
@
text
@d377 2
a378 2
  extern int allowed_zone(struct char_data * ch,int flag);
  extern int allowed_room(struct char_data * ch,int flag);
d458 1
a458 1
  if (!allowed_zone(ch,zone_table[world[location].zone].zflag))
d460 1
a460 1
  if (!allowed_room(ch,world[location].room_flags))
@


1.54
log
@Artus> Added extra fflush() calls.. May/not help crash saves recovering ;o)
@
text
@d1639 1
a1639 1
    send_to_all("Rebooting.. come back in about 10 seconds.\r\n");
d1644 1
a1644 1
    send_to_all("Rebooting.. come back in about 10 seconds.\r\n");
d2571 9
d2585 1
d2587 5
a2591 1
  else if ((GET_LEVEL(ch) < LVL_GRGOD) || (str_cmp("all", arg) && str_cmp("room", arg))) {
d2593 1
d2595 6
a2600 8
    else if (!IS_NPC(vict) && GET_LEVEL(ch) <= GET_LEVEL(vict))
      send_to_char("No, no, no!\r\n", ch);
    else {
      send_to_char(OK, ch);
      act(buf1, TRUE, ch, NULL, vict, TO_VICT);
      sprintf(buf, "(GC) %s forced %s to %s", GET_NAME(ch), GET_NAME(vict), to_force);
      mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      command_interpreter(vict, to_force);
d2602 23
a2624 1
  } else if (!str_cmp("room", arg)) {
d2632 1
a2632 1
      if (!IS_NPC(vict) && GET_LEVEL(vict) >= GET_LEVEL(ch))
d2637 4
a2640 1
  } else { /* force all */
d2644 2
a2645 2

    for (i = descriptor_list; i; i = next_desc) {
d2647 1
a2647 2

      if (STATE(i) != CON_PLAYING || !(vict = i->character) || (!IS_NPC(vict) && GET_LEVEL(vict) >= GET_LEVEL(ch)))
d2652 1
a2652 1
  }
@


1.53
log
@Artus> A3_0_315
@
text
@d4096 1
@


1.52
log
@Artus>
Adrenaline : (Potion Quaffing): 6 per fight Round instead of 5.
             (Flying Tackle)  : 2 fight rounds vs 3.
Balance    : QEQ no longer gets written to the log file when unbalanced.
Colour     : &f is no longer flash, &@@ is. Keep it quiet(tm).
Corpse File: Flush()ing after write().
Double Kick: Now calls apply_spell_skill_abil()
Echo       : No longer sends text to mobs calling it.
Fighting   : Is only possible if STATE = CON_PLAYING
Glance     : Fixed erroneous dex check.
OLC        : No longer possible while fighting.
           : LVL_IMPL+ (150+) can now edit mob levels up to 120.
Pit Trap   : Now logs deaths.
             No longer says "theoretically" on creation.
Report File: Flush()ing after write().
Spell/Skill: Now allows up to NUM_CLASSES class lines in primal_spskls
             (Used to only allow up to 10)
@
text
@d2513 1
d2528 1
a2528 1
  sprintf(buf, "[%5ld] [%3d %s] %-12s : %-18s : %-20s",
d2532 1
a2532 1
	  ctime(&chdata.player_specials_primalsaved.last_logon));
d2534 1
a2534 1
  sprintf(buf, "%17s%-12s : %-18s : %-20s",
d2537 1
a2537 1
          ctime(&chdata.player_specials_primalsaved.lastUnsuccessfulLogon));
@


1.51
log
@Artus> Added OLC Players to "show zone #" for >= GRGOD
       "rebalanc" = CMD_NONE
@
text
@d236 7
a242 4
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else
      act(buf, FALSE, ch, 0, 0, TO_CHAR);
@


1.50
log
@Artus> Added "rebalance" command (Wiz) Rebuilds balance files.
@
text
@d136 1
a136 1
void print_zone_to_buf(char *bufptr, zone_rnum zone, bool detailed);
d2979 1
a2979 1
void print_zone_to_buf(char *bufptr, zone_rnum zone, bool detailed)
d2992 1
d3007 23
d3101 1
a3101 1
      print_zone_to_buf(buf, world[ch->in_room].zone, TRUE);
d3105 1
a3105 1
	print_zone_to_buf(buf, zrn, TRUE);
d3112 1
a3112 1
	print_zone_to_buf(buf, zrn, FALSE);
@


1.49
log
@Latest Version
@
text
@d33 1
d100 1
d218 6
@


1.48
log
@

Modified: DM

Changed:
- fixed typo is stat_char with thac0 and hr around the wrong way
@
text
@d68 1
d3263 1
a3263 1
   { "brief",		LVL_GOD, 	PC, 	BINARY,  "On or Off"},  /* 0*/
d3265 1
a3265 1
   { "title",		LVL_GOD, 	PC, 	MISC , "Target's new title" },
d3292 3
a3294 3
   { "drunk",		LVL_GRGOD, 	BOTH, 	MISC, "State (0->24) or Off" },
   { "hunger",		LVL_GRGOD, 	BOTH, 	MISC, "State (0->24) or Off" },    /* 30 */
   { "thirst",		LVL_GRGOD, 	BOTH, 	MISC, "State (0->24) or Off" },
d3302 1
a3302 1
   { "class",		LVL_GRGOD, 	BOTH, 	MISC, "First few letters of class" },
d3305 1
a3305 1
   { "loadroom", 	LVL_GRGOD, 	PC, 	MISC, "Room to load player at (vnum) or 'defaults'" },
d3308 1
a3308 1
   { "passwd",		LVL_IMPL, 	PC, 	MISC, "Set player's password" },    /* 45 */
d3310 1
a3310 1
   { "sex", 		LVL_GRGOD, 	BOTH, 	MISC, "Male/Female/Neutral" },
d3319 1
a3319 1
   { "infection",       LVL_GRGOD,      PC,     MISC, "Werewolf/Vampire/None" },
d3328 11
a3338 9
   { "autoassist",      LVL_GOD,        PC,     MISC, "Off or player to autoassist"   },   
   { "autoassisters",   LVL_GOD,        BOTH,   MISC, "Off"  },
   { "autosplit",       LVL_GOD,        BOTH,   MISC, "On or Off" },    /* 65 */ 
   { "race", 		LVL_GOD, 	PC,   MISC, "First few letters of race name" },
   { "special",         LVL_GRGOD,      PC,   MISC, "Special # to set On or Off or 'list'" },
   { "nohints",         LVL_GOD,        PC,   BINARY, "On or Off" },
   { "statpoints",     LVL_GOD,        PC,   NUMBER, "Stat Points" }, 
   { "pkill",           LVL_GOD,        PC,   BINARY, "On of Off" }, /* 70 */
   { "whostring",       LVL_GRGOD,	PC,	MISC, "Targets Who String (Max 20 Chars" },
d3571 1
a3571 1
    if (GET_IDNUM(ch) < 3) {
d3848 1
a3848 1
    GET_MODIFIER(ch) = race_modifiers[i] + class_modifiers[GET_CLASS(vict)]
d3909 34
a3942 1
    
d5197 1
a5197 1
                  spellnum >= 0 && spellnum < MAX_SPELLS &&
d5201 2
d5204 5
d5215 1
d5237 1
d5388 1
a5388 1
  if (spellnum <= 0 || spellnum > MAX_SPELLS) {
d5390 6
@


1.47
log
@Artus> Localtime fix.
@
text
@d1200 3
a1202 4
    sprintf(buf, "AC: [%d], Thac0: [%d] Hitroll: [&r%2d&n], Damroll: [&r%2d&n], Saving throws: [%d/%d/%d/%d/%d]\r\n",
	  compute_armor_class(k, 0), k->points.hitroll,
	  thaco(k, NULL),
	  k->points.damroll, saving_throws(k, 0), saving_throws(k, 1), 
d1727 6
a1732 3
  // DM - stop char switching
  else if (!IS_NPC(victim))
    send_to_char("No you will not switch into playing characters!\r\n", ch);
@


1.46
log
@
: ----------------------------------------------------------------------
: Enter Log.  Lines beginning with `CVS:' are removed automatically
:
: Committing in .
:
: Modified Files:
: 	act.informative.c act.other.c act.wizard.c balance.c class.c
: 	constants.c db.c fight.c handler.c interpreter.c magic.c
: 	oedit.c redit.c spec_procs.c spell_parser.c spells.h
: 	update_revisions
: ----------------------------------------------------------------------

Modified: DM

Changed:
- heaps: mostly minor bug fixes.
@
text
@d1059 3
d1134 1
d1137 18
d2452 1
d2454 1
a2454 1
  int d, h, m;
a2459 1

d2462 16
@


1.45
log
@
Modified: DM

Changed:
- Don't ask (large group checkin) - lots of bug fixes mainly.
- Use cvs diff if you really wanna see the changes.
@
text
@d1 1
a1 2
/*
************************************************************************
d1178 1
a1178 1
    sprintf(buf, "AC: [%d], Hitroll: [&r%2d&n], Damroll: [&r%2d&n], Saving throws: [%d/%d/%d/%d/%d]\r\n",
d1180 1
d1706 3
d3524 4
@


1.44
log
@
Modified: DM

Added:
- In game check on removing quest items for players questlog
  (to actually remove the obj iff using it)
@
text
@d3964 3
a3966 4
  if (retval)
  {
	sprintf(buf, "%s performed set command - '%s%s'", GET_NAME(ch), arg, argument);
  	mudlog(buf, CMP, MAX(LVL_GOD, GET_LEVEL(ch)), TRUE);
d4566 1
d4587 3
a4589 1
  if (subcmd == -1) {
a4595 1
  // TODO: fill the rest in ...
d4599 2
a4600 1
        break;
d4602 1
d4605 1
d4611 1
a4616 2
//    send_to_char("Some Imp has to add the usage details\r\n", ch); 
//    return;
d4619 3
a4621 1
  if (!(vict = get_player_vis(ch, arg2, FIND_CHAR_WORLD))) {
d4684 5
a4688 1
      sprintf(buf2,"Quest items for &7%s&n:\r\n",GET_NAME(vict));
d4692 5
a4696 1
      send_to_char("They have no quest items...\r\n",ch);
d4705 1
a4705 1
      send_to_char("&1Usage: &4questlog add <name> &c<obj vnum>&n\r\n",ch);
d4749 1
a4749 1
      send_to_char("&1Usage: &4questlog del <name> &c<obj vnum>&n\r\n",ch);
d5033 2
a5034 2
	send_to_char("Stat which quest item (vnum) ?\r\n", ch);
	break;
@


1.43
log
@
Modified: DM

Added:
- quest enhancement and enhancement value clears on deletion of obj
@
text
@d92 1
d4566 1
d4637 2
d4775 1
d4794 8
@


1.42
log
@Artus> Added ghosts.. Newbies no longer die, they become ghosts.
@
text
@d4764 7
@


1.41
log
@Artus> Just a couple of minor bugfixes... Accounted for colour in whostring..
@
text
@d2064 2
@


1.40
log
@Jus> Fixed a bunch of badly written for loops.. Modified who list to show all
     three levels. Modified who list to allow a string to be placed instead of
     level/class/etc. This string can be set with the
     set <player> whostring [string] command (LR_GRGOD+).
     If [string] is blank, level/class/etc will be displayed.
@
text
@d3304 1
a3304 1
  if (GET_LEVEL(ch) != LVL_IMPL) {
d3518 1
a3518 1
    if (GET_IDNUM(ch) != 1) {
@


1.39
log
@Jus> Changed score display again. Commiting to move to another machine.
     These changes are not final, this is an intermediate build.
@
text
@d3289 1
d3846 11
@


1.38
log
@
Modified: DM

Changed:
- quest points -> stat points
- stat point updates
@
text
@d89 1
a89 1
int compute_armor_class(struct char_data *ch);
d1179 1
a1179 1
	  compute_armor_class(k), k->points.hitroll,
@


1.37
log
@
Modified: DM

Changed:
- fixed stat char display problems
@
text
@d1152 1
a1152 1
    sprintf(buf,"Start Rooms: [%d, %d, %d], Quest Points: [%4d]\r\n",
d1154 1
a1154 1
        ENTRY_ROOM(k, WORLD_FUTURE), GET_QP(k));
d3287 1
a3287 1
   { "questpoints",     LVL_GOD,        PC,   NUMBER, "Quest Points" }, 
d3838 1
a3838 1
    GET_QUEST_POINTS(vict) = RANGE(1, 10000);
@


1.36
log
@Art> Modified compute_armor_class() and thaco().. Most notable, thaco() now
expects ch, victim (victim may be null), for mob thaco calculations. Probably
should have done it with FIGHTING(ch) but oh well. :o). Also added in some
debug stuff, including a debug flag. A byte sized bitvector that's not saved,
char_special_data.small_bits or SMALL_BITS(ch).. GET_DEBUG() for debug.
@
text
@a1097 1
    strcpy(buf, "Monster Class: ");
d1099 1
a1104 1
  strcat(buf, buf2);
d1108 1
a1108 1
  sprintf(buf2, ", Lev: [%s%2d%s], XP: [%s%8d%s], Align: [%4d]\r\n",
d1113 2
a1114 2
    if (GET_LEVEL(ch) < LVL_IMMORT)
      sprintf(buf2, ", Lev: [%s%3d%s], XP: [%s%8d%s], XP_NL: [%s%8d%s], Align: [%4d]\r\n",
d1119 2
a1120 2
    else
      sprintf(buf2, ", Lev: [%s%3d%s], XP: [%s%8d%s], Align: [%4d]\r\n",
d1124 2
a1126 1
  } 
@


1.35
log
@
Modified: DM

Changed:
- Fixes for extended zone data
@
text
@d98 1
d149 66
d1178 2
a1179 2
    sprintf(buf, "AC: [%d%+d/10] (%d), Hitroll: [&r%2d&n], Damroll: [&r%2d&n], Saving throws: [%d/%d/%d/%d/%d]\r\n",
	  GET_AC(k), dex_app[GET_DEX(k)].defensive, compute_armor_class(k), k->points.hitroll,
@


1.34
log
@Modified: DM

Changed:
- added extra detailed zone info (UNCOMPLETE!)
@
text
@d2871 1
a2871 1
    generate_zone_data();
d2873 1
a2873 1
    sprintf(bufptr, "%s&RSTILL FIXING&n:\r\n", bufptr); 
@


1.33
log
@Modified: DM

Changed:
- Displayed Unlim in spells given by MAGIC_EQ in stat_char
@
text
@d91 3
d132 1
a132 1
void print_zone_to_buf(char *bufptr, zone_rnum zone);
d2676 1
a2676 1
    if (GET_LEVEL(ch) < LVL_GOD && (GET_OLC_ZONE(ch) != -1 && GET_OLC_ZONE(ch)
d2857 1
a2857 1
void print_zone_to_buf(char *bufptr, zone_rnum zone)
d2868 17
d2955 1
a2955 1
      print_zone_to_buf(buf, world[ch->in_room].zone);
d2959 1
a2959 1
	print_zone_to_buf(buf, zrn);
d2966 1
a2966 1
	print_zone_to_buf(buf, zrn);
@


1.32
log
@Modified: DM

Added:
- magic weapon spell cast info
- debug info to take out
@
text
@d1322 27
a1348 1
        sprintf(buf, "SPL: (%3dhr) %s%-21s%s ", aff->duration + 1,
d1350 2
@


1.31
log
@Modified: Artus

Added:
- remort level information in player stats
@
text
@d757 7
a763 2
    sprintf(buf, "Tohit: &c%d&n, Todam: &r%d&nd&r%d&n, Type: &c%d&n", GET_OBJ_VAL(j, 0),
            GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 3));
d2118 1
d4040 1
d4045 1
a4045 1
    if (load_char(arg, &tmp_store)) {
d4047 1
d4056 1
d4065 1
a4065 1
  sprintf(buf, "%s%-20s %-10s\r\n",buf,"&1Spell/Skill","Ability&n");
d4082 1
a4082 1
      /* Display the stat requirements */
@


1.30
log
@*** empty log message ***
@
text
@d1197 4
d5420 2
a5421 2
				sprintf(buf, "You hear rumours that the gold rush at %s has "
					     "ended.\r\n", zone_table[zone].name);
d5569 1
a5569 1
	sprintf(buf, "You hear rumours of a gold rush at %s!\r\n", zone_table[zone].name);
@


1.29
log
@Modified stat, added timers.
@
text
@d64 1
d68 1
d1110 7
d1197 4
a1200 2
    /* Kill Counts - Artus */
    sprintf(buf, "Kills: Imm[&g%d&n] By Imm[&g%d&n] Mob[&g%d&n] By Mob[&g%d&n] PC[&g%d&n] By PC[&g%d&n]\r\n", GET_IMMKILLS(ch), GET_KILLSBYIMM(ch), GET_MOBKILLS(ch), GET_KILLSBYMOB(ch), GET_PCKILLS(ch), GET_KILLSBYPC(ch));
d4229 1
a4229 1
	int i, j, k, l, found = 0;
d4231 3
a4233 3
	for( i = 0; i < MAX_QUEST_ITEMS; i++ ) {
		if (found)
			break;
d4235 1
d4237 1
d4240 3
a4242 1
			itemnumber--;
d4244 3
a4246 2
		// We have the enhancement
		if(itemnumber == 0 ) {
d4248 3
a4250 3
		  for( j = 0; j < MAX_NUM_ENHANCEMENTS; j++ ) {
			if (found)
				break;
d4252 6
d4259 2
a4260 2
		
			for( k = 0; k < MAX_ENHANCEMENT_VALUES; k++ ) {
d4262 4
a4265 3
			   found = 0;
			   for( l = 0; l < MAX_OBJ_AFFECT; l++ ) {
			      if(qitem->affected[l].location == GET_QUEST_ENHANCEMENT(ch, i, j) ){
d4271 3
a4273 1
			    if( !found ) { // New affect
d4275 3
a4277 2
			         if( qitem->affected[l].location = APPLY_NONE ) {
			            found = 1;
d4281 2
a4282 1
				} 
a4288 1

a4331 1
	  enhanced = 1;
d4339 3
d4345 2
a4346 1
		   enhanced++;
d4468 2
a4469 2
    send_to_char("Some Imp has to add the usage details\r\n", ch); 
    return;
d4786 1
a4786 1
    if( !isdigit(*arg3) ) {
d5494 1
a5494 1
	ev->ch = ch;
d5525 1
a5525 1
	ev->ch = ch;
d5556 1
a5556 1
	ev->ch = ch;
d5591 1
a5591 1
	ev->ch = ch;
d5616 1
a5616 1
	ev->ch = ch;
d5627 1
a5627 1
	sprintf(buf1, "&G- QUEST NOTICE '&gPandoras Box&G' -&g\r\n%s\r\n", buf2);
d5629 1
d5744 1
a5744 1
			"     %s%s\r\n"
d5747 2
a5748 2
			target, (ev->ch != NULL ? GET_NAME(ev->ch) : "None"),
			roomdesc, room,
d5765 10
a5774 1

d5787 1
a5787 1
		send_to_char("Usage: event <list | create | destroy>\r\n", ch);
@


1.28
log
@Artus - Just changed stat to use a couple of new defines..
@
text
@d829 1
d937 1
d943 20
a1330 25
      /*
      if( timer->duration == -1 ) {
        sprintf(buf, "ABL: (Unlim) &c%-21s &n ", skill_name(aff->type));
        if (aff->modifier) {
          sprintf(buf2, "%+d to %s", aff->modifier, apply_types[(int) aff->location]);
          strcat(buf, buf2);
        }
      }
      else {
        sprintf(buf, "SPL: (%3dhr) %s%-21s%s ", aff->duration + 1,
              CCCYN(ch, C_NRM), skill_name(aff->type), CCNRM(ch, C_NRM));
        if (aff->modifier) {
          sprintf(buf2, "%+d to %s", aff->modifier, apply_types[(int) aff->location]);
          strcat(buf, buf2);
        }
      }      
      if (aff->bitvector) {
	if (*buf2)
	  strcat(buf, ", sets ");
	else
	  strcat(buf, "sets ");
	sprintbit(aff->bitvector, affected_bits, buf2);
	strcat(buf, buf2);
      }
      send_to_char(strcat(buf, "\r\n"), ch); */
@


1.27
log
@Artus - Modified do_recall to allow champs to goto within their OLC zone.
@
text
@d1140 1
a1140 1
        sprintf(buf, "%s %s[%d]", buf, punish_types[i], k->player_specials->saved.phours[i]);
d1153 2
a1154 2
      if (k->player_specials->saved.offences[i] > 0) {
        sprintf(buf, "%s %s[%d]", buf, offence_types[i], k->player_specials->saved.offences[i]);
@


1.26
log
@Artus - Added in line for number of kills/killed bys..
@
text
@d305 31
@


1.25
log
@*** empty log message ***
@
text
@d1132 5
a1136 1
    sprintf(buf, "Clan: %d (%s) Rank: %d of %d\r\n", GET_CLAN(k), ((GET_CLAN(k) > 0) ? clan[find_clan_by_id(GET_CLAN(k))].name : "none"), GET_CLAN_RANK(k), ((GET_CLAN(k) > 0) ? clan[find_clan_by_id(GET_CLAN(k))].ranks : 0));
@


1.24
log
@Artus - Set clan/clanrank, goto checks et al.
@
text
@d79 1
d3384 4
a3387 4
    GET_MODIFIER(ch) = race_modifiers[GET_RACE(ch)] + class_modifiers[i] +
	special_modifier(ch); 
    set_class_specials(ch);
    apply_specials(ch, FALSE);
d3623 1
d3625 3
a3627 3
    GET_MODIFIER(ch) = race_modifiers[i] + class_modifiers[GET_CLASS(ch)]
	+ special_modifier(ch);
   set_race_specials(ch); 
d3657 4
@


1.23
log
@*** empty log message ***
@
text
@d332 2
a333 1
/* stops imms going to clan halls - Hal*/
d335 2
a336 1
  if(world[location].number >= 103 && world[location].number <= 150 && GET_LEVEL(ch) < LVL_GOD)
d338 1
a338 2
    send_to_char("As you fly through time and space towards the clan area\r\n"
               "a guardian spirit tells you in a nice kind voice,\"umm no sorry can't go there\"\r\n",ch);
d3107 1
a3107 1
   { "clan",            LVL_GOD,        PC,     MISC, "On or Off"   },  
d3109 1
a3109 1
   { "clanrank",        LVL_CLAN_GOD,   PC,     MISC, "Off or clan name" },    /* 60 */
d3119 1
d3540 1
a3540 1
    if (find_clan_by_id(value) < 0) {
d3665 5
@


1.22
log
@Modified: ARTUS - Clan, Punishment, Saving Throws
@
text
@d1100 1
a3616 1
      sprintf(buf, "Race returned: %d\r\n", i);
d3648 6
a3664 5
   sprintf(buf, "&g%s&n toggled &4%s&n for &7%s&n.\r\n", special_ability_bits[atoi(val_arg)-1], 
	IS_SET(GET_SPECIALS(vict), (1 << atoi(val_arg) -1)) ? "on" : "off", GET_NAME(vict));
   send_to_char(buf, ch);
   apply_specials(vict, FALSE);
   break;
d3672 6
a3677 2
  sprintf(buf, "(GC) %s: %s", GET_NAME(ch), val_arg);
  mudlog(buf, NRM, GET_LEVEL(ch) , TRUE);
d3766 7
@


1.21
log
@
Added:
- Ability for zone owners to load objs and mobiles and reset their zone
@
text
@d34 1
a61 1
extern struct clan_data clan_info[NUM_CLANS];
d87 1
a87 1

d1048 2
a1049 2
	  k->points.damroll, GET_SAVE(k, 0), GET_SAVE(k, 1), GET_SAVE(k, 2),
	  GET_SAVE(k, 3), GET_SAVE(k, 4));
d1100 32
d1139 2
a1140 2
    } */
    send_to_char(buf, ch);
d1210 1
a1210 1
  /* DM - clan info */
d1212 3
a1214 2
    i = GET_CLAN_NUM(k);
 
d1216 1
a1216 1
      if ((i >= 0) && (i < NUM_CLANS)) {
d1218 1
a1218 1
            clan_info[i].disp_name, clan_info[i].ranks[GET_CLAN_LEV(k)]);
d1222 1
d2672 1
a2672 1
      result = PLR_TOG_CHK(vict, PLR_NOSHOUT);
d2674 1
a2674 1
        PLR_TOG_CHK(vict, PLR_NOSHOUT);
d2695 1
a2695 1
      if (PLR_FLAGGED(vict, PLR_FROZEN)) {
d2704 4
a2707 1
      SET_BIT(PLR_FLAGS(vict), PLR_FROZEN);
d2721 3
a2723 1
      if (!PLR_FLAGGED(vict, PLR_FROZEN)) {
d2735 3
a2737 1
      REMOVE_BIT(PLR_FLAGS(vict), PLR_FROZEN);
d3104 2
a3105 2
   { "noignore",        LVL_GOD,        PC,     BINARY, "On or Off" },
   { "leader",          LVL_GOD,        PC,     MISC, "On or Off"   },  
d3107 1
a3107 1
   { "clan",            LVL_GOD,        PC,     MISC, "Off or clan name" },    /* 60 */
d3311 5
a3315 1
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_FROZEN);
d3528 5
a3532 12
  case 58: // Leader (clan)
    if (str_cmp(val_arg, "on") == 0) {
      if (GET_CLAN_NUM(vict) < 0) {
        sprintf(buf, "%s is not in a clan.\r\n", GET_NAME(vict));
        send_to_char(buf, ch);
      } else {
        sprintf(buf, "Leader ON for %s.\n\r", GET_NAME(vict));
        send_to_char(buf, ch);
 
        if (!EXT_FLAGGED(vict, EXT_LEADER))
          SET_BIT(EXT_FLAGS(vict) , EXT_LEADER );
      }
d3534 2
d3537 3
a3539 6
    if (str_cmp(val_arg, "off") == 0) {
      if (EXT_FLAGGED(vict, EXT_LEADER))
        REMOVE_BIT(EXT_FLAGS(vict), EXT_LEADER);
 
      sprintf(buf, "Leader OFF for %s.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
d3541 8
a3548 1
    break ;
d3554 9
a3562 40
  case 60: // Clan
    if (str_cmp(val_arg, "off") == 0) {
      if (GET_CLAN_NUM(vict) < 0)
        sprintf(buf, "%s is already clanless.", GET_NAME(vict));
      else {
        sprintf(buf, "%s is now clanless.", GET_NAME(vict));

      if (vict != ch) {
          sprintf (buf, "You have been banished from the %s.\r\n", get_clan_disp(vict));
          send_to_char(buf, vict);
        }
 
        GET_CLAN_NUM(vict) = -1;
        GET_CLAN_LEV(vict) = 0 ;
 
        REMOVE_BIT(EXT_FLAGS(vict), EXT_CLAN);
 
        if (EXT_FLAGGED(vict, EXT_LEADER))
          REMOVE_BIT(EXT_FLAGS(vict), EXT_LEADER);
 
        if (EXT_FLAGGED(vict, EXT_SUBLEADER))
          REMOVE_BIT(EXT_FLAGS(vict), EXT_SUBLEADER);
 
      }
    } else {
      for (i=0; i < NUM_CLANS; i++)  {
        if (!strn_cmp(val_arg, get_clan_name(i), 3))
          cnum=i;
      }
 
      if (cnum == 0)
        sprintf(buf, "That is not a clan.");
      else {
        GET_CLAN_NUM(vict) = cnum;
        SET_BIT (EXT_FLAGS(vict), EXT_CLAN);
        sprintf(buf, "%s is now a member of the %s.", GET_NAME(vict), get_clan_disp(vict));
        if( vict != ch) {
          sprintf(buf, "You are now a member of the %s.\r\n", get_clan_disp(vict));
          send_to_char(buf, vict);
        }
d3565 3
@


1.20
log
@reason string fixes, OLC description in set help
@
text
@d1593 5
d1611 5
d2538 1
a2538 1
  if (*arg == '*') {
d2554 6
@


1.19
log
@

Added:
- invis level range check (fix)

Changed:
- restore to remove blind, para, poison, curse and not to set mob stats
@
text
@d1756 1
d1759 5
a1763 1
  reason++;
a1800 1
    send_to_char(reason, ch);
d2566 1
d3039 1
a3039 1
   { "olc",             LVL_IMPL,       PC,     NUMBER, "OLC Zone for target" },
@


1.18
log
@
Changed:
- set loadroom to use new entry room system
- fixed stat_character to display correct entry rooms
@
text
@d937 1
a937 1
    if( GET_INVIS_TYPE(ch) == -2 )
d939 3
a941 3
    else if( GET_INVIS_TYPE(ch) == -1 )
      sprintf(buf3,", Invis to Lvl [%s%d%s]",CCYEL(ch,C_NRM),GET_INVIS_LEV(k),CCNRM(ch,C_NRM));
    else if( GET_INVIS_TYPE(ch) == 0 )
d1852 26
a1877 13

    if ((GET_LEVEL(ch) >= LVL_GRGOD) && (GET_LEVEL(vict) >= LVL_ANGEL)) {
      for (i = 1; i <= MAX_SKILLS; i++)
	SET_SKILL(vict, i, 100);

      if (GET_LEVEL(vict) >= LVL_GRGOD) {
	vict->real_abils.str_add = 100;
	vict->real_abils.intel = 25;
	vict->real_abils.wis = 25;
	vict->real_abils.dex = 25;
	vict->real_abils.str = 25;
	vict->real_abils.con = 25;
	vict->real_abils.cha = 25;
a1878 1
      vict->aff_abils = vict->real_abils;
d2031 1
a2031 1
       send_to_char("You can't go invisible above your own level.\r\n", ch);
d2033 1
a2033 1
       perform_immort_vis(ch);
d2037 2
a2038 2
       // Are they specifying a range?
       if ( isdigit(buf1[0]) ) {
d2041 2
a2042 2
             send_to_char("The level range is invalid.\r\n", ch);
             return;
d2044 2
a2045 6
          else
             GET_INVIS_TYPE(ch) = toplevel;
       } // Specified a range?
       else { /* Specified a particular invisibility level? */
          if( strcmp(buf1, "single") == 0 ) {
             GET_INVIS_TYPE(ch) = INVIS_SINGLE;
d2047 9
a2055 1
       }
@


1.17
log
@
Added:
- ignore restrictions for playerid 1 - on set command levels, and specifically
  on set level
@
text
@d1020 3
a1022 2
    sprintf(buf,"Start Rooms: [%d, %d, %d], Quest Points: [%4d]\r\n",ENTRY_ROOM(ch,WORLD_MEDIEVAL),
        ENTRY_ROOM(ch,WORLD_WEST), ENTRY_ROOM(ch, WORLD_FUTURE), GET_QP(ch));
d3009 1
a3009 1
   { "loadroom", 	LVL_GRGOD, 	PC, 	MISC, "Room to load player at (vnum) or Off" },
d3309 9
d3319 4
a3322 2
    if (!str_cmp(val_arg, "off")) {
      REMOVE_BIT(PLR_FLAGS(vict), PLR_LOADROOM);
d3326 5
a3330 4
        SET_BIT(PLR_FLAGS(vict), PLR_LOADROOM);
	GET_LOADROOM(vict) = rvnum;
	sprintf(output, "%s will enter at room #%d.", GET_NAME(vict),
		GET_LOADROOM(vict));
d3336 1
a3336 1
      send_to_char("Must be 'off' or a room's virtual number.\r\n", ch);
d3340 1
@


1.16
log
@
Removed:
- removed debug line in set <class>
@
text
@d2758 5
a2762 3
  if (GET_LEVEL(ch) < fields[l].level) {
    send_to_char("You are not godly enough for that!\r\n", ch);
    return;
d2764 1
d3058 5
a3062 3
  if (GET_LEVEL(ch) < set_fields[mode].level) {
    send_to_char("You are not godly enough for that!\r\n", ch);
    return (0);
d3262 6
a3267 3
    if (value > GET_LEVEL(ch) || value > LVL_GRIMPL) {
      send_to_char("You can't do that.\r\n", ch);
      return (0);
a3268 1
    RANGE(0, LVL_GRIMPL);
d3270 1
@


1.15
log
@
Removed:
- removed class_abbrevs def -> moved into constants.h

Changed:
- set to max LVL_OWNER and <= current level
@
text
@a3283 2
      sprintf(buf, "Class returned: %d\r\n", i);
      send_to_char(buf, ch);
@


1.14
log
@
Added:
- Initial inclusion of dgscripts
@
text
@a47 1
extern char *class_abbrevs[];
d1313 3
d3257 1
a3257 1
    if (value > GET_LEVEL(ch) || value > LVL_IMPL) {
d3261 1
a3261 1
    RANGE(0, LVL_IMPL);
d3623 3
@


1.13
log
@
Added:
- permanant affect check in unaffect command (ignores perms)
@
text
@d34 1
d693 2
d913 3
d1190 1
d1264 40
d1598 1
d1606 1
a1606 1
      obj_to_char(obj, ch);
d1612 2
@


1.12
log
@
Added:
- spell show race argument to show spells/skills limited by race

Changed:
- formatting of some functions
@
text
@d295 1
d303 4
a306 1
    if(((target_mob = get_char_vis(ch,name_mob,FALSE)) == NULL)
d313 1
d2489 1
d2613 6
a2618 2
	while (vict->affected)
	  affect_remove(vict, vict->affected);
@


1.11
log
@
Added:
- goto: 2 violence round wait for angels and below
- skillshow: update for new structs, and bug fixes
- vnum: list option to list all objs/mobs/rooms in a zone
- stat obj: corpse info
- last successful and unsuccessful logon information
- shutdown check for unsaved OLC changes
- punishment channel - reason no less than 10 chars for freeze, mute,
  advance/demote, notitle
@
text
@d86 1
d599 5
a603 2
  sprintf(buf, "&0SpecProc&n: &c%s&n\r\n&0Flags&n: &c%s&n\r\n",
	  (rm->func == NULL) ? "None" : "Exists", buf2);
d1035 2
a1036 2
    sprintf(buf, "AC: [%d%+d/10], Hitroll: [&r%2d&n], Damroll: [&r%2d&n], Saving throws: [%d/%d/%d/%d/%d]\r\n",
	  GET_AC(k), dex_app[GET_DEX(k)].defensive, k->points.hitroll,
d1419 2
a1420 1
  else if (!(GET_LEVEL(ch)>=LVL_IMPL) && IS_SET(world[victim->in_room].room_flags,ROOM_HOUSE))
d2342 2
d2418 1
a2418 1
        (!PLR_FLAGGED(d->character, PLR_WRITING | PLR_MAILING))
d2922 1
a2922 1
   { "exp", 		LVL_GRGOD, 	BOTH, 	NUMBER, "Experience earnt" },
d2972 1
a2992 2
  sprintf(buf,"mode %d, set level %d, char level %d\r\n",mode, set_fields[mode].level, GET_LEVEL(ch));
  log(buf);
a3314 6
    // Only Implementors plus can set olc permissions
    if (GET_LEVEL(ch) < LVL_IMPL) {
      send_to_char("Nice Try.\r\n",ch);
      return 0;      
    }

d3481 1
d3514 1
d3519 5
d3536 2
d4226 1
d4228 17
a4244 1
    send_to_char("On whom?\r\n",ch);
d4709 3
a4711 7
// DM - TODO - fix for user levels
ACMD(do_spellinfo)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  char arg3[MAX_INPUT_LENGTH], rest[MAX_INPUT_LENGTH];
  char *s, *t;
  int spellnum, i, found, index, j;
a4712 2
  extern const char *pc_class_types[];
  int sort_index, class_index, spell_index, sort_type;
d4714 64
a4777 8
  /* get: blank, spell name, target name */
  s = strtok(argument, "'");
 
  if (s == NULL) {
    if (GET_LEVEL(ch) >= LVL_IMMORT) {
      sprintf(buf,"&1Usage: &4%s &n{ '<spellname>' | <classname> [ <sort type> ] }\r\n", CMD_NAME);
    } else {
      sprintf(buf,"&1Usage: &4%s &n<classname> [ <sort type> ]\r\n", CMD_NAME);
d4779 36
a4814 1
    send_to_char(buf,ch);
a4817 2
  s = strtok(NULL, "'");
  if (s == NULL) {
d4819 18
a4836 20
    // First check if we are going to list the spells for a particular class
    found = FALSE;
    half_chop(argument,arg1,rest);

    class_index=search_block_case_insens(arg1,pc_class_types,FALSE);
    if (class_index>=0) {
      found = TRUE;
        
      half_chop(rest,arg2,rest);
      if (!*arg2) {
        sort_type=SORT_ALPHA; 
      } else if ((sort_type=search_block_case_insens(arg2,sort_names,FALSE))<0) {
        sprintf(buf2,"Invalid sort type. Valid types are: ");
        for (i=0;i<NUM_SORT_TYPES;i++) {
          sprintf(buf1,"%s ",sort_names[i]);
          strcat(buf2,buf1);
        }
        send_to_char(buf2,ch);
        return;
      }
d4839 2
a4840 25
    if (found) {
      sprintf(buf2,"&1Spells and Skills for the &B%s&1 sorted &b%s&n\r\n\r\n", 
        CLASS_NAME(class_index),sort_names[sort_type]);
      sprintf(buf1, "&1%-20s %-3s %s&n\r\n",
                      "Spell/Skill", "Lvl", "Requirements");
      strncat(buf2, buf1, strlen(buf1));
      for (spell_index = 1; spell_index < MAX_SKILLS; spell_index++) {
        if (sort_type == SORT_ALPHA)
	  spellnum = spell_sort_info[SORT_ALPHA][0][spell_index];
        else 
	  spellnum = spell_sort_info[sort_type][class_index][spell_index];

	if (spell_info[spellnum].min_level[class_index] != LVL_OWNER+1) {
	  // sprintf(buf2,"&R%-20s&n (%d)\r\n", spell_info[spellnum].name,
	  //	spell_info[spellnum].min_level[class_index]);
          //strcat(buf,buf2);

          sprintf(buf1, "%-20s %-3d ", spell_info[spellnum].name,
              spell_info[spellnum].min_level[class_index]);
          strncat(buf2, buf1, strlen(buf1));
 
          /* Display the stat requirements */
          if (spell_info[spellnum].str[class_index]!=0){
              sprintf(buf1,"%sStr: %s%2d%s ",CCGRN(ch,C_NRM),CCCYN(ch,C_NRM), 
                spell_info[spellnum].str[class_index],CCNRM(ch,C_NRM));
d4842 7
a4848 2
            strncat(buf2, buf1, strlen(buf1));
          }
d4850 6
a4855 3
          if (spell_info[spellnum].intl[class_index]!=0){
              sprintf(buf1,"%sInt: %s%2d%s ",CCGRN(ch,C_NRM),CCCYN(ch,C_NRM),
                spell_info[spellnum].intl[class_index],CCNRM(ch,C_NRM));
d4857 6
a4862 2
            strncat(buf2, buf1, strlen(buf1));
          }
d4864 6
a4869 3
          if (spell_info[spellnum].wis[class_index]!=0){
              sprintf(buf1,"%sWis: %s%2d%s ",CCGRN(ch,C_NRM),CCCYN(ch,C_NRM),
                spell_info[spellnum].wis[class_index],CCNRM(ch,C_NRM));
d4871 74
a4944 2
            strncat(buf2, buf1, strlen(buf1));
          }
d4946 6
a4951 3
          if (spell_info[spellnum].dex[class_index]!=0){
              sprintf(buf1,"%sDex: %s%2d%s ",CCGRN(ch,C_NRM),CCCYN(ch,C_NRM),
                spell_info[spellnum].dex[class_index],CCNRM(ch,C_NRM));
d4953 6
a4958 2
            strncat(buf2, buf1, strlen(buf1));
          }
d4960 6
a4965 3
          if (spell_info[spellnum].con[class_index]!=0){
              sprintf(buf1,"%sCon: %s%2d%s ",CCGRN(ch,C_NRM),CCCYN(ch,C_NRM),
                spell_info[spellnum].con[class_index],CCNRM(ch,C_NRM));
d4967 6
a4972 2
            strncat(buf2, buf1, strlen(buf1));
          }
d4974 5
a4978 10
          if (spell_info[spellnum].cha[class_index]!=0){
              sprintf(buf1,"%sCha: %s%2d%s ",CCGRN(ch,C_NRM),CCCYN(ch,C_NRM),
                spell_info[spellnum].cha[class_index],CCNRM(ch,C_NRM));
 
            strncat(buf2, buf1, strlen(buf1));
          }
 
          sprintf(buf1,"\r\n");
          strncat(buf2, buf1, strlen(buf1));
        }
d4980 8
a4987 5
      page_string(ch->desc,buf2,TRUE);
      return;
    } else {
      send_to_char("Invalid Class Name.\r\n",ch);
      return;
d4989 3
d4993 1
d4995 4
d5000 2
a5001 2
    send_to_char("Spell names must be enclosed in the Holy Magic Symbols: '\r\n", ch);
    return;
d5003 17
a5019 1
  t = strtok(NULL, "\0");
d5021 11
a5031 2
  if (GET_LEVEL(ch) < LVL_IMMORT) {
    sprintf(buf,"&1Usage: &4%s &n<classname> [ <sort type> ]\r\n", CMD_NAME);
d5035 12
a5046 7
 
  /* spellnum = search_block(s, spells, 0); */
  spellnum = find_skill_num(s); 
 
  if (spellnum == -1) {
    send_to_char("Spell/Skill name not found.\r\n",ch);
    return;
d5049 44
a5092 1
  sprintf(buf,"Name: &R%s&n\r\n", spell_info[spellnum].name);
d5094 4
a5097 2
  for (i = 0; i < NUM_CLASSES; i++) {
    if (spell_info[spellnum].min_level[i] != LVL_OWNER+1) {
d5099 5
a5103 5
      sprintf(buf2,"&B%s:&n\r\nLevel: &M%d&n Mana_min: &G%d&n Mana_max: &G%d&n Mana_change: &G%d&n\r\n",
	      pc_class_types[i], spell_info[spellnum].min_level[i],  
	      spell_info[spellnum].mana_min[i],  
	      spell_info[spellnum].mana_max[i],  
	      spell_info[spellnum].mana_change[i]);
d5105 4
a5108 1
      strcat(buf,buf2);
d5110 1
a5110 5
      sprintf(buf2, "&gInt: &c%d &gWis: &c%d &gStr: &c%d &gCon: &c%d &gDex: &c%d &gCha: &c%d&n\r\n",
	      spell_info[spellnum].intl[i], spell_info[spellnum].wis[i], 
	      spell_info[spellnum].str[i], spell_info[spellnum].con[i], 
	      spell_info[spellnum].dex[i], spell_info[spellnum].cha[i]); 
      strcat(buf,buf2);
d5112 5
a5116 4
      sprintf(buf2, "Class Effeciency: &R%d&n%% Class Mana Percentage: &R%d&n%%&n\r\n\r\n",
	      spell_info[spellnum].spell_effec[i],
	      spell_info[spellnum].mana_perc[i]);
      strcat(buf,buf2);
d5118 2
a5120 1
  page_string(ch->desc,buf,TRUE);
d5123 3
d5559 1
a5559 1
	if(strcmp(arg, "list") == 0 ) {
d5578 1
a5578 1
	if( strcmp(arg, "create") == 0 ) {
d5585 1
a5585 1
		if( strcmp(arg, "curfew") == 0 ) {
d5589 1
a5589 1
		if( strcmp(arg, "goldrush") == 0 ) {
d5593 1
a5593 1
		if( strcmp(arg, "quest") == 0 ) {
d5597 1
a5597 1
		if( strcmp(arg, "election") == 0 ) {
d5606 1
a5606 1
	if( strcmp(arg, "destroy") == 0 ) {
d5613 1
a5613 1
		if( strcmp(arg, "curfew") == 0 ) {
d5617 1
a5617 1
		if( strcmp(arg, "goldrush") == 0 ) {
d5621 1
a5621 1
		if( strcmp(arg, "quest") == 0) {
d5625 1
a5625 1
		if( strcmp(arg, "election") == 0 ) {
@


1.10
log
@
Added:
- Ahh, too much stuff, sorry was ages since this stuff was last checked in
@
text
@d33 1
d349 5
a449 2


d452 9
d463 3
a465 2
  if (!*buf || !*buf2 || (!is_abbrev(buf, "mob") && !is_abbrev(buf, "obj"))) {
    send_to_char("&1Usage: &4vnum { obj | mob } <name>\r\n", ch);
d468 85
d727 7
a733 3
    sprintf(buf, "Max-contains: &c%d&n, Locktype: &c%d&n, Corpse: &g%s&n",
            GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1),
            GET_OBJ_VAL(j, 3) ? "Yes" : "No");
d1296 1
a1296 1
	victim->player.time.logon = tmp_store.last_logon;
d1338 2
a1343 1
  one_argument(argument, arg);
d1345 8
d1359 1
a1359 1
    send_to_all("Rebooting.. come back in a minute or two.\r\n");
d1364 1
a1364 1
    send_to_all("Rebooting.. come back in a minute or two.\r\n");
a1557 2


d1568 1
a1568 1
    send_to_char("&1Usage: &4vstat { obj | mob } <number>\r\n", ch);
d1571 1
d1689 2
a1690 1
  char *name = arg, *level = buf2;
d1693 3
a1695 1
  two_arguments(argument, name, level);
d1732 6
d1741 1
a1741 1
    demote_level(victim, newlevel);
d2188 1
a2188 1
  sprintf(buf, "[%5ld] [%2d %s] %-12s : %-18s : %-20s\r\n",
d2190 8
a2197 2
	  class_abbrevs[(int) chdata.chclass], chdata.name, chdata.host,
	  ctime(&chdata.last_logon));
d2220 2
a2221 1
  sprintf(buf, "%s was last on: %s\r\n",chdata.name,ctime(&chdata.last_logon));
d2478 3
d2482 2
a2483 1
  one_argument(argument, arg);
d2517 6
d2528 5
d2536 6
d2547 5
d2562 5
d2574 5
d2734 2
a2735 1
	    birth, ctime(&vbuf.last_logon), (int) (vbuf.played / 3600),
d2889 1
a2889 1
    const char level;
d2964 1
d3513 4
d3802 3
a3804 2
  int i, sortpos, spellnum, mana;
  struct char_data *vict;
d3807 4
d3816 16
a3831 2
    send_to_char(NOPERSON,ch);
    return;
d3834 2
a3835 2
  sprintf(buf, "Spell/Skill abilities for &B%s&n.\r\n",GET_NAME(vict));
  sprintf(buf, "%sPractice Sessions: &M%d&n.\r\n",buf,GET_PRACTICES(vict));
d3837 1
a3837 1
  sprintf(buf, "%s%-20s %-10s\r\n",buf,"Spell/Skill","Ability");
d3848 4
a3851 3
    if (GET_LEVEL(ch) >= spell_info[i].min_level[(int) GET_CLASS(ch)]) {
      mana = mag_manacost(ch, i);
      sprintf(buf, "%-20s %-10.10s %-3d ", spell_info[i].name, GET_SKILL(vict, i), mana);
d3856 1
a3856 1
        if (GET_REAL_STR(ch) >= spell_info[i].str[class_index])
d3865 1
a3865 1
        if (GET_REAL_INT(ch) >= spell_info[i].intl[class_index])
d3874 1
a3874 1
        if (GET_REAL_WIS(ch) >= spell_info[i].wis[class_index])
d3883 1
a3883 1
        if (GET_REAL_DEX(ch) >= spell_info[i].dex[class_index])
d3891 1
a3891 1
        if (GET_REAL_CON(ch) >= spell_info[i].con[class_index])
d3899 1
a3899 1
        if (GET_REAL_CHA(ch) >= spell_info[i].cha[class_index])
d3913 4
d4684 1
a4684 1
ACMD(do_spellshow)
d4733 1
a4733 1
      sprintf(buf2,"Spells and Skills for the &B%s&n sorted &b%s&n:\r\n", 
d4735 3
d4740 1
a4740 1
	  spellnum = spell_sort_info[0][0][spell_index];
@


1.9
log
@
Added:
- newbie logging
- random hint channel

Changed:
- Rewrote the ignore code, ignore char all/tells, ignore level all/tells
@
text
@a3462 4
int showVariables(struct char_data *ch) {

}

d3937 1
a3937 1
show_enhancements_to_player(struct char_data *ch) {
@


1.8
log
@
Added:
- Cant remember
@
text
@d304 1
a304 1
      send_to_char("That person does not appear to be anywhere!",ch);
d309 1
a309 1
      send_to_char("You can only go to Player Characters!",ch);
d1164 1
a1164 1
    else send_to_char("That person does not appear to be here.",ch);
d3190 6
a3195 5
      GET_IGN1(vict) = 0 ;
      GET_IGN2(vict) = 0 ;
      GET_IGN3(vict) = 0 ;
      GET_IGN_LEVEL(vict) = 0;
      GET_IGN_NUM(vict) = 0 ;
@


1.7
log
@
Added:
- timers (like affects)
- new skills, fixes

TODO:
- test timers on objects - add to stat obj screen
@
text
@d587 1
d593 1
a593 1
    sprintf(buf, "Color: [%d], Type: [%d], Hours: [%d]",
d598 3
a600 3
    sprintf(buf, "Spells: %s (%d), %s (%d), %s (%d), %s (%d)",
		skill_name(GET_OBJ_VAL(j,0)), GET_OBJ_VAL(j, 0),
                skill_name(GET_OBJ_VAL(j,1)), GET_OBJ_VAL(j, 1), 
d606 3
a608 2
    sprintf(buf, "Spell: %s (%d), Mana: %d", skill_name(GET_OBJ_VAL(j, 0)), GET_OBJ_VAL(j, 0),
            GET_OBJ_VAL(j, 1));
d612 1
a612 1
    sprintf(buf, "Tohit: %d, Todam: %dd%d, Type: %d", GET_OBJ_VAL(j, 0),
d616 1
a616 1
    sprintf(buf, "Tohit: %d, Todam: %d, Type: %d", GET_OBJ_VAL(j, 0),
d620 1
a620 1
    sprintf(buf, "AC-apply: [%d]", GET_OBJ_VAL(j, 0));
d623 1
a623 1
    sprintf(buf, "Loaded: %s, Damage: %dd%d, Protecting Item: %d",
d628 1
a628 1
    sprintf(buf, "Max-contains: %d, Locktype: %d, Corpse: %s",
d635 1
a635 1
    sprintf(buf, "Max-contains: %d, Contains: %d, Poisoned: %s, Liquid: %s",
d640 1
a640 1
    sprintf(buf, "Tongue: %d", GET_OBJ_VAL(j, 0));
d643 1
a643 1
    sprintf(buf, "Keytype: %d", GET_OBJ_VAL(j, 0));
d646 20
a665 2
    sprintf(buf, "Makes full: %d, Poisoned: %d",
            GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 3));
d668 1
a668 1
    sprintf(buf, "Values 0-3: [%d] [%d] [%d] [%d]",
d2872 1
a2872 1
    vict->points.max_hit = RANGE(1, 32000);
d2876 1
a2876 1
    vict->points.max_mana = RANGE(1, 32000);
d2880 1
a2880 1
    vict->points.max_move = RANGE(1, 32000);
d2959 1
a2959 1
    GET_GOLD(vict) = RANGE(0, 100000000);
d2962 1
a2962 1
    GET_BANK_GOLD(vict) = RANGE(0, 100000000);
d2965 1
a2965 1
    vict->points.exp = RANGE(0, 50000000);
d2968 1
a2968 1
    vict->points.hitroll = RANGE(-120, 120);
d2972 1
a2972 1
    vict->points.damroll = RANGE(-120, 120);
d2998 1
a2998 1
    GET_PRACTICES(vict) = RANGE(0, 100);
@


1.6
log
@
Changed:
- the stat room info
@
text
@d338 1
a338 1
/*
d340 1
a340 1
    sprintf(buf, "$n %s", POOFOUT(ch));
d342 2
a343 2
    strcpy(buf, "$n disappears in a puff of smoke.");
 */
d354 1
a354 1
/*
d356 1
a356 1
        sprintf(buf, "$n %s", POOFIN(ch));
d358 1
a358 1
        strcpy(buf, "$n appears with an ear-splitting bang.");
d360 1
a360 1
      act(buf, TRUE, ch, 0, 0, TO_ROOM); */
d787 1
d969 1
a969 2
    }
    send_to_char(buf,ch); */
d1086 38
@


1.5
log
@
Added:
- olc stuff - sectors, zone flags

Changed:
- Heaps of little fixes ....
@
text
@d489 6
a494 4
  sprintf(buf, "Sector Types:\r\n"
               " Base: %s, Atmosphere: %s,\r\n"
               " Temperature: %s, Gravity: %s\r\n" 
               " Environment: %s\r\n",
d499 1
a499 1
  sprintf(buf, "SpecProc: %s, Flags: %s\r\n",
d503 1
a503 1
  send_to_char("Description:\r\n", ch);
d518 1
a518 1
  sprintf(buf, "Chars present:%s", CCYEL(ch, C_NRM));
d522 3
a524 1
    sprintf(buf2, "%s %s(%s)", found++ ? "," : "", GET_NAME(k),
d526 4
d545 1
a545 1
    sprintf(buf, "Contents:%s", CCGRN(ch, C_NRM));
d549 1
a549 1
      sprintf(buf2, "%s %s", found++ ? "," : "", j->short_description);
@


1.4
log
@

Added:
- more shite
@
text
@d451 1
a451 1
    send_to_char("Usage: vnum { obj | mob } <name>\r\n", ch);
d472 1
d478 7
a484 2
  sprinttype(rm->sector_type, sector_types, buf2);
  sprintf(buf, "Zone: [%3d], VNum: [%s%5d%s], RNum: [%5d], Type: %s\r\n",
d486 9
a494 2
	  CCNRM(ch, C_NRM), ch->in_room, buf2);
  send_to_char(buf, ch);
d1344 1
a1344 1
    send_to_char("Usage: load { obj | mob } <number>\r\n", ch);
d1392 1
a1392 1
    send_to_char("Usage: vstat { obj | mob } <number>\r\n", ch);
d1497 1
a1497 1
    send_to_char("Usage: syslog { Off | Brief | Normal | Complete }\r\n", ch);
d1868 1
a1868 1
    send_to_char("Usage: DC <user number> (type USERS for a list)\r\n", ch);
d2106 2
a2107 2
      send_to_char("Usage: immnet <text> | #<level> <text> | *<emotetext> |\r\n"
                   "       immnet @@<level> *<emotetext> | imm @@\r\n",ch);
d2400 1
a2400 2
  sprintf(bufptr, "%s&B%3d&n %-20.20s &gAge&n: &y%3d&n; &gReset&n: &y%3d&n &b(&r%1d&b)&n; 
&gTop&n: &c%5d&n &gFlags&n: %s\r\n", bufptr, zone_table[zone].number, zone_table[zone].name,
d2534 1
a2534 1
    strcpy(buf, "Current stats:\r\n");
d2554 1
a2554 1
    strcpy(buf, "Errant Rooms\r\n------------\r\n");
d2563 1
a2563 1
    strcpy(buf, "Death Traps\r\n-----------\r\n");
d2571 1
a2571 1
    strcpy(buf, "Godrooms\r\n--------------------------\r\n");
d2586 2
a2587 2
    send_to_char("People currently snooping:\r\n", ch);
    send_to_char("--------------------------\r\n", ch);
d2612 1
a2612 1
  send_to_char("\r\n &BSpecials available:&n\r\n", ch);
d2754 2
d3078 6
d3264 1
a3264 1
	send_to_char("You must specify the value of the special.\r\n Use &gset <player> special list&n to see specials available.\r\n", ch);
d3269 2
a3270 2
	send_to_char("That's not a valid option!\r\nUser &gset <player> special list&n to see options.\r\n", ch);
  	return (0);
d3281 1
a3281 1
   sprintf(buf, "&g%s&n toggled &W%s&n for &B%s&n.\r\n", special_ability_bits[atoi(val_arg)-1], 
d3325 1
a3325 1
  } else if (!str_cmp(name, "mob"))
d3327 1
d3333 1
a3333 1
    send_to_char("&yUsage: &bset &B<victim> <field> <value>&n\r\n", ch);
d3396 35
a3430 2
// DM - TODO - Decide on sethelp (add in wizhelp file?)
//   TALI - Decided to just do a set_list function to show the god
d3876 1
a3876 1
  send_to_char("&BQuest Item Enhancements:&n\r\n", ch);
d3908 1
a3908 1
	sprintf(buf, "Quest item enhancement (set on %s) for &y%s&n removed.\r\n",
d3955 1
a3955 1
    send_to_char("That'll either be &clist&n/&cadd&n/&cdel&n/&cenhance&n/&cstat&n.\r\n",ch);
d4027 1
a4027 1
      sprintf(buf2,"Quest items for &B%s&n:\r\n",GET_NAME(vict));
d4040 1
a4040 1
      send_to_char("Usage: questlog add <name> &c<obj vnum>&n\r\n",ch);
d4084 1
a4084 1
      send_to_char("Usage: questlog del <name> &c<obj vnum>&n\r\n",ch);
d4152 2
a4153 2
	send_to_char("Enhancement usage: questlog enhance <player> <x>.<obj vnum> <enh #> <val>\r\n"
		     "       Optionally: questlog enhance <player> <list | apply | delete>\r\n", ch);
d4207 1
a4207 1
	sprintf(buf, "Quest item enhancements for &B%s&n:\r\n", GET_NAME(vict));
d4237 1
a4237 1
        send_to_char("Usage: questlog enhance <name> &c<num in list>.<obj vnum>&n <enh #> <val>\r\n",ch);
@


1.3
log
@

Added:
- Events
-

Changed:
- Score command
-

TODO:
- Finish the base
-
@
text
@d861 2
a862 2
    sprintf(buf,"Start Rooms: [%d, %d, %d]\r\n",ENTRY_ROOM(ch,WORLD_MEDIEVAL),
        ENTRY_ROOM(ch,WORLD_WEST), ENTRY_ROOM(ch, WORLD_FUTURE));
d4542 1
d4623 11
a4633 1
void destroy_event_quest(struct char_data *ch) {
d4635 8
a4642 1
	send_to_char("Not implemented yet.\r\n", ch);
d4644 1
d4646 20
d4792 1
a4792 1
	if (*buf2)
d4794 1
a4794 2
		sprintf(buf1, "&G-ITEM HUNT NOTICE-&g\r\n%s\r\n", buf2);
		send_to_all(buf1);
d4796 2
d4804 24
d4830 1
a4830 1
	send_to_char("&rWarning : In progress.&n\r\n", ch);
d4835 2
a4836 1
			"  - itemhunt\r\n", ch);
d4844 2
d4968 1
a4968 1

d5024 2
a5025 1
		if( !*buf1 ) {
d5030 1
a5030 1
		if( strcmp(buf1, "curfew") == 0 ) {
d5034 1
a5034 1
		if( strcmp(buf1, "goldrush") == 0 ) {
d5038 2
a5039 2
		if( strcmp(buf1, "quest") == 0) {
			destroy_event_quest(ch);
d5042 1
a5042 1
		if( strcmp(buf1, "election") == 0 ) {
@


1.2
log
@my new skills!


Added:
-
-

Removed:
-
-

Changed:
-
-

TODO:
-
-
@
text
@d1 2
a2 1
/* ************************************************************************
d61 2
a62 1

d82 3
d2426 1
d2537 2
d2588 3
d2650 1
d2652 52
a2703 52
   { "brief",		LVL_GOD, 	PC, 	BINARY },  /* 0 */
   { "invstart", 	LVL_GOD, 	PC, 	BINARY },  /* 1 */
   { "title",		LVL_GOD, 	PC, 	MISC },
   { "nosummon", 	LVL_GRGOD, 	PC, 	BINARY },
   { "maxhit",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "maxmana", 	LVL_GRGOD, 	BOTH, 	NUMBER },  /* 5 */
   { "maxmove", 	LVL_GRGOD, 	BOTH, 	NUMBER },
   { "hit", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "mana",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "move",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "align",		LVL_GOD, 	BOTH, 	NUMBER },  /* 10 */
   { "str",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "stradd",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "int", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "wis", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "dex", 		LVL_GRGOD, 	BOTH, 	NUMBER },  /* 15 */
   { "con", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "cha",		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "ac", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "gold",		LVL_GOD, 	BOTH, 	NUMBER },
   { "bank",		LVL_GOD, 	PC, 	NUMBER },  /* 20 */
   { "exp", 		LVL_GRGOD, 	BOTH, 	NUMBER },
   { "hitroll", 	LVL_GRGOD, 	BOTH, 	NUMBER },
   { "damroll", 	LVL_GRGOD, 	BOTH, 	NUMBER },
   { "invis",		LVL_IMPL, 	PC, 	NUMBER },
   { "nohassle", 	LVL_GRGOD, 	PC, 	BINARY },  /* 25 */
   { "frozen",		LVL_FREEZE, 	PC, 	BINARY },
   { "practices", 	LVL_GRGOD, 	PC, 	NUMBER },
   { "lessons", 	LVL_GRGOD, 	PC, 	NUMBER },
   { "drunk",		LVL_GRGOD, 	BOTH, 	MISC },
   { "hunger",		LVL_GRGOD, 	BOTH, 	MISC },    /* 30 */
   { "thirst",		LVL_GRGOD, 	BOTH, 	MISC },
   { "killer",		LVL_GOD, 	PC, 	BINARY },
   { "thief",		LVL_GOD, 	PC, 	BINARY },
   { "level",		LVL_IMPL, 	BOTH, 	NUMBER },
   { "room",		LVL_IMPL, 	BOTH, 	NUMBER },  /* 35 */
   { "roomflag", 	LVL_GRGOD, 	PC, 	BINARY },
   { "siteok",		LVL_GRGOD, 	PC, 	BINARY },
   { "deleted", 	LVL_IMPL, 	PC, 	BINARY },
   { "class",		LVL_GRGOD, 	BOTH, 	MISC },
   { "nowizlist", 	LVL_GOD, 	PC, 	BINARY },  /* 40 */
   { "quest",		LVL_GOD, 	PC, 	BINARY },
   { "loadroom", 	LVL_GRGOD, 	PC, 	MISC },
   { "color",		LVL_GOD, 	PC, 	BINARY },
   { "idnum",		LVL_IMPL, 	PC, 	NUMBER },
   { "passwd",		LVL_IMPL, 	PC, 	MISC },    /* 45 */
   { "nodelete", 	LVL_GOD, 	PC, 	BINARY },
   { "sex", 		LVL_GRGOD, 	BOTH, 	MISC },
   { "age",		LVL_GRGOD,	BOTH,	NUMBER },
   { "height",		LVL_GOD,	BOTH,	NUMBER },
   { "weight",		LVL_GOD,	BOTH,	NUMBER },  /* 50 */
   { "olc",             LVL_IMPL,       PC,     NUMBER },
d2706 16
a2721 16
   { "timer",           LVL_IMPL,       PC,     NUMBER },
   { "holylight",       LVL_GRGOD,      PC,     BINARY },  
   { "infection",       LVL_GRGOD,      PC,     MISC },
   { "tag",             LVL_GOD,        PC,     BINARY },  /* 55 */
   { "palign",          LVL_GOD,        PC,     BINARY },
   { "noignore",        LVL_GOD,        PC,     BINARY },
   { "leader",          LVL_GOD,        PC,     MISC   },  
   { "fix",             LVL_IMPL,       PC,     BINARY },
   { "clan",            LVL_GOD,        PC,     MISC },    /* 60 */
   { "autogold",        LVL_GOD,        PC,     BINARY },
   { "autoloot",        LVL_GOD,        PC,     BINARY },
   { "autoassist",      LVL_GOD,        PC,     MISC   },   
   { "autoassisters",   LVL_GOD,        BOTH,   MISC   },
   { "autosplit",       LVL_GOD,        BOTH,   MISC },    /* 65 */ 
   { "race", 		LVL_GOD, 	PC,   MISC },
   { "special",         LVL_GRGOD,      PC,   MISC },
d3250 1
a3250 1
   	return (0);
d3276 11
d3312 2
a3313 1
    send_to_char("Usage: set <victim> <field> <value>\r\n", ch);
d3376 1
d4542 443
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d11 4
d16 1
d3241 2
a3242 3
	if (IS_SET(GET_SPECIALS(ch), (1 << atoi(val_arg) - 1))) {
		send_to_char("Bit removed\r\n", ch);
		REMOVE_BIT(GET_SPECIALS(ch), (1 << atoi(val_arg) - 1));
d3245 1
a3245 2
		send_to_char("Bit set\r\n", ch);
		SET_BIT(GET_SPECIALS(ch), (1 << atoi(val_arg) - 1));
@

