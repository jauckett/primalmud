head	1.82;
access;
symbols
	LATEST:1.6
	A3_0_1:1.5;
locks; strict;
comment	@ * @;


1.82
date	2004.07.15.02.42.30;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	2004.06.06.08.20.50;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	2004.06.05.08.31.02;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	2004.06.04.12.34.02;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	2004.05.29.23.57.08;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	2004.05.21.14.16.54;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	2004.05.18.11.07.14;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	2004.05.10.03.25.02;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	2004.05.08.01.46.41;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	2004.05.07.06.10.10;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	2004.05.06.02.23.30;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	2004.04.29.08.24.34;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	2004.04.29.08.02.04;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	2004.03.01.03.35.12;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	2004.02.28.10.07.05;	author john;	state Exp;
branches;
next	1.67;

1.67
date	2004.02.23.03.04.55;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.30.05.26.15;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	2004.01.24.01.13.14;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	2004.01.21.08.12.03;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.15.01.19.09;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	2004.01.14.05.58.24;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.12.04.39.09;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	2004.01.11.20.29.09;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	2004.01.10.13.04.50;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	2004.01.10.12.02.26;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.06.04.32.51;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.04.12.17.15;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.04.10.35.01;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.02.02.44.33;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	2003.12.17.02.25.06;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.09.05.42.45;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	2003.11.22.22.04.00;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	2003.11.21.02.48.06;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	2003.11.19.01.20.18;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	2003.11.18.08.25.29;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	2003.11.13.01.05.29;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	2003.11.12.22.50.32;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	2003.11.12.11.00.14;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	2003.11.08.11.58.23;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	2003.11.05.12.17.14;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	2003.11.05.03.39.27;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	2003.11.03.17.01.12;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	2003.10.29.12.23.11;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	2003.10.21.05.30.48;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.20.12.01.50;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.14.07.24.17;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	2002.10.01.10.26.03;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	2002.07.20.08.17.56;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.07.05.14.12;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.14.06.10.19;	author primal;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.25.03.58.12;	author primal;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.23.06.37.38;	author primal;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.07.01.05.33;	author karma;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.25.00.11.31;	author artus;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.11.04.24.29;	author rod;	state Exp;
branches;
next	1.27;

1.27
date	2001.10.28.06.37.48;	author karma;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.13.08.07.16;	author primal;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.12.03.26.00;	author artus;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.12.01.48.09;	author artus;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.11.13.27.34;	author artus;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.26.23.52.26;	author primal;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.21.02.49.59;	author artus;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.18.03.29.03;	author artus;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.18.00.13.37;	author artus;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.15.11.40.52;	author artus;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.11.13.59.14;	author artus;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.09.03.29.54;	author artus;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.03.10.08.52;	author primal;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.03.06.24.04;	author primal;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.03.05.27.54;	author artus;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.03.03.21.32;	author primal;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.28.00.38.45;	author artus;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.26.07.50.15;	author primal;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.11.15.11.53;	author primal;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.03.01.10.24;	author primal;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.02.04.34.49;	author primal;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.22.47.55;	author primal;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.20.16.40.22;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.14.00.52.56;	author primal;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.26.07.52.28;	author primal;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.12.29.21;	author talisman;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.44.00;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.82
log
@Artus> Bodyslam now sends a message to the target room.
       Bodyslam no longer slams through exit to same room.
@
text
@/* ************************************************************************
*   File: spell_parser.c                                Part of CircleMUD *
*  Usage: top-level magic routines; outside points of entry to magic sys. *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */


#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "interpreter.h"
#include "spells.h"
#include "handler.h"
#include "comm.h"
#include "db.h"
#include "dg_scripts.h"
#include "clan.h" // For violence_check
#include "constants.h"

//struct spell_info_type spell_info[TOP_SPELL_DEFINE + 1];

#define SINFO spell_info[spellnum]

extern struct room_data *world;
extern struct spell_info_type spell_info[];

/* local functions */
void say_spell(struct char_data * ch, int spellnum, struct char_data * tch, struct obj_data * tobj, int cargeamt);
void spello(int spl, const char *name, int max_mana, int min_mana, int mana_change, int minpos, int targets, int violent, int routines);
int mag_manacost(struct char_data * ch, int spellnum);
ACMD(do_cast);
void unused_spell(int spl);
void mag_assign_spells(void);
bool violence_check(struct char_data *ch, struct char_data *vict, int skillnum);

/* external functions */
ACMD(do_hit);
int compute_armor_class(struct char_data *ch, bool divide);
void check_killer(struct char_data * ch, struct char_data * vict);
void clan_rel_inc(struct char_data *ch, struct char_data *vict, int amt);
int is_axe(struct obj_data *obj);
int ok_damage_shopkeeper(struct char_data * ch, struct char_data * victim);

SPECIAL(postmaster);
SPECIAL(receptionist);

/*
 * This arrangement is pretty stupid, but the number of skills is limited by
 * the playerfile.  We can arbitrarily increase the number of skills by
 * increasing the space in the playerfile. Meanwhile, 200 should provide
 * ample slots for skills.
 */

struct syllable {
  const char *org;
  const char *news;
};


struct syllable syls[] = {
  {" ", " "},
  {"ar", "abra"},
  {"ate", "i"},
  {"cau", "kada"},
  {"blind", "nose"},
  {"bur", "mosa"},
  {"cu", "judi"},
  {"de", "oculo"},
  {"dis", "mar"},
  {"ect", "kamina"},
  {"en", "uns"},
  {"gro", "cra"},
  {"light", "dies"},
  {"lo", "hi"},
  {"magi", "kari"},
  {"mon", "bar"},
  {"mor", "zak"},
  {"move", "sido"},
  {"ness", "lacri"},
  {"ning", "illa"},
  {"per", "duda"},
  {"ra", "gru"},
  {"re", "candus"},
  {"son", "sabru"},
  {"tect", "infra"},
  {"tri", "cula"},
  {"ven", "nofo"},
  {"word of", "inset"},
  {"a", "i"}, {"b", "v"}, {"c", "q"}, {"d", "m"}, {"e", "o"}, {"f", "y"}, {"g", "t"},
  {"h", "p"}, {"i", "u"}, {"j", "y"}, {"k", "t"}, {"l", "r"}, {"m", "w"}, {"n", "b"},
  {"o", "a"}, {"p", "s"}, {"q", "d"}, {"r", "f"}, {"s", "g"}, {"t", "h"}, {"u", "e"},
  {"v", "z"}, {"w", "x"}, {"x", "n"}, {"y", "l"}, {"z", "k"}, {"", ""}
};

const char *unused_spellname = "!UNUSED!"; /* So we can get &unused_spellname */

int mag_manacost(struct char_data * ch, int spellnum)
{
  int mana = MAX(SINFO.mana_max[(int) GET_CLASS(ch)] - 
	     (SINFO.mana_change[(int) GET_CLASS(ch)] *
		    (GET_LEVEL(ch) - SINFO.min_level[(int) GET_CLASS(ch)])),
	     SINFO.mana_min[(int) GET_CLASS(ch)]);

  // DM - mana percentage - Artus: Modified, Div0 Bug.
  if (SINFO.mana_perc[(int)GET_CLASS(ch)] > 0)
    mana = (int)((100 * mana) / SINFO.mana_perc[(int)GET_CLASS(ch)]);
  return (mana);
}


/* say_spell erodes buf, buf1, buf2 */
void say_spell(struct char_data * ch, int spellnum, struct char_data * tch,
	            struct obj_data * tobj, int chargeamt)
{
  char lbuf[256];
  const char *format;
  int concealed = 0;
  struct char_data *i;
  int j, ofs = 0;

  *buf = '\0';
  strcpy(lbuf, skill_name(spellnum));

  while (lbuf[ofs]) 
  {
    for (j = 0; *(syls[j].org); j++) 
    {
      if (!strncmp(syls[j].org, lbuf + ofs, strlen(syls[j].org))) 
      {
	strcat(buf, syls[j].news);
	ofs += strlen(syls[j].org);
        break;
      }
    }
    if (!*syls[j].org) 
    {
      basic_mud_log("No entry in syllable table for substring of '%s'", lbuf);
      ofs++;
    }
  }

  // Generate the strings, one with clean spell name, one with 'magic words'.
  if (tch != NULL && IN_ROOM(tch) == IN_ROOM(ch)) 
  {
    if (tch == ch)
      format = "$n closes $s eyes and utters the words, '%s'.";
    else
      format = "$n stares at $N and utters the words, '%s'.";
  } else if (tobj != NULL &&
	     ((IN_ROOM(tobj) == IN_ROOM(ch)) || (tobj->carried_by == ch)))
    format = "$n stares at $p and utters the words, '%s'.";
  else
    format = "$n utters the words, '%s'.";
  sprintf(buf1, format, skill_name(spellnum));
  sprintf(buf2, format, buf);

  // Are we concealing? -- Artus.
  if (!IS_NPC(ch) && GET_SKILL(ch, SKILL_CONCEAL_SPELL_CASTING) &&
      (number(1, 101) < GET_SKILL(ch, SKILL_CONCEAL_SPELL_CASTING)))
  {
    send_to_char("You manage to conceal your spell casting.\r\n", ch);
    concealed = 1;
  }
  // Send the message to those in the room.
  for (i = world[IN_ROOM(ch)].people; i; i = i->next_in_room)
  {
    if ((i==ch) || (i==tch) || (!i->desc) || !AWAKE(i) || 
	((concealed==1) && LR_FAIL(i, LVL_IS_GOD)))
      continue;
    if (GET_SKILL(i, spellnum) > 0)
      perform_act(buf1, ch, tobj, tch, i);
    else
      perform_act(buf2, ch, tobj, tch, i);
  }
  // Now, Handle the Victim, if there is one. -- Artus.
  if ((tch != NULL) && (tch != ch) && (tch->desc) && AWAKE(tch) &&
      ((concealed == 0) || !LR_FAIL(tch, LVL_IS_GOD)))
  {
    if (chargeamt > 0)
      sprintf(buf1, "$n takes your money, stares at you, and utters the words, '%s'.", (GET_SKILL(tch, spellnum) > 0) ? skill_name(spellnum) : buf);
    else
      sprintf(buf1, "$n stares at you and utters the words, '%s'.",
              (GET_SKILL(tch, spellnum) > 0) ? skill_name(spellnum) : buf);
    perform_act(buf1, ch, NULL, tch, tch); 
  }
}

/*
 * This function should be used anytime you are not 100% sure that you have
 * a valid spell/skill number.  A typical for() loop would not need to use
 * this because you can guarantee > 0 and <= TOP_SPELL_DEFINE.
 */
const char *skill_name(int num)
{
  if (num > 0 && num <= TOP_SPELL_DEFINE)
    return (spell_info[num].name);
  else if (num == -1)
    return ("UNUSED");
  else
    return ("UNDEFINED");
}

	 
int find_skill_num(char *name)
{
  int index, ok;
  char *temp, *temp2;
  char first[256], first2[256];

  for (index = 1; index <= TOP_SPELL_DEFINE; index++) {
    if (is_abbrev(name, spell_info[index].name))
      return (index);

    ok = TRUE;
    /* It won't be changed, but other uses of this function elsewhere may. */
    temp = any_one_arg((char *)spell_info[index].name, first);
    temp2 = any_one_arg(name, first2);
    while (*first && *first2 && ok) {
      if (!is_abbrev(first2, first))
	ok = FALSE;
      temp = any_one_arg(temp, first);
      temp2 = any_one_arg(temp2, first2);
    }

    if (ok && !*first2)
      return (index);
  }

  return (-1);
}

/* Artus - Basic skill/spell test... */
bool basic_skill_test(struct char_data * ch, int spellnum, bool perform)
{
  if IS_NPC(ch) 
    return 0;

  if (!GET_SKILL(ch, spellnum)) {
    switch (spellnum) {
      case SKILL_AXEMASTERY:
      case SKILL_PERCEPTION:
	break;
      default:
	if (perform)
          send_to_char("You don't know how.\r\n", ch);
	break;
    }
    return 0;
  }

  if (!has_stats_for_skill(ch, spellnum, perform))
    return 0;

  if (perform) 
  {
    // DM - concentration loss formula - 
    if (number(0, 101) > GET_SKILL(ch, spellnum))
    {
      if (spellnum < MAX_SPELLS) 
        send_to_char("You lost your concentration.\r\n", ch);
      else
      {
	switch (spellnum)
	{
	  case SKILL_LISTEN: 
	    send_to_char("You can't hear anything.\r\n", ch);
	    break;
	  case SKILL_AXEMASTERY:
	  case SKILL_PERCEPTION:
	    break;
	  default:
            send_to_char("You fail.\r\n", ch);
	}
      }
      return 0;
    }
  }
  
  if (perform)
    apply_spell_skill_abil(ch, spellnum);

  return 1;
}
  
/*
 * This function is the very heart of the entire magic system.  All
 * invocations of all types of magic -- objects, spoken and unspoken PC
 * and NPC spells, the works -- all come through this function eventually.
 * This is also the entry point for non-spoken or unrestricted spells.
 * Spellnum 0 is legal but silently ignored here, to make callers simpler.
 */
int call_magic(struct char_data * caster, struct char_data * cvict,
	     struct obj_data * ovict, int spellnum, int level, int casttype)
{
  int savetype;

  if (spellnum < 1 || spellnum > TOP_SPELL_DEFINE)
    return (0);

  if (IS_NPC(caster) || LR_FAIL(caster, LVL_IMPL))
  {
    if (caster->nr != real_mobile(DG_CASTER_PROXY)) 
    {
      if (ROOM_FLAGGED(IN_ROOM(caster), ROOM_NOMAGIC) &&
	  (SINFO.violent || (casttype != CAST_MAGIC_OBJ)))
      {
	send_to_char("Your magic fizzles out and dies.\r\n", caster);
	act("$n's magic fizzles out and dies.", FALSE, caster, 0, 0, TO_ROOM);
	return (0);
      }
      if (ROOM_FLAGGED(IN_ROOM(caster), ROOM_PEACEFUL) &&
          (SINFO.violent || IS_SET(SINFO.routines, MAG_DAMAGE))) 
      {
	send_to_char("A flash of white light fills the room, dispelling your "
		     "violent magic!\r\n", caster);
	act("White light from no particular source suddenly fills the room, "
	    "then vanishes.", FALSE, caster, 0, 0, TO_ROOM);
	return (0);
      }
    }
  }
  /*
  if (ROOM_FLAGGED(IN_ROOM(caster), ROOM_NOMAGIC)) {
    send_to_char("Your magic fizzles out and dies.\r\n", caster);
    act("$n's magic fizzles out and dies.", FALSE, caster, 0, 0, TO_ROOM);
    return (0);
  }
  if (ROOM_FLAGGED(IN_ROOM(caster), ROOM_PEACEFUL) &&
      (SINFO.violent || IS_SET(SINFO.routines, MAG_DAMAGE))) {
    send_to_char("A flash of white light fills the room, dispelling your "
		 "violent magic!\r\n", caster);
    act("White light from no particular source suddenly fills the room, "
	"then vanishes.", FALSE, caster, 0, 0, TO_ROOM);
    return (0);
  }
  */

  /* determine the type of saving throw */
  switch (casttype)
  {
    case CAST_STAFF:
    case CAST_SCROLL:
    case CAST_POTION:
    case CAST_WAND:
      savetype = SAVING_ROD;
      break;
    case CAST_SPELL:
      savetype = SAVING_SPELL;
      break;
    default:
      savetype = SAVING_BREATH;
      break;
  }

  if (IS_SET(SINFO.routines, MAG_DAMAGE))
    if (mag_damage(level, caster, cvict, spellnum, savetype) == -1)
      return (-1);	/* Successful and target died, don't cast again. */

  if (IS_SET(SINFO.routines, MAG_AFFECTS))
    mag_affects(level, caster, cvict, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_UNAFFECTS))
    mag_unaffects(level, caster, cvict, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_POINTS))
    mag_points(level, caster, cvict, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_ALTER_OBJS))
    mag_alter_objs(level, caster, ovict, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_GROUPS))
    mag_groups(level, caster, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_MASSES))
    mag_masses(level, caster, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_AREAS))
    mag_areas(level, caster, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_SUMMONS))
    mag_summons(level, caster, ovict, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_CREATIONS))
    mag_creations(level, caster, spellnum);

  if (IS_SET(SINFO.routines, MAG_MANUAL))
    switch (spellnum)
    {
      case SPELL_CHARM:		   MANUAL_SPELL(spell_charm);            break;
      case SPELL_CREATE_WATER:	   MANUAL_SPELL(spell_create_water);     break;
      case SPELL_DETECT_POISON:	   MANUAL_SPELL(spell_detect_poison);    break;
      case SPELL_ENCHANT_WEAPON:   MANUAL_SPELL(spell_enchant_weapon);   break;
      case SPELL_IDENTIFY:	   MANUAL_SPELL(spell_identify);         break;
      case SPELL_LOCATE_OBJECT:    MANUAL_SPELL(spell_locate_object);    break;
      case SPELL_SUMMON:	   MANUAL_SPELL(spell_summon);           break;
      case SPELL_WORD_OF_RECALL:   MANUAL_SPELL(spell_recall);           break;
      case SPELL_TELEPORT:	   MANUAL_SPELL(spell_teleport);         break;
      case SPELL_FINGERDEATH:	   MANUAL_SPELL(spell_fingerdeath);      break;
      case SPELL_CONTROL_WEATHER:  MANUAL_SPELL(spell_control_weather);  break;
      case SPELL_FEAR: 		   MANUAL_SPELL(spell_fear);             break;
      case SPELL_GATE: 		   MANUAL_SPELL(spell_gate);             break;
      case SPELL_UNHOLY_VENGEANCE: MANUAL_SPELL(spell_unholy_vengeance); break;
    }

  // Apply ability gains - DM
  if (casttype == CAST_SPELL)
    apply_spell_skill_abil(caster, spellnum);

  return (1);
}

/*
 * Apply ability gains based on current spell/skill ability
 * This function should be called on every successful use of a spell/skill.
 */
void apply_spell_skill_abil(struct char_data *ch, int spellnum) {

  int ability=0;
  int chance;
  int roll;

  if (IS_NPC(ch))
    return;

  switch (spellnum)
  {
    case SKILL_TRACK:
      if (IS_SET(GET_SPECIALS(ch), SPECIAL_TRACKER))
	ability = MAX(1, GET_SKILL(ch, spellnum));
      break;
    case SKILL_BACKSTAB:
      if (IS_SET(GET_SPECIALS(ch), SPECIAL_BACKSTAB))
	ability = MAX(1, GET_SKILL(ch, spellnum));
    default:
      ability = GET_SKILL(ch, spellnum);
  }

  if ((ability < 1) || (ability >= MAX_SKILL_ABIL))
    return;

  chance = MAX(1, (int)((2 * ability)/3));
  roll = number(1, chance);

  // Chance of 2/3 * current skill level for char to increase ability  
  if (roll == 1) 
  {
    GET_SKILL(ch, spellnum) += 1;
    switch (spellnum) {
      case SKILL_PERCEPTION:
	break;
      default:
	if (ability >= MAX_SKILL_ABIL)
	  sprintf(buf, "&0You are now fully learend in %s!&n\r\n", 
	          spell_info[spellnum].name);
	else
	  sprintf(buf, "&0Your ability in using %s increases.&n\r\n", 
			spell_info[spellnum].name);
        send_to_char(buf, ch);
    }
  }
}

/*
 * mag_objectmagic: This is the entry-point for all magic items.  This should
 * only be called by the 'quaff', 'use', 'recite', etc. routines.
 *
 * For reference, object values 0-3:
 * staff  - [0]	level	[1] max charges	[2] num charges	[3] spell num
 * wand   - [0]	level	[1] max charges	[2] num charges	[3] spell num
 * scroll - [0]	level	[1] spell num	[2] spell num	[3] spell num
 * potion - [0] level	[1] spell num	[2] spell num	[3] spell num
 *
 * Staves and wands will default to level 14 if the level is not specified;
 * the DikuMUD format did not specify staff and wand levels in the world
 * files (this is a CircleMUD enhancement).
 */

void mag_objectmagic(struct char_data * ch, struct obj_data * obj,
		          char *argument)
{
  int i, k;
  struct char_data *tch = NULL;
  struct obj_data *tobj = NULL;

  one_argument(argument, arg);

  if (!*arg)
  {
    tch = ch;
    k = FIND_CHAR_ROOM;
  }
  else
    k = generic_find(arg, FIND_CHAR_ROOM | FIND_OBJ_INV | FIND_OBJ_ROOM |
		     FIND_OBJ_EQUIP, ch, &tch, &tobj);

  switch (GET_OBJ_TYPE(obj))
  {
    case ITEM_STAFF:
      if (k==0)
      {
	send_to_char("Could not find the requested target.\r\n", ch);
	return;
      }
      act("You tap $p three times on the ground.", FALSE, ch, obj, 0, TO_CHAR);
      if (obj->action_description)
	act(obj->action_description, FALSE, ch, obj, 0, TO_ROOM);
      else
	act("$n taps $p on the ground three times.", FALSE, ch, obj, 0, 
	    TO_ROOM);
      if (GET_OBJ_VAL(obj, 2) <= 0)
      {
	send_to_char("It seems powerless.\r\n", ch);
	act("Nothing seems to happen.", FALSE, ch, obj, 0, TO_ROOM);
	return;
      }
      GET_OBJ_VAL(obj, 2)--;
      WAIT_STATE(ch, PULSE_VIOLENCE);
      k = GET_OBJ_VAL(obj, 0) ? GET_OBJ_VAL(obj, 0) : DEFAULT_STAFF_LVL;
      call_magic(ch, tch, tobj, GET_OBJ_VAL(obj, 3), k, CAST_WAND);
      break;
    case ITEM_WAND:
      if (k == FIND_CHAR_ROOM)
      {
	if (tch == ch)
	{
	  act("You point $p at yourself.", FALSE, ch, obj, 0, TO_CHAR);
	  act("$n points $p at $mself.", FALSE, ch, obj, 0, TO_ROOM);
	} else {
	  act("You point $p at $N.", FALSE, ch, obj, tch, TO_CHAR);
	  if (obj->action_description)
	    act(obj->action_description, FALSE, ch, obj, tch, TO_ROOM);
	  else
	    act("$n points $p at $N.", TRUE, ch, obj, tch, TO_ROOM);
	}
      } else if (tobj != NULL) {
	act("You point $p at $P.", FALSE, ch, obj, tobj, TO_CHAR);
	if (obj->action_description)
	  act(obj->action_description, FALSE, ch, obj, tobj, TO_ROOM);
	else
	  act("$n points $p at $P.", TRUE, ch, obj, tobj, TO_ROOM);
      } else if (IS_SET(spell_info[GET_OBJ_VAL(obj, 3)].routines, MAG_AREAS | MAG_MASSES)) {
	/* Wands with area spells don't need to be pointed. */
	act("You point $p outward.", FALSE, ch, obj, NULL, TO_CHAR);
	act("$n points $p outward.", TRUE, ch, obj, NULL, TO_ROOM);
      } else {
	act("At what should $p be pointed?", FALSE, ch, obj, NULL, TO_CHAR);
	return;
      }
      if (GET_OBJ_VAL(obj, 2) <= 0)
      {
	send_to_char("It seems powerless.\r\n", ch);
	act("Nothing seems to happen.", FALSE, ch, obj, 0, TO_ROOM);
	return;
      }
      GET_OBJ_VAL(obj, 2)--;
      WAIT_STATE(ch, PULSE_VIOLENCE);
      if (GET_OBJ_VAL(obj, 0))
	call_magic(ch, tch, tobj, GET_OBJ_VAL(obj, 3),
		   GET_OBJ_VAL(obj, 0), CAST_WAND);
      else
	call_magic(ch, tch, tobj, GET_OBJ_VAL(obj, 3),
		   DEFAULT_WAND_LVL, CAST_WAND);
      break;
    case ITEM_SCROLL:
      if (*arg)
      {
	if (!k)
	{
	  act("There is nothing to here to affect with $p.", FALSE,
	      ch, obj, NULL, TO_CHAR);
	  return;
	}
      } else
	tch = ch;
      act("You recite $p which dissolves.", TRUE, ch, obj, 0, TO_CHAR);
      if (obj->action_description)
	act(obj->action_description, FALSE, ch, obj, NULL, TO_ROOM);
      else
	act("$n recites $p.", FALSE, ch, obj, NULL, TO_ROOM);
      WAIT_STATE(ch, PULSE_VIOLENCE);
      for (i = 1; i <= 3; i++)
	if (call_magic(ch, tch, tobj, GET_OBJ_VAL(obj, i),
			 GET_OBJ_VAL(obj, 0), CAST_SCROLL) <= 0)
	  break;

      if (obj != NULL)
	extract_obj(obj);
      break;
    case ITEM_POTION:
      tch = ch;
      act("You quaff $p.", FALSE, ch, obj, NULL, TO_CHAR);
      if (obj->action_description)
	act(obj->action_description, FALSE, ch, obj, NULL, TO_ROOM);
      else
	act("$n quaffs $p.", TRUE, ch, obj, NULL, TO_ROOM);

      /* Artus> 20031013 - 6 Potions/Round if Adrenaline, else 5. */
      if (IS_AFFECTED(ch, AFF_ADRENALINE))
	WAIT_STATE(ch, (PULSE_VIOLENCE / 6));
      else
	WAIT_STATE(ch, (PULSE_VIOLENCE / 5));
      for (i = 1; i <= 3; i++)
	if (call_magic(ch, ch, NULL, GET_OBJ_VAL(obj, i),
                       GET_OBJ_VAL(obj, 0), CAST_POTION) <= 0)
	  break;
      if (obj != NULL)
	extract_obj(obj);
      break;
    default:
      basic_mud_log("SYSERR: Unknown object_type %d in mag_objectmagic.",
	GET_OBJ_TYPE(obj));
    break;
  }
}

// Artus> handle_spell_payment... For SPECIAL_PRIEST.
int handle_spell_payment(struct char_data *ch, struct char_data *tch, 
                          int spellnum)
{
  int amt = 0;

  if (GET_GOLD(tch) < 1) 
    return 0;

  switch (spellnum)
  {
    case SPELL_ARMOR: 
    case SPELL_BLESS:
    case SPELL_DETECT_MAGIC:
    case SPELL_DETECT_POISON:
    case SPELL_DIVINE_PROTECTION:
    case SPELL_DRAGON:
    case SPELL_GREATER_REMOVE_CURSE:
    case SPELL_HOLY_AID:
    case SPELL_STRENGTH:
    case SPELL_SPIRIT_ARMOR:
    case SPELL_STONESKIN:
      // Don't charge them if they already had it.
      if (affected_by_spell(tch, spellnum))
	return 0;
      break;
    case SPELL_ADV_HEAL:
    case SPELL_CURE_CRITIC:
    case SPELL_CURE_LIGHT:
    case SPELL_DIVINE_HEAL:
    case SPELL_HEAL:
      // Don't charge them if they were already maxed out.
      if (GET_HIT(tch) >= GET_MAX_HIT(tch))
	return 0;
      break;
      // Special Cases
    case SPELL_CURE_BLIND:
      if (AFF_FLAGGED(tch, AFF_BLIND))
	return 0;
      break;
    case SPELL_DETECT_ALIGN:
      if (AFF_FLAGGED(tch, AFF_DETECT_ALIGN))
	return 0;
      break;
    case SPELL_DETECT_INVIS:
      if (AFF_FLAGGED(tch, AFF_DETECT_INVIS))
	return 0;
      break;
    case SPELL_FLY:
      if (AFF_FLAGGED(tch, AFF_FLY))
	return 0;
      break;
    case SPELL_HASTE:
      if (AFF_FLAGGED(tch, AFF_HASTE))
	return 0;
      break;
    case SPELL_INFRAVISION:
      if (AFF_FLAGGED(tch, AFF_INFRAVISION))
	return 0;
      break;
    case SPELL_INVISIBLE:
      if (AFF_FLAGGED(tch, AFF_INVISIBLE | AFF_ADVANCED_INVIS))
	return 0;
      break;
    case SPELL_PROT_FROM_EVIL:
      if (AFF_FLAGGED(tch, AFF_PROTECT_EVIL))
	return 0;
      break;
    case SPELL_PROT_FROM_GOOD:
      if (AFF_FLAGGED(tch, AFF_PROTECT_GOOD))
	return 0;
      break;
    case SPELL_REFRESH:
      if (GET_MOVE(tch) >= GET_MAX_MOVE(tch))
	return 0;
      break;
    case SPELL_REMOVE_CURSE:
      if (AFF_FLAGGED(tch, AFF_CURSE))
	return 0;
      break;
    case SPELL_REMOVE_PARA:
      if (!(affected_by_spell(ch, SPELL_PARALYZE)))
	return 0;
      break;
    case SPELL_REMOVE_POISON:
      if (!(affected_by_spell(tch, SPELL_POISON)))
	return 0;
      break;
    case SPELL_SANCTUARY:
      if (AFF_FLAGGED(tch, AFF_SANCTUARY))
	return 0;
      break;
    case SPELL_SENSE_LIFE:
      if (AFF_FLAGGED(tch, AFF_SENSE_LIFE))
	return 0;
      break;
    case SPELL_SENSE_WOUNDS:
      if (AFF_FLAGGED(tch, AFF_SENSE_WOUNDS))
	return 0;
      break;
    case SPELL_SERPENT_SKIN:
      if (AFF_FLAGGED(tch, AFF_REFLECT))
	return 0;
      break;
    case SPELL_SUMMON:
      if (IN_ROOM(ch) == IN_ROOM(tch))
	return 0;
      break;
    case SPELL_WATERWALK:
      if (AFF_FLAGGED(tch, AFF_WATERWALK | AFF_WATERBREATHE))
	return 0;
      break;
    case SPELL_WATERBREATHE:
      if (AFF_FLAGGED(tch, AFF_WATERBREATHE))
	return 0;
      break;
      // Lightning Shield / Fire Shield / Fire Wall are all intertwined.
    case SPELL_LIGHT_SHIELD:
    case SPELL_FIRE_SHIELD:
      if (!GET_EQ(tch, WEAR_SHIELD))
	return 0;
    case SPELL_FIRE_WALL:
      if (affected_by_spell(tch, SPELL_FIRE_WALL) ||
	  affected_by_spell(tch, SPELL_FIRE_SHIELD) ||
	  affected_by_spell(tch, SPELL_LIGHT_SHIELD))
	return 0;
      break;
    default: // Anything that we're not handling doesn't get charged.:
      return 0;
  }
  // If we got this far, we know we're going to charge.
  amt = MIN(GET_LEVEL(tch) * 100, mag_manacost(ch, spellnum) * MAX(1, GET_LEVEL(ch) - SINFO.min_level[(int)GET_CLASS(ch)]));
#ifndef IGNORE_DEBUG
  if (GET_DEBUG(ch))
  {
    sprintf(buf, "DBG: Mana: %d, Min Level: %d, Amt: %d\r\n", 
	    mag_manacost(ch, spellnum), SINFO.min_level[(int)GET_CLASS(ch)],
	    amt);
    send_to_char(buf, ch);
  }
#endif
  return MIN(GET_GOLD(tch), amt);
}

/*
 * cast_spell is used generically to cast any spoken spell, assuming we
 * already have the target char/obj and spell number.  It checks all
 * restrictions, etc., prints the words, etc.
 *
 * Entry point for NPC casts.  Recommended entry point for spells cast
 * by NPCs via specprocs.
 */

int cast_spell(struct char_data * ch, struct char_data * tch,
	           struct obj_data * tobj, int spellnum)
{
  if (spellnum < 0 || spellnum > TOP_SPELL_DEFINE)
  {
    basic_mud_log("SYSERR: cast_spell trying to call spellnum %d/%d.\n", spellnum,
	TOP_SPELL_DEFINE);
    return (0);
  }
    
  if (GET_POS(ch) < SINFO.min_position) {
    switch (GET_POS(ch)) {
      case POS_SLEEPING:
      send_to_char("You dream about great magical powers.\r\n", ch);
      break;
    case POS_RESTING:
      send_to_char("You cannot concentrate while resting.\r\n", ch);
      break;
    case POS_SITTING:
      send_to_char("You can't do this sitting!\r\n", ch);
      break;
    case POS_FIGHTING:
      send_to_char("Impossible!  You can't concentrate enough!\r\n", ch);
      break;
    default:
      send_to_char("You can't do much of anything like this!\r\n", ch);
      break;
    }
    return (0);
  }
  if (AFF_FLAGGED(ch, AFF_CHARM) && (ch->master == tch)) {
    send_to_char("You are afraid you might hurt your master!\r\n", ch);
    return (0);
  }
  if ((tch != ch) && IS_SET(SINFO.targets, TAR_SELF_ONLY)) {
    send_to_char("You can only cast this spell upon yourself!\r\n", ch);
    return (0);
  }
  if ((tch == ch) && IS_SET(SINFO.targets, TAR_NOT_SELF)) {
    send_to_char("You cannot cast this spell upon yourself!\r\n", ch);
    return (0);
  }
  if (IS_SET(SINFO.routines, MAG_GROUPS) && !AFF_FLAGGED(ch, AFF_GROUP)) {
    send_to_char("You can't cast this spell if you're not in a group!\r\n",ch);
    return (0);
  }
  // Redundant when coming from do_cast, but not so in other cases.
  if (SINFO.violent && !violence_check(ch, tch, spellnum))
    return (0);

  send_to_char(OK, ch);

  if (!IS_NPC(ch) && (IS_SET(GET_SPECIALS(ch), SPECIAL_PRIEST)) && (tch) &&
      (ch != tch) && !IS_NPC(tch))
  {
    int retval = 0;
    int chargeamt = handle_spell_payment(ch, tch, spellnum);
    say_spell(ch, spellnum, tch, tobj, chargeamt);
    retval = call_magic(ch, tch, tobj, spellnum, GET_LEVEL(ch), CAST_SPELL);
    if (retval > 0)
    {
      GET_GOLD(tch) -= chargeamt;
      GET_GOLD(ch) += chargeamt;
    }
    return retval;
  }
  say_spell(ch, spellnum, tch, tobj, 0);
  return call_magic(ch, tch, tobj, spellnum, GET_LEVEL(ch), CAST_SPELL);
}


/*
 * do_cast is the entry point for PC-casted spells.  It parses the arguments,
 * determines the spell number and finds a target, throws the die to see if
 * the spell can be cast, checks for sufficient mana and subtracts it, and
 * passes control to cast_spell().
 */

ACMD(do_cast)
{
  struct char_data *tch = NULL;
  struct obj_data *tobj = NULL;
  char *s, *t;
  int mana, spellnum, target = 0;

  if (IS_NPC(ch))
    return;

  /* get: blank, spell name, target name */
  s = strtok(argument, "'");

  if (s == NULL)
  {
    send_to_char("Cast what where?\r\n", ch);
    return;
  }
  s = strtok(NULL, "'");
  if (s == NULL)
  {
    send_to_char("Spell names must be enclosed in the Holy Magic Symbols: '\r\n", ch);
    return;
  }
  t = strtok(NULL, "\0");

  /* spellnum = search_block(s, spells, 0); */
  spellnum = find_skill_num(s);

  if ((spellnum < 1) || (spellnum > MAX_SPELLS))
  {
    send_to_char("Cast what?!?\r\n", ch);
    return;
  }

  /* check min stats required */
  if (!has_stats_for_skill(ch, spellnum, TRUE))
    return;
 
  /* Berserk - No spells. */
  if (IS_AFFECTED(ch, AFF_BERSERK))
  {
    send_to_char("You can't cast spells while berserk.\r\n", ch);
    return;
  }

  /* Chance of failng whilest dual wielding.. -- Artus */
  if (IS_DUAL_WIELDING(ch) && LR_FAIL(ch, LVL_IMPL))
    if (number(0, 18) > GET_DEX(ch))
    {
      send_to_char("Having your hands full encumbers your ability to perform the incantations!\r\n", ch);
      return;
    }

  /* Check to see if the caster is using a shield for lightning/fire shield - DM */
  if ((spellnum == SPELL_LIGHT_SHIELD) || (spellnum == SPELL_FIRE_SHIELD))
  {
    if (!GET_EQ(ch,WEAR_SHIELD))
    {
      send_to_char("You need to be using a shield to cast this.\r\n",ch);
      return;
    }
  }
 
  /* Check for alignment and existing protection for protection from evil/good - DM */
  if ((spellnum == SPELL_PROT_FROM_EVIL) || (spellnum == SPELL_PROT_FROM_GOOD))
  {
    if (affected_by_spell(ch,SPELL_PROT_FROM_EVIL) ||
                affected_by_spell(ch,SPELL_PROT_FROM_GOOD))
    {
       send_to_char("You already feel invulnerable.\r\n",ch);
       return;
    }
 
    /* Check the required aligns are right */
    if (spellnum == SPELL_PROT_FROM_EVIL)
    {
      if (!IS_GOOD(ch))
      {
        send_to_char("If only you were a nicer person.\r\n",ch);
        return;
      }
    } else {
      if (!IS_EVIL(ch))
      {
        send_to_char("If only you were meaner.\r\n",ch);
        return;
      }
    }
  }

  /* Find the target */
  if (t != NULL)
  {
    one_argument(strcpy(arg, t), t);
    skip_spaces(&t);
  }

  //sprintf(buf,"targets : %d\r\n", SINFO.targets);
  //send_to_char(buf,ch);

  if (IS_SET(SINFO.targets, TAR_IGNORE))
    target = TRUE;
  else if (t != NULL && *t)
  {
    int locatebits = 0;
    if (IS_SET(SINFO.targets, TAR_CHAR_WORLD))
      SET_BIT(locatebits, FIND_CHAR_ROOM | FIND_CHAR_WORLD);
    else if (IS_SET(SINFO.targets, TAR_CHAR_INWORLD))
      SET_BIT(locatebits, FIND_CHAR_ROOM | FIND_CHAR_INWORLD);
    else if (IS_SET(SINFO.targets, TAR_CHAR_ROOM))
      SET_BIT(locatebits, FIND_CHAR_ROOM);
    if (IS_SET(SINFO.targets, TAR_OBJ_INV))
      SET_BIT(locatebits, FIND_OBJ_INV);
    if (IS_SET(SINFO.targets, TAR_OBJ_EQUIP))
      SET_BIT(locatebits, FIND_OBJ_EQUIP);
    if (IS_SET(SINFO.targets, TAR_OBJ_WORLD))
      SET_BIT(locatebits, FIND_OBJ_ROOM | FIND_OBJ_WORLD);
    else if (IS_SET(SINFO.targets, TAR_OBJ_ROOM))
      SET_BIT(locatebits, FIND_OBJ_ROOM);
    if (generic_find(t, locatebits, ch, &tch, &tobj) != 0)
      target = true;
  } else {			/* if target string is empty */
    if (!target && IS_SET(SINFO.targets, TAR_FIGHT_SELF))
      if (FIGHTING(ch) != NULL)
      {
	tch = ch;
	target = TRUE;
      }
    if (!target && IS_SET(SINFO.targets, TAR_FIGHT_VICT))
      if (FIGHTING(ch) != NULL)
      {
	tch = FIGHTING(ch);
	target = TRUE;
      }
    /* if no target specified, and the spell isn't violent, default to self */
    if (!target && IS_SET(SINFO.targets, TAR_CHAR_ROOM) &&
	!SINFO.violent)
    {
      tch = ch;
      target = TRUE;
    }
    if (!target)
    {
      sprintf(buf, "Upon %s should the spell be cast?\r\n",
	 IS_SET(SINFO.targets, TAR_OBJ_ROOM | TAR_OBJ_INV | TAR_OBJ_WORLD | TAR_OBJ_EQUIP) ? ((IS_SET(SINFO.targets, TAR_CHAR_ROOM | TAR_CHAR_WORLD | TAR_CHAR_INWORLD)) ? "who/what" : "what") : "who");
      send_to_char(buf, ch);
      return;
    }
  }
  
  switch (spellnum) // Any special checks.
  { 
    case SPELL_HASTE: // Restrict Victim Level.
    case SPELL_SERPENT_SKIN:
      if (target && tch && (tch != ch) && !IS_NPC(ch) && 
	  LR_FAIL(tch, LVL_NEWBIE) && LR_FAIL(ch, LVL_IMPL))
      {
	sprintf(buf, "Perhaps you should wait until &7%s&n is a little more experienced..\r\n", HSSH(tch));
	send_to_char(buf, ch);
	return;
      }
      break;
  }

  // Artus> Violence Checks.
  if ((SINFO.violent) && (!violence_check(ch, tch, spellnum)))
    return;

  if (target && (tch == ch) && SINFO.violent)
  {
    send_to_char("You shouldn't cast that on yourself -- could be bad for your health!\r\n", ch);
    return;
  }
  if (!target)
  {
    send_to_char("Cannot find the target of your spell!\r\n", ch);
    return;
  }
#ifndef IGNORE_DEBUG
  else {
    if (GET_DEBUG(ch))
    {
      sprintf(buf, "DEBUG: target is (%s)\r\n", (tch) ? GET_NAME(tch) : "None");
      send_to_char(buf, ch);
    }
  }
#endif
  mana = mag_manacost(ch, spellnum);
  if ((mana > 0) && (GET_MANA(ch) < mana) && (LR_FAIL(ch, LVL_IS_GOD)))
  {
    send_to_char("You haven't the energy to cast that spell!\r\n", ch);
    return;
  }

  // Check MAGIC flags before loosing concentration
  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_NOMAGIC) && LR_FAIL(ch, LVL_IMPL))
  {
    send_to_char("Your magic fizzles out and dies.\r\n", ch);
    //act("$n's magic fizzles out and dies.", FALSE, caster, 0, 0, TO_ROOM);
    return;
  }
  
  /* You throws the dice and you takes your chances.. 101% is total failure */
  // DM - lost concentration formula
  if (number(0, 101) > GET_SKILL(ch, spellnum))
  {
    WAIT_STATE(ch, (int)PULSE_VIOLENCE/2);
    if (!tch || !skill_message(0, ch, tch, spellnum))
      send_to_char("You lost your concentration!\r\n", ch);
    if (mana > 0)
      GET_MANA(ch) = MAX(0, GET_MANA(ch)-(mana/2));
//      GET_MANA(ch) = MAX(0, MIN(GET_MAX_MANA(ch), GET_MANA(ch) - (mana / 2)));
    if (SINFO.violent && tch && IS_NPC(tch) && AWAKE(tch) && 
	CAN_SEE(tch, ch))
/*  Artus> Removed: Violence check already performed.
 *    if (violence_check(ch, tch, spellnum)) */
        hit(tch, ch, TYPE_UNDEFINED);
  } else { /* cast spell returns 1 on success; subtract mana & set waitstate */
    if (cast_spell(ch, tch, tobj, spellnum))
    {
      // Priests charge for their services
#if 0 // Artus> Moved to say_spell..
      if ((GET_CLASS(ch) == CLASS_PRIEST) && (tch != ch) && !IS_NPC(tch))
      {
        spell_cost = (int) (mana * GET_MODIFIER(ch) * GET_LEVEL(ch));
        if((GET_GOLD(tch) + GET_BANK_GOLD(tch)) < spell_cost)
	{
          send_to_char("They dont have enough money to pay for your services!\r\n", ch);
          return;
        }
        GET_GOLD(tch) -= spell_cost;
        if (GET_GOLD(tch) < 0)
	{
           GET_BANK_GOLD(tch) -= GET_GOLD(tch);
           GET_GOLD(tch) = 0;
        }
      }
#endif

      WAIT_STATE(ch, PULSE_VIOLENCE);
      if (mana > 0)
	GET_MANA(ch) = MAX(0, GET_MANA(ch) - mana);
//	GET_MANA(ch) = MAX(0, MIN(GET_MAX_MANA(ch), GET_MANA(ch) - mana));
    }
  }
}

void list_fighters_to_char(struct char_data *ch, int skillnum)
{
  struct char_data *c;
  int nFound = 0;

  for(c = world[ch->in_room].people; c; c = c->next) {
    if (FIGHTING(c) == ch) {
      nFound++;
      if (nFound == 1)
        sprintf(buf, "You are fighting %s%s&n", IS_NPC(c) ? "&6" : "&7", 
                     GET_NAME(c));
      else
        sprintf(buf + strlen(buf), "&n, %s%s", IS_NPC(c) ? "&6" : "&7", 
                     GET_NAME(c));
    }
  }

  if (nFound != 0)
    sprintf(buf + strlen(buf), "&n.\r\n");
  else
    sprintf(buf, "%s whom?\r\n", 
                 (skillnum == SCMD_HIT) ? "Hit" : 
                 ((skillnum == SCMD_MURDER) ? "Murder" : "Kill"));

  send_to_char(buf, ch);
}

/*
 * This functin is used by all offensive skills to check the common situations
 * which apply when using each skill.
 *
 * Returns TRUE if ok to continue, FALSE otherwise.
 * 
 * was going to be a todo: add another argument - bool to display or not 
 * display verbal shit - think its covered now in basic_skill_test
 */
bool violence_check(struct char_data *ch, struct char_data *vict, int skillnum)
{
  extern struct index_data *mob_index;
  extern struct zone_data *zone_table;	
  extern char pk_allowed;
  bool imm = FALSE;

  // Artus> Impl+ get certain rights :o)
  if (!IS_NPC(ch) && !LR_FAIL(ch, LVL_IMPL))
    imm = TRUE;

  /* Artus> Moved this above !vict check, Prevents casting MAG_AREA spells
   *        in peaceful rooms. */
  // peaceful rooms.
  if ((!imm) && 
      (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) &&
      (!IS_NPC(ch) || ch->nr != real_mobile(DG_CASTER_PROXY)))
  {
    GET_WAIT_STATE(ch) = 0;
    send_to_char(PEACEROOM, ch);
    return FALSE;
  }
 
  // No victim - continue ...
  if (vict == NULL)
    return TRUE;

  // Victim is not in Ch's room, make sure their room is !peaceful.
  if ((IN_ROOM(ch) != IN_ROOM(vict)) && !imm && 
      (ROOM_FLAGGED(IN_ROOM(vict), ROOM_PEACEFUL)) &&
      (!IS_NPC(ch) || ch->nr != real_mobile(DG_CASTER_PROXY)))
  {
    GET_WAIT_STATE(ch) = 0;
    sprintf(buf, "The room %s is in seems way too peaceful.\r\n", HSSH(vict));
    send_to_char(buf, ch);
    return FALSE;
  }

  // Moved from damage(): Should never happen...
  if (GET_POS(vict) <= POS_DEAD) 
  {
    basic_mud_log("SYSERR: Attempt to damage corpse '%s' in room #%d by '%s'.",
        GET_NAME(vict), GET_ROOM_VNUM(IN_ROOM(vict)), GET_NAME(ch));
    die(vict,ch);
    return FALSE;		/* -je, 7/7/92 */
  }

  // attacking self?
  if (vict == ch) 
  {
    send_to_char("Go inflict some pain on yourself elsewhere...\r\n", ch);
    return FALSE;
  } 

  if (IS_NPC(vict))
  {
    /* Moved from damage(): shopkeeper protection */
    if (!ok_damage_shopkeeper(ch, vict))
      return (0);

    // !KILL Flag.
    if (!imm && MOB_FLAGGED(vict,MOB_NOKILL))
    {
      sprintf(buf, "You cannot possibly harm %s.\r\n", HMHR(vict));
      send_to_char(buf, ch);
      return FALSE;
    }

    // Moved from damage(): Quest Mobs.
    if (!imm && MOB_FLAGGED(vict,MOB_QUEST) && !PRF_FLAGGED(ch, PRF_QUEST))
    {
      send_to_char("Sorry, they are part of a quest.\r\n",ch);
      return FALSE;
    } 

    // postmaster protection
    if (!imm && (GET_MOB_SPEC(vict) == postmaster)) 
    {
      send_to_char("You cannot attack the postmaster!!\r\n", ch);
      return FALSE;
    } 

    // receptionist protection
    if (!imm && (GET_MOB_SPEC(vict) == receptionist))
    {
      send_to_char("You cannot attack the Receptionist!\r\n", ch); 
      return FALSE;
    }
  }

  // attacking master?
  if (AFF_FLAGGED(ch, AFF_CHARM) && (ch->master == vict)) 
  {
    act("$N is just such a good friend, you simply can't hurt $M.", 
                    FALSE, ch, 0, vict, TO_CHAR);
    return FALSE;
  }   

  // ARTUS - PK.. Don't need to return false just yet, we'll let the original
  // pk code do that for us... We'll take care of mortal kombat here too.
  if (!IS_NPC(ch) && !IS_NPC(vict)) 
  {
    if (((GET_CLAN(ch) || EXT_FLAGGED(ch, EXT_PKILL)) && 
	 (GET_CLAN(vict) || EXT_FLAGGED(vict, EXT_PKILL))) ||
	(PRF_FLAGGED(ch, PRF_MORTALK) && PRF_FLAGGED(vict, PRF_MORTALK)))
      return TRUE;
  }

  // mounts
  if (IS_NPC(vict) && MOUNTING(vict)) 
  {
#ifndef IGNORE_DEBUG
    if (GET_DEBUG(ch))
    {
      sprintf(buf, "DEBUG: Ch: %s Vict: %s Mounting(ch): %s\r\n",
	  GET_NAME(ch), GET_NAME(vict), GET_NAME(MOUNTING(vict)));
      send_to_char(buf, ch);
    }
#endif
    if (MOUNTING(vict) == ch) 
    {
      send_to_char("You can't attack something you are mounting!\r\n", ch);
      return FALSE;
    }
    // Moved from damage(): Cannot attack rider.
    if (vict == MOUNTING(ch) && IS_NPC(ch))
    {
      send_to_char("Your rider controls your urge to kill them.\r\n", ch);
      return FALSE;
    }
    if ((GET_CLAN(MOUNTING(vict)) || EXT_FLAGGED(MOUNTING(vict), EXT_PKILL)) &&
      (GET_CLAN(ch) || EXT_FLAGGED(ch, EXT_PKILL)))
        return TRUE;
  } 

/*  if (IS_NPC(vict) && MOUNTING(vict) && !(FIGHTING(ch) == vict)) {
    send_to_char("That's someone's mount! Use 'murder' to attack another "
                 "player.\r\n", ch);
    return FALSE;
  } */

  /* Artus - Pkill Flag/Clan Checking... Looks redundant. 20031103
  if (!IS_NPC(ch) && !IS_NPC(vict))
  {
    if (((GET_CLAN(ch) > 0) || (EXT_FLAGGED(ch, EXT_PKILL))) &&
        ((GET_CLAN(vict) > 0) || (EXT_FLAGGED(vict, EXT_PKILL))))
      return TRUE;
  } */

  // pk zone check
  if (!IS_SET(zone_table[world[ch->in_room].zone].zflag, ZN_PK_ALLOWED) && 
                  !IS_NPC(vict) && !IS_NPC(ch) && !imm) 
  {
    send_to_char("Player Killing is not allowed in this Zone.\r\n", ch);
    act("$n just tried to attack $N, and failed miserably!", 
                    FALSE, ch, 0, vict, TO_NOTVICT);
    return FALSE;
  }

  if (!imm && !pk_allowed) 
  {
    if (!IS_NPC(vict) && !IS_NPC(ch) && skillnum != SCMD_MURDER &&
	skillnum != SPELL_CHANGED) {
      send_to_char("Use 'murder' to attack another player.\r\n", ch);
      return FALSE;
    }

    /* you can't order a charmed pet to attack a player */
    if (AFF_FLAGGED(ch, AFF_CHARM) && !IS_NPC(ch->master) && !IS_NPC(vict))
      return FALSE;                 
  }

  return TRUE;
}

/* 
 * Similar to do_cast, this function is the entry point for violient PC-used 
 * skills ... 
 */
ACMD(do_violent_skill) 
{
  int skillnum = subcmd;

  struct char_data *vict = NULL;
  struct obj_data *wielded = ch->equipment[WEAR_WIELD];
  extern struct index_data *mob_index;
  byte percent, prob;
  struct char_data *next_vict;
  sh_int room;
  int door, dam, skip = 0;
  bool performed = FALSE;

  struct obj_data *boots;
  int weight = 0, type = SKILL_KICK;
  int calc_dam_amt(struct char_data *ch, struct char_data *vict, int skillnum);
  int char_can_enter(struct char_data *ch, struct room_data *room, bool show);

  // Check that no mounted char is trying to do an attack by itself
/*  if (IS_NPC(ch) && MOUNTING(ch) && !FIGHTING(MOUNTING(ch))) {
    return;
  } */

  // Only let PC hit and kill commands through
  if (IS_NPC(ch) && !(skillnum == SCMD_HIT || skillnum == SCMD_KILL))
  {
    basic_mud_log("SYSERR: NPC (%s) using skill (%d)", GET_NAME(ch), skillnum);
    return;
  }

  // Check if the char is a ghost.
  if (!IS_NPC(ch))
  {
    if (IS_GHOST(ch))
    {
      send_to_char("As a ghost, you find yourself unable to harm others.\r\n", 
	           ch);
      return;
    }

    // Check the chars skill ability 
    switch (skillnum)
    {
      case SCMD_HIT:
      case SCMD_MURDER:
      case SCMD_KILL:
	break;
      case SKILL_BACKSTAB:
	if (IS_SET(GET_SPECIALS(ch), SPECIAL_BACKSTAB))
	  break;
      default:
	if (!has_stats_for_skill(ch, skillnum, TRUE))
	  return;
    } // Skillnum.
  } // !IS_NPC

  one_argument(argument, arg);
  vict = generic_find_char(ch, arg, FIND_CHAR_ROOM);

  switch (skillnum)
  {
   
    // ********* MURDER, HIT, KILL (the abnormal defines) *********************
    case SCMD_MURDER:
    case SCMD_HIT:
    case SCMD_KILL:
      if (!*arg)
      {
        list_fighters_to_char(ch, skillnum);
        return;
      } else if (vict == NULL) {
        send_to_char("They don't seem to be here.\r\n", ch);
        return;
      }
      // Implementor kill ....
      if (skillnum == SCMD_KILL && !IS_NPC(ch) && !LR_FAIL(ch, LVL_IMPL))
      {
        act("You chop $M to pieces!  Ah!  The &rblood&n!", 
	    FALSE, ch, 0, vict, TO_CHAR);
        act("$N chops you to pieces!", FALSE, vict, 0, ch, TO_CHAR);
        act("$n brutally slays $N!", FALSE, ch, 0, vict, TO_NOTVICT);
        raw_kill(vict,ch);
        return;
      }
      // Common violence checks
      if (!violence_check(ch, vict, skillnum))
        return;
      // Was in do_hit - wondering why atm - should move into violence_check
      if (IS_AFFECTED(ch,AFF_CHARM) && !ch->master)
        REMOVE_BIT(AFF_FLAGS(ch),AFF_CHARM);
      // ----------- Not fighting ---------- target != fighting ----
      if ((GET_POS(ch) == POS_STANDING) && (vict != FIGHTING(ch)))
      {
        if (wielded && OBJ_IS_GUN(wielded))
	{
          send_to_char("You would do better to shoot this weapon!\n\r", ch);
          return;
        }
        // Set killer flags etc ...
        if (skillnum == SCMD_MURDER)
          check_killer(ch, vict);
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE + 2;
        hit(ch, vict, TYPE_UNDEFINED);
        // Order mount to attack 
        if (!IS_NPC(ch) && MOUNTING(ch) && !FIGHTING(MOUNTING(ch)))
	{
          send_to_char("You order your mount to attack!\r\n", ch);
          act("$n orders $s mount to attack.\r\n", FALSE, ch, 0, 0, TO_ROOM);
          do_violent_skill(MOUNTING(ch), arg, 0, SCMD_HIT);
        }
      // -- ch is fighting, check for switching  -----------------------
      } else if (FIGHTING(vict) != ch) { // vict isn't fighting ch - cant switch
        send_to_char("You're already fighting someone!\r\n", ch);
      // -- Switch player target ---------------------------------------
      } else if (FIGHTING(vict) == ch && FIGHTING(ch) != vict) {
        act("You turn to fight $N!", FALSE, ch, 0, vict, TO_CHAR);
        act("$n turns to fight $N.", FALSE, ch, 0, vict, TO_ROOM);
        act("$n turns to fight you!", FALSE, ch, 0, vict, TO_VICT);
        FIGHTING(ch) = vict;
      // -- ch already fighting vict -----------------------------------
      } else {
        send_to_char("You do the best you can!\r\n", ch);
      }
      break;
    // ********************** AXETHROW (Hurl Axes) ****************************
    case SKILL_AXETHROW:
      // Check if char has axe in inventory.
      if (vict == NULL) 
      {
	send_to_char("Throw your axe at who, exactly?\r\n", ch);
	return;
      }
      if (!violence_check(ch, vict, skillnum))
        return;
      for (boots = ch->carrying; boots; boots = boots->next_content)
	if (is_axe(boots))
	  break;
      if (!(boots))
      {
	send_to_char("You don't have any axes to throw!\r\n", ch);
	return;
      }
      dam = dice(GET_OBJ_VAL(boots, 0), GET_OBJ_VAL(boots, 1));
      skip = 0;
      // Char has item... Time to throw..
      obj_from_char(boots);
      skip = basic_skill_test(ch, SKILL_AXEMASTERY, 1);
      if (skip) 
	dam = (int)(dam * 1.75);
      if (DEX_CHECK(ch, 0) && !skip)
      {
	act("$N catches your axe as you throw it at $m.", FALSE, ch, NULL, vict, TO_CHAR);
	act("You skillfully catch an axe thrown by $n.", FALSE, ch, NULL, vict, TO_VICT);
	act("$N skillfully catches an axe thrown by $n.", FALSE, ch, NULL, vict, TO_NOTVICT);
	obj_to_char(boots, vict, __FILE__, __LINE__);
	return;
      }
      if (DEX_CHECK(ch, 18) || skip)
      {
	act("You hit $N with your axe, and catch it again.", FALSE, ch, NULL, vict, TO_CHAR);
	act("$n hits you with an axe, and catches it again.", FALSE, ch, NULL, vict, TO_VICT);
	act("$n hits $N with an axe, and skillfully catches it again.", FALSE, ch, NULL, vict, TO_NOTVICT);
	obj_to_char(boots, ch, __FILE__, __LINE__);
      } else {
	act("You hit $N with your axe.", FALSE, ch, NULL, vict, TO_CHAR);
	act("$n hits you with an axe.", FALSE, ch, NULL, vict, TO_VICT);
	act("$n throws an axe at $N.", FALSE, ch, NULL, vict, TO_NOTVICT);
	obj_to_char(boots, vict, __FILE__, __LINE__);
      }
      damage(ch, vict, dam, SKILL_AXETHROW, FALSE);
      clan_rel_inc(ch, vict, -5);

      if (IS_AFFECTED(ch, AFF_ADRENALINE))
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 2;
      else
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 3;
	
      break;
    // ********************** BACKSTAB ****************************************
    case SKILL_BACKSTAB:
      // Check for target
      if (vict == NULL)
      {
	if (!(FIGHTING(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_BACKSTAB)))
	{ 
	  send_to_char("Backstab who?\r\n", ch);
	  return;
	} else 
	  vict = FIGHTING(ch);
      }
      // Check to see if ch is wielding a weapon at all
      if (!wielded)
      {
        send_to_char("You need to wield a weapon to make it a success.\r\n", 
                        ch);
        return;
      }
      // Check for valid backstab weapon
      if (GET_OBJ_VAL(wielded, 3) != TYPE_PIERCE - TYPE_HIT)
      {
        send_to_char("You must use a piercing weapon as your primary weapon in order to backstab!\r\n", ch);
        return;
      }
      // Check if victim is fighting - and backstab special
      if (!IS_SET(GET_SPECIALS(ch), SPECIAL_BACKSTAB))
      {
	if (FIGHTING(vict))
	{
	  send_to_char("You can't backstab a fighting person -- "
		       "they're too alert!\r\n", ch);
	  return;
	}
	if (FIGHTING(ch))
	{
	  send_to_char(CHARFIGHTING, ch);
	  return;
	}
      }
      // Common violence checks
      if (!violence_check(ch, vict, skillnum))
        return;
      // ARTUS - Clones
      if (IS_CLONE(vict))
      {
        send_to_char("You can't backstab a clone!\r\n", ch);
        return;
      }
      // ARTUS - Zomies
      if (IS_ZOMBIE(vict))
      {
        send_to_char("You can't backstab a zombie!\r\n", ch);
        return;
      }
      // Aware Mob messages ...
      if (MOB_FLAGGED(vict, MOB_AWARE))
      {
        switch (number(1,4))
	{
	  case 1:
	    send_to_char("Your weapon hits an invisible barrier and fails to "
                         "penetrate it.\r\n", ch);
	    break;
	  case 2:
	    act("$N skillfuly blocks your backstab and attacks with rage!", 
		FALSE, ch, 0 , vict, TO_CHAR);
	    break;
	  case 3:
	    act("$N cleverly avoids your backstab.", 
		FALSE, ch, 0 , vict, TO_CHAR);
	    break;
	  case 4:
	    act("$N steps to the side avoiding your backstab!", 
		FALSE, ch, 0 , vict, TO_CHAR);
	    break;
        }
        hit(vict, ch, TYPE_UNDEFINED);
        return;
      }
      percent = number(1, 101);     // 101% is a complete failure
      if (IS_SET(GET_SPECIALS(ch), SPECIAL_BACKSTAB))
	prob = MAX(50, MAX(GET_LEVEL(ch), GET_SKILL(ch, SKILL_BACKSTAB)));
      else
	prob = GET_SKILL(ch, SKILL_BACKSTAB);
      if (AWAKE(vict) && (percent > prob))
        damage(ch, vict, 0, SKILL_BACKSTAB, FALSE);
      else
        hit(ch, vict, SKILL_BACKSTAB);
      clan_rel_inc(ch, vict, -5);
      // Wait of 2 violence rounds if affected by adrenaline, or have backstab
      // special, otherwise the normal 3
      if (IS_AFFECTED(ch, AFF_ADRENALINE) || 
          IS_SET(GET_SPECIALS(ch), SPECIAL_BACKSTAB))
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE;
      else
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 2;
      break;

    // ********************** BASH ********************************************
    case SKILL_BASH:

      if (vict == NULL) {
        if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
          vict = FIGHTING(ch);
        } else {
          send_to_char("Bash who?\r\n", ch);
          return;
        }
      }

      if (!wielded) {
        send_to_char("You need to wield a weapon to make it a success.\r\n", 
                        ch);
        return;
      }

      if (GET_POS(vict) < POS_FIGHTING) {
        send_to_char("Your victim is already down!.\r\n", ch);
        return;
      }

      if (!violence_check(ch, vict, skillnum))
        return;

      percent = number(1, 111);  /* 101% is a complete failure */
      prob = GET_SKILL(ch, SKILL_BASH);

      if (MOB_FLAGGED(vict, MOB_NOBASH))
        percent = 101;
      if (PRF_FLAGGED(ch, PRF_MORTALK))
        percent = 101;

      // Wait of 2 violence rounds if affected by adrenaline, otherwise normal 3
      if (IS_AFFECTED(ch, AFF_ADRENALINE))
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 2;
      else
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 3;

      if (percent > prob) {
        damage(ch, vict, 0, SKILL_BASH, FALSE);
        GET_POS(ch) = POS_SITTING;
      } else {
        // If we bash a player and they wimp out, they will move to the previous
        // room before we set them sitting.  If we try to set the victim sitting
        // first to make sure they don't flee, then we can't bash them!  So now
        // we only set them sitting if they didn't flee. -gg 9/21/98
        // -1 = dead, 0 = miss 
	dam = calc_dam_amt(ch, vict, SKILL_BASH);
        if (damage(ch, vict, dam, SKILL_BASH, FALSE) > 0) 
	{
          GET_WAIT_STATE(vict) = PULSE_VIOLENCE;
          if (IN_ROOM(ch) == IN_ROOM(vict)) 
	  {
            GET_POS(vict) = POS_SITTING;
            GET_WAIT_STATE(vict) = PULSE_VIOLENCE * 2;
          }
        }
      }
      clan_rel_inc(ch, vict, -5);
      break;

    // ********************** BERSERK *****************************************
    case SKILL_BERSERK:
      if (!FIGHTING(ch)) {
	send_to_char("You don't seem to be fighting anyone.\r\n", ch);
	return;
      }
      if (IS_AFFECTED(ch, AFF_BERSERK)) {
	send_to_char("You can't be any more berserk.\r\n", ch);
	return;
      }
      if (number(0, 101) > GET_SKILL(ch, SKILL_BERSERK)) { // 101 - Fail
	send_to_char("The madness of berserk eludes you.\r\n", ch);
	return;
      }
      if (!(char_affected_by_timer(ch, TIMER_BERSERK))) 
        timer_to_char(ch,timer_new(TIMER_BERSERK));
      if (timer_use_char(ch,TIMER_BERSERK)) {
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE;
	apply_spell_skill_abil(ch, SKILL_BERSERK);
        SET_BIT(AFF_FLAGS(ch), AFF_BERSERK);
        send_to_char("You find yourself in a battle frenzy.\r\n", ch);
        act("$n laughs madly and fights with new energy.", FALSE, ch, 0, 0, TO_ROOM);
      } else {
        send_to_char(RESTSKILL,ch);
        return;
      }
      return;
      break;
    // ********************** KICK ********************************************
    case SKILL_KICK:
      if (!(vict)) {
        if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
          vict = FIGHTING(ch);
        } else {
          send_to_char("Kick who?\r\n", ch);
          return;
        }
      }

      // Common violence checks
      if (!violence_check(ch, vict, skillnum))
        return;

      // 101% is a complete failure 
      percent = ((10 - compute_armor_class(vict, 1)) * 2) + number(1, 101);
      prob = GET_SKILL(ch, SKILL_KICK);

      // Wait of 2 violence rounds if affected by adrenaline, otherwise normal 3
      if (IS_AFFECTED(ch, AFF_ADRENALINE))
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 2;
      else
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 3;

      if (percent > prob) {
        damage(ch, vict, 0, SKILL_KICK, FALSE);
      } else {
	dam = calc_dam_amt(ch, vict, SKILL_KICK);
	// Power kick baby - only base it on first kick?
	// Its pretty generous
	if (basic_skill_test(ch, SKILL_POWERKICK, FALSE)) 
	{
	  if ((boots = GET_EQ(ch, WEAR_FEET))) 
            weight = GET_OBJ_WEIGHT(boots);
          dam += (int)((2 * weight) + str_app[GET_STR(ch)].todam); 
	  apply_spell_skill_abil(ch, SKILL_POWERKICK);
	  type = SKILL_POWERKICK;
	}

	if (damage(ch, vict, dam, type, FALSE) > 0) 
	{
          if ((GET_SKILL(ch, SKILL_DOUBLE_KICK) &&
	      (IN_ROOM(ch) == IN_ROOM(vict)) && // Sanity - Artus
              (number(1, 101 - (GET_LEVEL(vict) - GET_LEVEL(ch))) < 
                   GET_SKILL(ch, SKILL_DOUBLE_KICK)))) 
	  {
            act("...$n jumps delivering a quick and powerful second kick!", 
                            FALSE, ch, 0, 0, TO_ROOM);
            act("...$n jumps delivering another powerful kick to you!", 
                            FALSE, ch, 0, vict, TO_VICT);
            act("...you quickly jump and deliver another powerful kick to $N!", 
                            FALSE, ch, 0, vict, TO_CHAR);
            damage(ch, vict, GET_LEVEL(ch), SKILL_KICK, FALSE);
	    apply_spell_skill_abil(ch, SKILL_DOUBLE_KICK); // Artus> 20031014
	  }
        }
      }
      clan_rel_inc(ch, vict, -1);
      break;

    // ********************** PRIMAL SCREAM ***********************************
    case SKILL_PRIMAL_SCREAM:

      //primal scream does not call violence_check - so we must do all those
      //checks correctly in here ...
      
      prob = GET_SKILL(ch, SKILL_PRIMAL_SCREAM);
      percent = number(1,101); /* 101 is a complete failure */

      if (FIGHTING(ch)) 
      {
        send_to_char("You can't prepare yourself properly while fighting!\r\n",
                        ch);
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 3;
        return;
      }

      if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) 
      {
        send_to_char(PEACEROOM, ch);
        return;
      }

      if (percent > prob) 
      {
        act("$n lets out a feeble wimper as $e attempts a primal scream.",
                        FALSE,ch,0,0,TO_ROOM);
        act("You let out a sad little wimper.",FALSE,ch,0,0,TO_CHAR);
        return;
      }

      act("$n inhales deeply and lets out an ear shattering scream!!\r\n",
                        FALSE,ch,0,0,TO_ROOM);
      act("You fill your lungs to capacity and let out an ear shattering "
            "scream!!",FALSE,ch,0,0,TO_CHAR);

      room = ch->in_room;
      /* this shood make it be heard in a 4 room radius */
      for (door = 0; door < NUM_OF_DIRS; door++)
      {
        if (!world[ch->in_room].dir_option[door])
          continue;
        ch->in_room = world[ch->in_room].dir_option[door]->to_room;
        if (room != ch->in_room && ch->in_room != NOWHERE)
          act("You hear a frightening scream coming from somewhere nearby...",
                          FALSE, ch, 0, 0, TO_ROOM);
        ch->in_room = room;
      }

      for (vict = world[ch->in_room].people; vict; vict = next_vict) 
      {
        next_vict = vict->next_in_room;

        if (vict == ch)
          continue; /* ch is the victim skip to next person */
	if (IS_NPC(ch))
	{
	  if (IS_NPC(vict) && !IS_AFFECTED(vict, AFF_CHARM))
	    continue;
	  if (!IS_NPC(vict) && !LR_FAIL(vict, LVL_GOD))
	    continue;
	} else {
	  if (!IS_NPC(vict))
	    continue;
	  if (IS_AFFECTED(vict, AFF_CHARM))
	    continue;
	  if (MOB_FLAGGED(vict, MOB_NOKILL))
	    continue;
	}

	performed = TRUE;
	dam = calc_dam_amt(ch,vict,SKILL_PRIMAL_SCREAM);
	damage(ch,vict,dam,SKILL_PRIMAL_SCREAM,FALSE);
      }

      // Wait of 2 violence rounds if affected by adrenaline, otherwise normal 3
      if (IS_AFFECTED(ch, AFF_ADRENALINE))
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 2;
      else
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 3;

      if (!performed)
        return;
      
      // Artus> This shouldnt touch PCs anyway. clan_rel_inc(ch, vict, 1);
      break;
 

    // ********************** HEADBUTT ****************************************
    case SKILL_HEADBUTT:

      if (!(vict)) 
      {
        if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) 
	{
          vict = FIGHTING(ch);
        } else {
          send_to_char("Headbutt who?\r\n", ch);
          return;
        }
      }

      // Common violence checks
      if (!violence_check(ch, vict, skillnum))
        return;

      /* 101% is a complete failure */
      percent = ((10 - compute_armor_class(vict, 1)) * 2) + number(1, 101);
      prob = GET_SKILL(ch, SKILL_HEADBUTT);

      // Wait of 2 violence rounds if affected by adrenaline, otherwise normal 3
      if (IS_AFFECTED(ch, AFF_ADRENALINE))
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 2;
      else
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 3;

      if (percent > prob) 
      {
        damage(ch, vict, 0, SKILL_HEADBUTT, FALSE);
        return;
      }
      /* Artus> Lets try this another way...
       *  if (damage(ch, vict, (int)(GET_LEVEL(ch) * 2 * (SPELL_EFFEC(ch, skillnum) / 100) + GET_EQ_WEIGHT(ch, WEAR_HEAD) + str_app[GET_STR(ch)].todam), SKILL_HEADBUTT, FALSE) > 0) 
       *   GET_WAIT_STATE(vict) = PULSE_VIOLENCE; */
      dam = calc_dam_amt(ch, vict, SKILL_HEADBUTT);
      if (damage(ch, vict, dam, SKILL_HEADBUTT, FALSE) > 0)
	GET_WAIT_STATE(vict) = PULSE_VIOLENCE;
      
      clan_rel_inc(ch, vict, -3);
      break; 

    // ********************** PILEDRIVE ***************************************
    case SKILL_PILEDRIVE:

      if (!(vict)) 
        if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) 
	{
          vict = FIGHTING(ch);
        } else {
          send_to_char("Piledrive who?\r\n", ch);
          return;
        }

      // Common violence checks
      if (!violence_check(ch, vict, skillnum))
        return;

      /* 101% is a complete failure */
      percent = ((10 - compute_armor_class(vict, 1)) * 2) + number(1, 101);
      prob = GET_SKILL(ch, SKILL_PILEDRIVE);

      // Wait of 2 violence rounds if affected by adrenaline, otherwise normal 3
      if (IS_AFFECTED(ch, AFF_ADRENALINE))
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 2;
      else
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 3;

      if (percent > prob) {
        damage(ch, vict, 0, SKILL_PILEDRIVE, FALSE);
        return;
      }
      /* Artus> Lets do this a little differently.. Too.
       * if (damage(ch, vict, (int)(GET_LEVEL(ch) * 3 * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), SKILL_PILEDRIVE, FALSE)) 
       *   GET_WAIT_STATE(vict) = PULSE_VIOLENCE * 3; */
      dam = calc_dam_amt(ch, vict, SKILL_PILEDRIVE);
      if (damage(ch, vict, dam, SKILL_PILEDRIVE, FALSE))
	GET_WAIT_STATE(vict) = PULSE_VIOLENCE * 3;
      clan_rel_inc(ch, vict, -4);
      break;

    // ********************** TRIP ********************************************
    case SKILL_TRIP:

      if (!(vict)) {
        if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
          vict = FIGHTING(ch);
        } else {
          send_to_char("Trip who?\r\n", ch);
          return;
        }
      }

      if (GET_POS(vict) == POS_SITTING) {
        send_to_char("They are already down.\r\n",ch);
        return;
      }

      // Common violence checks
      if (!violence_check(ch, vict, skillnum))
        return;

      /* 101% is a complete failure */
      percent = ((10 - compute_armor_class(vict, 1)) * 2) + number(1, 101);
      prob = GET_SKILL(ch, SKILL_TRIP);

      // Wait of 2 violence rounds if affected by adrenaline, otherwise normal 3
      if (IS_AFFECTED(ch, AFF_ADRENALINE))
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 2;
      else
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 3;

      if (percent > prob) 
      {
        damage(ch, vict, 0, SKILL_TRIP, FALSE);
        return;
      }
      dam = calc_dam_amt(ch, vict, SKILL_TRIP);
      if (damage(ch, vict, dam, SKILL_TRIP, FALSE) > 0) 
      {
	  GET_POS(vict) = POS_SITTING;
          GET_WAIT_STATE(vict) = PULSE_VIOLENCE * 2;
      }
      clan_rel_inc(ch, vict, -2);
      break;

    // ********************** BEARHUG *****************************************
    case SKILL_BEARHUG:

      if (!(vict)) 
        if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) 
	{
          vict = FIGHTING(ch);
        } else {
          send_to_char("Bearhug who?\r\n", ch);
          return;
        }

      // Common violence checks
      if (!violence_check(ch, vict, skillnum))
        return;

      /* 101% is a complete failure */
      percent = ((10 - compute_armor_class(vict, 1)) * 2) + number(1, 101);
      prob = GET_SKILL(ch, SKILL_BEARHUG);

      if (IS_AFFECTED(ch, AFF_ADRENALINE))
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE;
      else
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 2;

      if (percent > prob) 
      {
        damage(ch, vict, 0, SKILL_BEARHUG, FALSE);
        return;
      } 
 
      dam = calc_dam_amt(ch, vict, SKILL_BEARHUG);
      
      if (damage(ch, vict, dam, SKILL_BEARHUG, FALSE) > 0)
	GET_WAIT_STATE(vict) = PULSE_VIOLENCE * 2;

      clan_rel_inc(ch, vict, -3);
      break;

    // ********************** BATTLECRY ***************************************
    case SKILL_BATTLECRY:
 
      if (!(vict)) {
        if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
          vict = FIGHTING(ch);
        } else {
          send_to_char("On whom should you perform a battlecry?\r\n", ch);
          return;
        }
      }

      // Common violence checks
      if (!violence_check(ch, vict, skillnum)) {
        return;
      }

      if (!basic_skill_test(ch, SKILL_BATTLECRY, TRUE)) {
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 3;
        act("You fail a battlecry attempt on $N!",
            FALSE, ch, 0, vict, TO_CHAR);
        act("$n fails a battlecry attempt on you!",
            TRUE, ch, 0, vict, TO_VICT);
        act("$n fails a battlecry attempt on $N!",
            TRUE, ch, 0, vict, TO_NOTVICT);
        hit(ch, vict, TYPE_UNDEFINED);
        return;
      } else {
        act("You scream 'AAARRGGGG' as you perform a battlecry on $N!",
            FALSE, ch, 0, vict, TO_CHAR);
        act("$n screams 'AAARRGGGG' as $m performs $s battlecry on you!",
            TRUE, ch, 0, vict, TO_VICT);
        act("$n screams 'AAARRGGGG' as $m performs $s battlecry on $N!",
            TRUE, ch, 0, vict, TO_NOTVICT);

        if (basic_skill_test(ch, SKILL_KICK, FALSE) && vict && 
	    IN_ROOM(ch) == IN_ROOM(vict)) {
          sprintf(buf, " %s", arg);
          do_violent_skill(ch, buf, 0, SKILL_KICK);
        }

        if (basic_skill_test(ch, SKILL_BEARHUG, FALSE) && vict && 
	    IN_ROOM(ch) == IN_ROOM(vict)) {
          sprintf(buf, " %s", arg);
          do_violent_skill(ch, buf, 0, SKILL_BEARHUG);
        }

        if (basic_skill_test(ch, SKILL_HEADBUTT, FALSE) && vict && 
	    IN_ROOM(ch) == IN_ROOM(vict)) {
          sprintf(buf, " %s", arg);
          do_violent_skill(ch, buf, 0, SKILL_HEADBUTT);
        }

        if (basic_skill_test(ch, SKILL_PILEDRIVE, FALSE) && vict && 
	    IN_ROOM(ch) == IN_ROOM(vict)) {
          sprintf(buf, " %s", arg);
          do_violent_skill(ch, buf, 0, SKILL_PILEDRIVE);
        }

        if (basic_skill_test(ch, SKILL_BASH, FALSE) && vict && 
	    IN_ROOM(ch) == IN_ROOM(vict) && wielded != NULL) {
          sprintf(buf, " %s", arg);
          do_violent_skill(ch, buf, 0, SKILL_BASH);
        }

        GET_WAIT_STATE(vict) = PULSE_VIOLENCE * 4;
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 3;
	clan_rel_inc(ch, vict, -7);
      }
      break;

    // ********************** BODYSLAM ****************************************
    case SKILL_BODYSLAM:
      int attempt;

      if (!(vict)) {
        if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
            vict = FIGHTING(ch);
        } else {
          send_to_char("Bodyslam who?\r\n", ch);
          return;
        }
      }

      // Common Violence Checks.
      if (!violence_check(ch, vict, skillnum)) 
        return;

      // clan protection (guards and healers) - dont want them moving rooms
      if (IS_NPC(vict) && GET_MOB_VZNUM(vict) == CLAN_ZONE)
      {
        sprintf(buf, 
	    "%s stops you before you can bodyslam %s.\r\n", 
	    GET_NAME(vict), HMHR(vict));
	send_to_char(buf, ch);
	return;
      }

      /* 101% is a complete failure */
      percent = ((10 - compute_armor_class(vict, 1)) * 2) + number(1, 101);
      prob = GET_SKILL(ch, SKILL_BODYSLAM);

      GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 2;

      if (percent > prob) {
	act("You attempt to bodyslam $N and miss dearly!", 
	    TRUE, ch, 0, vict, TO_CHAR);
	act("$n attempts to bodyslam you and misses dearly!", 
	    TRUE, ch, 0, vict, TO_VICT);
	act("$n attempts to bodyslam $N but only misses dearly!",
	    TRUE, ch, 0, vict, TO_ROOM);
        damage(ch, vict, 0, SKILL_BODYSLAM, FALSE);
      } else {
	// 6 chances of ch removing victim from room, based on a random exit ...
        if (vict && IN_ROOM(ch) == IN_ROOM(vict)) 
	{
	  /* Select a random direction */
	  attempt = number(0, NUM_OF_DIRS + MAX(0, 18 - GET_DEX(ch)));
	  if ((attempt < NUM_OF_DIRS) && CAN_GO(vict, attempt) && 
	      !ROOM_FLAGGED(EXIT(vict, attempt)->to_room, ROOM_DEATH) &&
	      (EXIT(vict, attempt)->to_room != IN_ROOM(vict)) &&
	      char_can_enter(vict, &world[EXIT(vict, attempt)->to_room], FALSE))
	  {
	    performed = TRUE; // well moved from room acutally
	    if (GET_EQ(ch, WEAR_BODY))
	      dam = number(1, GET_OBJ_WEIGHT(GET_EQ(ch, WEAR_BODY)));
	    else
	      dam = number(1, 3);
	    if (damage(ch, vict, dam, SKILL_BODYSLAM, FALSE) > 0)
	    {
	      sprintf(buf, "You are bodyslammed out of the room, %s, by $n!", dirs[attempt]);
	      act(buf, TRUE, ch, 0, vict, TO_VICT);
	      sprintf(buf, "$N is bodyslammed %s from the room by $n!", dirs[attempt]);
	      act(buf, TRUE, ch, 0, vict, TO_ROOM);
	      sprintf(buf, "You bodyslam $N out of the room, %s!", dirs[attempt]);
	      act(buf, TRUE, ch, 0, vict, TO_CHAR);
	      // move the vict to room
	      char_from_room(vict);
	      char_to_room(vict, EXIT(ch, attempt)->to_room);
	      look_at_room(vict, TRUE);
	      act("$n is forced into the room.", TRUE, vict, 0, NULL, TO_ROOM);
	      GET_WAIT_STATE(ch) = 0;
	      stop_fighting(vict);
	      if (FIGHTING(ch) == vict)
		stop_fighting(ch);
	    }
	    break;
	  }
	}

	if (!performed)
	{ // not moved from room
	    dam = calc_dam_amt(ch, vict, SKILL_BODYSLAM);
            if (damage(ch, vict, dam, SKILL_BODYSLAM, FALSE) > 0) 
	    {
              act("$N is slammed to the ground by $n's bodyslam!",
                  TRUE, ch, 0, vict, TO_ROOM);
              act("You slam $N into the ground!",
                  TRUE, ch, 0, vict, TO_CHAR);
              act("You are slammed into the ground by $n's bodyslam! OUCH!",
                  TRUE, ch, 0, vict, TO_VICT);
	    }
          }
	}
	clan_rel_inc(ch, vict, -3);
	break;

    // ********************** FLYING TACKLE ***********************************
    case SKILL_FLYINGTACKLE:

      if (!(vict)) {
        if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
          vict = FIGHTING(ch);
        } else {
          send_to_char("Whom do you wish to fly tackle?\r\n", ch);
          return;
        }
      }

      // Artus> TODO: Base on carried weight.

      // Common violence checks
      if (!violence_check(ch, vict, skillnum))
        return;

      /* 101% is a complete failure */
      percent = ((10 - compute_armor_class(vict, 1)) * 2) + number(1, 101);
      prob = GET_SKILL(ch, SKILL_FLYINGTACKLE);

      GET_MOVE(ch) = MAX(0, GET_MOVE(ch) - 5); 

      if (percent > prob) {
        if (IS_AFFECTED(ch, AFF_ADRENALINE)) {
          GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 2;
        } else {
          GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 3;
        }
        damage(ch, vict, 0, SKILL_FLYINGTACKLE, FALSE);
        return;
      } else {
	dam = calc_dam_amt(ch, vict, SKILL_FLYINGTACKLE);
        if (damage(ch, vict, dam, SKILL_FLYINGTACKLE, FALSE)) {
          if (IS_AFFECTED(ch, AFF_ADRENALINE)) {
            GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 2;
          } else {
            GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 3;
          }
	  GET_WAIT_STATE(vict) = PULSE_VIOLENCE * 3;
	}
      }
      clan_rel_inc(ch, vict, -3);
      break;

    default:
      basic_mud_log("SYSERR: Invalid skill (%d) number passed to do_violent_skill", 
                      skillnum);
      return;
  }

  // We made it - usage of skill was a success - now apply ability gains ....
  if (skillnum != SCMD_HIT && skillnum != SCMD_KILL && skillnum != SCMD_MURDER)
    apply_spell_skill_abil(ch, skillnum); 

  // DM: TODO: shoot
}

// DM - no longer used
void spell_level(int spell, int chclass, int level, byte intl, byte str, byte wis, byte con, byte dex, byte cha)
{
  int bad = 0;

  if (spell < 0 || spell > TOP_SPELL_DEFINE) {
    basic_mud_log("SYSERR: attempting assign to illegal spellnum %d/%d", spell, TOP_SPELL_DEFINE);
    return;
  }

  if (chclass < 0 || chclass >= NUM_CLASSES) {
    basic_mud_log("SYSERR: assigning '%s' to illegal class %d/%d.", skill_name(spell),
		chclass, NUM_CLASSES - 1);
    bad = 1;
  }

  if (level < 1 || level > LVL_IMPL) {
    basic_mud_log("SYSERR: assigning '%s' to illegal level %d/%d.", skill_name(spell),
		level, LVL_IMPL);
    bad = 1;
  }

  if (!bad) {    
    spell_info[spell].min_level[chclass] = level;

    spell_info[spell].str[chclass] = str;
    spell_info[spell].intl[chclass] = intl;
    spell_info[spell].wis[chclass] = wis;
    spell_info[spell].dex[chclass] = dex;
    spell_info[spell].con[chclass] = con;
    spell_info[spell].cha[chclass] = cha;
  }

}


/* Assign the spells on boot up */
void spello(int spl, const char *name, int max_mana, int min_mana,
	int mana_change, int minpos, int targets, int violent, int routines)
{
  int i;

  for (i = 0; i < NUM_CLASSES; i++) {
    spell_info[spl].min_level[i] = LVL_OWNER+1;
    spell_info[spl].mana_max[i] = -1;
    spell_info[spl].mana_min[i] = -1;
    spell_info[spl].mana_change[i] = -1;
    spell_info[spl].intl[i] = -1;
    spell_info[spl].dex[i] = -1;
    spell_info[spl].wis[i] = -1;
    spell_info[spl].str[i] = -1;
    spell_info[spl].con[i] = -1;
    spell_info[spl].cha[i] = -1;
  }
  spell_info[spl].min_position = minpos;
  spell_info[spl].targets = targets;
  spell_info[spl].violent = violent;
  spell_info[spl].routines = routines;
  spell_info[spl].name = name;
}


void unused_spell(int spl)
{
  int i;

  for (i = 0; i < NUM_CLASSES; i++) {
    spell_info[spl].min_level[i] = LVL_OWNER + 1;
    spell_info[spl].mana_max[i] = -1;
    spell_info[spl].mana_min[i] = -1;
    spell_info[spl].mana_change[i] = -1;
    spell_info[spl].intl[i] = -1;
    spell_info[spl].dex[i] = -1;
    spell_info[spl].wis[i] = -1;
    spell_info[spl].str[i] = -1;
    spell_info[spl].con[i] = -1;
    spell_info[spl].cha[i] = -1;
  }
  spell_info[spl].min_position = 0;
  spell_info[spl].targets = 0;
  spell_info[spl].violent = 0;
  spell_info[spl].routines = 0;
  spell_info[spl].name = unused_spellname;
}

#define skillo(skill, name) spello(skill, name, 0, 0, 0, 0, 0, 0, 0);


/*
 * Arguments for spello calls:
 *
 * spellnum, maxmana, minmana, manachng, minpos, targets, violent?, routines.
 *
 * spellnum:  Number of the spell.  Usually the symbolic name as defined in
 * spells.h (such as SPELL_HEAL).
 *
 * spellname: The name of the spell.
 *
 * maxmana :  The maximum mana this spell will take (i.e., the mana it
 * will take when the player first gets the spell).
 *
 * minmana :  The minimum mana this spell will take, no matter how high
 * level the caster is.
 *
 * manachng:  The change in mana for the spell from level to level.  This
 * number should be positive, but represents the reduction in mana cost as
 * the caster's level increases.
 *
 * minpos  :  Minimum position the caster must be in for the spell to work
 * (usually fighting or standing). targets :  A "list" of the valid targets
 * for the spell, joined with bitwise OR ('|').
 *
 * violent :  TRUE or FALSE, depending on if this is considered a violent
 * spell and should not be cast in PEACEFUL rooms or on yourself.  Should be
 * set on any spell that inflicts damage, is considered aggressive (i.e.
 * charm, curse), or is otherwise nasty.
 *
 * routines:  A list of magic routines which are associated with this spell
 * if the spell uses spell templates.  Also joined with bitwise OR ('|').
 *
 * See the CircleMUD documentation for a more detailed description of these
 * fields.
 */

/*
 * NOTE: SPELL LEVELS ARE NO LONGER ASSIGNED HERE AS OF Circle 3.0 bpl9.
 * In order to make this cleaner, as well as to make adding new classes
 * much easier, spell levels are now assigned in class.c.  You only need
 * a spello() call to define a new spell; to decide who gets to use a spell
 * or skill, look in class.c.  -JE 5 Feb 1996
 */

void mag_assign_spells(void)
{
  int i;

  /* Do not change the loop below. */
  for (i = 0; i <= TOP_SPELL_DEFINE; i++)
    unused_spell(i);
  /* Do not change the loop above. */

  spello(SPELL_ADV_HEAL, "advanced heal", 130, 70, 2,
         POS_FIGHTING, TAR_CHAR_ROOM, FALSE, MAG_POINTS | MAG_AFFECTS | MAG_UNAFFECTS);
                                                  
  spello(SPELL_ANIMATE_DEAD, "animate dead", 100, 80, 2,
         POS_STANDING, TAR_OBJ_ROOM, FALSE, MAG_SUMMONS);
 
  spello(SPELL_ARMOR, "armor", 30, 15, 3,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_BLESS, "bless", 35, 5, 3,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_BLINDNESS, "blindness", 35, 25, 1,
         POS_STANDING, TAR_CHAR_ROOM | TAR_NOT_SELF, TRUE, MAG_AFFECTS);
 
  spello(SPELL_BURNING_HANDS, "burning hands", 30, 10, 3,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);
 
  spello(SPELL_CALL_LIGHTNING, "call lightning", 40, 25, 3,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);
 
  spello(SPELL_CHARM, "charm", 75, 50, 2,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_NOT_SELF, TRUE, MAG_MANUAL);
 
  spello(SPELL_CHILL_TOUCH, "chill touch", 30, 10, 3,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE | MAG_AFFECTS);

  spello(SPELL_CLONE, "clone", 145, 100, 2,
         POS_STANDING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_SUMMONS);
 
  spello(SPELL_CLOUD_KILL, "cloud kill", 250, 250, 3,
         POS_FIGHTING, TAR_IGNORE, TRUE, MAG_AREAS);
 
  spello(SPELL_COLOR_SPRAY, "color spray", 30, 15, 3,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);
 
  spello(SPELL_CONTROL_WEATHER, "control weather", 75, 25, 5,
         POS_STANDING, TAR_IGNORE, FALSE, MAG_MANUAL);
 
  spello(SPELL_CREATE_FOOD, "create food", 30, 5, 4,
         POS_STANDING, TAR_IGNORE, FALSE, MAG_CREATIONS);
 
  spello(SPELL_CREATE_WATER, "create water", 30, 5, 4,
         POS_STANDING, TAR_OBJ_INV | TAR_OBJ_EQUIP, FALSE, MAG_MANUAL);
 
  spello(SPELL_CURE_BLIND, "cure blind", 30, 5, 2,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_UNAFFECTS);
 
  spello(SPELL_CURE_CRITIC, "cure critical", 30, 10, 2,
         POS_FIGHTING, TAR_CHAR_ROOM, FALSE, MAG_POINTS);

  spello(SPELL_CURE_LIGHT, "cure light", 30, 10, 2,
         POS_FIGHTING, TAR_CHAR_ROOM, FALSE, MAG_POINTS);
 
  spello(SPELL_CURSE, "curse", 80, 50, 2,
         POS_STANDING, TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, TRUE, MAG_AFFECTS | MAG_ALTER_OBJS);
 
  spello(SPELL_DETECT_ALIGN, "detect alignment", 20, 10, 2,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_DETECT_INVIS, "detect invisibility", 20, 15, 2,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_DETECT_MAGIC, "detect magic", 20, 10, 2,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_DETECT_POISON, "detect poison", 15, 5, 1,
         POS_STANDING, TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_MANUAL);
 
  spello(SPELL_DISPEL_EVIL, "dispel evil", 40, 25, 3,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);
 
  spello(SPELL_DISPEL_GOOD, "dispel good", 40, 25, 3,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);
 
  spello(SPELL_DIVINE_HEAL, "divine heal", 175, 100, 3,
         POS_FIGHTING, TAR_CHAR_ROOM, FALSE, MAG_POINTS | MAG_AFFECTS | MAG_UNAFFECTS);
 
  spello(SPELL_DIVINE_PROTECTION, "divine protection", 80, 65, 3,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_DRAGON, "dragon", 50, 20, 5,
         POS_FIGHTING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_EARTHQUAKE, "earthquake", 40, 25, 3,
         POS_FIGHTING, TAR_IGNORE, TRUE, MAG_AREAS);
 
  spello(SPELL_ENCHANT_WEAPON, "enchant weapon", 150, 100, 10,
         POS_STANDING, TAR_OBJ_INV | TAR_OBJ_EQUIP, FALSE, MAG_MANUAL);
 
  spello(SPELL_ENERGY_DRAIN, "energy drain", 40, 25, 1,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE | MAG_MANUAL);
 
  spello(SPELL_FEAR, "fear", 40, 20, 2,
         POS_FIGHTING, TAR_CHAR_ROOM, TRUE, MAG_MANUAL);
 
  spello(SPELL_FINGERDEATH, "finger of death", 250, 220, 3,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_MANUAL);
 
  spello(SPELL_FIREBALL, "fireball", 40, 30, 2,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);
 
  spello(SPELL_FIRE_SHIELD, "fire shield", 175, 75, 3,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_FIRE_WALL, "fire wall", 250, 147, 6,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_FLY, "fly", 102, 52, 2,
         POS_FIGHTING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_GROUP_ARMOR, "group armor", 70, 60, 2,
         POS_STANDING, TAR_IGNORE, FALSE, MAG_GROUPS);

  spello(SPELL_GROUP_HEAL, "group heal", 130, 110, 5,
         POS_FIGHTING, TAR_IGNORE, FALSE, MAG_GROUPS);
 
  spello(SPELL_GROUP_SANCTUARY, "group sanctuary", 150, 120, 5,
         POS_FIGHTING, TAR_IGNORE, FALSE, MAG_GROUPS);
 
  spello(SPELL_HARM, "harm", 75, 45, 3,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);
 
  spello(SPELL_HEAL, "heal", 80, 40, 3,
         POS_FIGHTING, TAR_CHAR_ROOM, FALSE, MAG_POINTS | MAG_AFFECTS | MAG_UNAFFECTS);
 
  spello(SPELL_GATE, "dimension gate", 130, 90, 2,
         POS_STANDING, TAR_CHAR_INWORLD | TAR_NOT_SELF, FALSE, MAG_MANUAL);  

  spello(SPELL_HASTE, "haste", 150, 120, 3,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_HOLY_AID, "holy aid", 70, 40, 3,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_IDENTIFY, "identify", 50, 25, 2,
         POS_STANDING, TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_MANUAL);
 
  spello(SPELL_INFRAVISION, "infravision", 30, 20, 1,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_INVISIBLE, "invisibility", 40, 30, 1,
         POS_STANDING, TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_LIGHTNING_BOLT, "lightning bolt", 30, 15, 1,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);
 
  spello(SPELL_LIGHT_SHIELD, "lightning shield", 150, 85, 3,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_LOCATE_OBJECT, "locate object", 30, 20, 1,
         POS_STANDING, TAR_OBJ_WORLD, FALSE, MAG_MANUAL);
 
  spello(SPELL_MAGIC_MISSILE, "magic missile", 25, 10, 3,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);
 
  spello(SPELL_MANA, "mana", 10, 10, 10, POS_STANDING,
             TAR_CHAR_ROOM, FALSE, MAG_POINTS | MAG_AFFECTS);

  spello(SPELL_METEOR_SWARM, "meteor swarm", 80, 70, 3,
         POS_FIGHTING, TAR_IGNORE, TRUE, MAG_AREAS);
 
  spello(SPELL_PARALYZE, "paralyze",  50, 30, 2,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_NOT_SELF, TRUE, MAG_AFFECTS); 

  spello(SPELL_PLASMA_BLAST, "plasma blast", 80, 50, 2,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);
 
  spello(SPELL_POISON, "poison", 50, 20, 3,
         POS_STANDING, TAR_CHAR_ROOM | TAR_NOT_SELF | TAR_OBJ_INV, TRUE, MAG_AFFECTS);
 
  spello(SPELL_PROT_FROM_EVIL, "protection from evil", 123, 123, 0,
         POS_STANDING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
 
  spello(SPELL_PROT_FROM_GOOD, "protection from good", 133, 133, 0,
         POS_STANDING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
 
  spello(SPELL_NOHASSLE, "nohassle", 476, 476, 0,
        POS_STANDING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
 
  spello(SPELL_REFRESH, "refresh", 60, 30, 3,
         POS_FIGHTING, TAR_CHAR_ROOM, FALSE, MAG_POINTS);
 
  spello(SPELL_REMOVE_CURSE, "remove curse", 45, 25, 5,
         POS_STANDING, TAR_CHAR_ROOM | TAR_OBJ_EQUIP | TAR_OBJ_INV, FALSE, MAG_UNAFFECTS | MAG_ALTER_OBJS);
 
  spello(SPELL_GREATER_REMOVE_CURSE, "greater remove curse", 90, 45, 5,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_UNAFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_REMOVE_PARA, "remove paralysis", 50, 30, 5,
         POS_FIGHTING, TAR_CHAR_ROOM, FALSE, MAG_UNAFFECTS);
 
  spello(SPELL_REMOVE_POISON, "remove poison", 40, 8, 4,
         POS_STANDING, TAR_CHAR_ROOM | TAR_OBJ_INV, FALSE, MAG_UNAFFECTS);
 
  spello(SPELL_SANCTUARY, "sanctuary", 110, 100, 5,
         POS_FIGHTING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS); 

  spello(SPELL_SENSE_LIFE, "sense life", 45, 20, 3,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_SENSE_WOUNDS, "sense wounds", 45, 20, 3,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
 
  spello(SPELL_SERPENT_SKIN, "serpent skin", 200, 70, 10,
         POS_FIGHTING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_SHOCKING_GRASP, "shocking grasp", 30, 15, 3,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_SLEEP, "sleep", 40, 25, 5,
         POS_STANDING, TAR_CHAR_ROOM, TRUE, MAG_AFFECTS);
 
  spello(SPELL_SPIRIT_ARMOR, "spirit armor", 60, 42, 3,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_STONESKIN, "stoneskin", 77, 47, 3,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_STRENGTH, "strength", 35, 30, 1,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_SUMMON, "summon", 75, 60, 3,
         POS_STANDING, TAR_CHAR_INWORLD | TAR_NOT_SELF, FALSE, MAG_MANUAL);
 
  spello(SPELL_TELEPORT, "teleport", 30, 110, 3,
         POS_STANDING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_MANUAL);

  spello(SPELL_UNHOLY_VENGEANCE, "unholy vengeance", 666, 666, 0,
         POS_STANDING, TAR_CHAR_WORLD | TAR_NOT_SELF, FALSE, MAG_MANUAL);
 
  spello(SPELL_WATERBREATHE, "waterbreathe", 100, 40, 2,
         POS_FIGHTING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_WATERWALK, "waterwalk", 50, 30, 2,
         POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);
 
  spello(SPELL_WHIRLWIND, "whirlwind", 80, 50, 3,
         POS_FIGHTING, TAR_IGNORE, TRUE, MAG_AREAS);
 
  spello(SPELL_WORD_OF_RECALL, "recall", 20, 10, 2,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_MANUAL);
 
  spello(SPELL_WRAITH_TOUCH, "wraith touch", 200, 150, 2,
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);  

/*********************** stock 30bpl119 spello's
  spello(SPELL_ANIMATE_DEAD, "animate dead", 35, 10, 3, POS_STANDING,
	TAR_OBJ_ROOM, FALSE, MAG_SUMMONS);

  spello(SPELL_ARMOR, "armor", 30, 15, 3, POS_FIGHTING,
	TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_BLESS, "bless", 35, 5, 3, POS_STANDING,
	TAR_CHAR_ROOM | TAR_OBJ_INV, FALSE, MAG_AFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_BLINDNESS, "blindness", 35, 25, 1, POS_STANDING,
	TAR_CHAR_ROOM | TAR_NOT_SELF, FALSE, MAG_AFFECTS);

  spello(SPELL_BURNING_HANDS, "burning hands", 30, 10, 3, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_CALL_LIGHTNING, "call lightning", 40, 25, 3, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_CHARM, "charm person", 75, 50, 2, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_NOT_SELF, TRUE, MAG_MANUAL);

  spello(SPELL_CHILL_TOUCH, "chill touch", 30, 10, 3, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE | MAG_AFFECTS);

  spello(SPELL_CLONE, "clone", 80, 65, 5, POS_STANDING,
	TAR_SELF_ONLY, FALSE, MAG_SUMMONS);

  spello(SPELL_COLOR_SPRAY, "color spray", 30, 15, 3, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_CONTROL_WEATHER, "control weather", 75, 25, 5, POS_STANDING,
	TAR_IGNORE, FALSE, MAG_MANUAL);

  spello(SPELL_CREATE_FOOD, "create food", 30, 5, 4, POS_STANDING,
	TAR_IGNORE, FALSE, MAG_CREATIONS);

  spello(SPELL_CREATE_WATER, "create water", 30, 5, 4, POS_STANDING,
	TAR_OBJ_INV | TAR_OBJ_EQUIP, FALSE, MAG_MANUAL);

  spello(SPELL_CURE_BLIND, "cure blind", 30, 5, 2, POS_STANDING,
	TAR_CHAR_ROOM, FALSE, MAG_UNAFFECTS);

  spello(SPELL_CURE_CRITIC, "cure critic", 30, 10, 2, POS_FIGHTING,
	TAR_CHAR_ROOM, FALSE, MAG_POINTS);

  spello(SPELL_CURE_LIGHT, "cure light", 30, 10, 2, POS_FIGHTING,
	TAR_CHAR_ROOM, FALSE, MAG_POINTS);

  spello(SPELL_CURSE, "curse", 80, 50, 2, POS_STANDING,
	TAR_CHAR_ROOM | TAR_OBJ_INV, TRUE, MAG_AFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_DETECT_ALIGN, "detect alignment", 20, 10, 2, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_DETECT_INVIS, "detect invisibility", 20, 10, 2, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_DETECT_MAGIC, "detect magic", 20, 10, 2, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_DETECT_POISON, "detect poison", 15, 5, 1, POS_STANDING,
	TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_MANUAL);

  spello(SPELL_DISPEL_EVIL, "dispel evil", 40, 25, 3, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_DISPEL_GOOD, "dispel good", 40, 25, 3, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_DRAGON, "dragon", 50, 20, 5, POS_FIGHTING, 
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_EARTHQUAKE, "earthquake", 40, 25, 3, POS_FIGHTING,
	TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_ENCHANT_WEAPON, "enchant weapon", 150, 100, 10, POS_STANDING,
	TAR_OBJ_INV, FALSE, MAG_MANUAL);

  spello(SPELL_ENERGY_DRAIN, "energy drain", 40, 25, 1, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE | MAG_MANUAL);

  spello(SPELL_GROUP_ARMOR, "group armor", 50, 30, 2, POS_STANDING,
	TAR_IGNORE, FALSE, MAG_GROUPS);

  spello(SPELL_FIREBALL, "fireball", 40, 30, 2, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_GROUP_HEAL, "group heal", 80, 60, 5, POS_STANDING,
	TAR_IGNORE, FALSE, MAG_GROUPS);

  spello(SPELL_HARM, "harm", 75, 45, 3, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_HEAL, "heal", 60, 40, 3, POS_FIGHTING,
	TAR_CHAR_ROOM, FALSE, MAG_POINTS | MAG_UNAFFECTS);

  spello(SPELL_INFRAVISION, "infravision", 25, 10, 1, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_INVISIBLE, "invisibility", 35, 25, 1, POS_STANDING,
	TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_AFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_LIGHTNING_BOLT, "lightning bolt", 30, 15, 1, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_LOCATE_OBJECT, "locate object", 25, 20, 1, POS_STANDING,
	TAR_OBJ_WORLD, FALSE, MAG_MANUAL);

  spello(SPELL_MAGIC_MISSILE, "magic missile", 25, 10, 3, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_POISON, "poison", 50, 20, 3, POS_STANDING,
	TAR_CHAR_ROOM | TAR_NOT_SELF | TAR_OBJ_INV, TRUE,
	MAG_AFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_PROT_FROM_EVIL, "protection from evil", 40, 10, 3, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_REMOVE_CURSE, "remove curse", 45, 25, 5, POS_STANDING,
	TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_EQUIP, FALSE,
	MAG_UNAFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_REMOVE_POISON, "remove poison", 40, 8, 4, POS_STANDING,
	TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_UNAFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_SANCTUARY, "sanctuary", 110, 85, 5, POS_STANDING,
	TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_SENSE_LIFE, "sense life", 20, 10, 2, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_SHOCKING_GRASP, "shocking grasp", 30, 15, 3, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_SLEEP, "sleep", 40, 25, 5, POS_STANDING,
	TAR_CHAR_ROOM, TRUE, MAG_AFFECTS);

  spello(SPELL_STRENGTH, "strength", 35, 30, 1, POS_STANDING,
	TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_SUMMON, "summon", 75, 50, 3, POS_STANDING,
	TAR_CHAR_WORLD | TAR_NOT_SELF, FALSE, MAG_MANUAL);

  spello(SPELL_TELEPORT, "teleport", 75, 50, 3, POS_STANDING,
	TAR_CHAR_ROOM, FALSE, MAG_MANUAL);

  spello(SPELL_WATERWALK, "waterwalk", 40, 20, 2, POS_STANDING,
	TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_WORD_OF_RECALL, "recall", 20, 10, 2, POS_FIGHTING,
	TAR_CHAR_ROOM, FALSE, MAG_MANUAL);


****************************************/


  /* NON-castable spells should appear below here. */

  spello(SPELL_IDENTIFY, "identify", 0, 0, 0, 0,
	TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_MANUAL);

  /*
   * These spells are currently not used, not implemented, and not castable.
   * Values for the 'breath' spells are filled in assuming a dragon's breath.
   */

  spello(SPELL_CHANGED, "lycanthropy", 0, 0, 0, POS_SITTING, 
        TAR_IGNORE, TRUE, 0);

  spello(SPELL_CREAMED, "creamed", 0, 0, 0, POS_SITTING, TAR_IGNORE, TRUE, 0);

  spello(SPELL_FIRE_BREATH, "fire breath", 0, 0, 0, POS_SITTING,
	TAR_IGNORE, TRUE, 0);

  spello(SPELL_GAS_BREATH, "gas breath", 0, 0, 0, POS_SITTING,
	TAR_IGNORE, TRUE, 0);

  spello(SPELL_FROST_BREATH, "frost breath", 0, 0, 0, POS_SITTING,
	TAR_IGNORE, TRUE, 0);

  spello(SPELL_ACID_BREATH, "acid breath", 0, 0, 0, POS_SITTING,
	TAR_IGNORE, TRUE, 0);

  spello(SPELL_LIGHTNING_BREATH, "lightning breath", 0, 0, 0, POS_SITTING,
	TAR_IGNORE, TRUE, 0);
  
  spello(SPELL_SUPERMAN, "superman", 0, 0, 0,
         POS_STANDING, TAR_IGNORE, FALSE, MAG_MANUAL);


  /*
   * Declaration of skills - this actually doesn't do anything except
   * set it up so that immortals can use these skills by default.  The
   * min level to use the skill for other classes is set up in class.c.
   */

  skillo(SKILL_BACKSTAB, "backstab"); 
  skillo(SKILL_BASH, "bash"); 
  skillo(SKILL_COMPARE, "compare"); 
  skillo(SKILL_HIDE, "hide"); 
  skillo(SKILL_HUNT, "hunt"); 
  skillo(SKILL_KICK, "kick"); 
  skillo(SKILL_PICK_LOCK, "pick lock"); 
  skillo(SKILL_PRIMAL_SCREAM, "primal scream"); 
  skillo(SKILL_RESCUE, "rescue"); 
  skillo(SKILL_RETREAT, "retreat"); 
  skillo(SKILL_SCAN, "scan"); 
  skillo(SKILL_2ND_ATTACK, "second attack"); 
  skillo(SKILL_SNEAK, "sneak"); 
  skillo(SKILL_SPY, "spy"); 
  skillo(SKILL_STEAL, "steal"); 
  skillo(SKILL_3RD_ATTACK, "third attack"); 
  skillo(SKILL_THROW, "throw"); 
  skillo(SKILL_TRACK, "track");

  /* New skills */
  skillo(SKILL_ADRENALINE, "adrenaline");
  skillo(SKILL_AMBIDEXTERITY, "ambidexterity");
  skillo(SKILL_AMBUSH, "ambush");
  skillo(SKILL_ARMOURCRAFT, "armorcraft");
  skillo(SKILL_ATTEND_WOUNDS, "attend wounds");
  skillo(SKILL_AXEMASTERY, "axemastery");
  skillo(SKILL_BARGAIN,	"bargain");
  skillo(SKILL_BATTLECRY, "battlecry");
  skillo(SKILL_BEARHUG, "bearhug");
  skillo(SKILL_BERSERK, "berserk");
  skillo(SKILL_BLADEMASTERY, "blademastery");
  skillo(SKILL_BODYSLAM, "bodyslam");
  spell_info[SKILL_BODYSLAM].violent = 2; // Don't flee/show wounds in damage()
  skillo(SKILL_CLOT_WOUNDS, "clot wounds");
  skillo(SKILL_DETECT_DEATH, "detect deathtraps"); 
  skillo(SKILL_DOUBLE_KICK, "double kick");

  skillo(SKILL_HEALING_MASTERY, "healing mastery");
  skillo(SKILL_HEALING_EFFICIENCY, "healing efficiency");
  skillo(SKILL_BURGLE, "burglery");
  skillo(SKILL_SENSE_STATS, "sense stats");
  skillo(SKILL_SENSE_CURSE, "sense curse");
  skillo(SKILL_MOUNTAINEER, "mountaineering");
  skillo(SKILL_DOUBLE_BACKSTAB, "double backstab");
  skillo(SKILL_DEFEND, "defend");
  skillo(SKILL_CONCEAL_SPELL_CASTING, "conceal spell casting");
  skillo(SKILL_CAMPING, "camping");
  skillo(SKILL_BARGAIN, "bargaining");
  skillo(SKILL_BLADEMASTERY, "blade mastery");
  skillo(SKILL_AXEMASTERY, "axe mastery");
  skillo(SKILL_WEAPONCRAFT, "weaponcraft");
  skillo(SKILL_AMBIDEXTERITY, "ambidexterity");

  skillo(SKILL_DISARM, "disarm"); 
  skillo(SKILL_HEADBUTT, "headbutt");
  skillo(SKILL_PILEDRIVE, "piledrive");
  skillo(SKILL_PURSE, "purse evaluation");
  skillo(SKILL_TRIP, "trip");
  skillo(SKILL_WEAPONCRAFT, "weaponcraft");
  skillo(SKILL_TUMBLE, "tumble");
  skillo(SKILL_FLYINGTACKLE, "flytackle");
  skillo(SKILL_FIRST_AID, "first aid");
  skillo(SKILL_POISONBLADE, "poison blade");
  skillo(SKILL_DARKRITUAL, "dark ritual");
  skillo(SKILL_MOUNT, "mount");
  skillo(SKILL_MEDITATE, "meditate");
  skillo(SKILL_TORCH, "torch");
  skillo(SKILL_SHIELDMASTERY, "shielding mastery");
  skillo(SKILL_POWERKICK, "kicking mastery");
  skillo(SKILL_SUICIDE, "suicide");
  skillo(SKILL_COMPOST, "compost");
  skillo(SKILL_TRAP_PIT, "trap pit");
  skillo(SKILL_SLIP, "slip");
  skillo(SKILL_SLEIGHT, "sleight");
  skillo(SKILL_GLANCE, "glance");
  skillo(SKILL_LISTEN, "listen");
  skillo(SKILL_PERCEPTION, "perceiving eye");
  skillo(SKILL_HEAL_TRANCE, "healing trance");
  skillo(SKILL_AXETHROW, "axethrow");
  skillo(SKILL_TRAP_MAGIC, "trap magic");
/* manufacturing skills */
  skillo(SKILL_TAILORING, "tailoring");
  skillo(SKILL_BLACKSMITHING, "blacksmithing");
  skillo(SKILL_BREWING, "brewing");
  skillo(SKILL_JEWELRY, "jewelry");
}
@


1.81
log
@Artus> Gloves don't show up as dual wield now.
       Backstab with no target, when fighting and have combat backstab, targets
       person fighting.
@
text
@d2120 1
d2140 1
a2140 1

@


1.80
log
@Artus> Added spello for cream pie command.
@
text
@a1334 1

d1340 3
a1342 2
  // Only let NPC hit and kill commands through
  if (IS_NPC(ch) && !(skillnum == SCMD_HIT || skillnum == SCMD_KILL)) {
d1383 2
a1384 2

      if (!*arg) {
a1390 1

d1392 2
a1393 1
      if (skillnum == SCMD_KILL && !IS_NPC(ch) && !LR_FAIL(ch, LVL_IMPL)) {
d1395 1
a1395 1
                FALSE, ch, 0, vict, TO_CHAR);
a1400 1

a1403 1
  
a1406 1

d1408 4
a1411 3
      if ((GET_POS(ch) == POS_STANDING) && (vict != FIGHTING(ch))) {

        if (wielded && OBJ_IS_GUN(wielded)) {
a1414 1

d1416 1
a1416 1
        if (skillnum == SCMD_MURDER) {
a1417 2
        }

a1419 1

d1421 2
a1422 1
        if (!IS_NPC(ch) && MOUNTING(ch) && !FIGHTING(MOUNTING(ch))) {
a1426 1

a1440 1

a1496 1
 
d1499 7
a1505 3
      { 
        send_to_char("Backstab who?\r\n", ch);
        return;
a1506 1

a1513 1

d1517 1
a1517 2
        send_to_char("Only piercing weapons can be used for backstabbing.\r\n",
                        ch);
a1519 1

a1534 1

a1537 1

a1543 1
      
a1549 1
      
a1574 1

a1579 1

a1583 1

a1584 1

d1589 2
a1591 3
      else
        GET_WAIT_STATE(ch) = PULSE_VIOLENCE * 3;

@


1.79
log
@Artus> Required changes for new find_xxx functions.
@
text
@d2799 2
@


1.78
log
@Artus> Priests can wait for their spells to be cast, too.
@
text
@d859 1
a859 1
  int mana, spellnum, i, target = 0;
d867 2
a868 1
  if (s == NULL) {
d873 2
a874 1
  if (s == NULL) {
d883 2
a884 1
  if ((spellnum < 1) || (spellnum > MAX_SPELLS)) {
a888 12
  /* Artus> Moved to has_stats_for_skill 
  if (GET_LEVEL(ch) < SINFO.min_level[(int) GET_CLASS(ch)]) 
  {
    send_to_char("You do not know of that spell!\r\n", ch);
    return;
  }
  
  if (GET_SKILL(ch, spellnum) == 0) {
    send_to_char(UNFAMILIARSPELL, ch);
    return;
  } */

d894 2
a895 1
  if (IS_AFFECTED(ch, AFF_BERSERK)) {
d909 4
a912 2
  if ((spellnum == SPELL_LIGHT_SHIELD) || (spellnum == SPELL_FIRE_SHIELD)) {
    if (!GET_EQ(ch,WEAR_SHIELD)) {
d919 2
a920 1
  if ((spellnum == SPELL_PROT_FROM_EVIL) || (spellnum == SPELL_PROT_FROM_GOOD)) {
d922 2
a923 1
                affected_by_spell(ch,SPELL_PROT_FROM_GOOD)) {
d929 4
a932 2
    if (spellnum == SPELL_PROT_FROM_EVIL) {
      if (!IS_GOOD(ch)) {
d937 2
a938 1
      if (!IS_EVIL(ch)) {
d946 2
a947 1
  if (t != NULL) {
d955 1
a955 1
  if (IS_SET(SINFO.targets, TAR_IGNORE)) {
d957 19
a975 34
  } else if (t != NULL && *t) {
    if (!target && (IS_SET(SINFO.targets, TAR_CHAR_ROOM))) {
      if ((tch = get_char_vis(ch, t, FIND_CHAR_ROOM)) != NULL)
	target = TRUE;
    }
    if (!target && IS_SET(SINFO.targets, TAR_CHAR_WORLD))
      if ((tch = get_char_vis(ch, t, FIND_CHAR_WORLD)) != NULL)
	target = TRUE;

    // DM - in same primal 'world'
    if (!target && IS_SET(SINFO.targets, TAR_CHAR_INWORLD))
      if ((tch = get_char_vis(ch, t, FIND_CHAR_INWORLD)) != NULL)
	target = TRUE;

    if (!target && IS_SET(SINFO.targets, TAR_OBJ_INV))
      if ((tobj = get_obj_in_list_vis(ch, t, ch->carrying)) != NULL)
	target = TRUE;

    if (!target && IS_SET(SINFO.targets, TAR_OBJ_EQUIP)) 
      for (i = 0; !target && i < NUM_WEARS; i++)
	if (GET_EQ(ch, i) && isname(t, GET_EQ(ch, i)->name)) 
	{
	  tobj = GET_EQ(ch, i);
	  target = TRUE;
	}

    if (!target && IS_SET(SINFO.targets, TAR_OBJ_ROOM))
      if ((tobj = get_obj_in_list_vis(ch, t, world[IN_ROOM(ch)].contents)) != NULL)
	target = TRUE;

    if (!target && IS_SET(SINFO.targets, TAR_OBJ_WORLD))
      if ((tobj = get_obj_vis(ch, t)) != NULL)
	target = TRUE;

d978 2
a979 1
      if (FIGHTING(ch) != NULL) {
d984 2
a985 1
      if (FIGHTING(ch) != NULL) {
d991 2
a992 1
	!SINFO.violent) {
d996 2
a997 1
    if (!target) {
d999 1
a999 1
	 IS_SET(SINFO.targets, TAR_OBJ_ROOM | TAR_OBJ_INV | TAR_OBJ_WORLD | TAR_OBJ_EQUIP) ? "what" : "who");
d1023 2
a1024 1
  if (target && (tch == ch) && SINFO.violent) {
d1028 2
a1029 1
  if (!target) {
d1035 2
a1036 1
    if (GET_DEBUG(ch)) {
d1043 2
a1044 1
  if ((mana > 0) && (GET_MANA(ch) < mana) && (LR_FAIL(ch, LVL_IS_GOD))) {
a1048 1

d1050 2
a1051 1
  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_NOMAGIC) && LR_FAIL(ch, LVL_IMPL)) {
d1059 2
a1060 1
  if (number(0, 101) > GET_SKILL(ch, spellnum)) {
d1374 1
a1374 1
  vict = get_char_vis(ch, arg, FIND_CHAR_ROOM);
@


1.77
log
@Artus> Quest Mobs.
@
text
@a192 31
#if 0 // Artus> This isn't working properly.
  // Hide the casting
  if (tch != NULL && GET_SKILL(ch, SKILL_CONCEAL_SPELL_CASTING) && (GET_LEVEL(tch) < LVL_ANGEL))
  {
    if (number(1, 100) > GET_SKILL(ch, SKILL_CONCEAL_SPELL_CASTING))
    {
      for (i = world[IN_ROOM(ch)].people; i; i = i->next_in_room) 
      {
	if (i == ch || i == tch || !i->desc || !AWAKE(i))
	  continue;
	if (GET_CLASS(ch) == GET_CLASS(i))
	  perform_act(buf1, ch, tobj, tch, i);
	else
	  perform_act(buf2, ch, tobj, tch, i);
      }
    } else {
      send_to_char("You manage to conceal your casting.\r\n", ch);
      concealed = 1;
    }
  }
  if (tch != NULL && tch != ch && IN_ROOM(tch) == IN_ROOM(ch)) 
  {
    if(GET_CLASS(ch) == CLASS_PRIEST && tch != ch && !IS_NPC(tch))
      sprintf(buf1, "$n takes your money, stares at you, and utters the words, '%s'.", GET_CLASS(ch) == GET_CLASS(tch) ? skill_name(spellnum) : buf);
    else
      sprintf(buf1, "$n stares at you and utters the words, '%s'.",
            GET_CLASS(ch) == GET_CLASS(tch) ? skill_name(spellnum) : buf);
     if (!concealed)
       act(buf1, FALSE, ch, NULL, tch, TO_VICT); 
  }
#endif
d834 1
a834 1
    call_magic(ch, tch, tobj, spellnum, GET_LEVEL(ch), CAST_SPELL);
@


1.76
log
@Artus> Unholy Vengeance.
@
text
@d1244 1
a1244 1
    if (!imm && MOB_FLAGGED(vict,MOB_QUEST))
@


1.75
log
@Artus> Added IS_NPC check to GET_SKILL check.
@
text
@d427 14
a440 13
      case SPELL_CHARM:		  MANUAL_SPELL(spell_charm); break;
      case SPELL_CREATE_WATER:	  MANUAL_SPELL(spell_create_water); break;
      case SPELL_DETECT_POISON:	  MANUAL_SPELL(spell_detect_poison); break;
      case SPELL_ENCHANT_WEAPON:  MANUAL_SPELL(spell_enchant_weapon); break;
      case SPELL_IDENTIFY:	  MANUAL_SPELL(spell_identify); break;
      case SPELL_LOCATE_OBJECT:   MANUAL_SPELL(spell_locate_object); break;
      case SPELL_SUMMON:	  MANUAL_SPELL(spell_summon); break;
      case SPELL_WORD_OF_RECALL:  MANUAL_SPELL(spell_recall); break;
      case SPELL_TELEPORT:	  MANUAL_SPELL(spell_teleport); break;
      case SPELL_FINGERDEATH:	  MANUAL_SPELL(spell_fingerdeath); break;
      case SPELL_CONTROL_WEATHER: MANUAL_SPELL(spell_control_weather); break;
      case SPELL_FEAR: 		  MANUAL_SPELL(spell_fear); break;
      case SPELL_GATE: 		  MANUAL_SPELL(spell_gate); break;
d2647 3
@


1.74
log
@Artus> Fixed issue where MAGIC_EQ spells would not apply in !(MAGIC) rooms.
       Will probably need to fix this properly soon.
@
text
@d165 1
a165 1
  if ((GET_SKILL(ch, SKILL_CONCEAL_SPELL_CASTING)) &&
@


1.73
log
@Artus> Minor cleanup.
@
text
@d342 2
a343 1
      if (ROOM_FLAGGED(IN_ROOM(caster), ROOM_NOMAGIC)) 
@


1.72
log
@Artus> Now warning free :o)
@
text
@d424 15
a438 15
    switch (spellnum) {
    case SPELL_CHARM:		MANUAL_SPELL(spell_charm); break;
    case SPELL_CREATE_WATER:	MANUAL_SPELL(spell_create_water); break;
    case SPELL_DETECT_POISON:	MANUAL_SPELL(spell_detect_poison); break;
    case SPELL_ENCHANT_WEAPON:  MANUAL_SPELL(spell_enchant_weapon); break;
    case SPELL_IDENTIFY:	MANUAL_SPELL(spell_identify); break;
    case SPELL_LOCATE_OBJECT:   MANUAL_SPELL(spell_locate_object); break;
    case SPELL_SUMMON:		MANUAL_SPELL(spell_summon); break;
    case SPELL_WORD_OF_RECALL:  MANUAL_SPELL(spell_recall); break;
    case SPELL_TELEPORT:	MANUAL_SPELL(spell_teleport); break;

    case SPELL_FINGERDEATH:	MANUAL_SPELL(spell_fingerdeath); break;
    case SPELL_CONTROL_WEATHER: MANUAL_SPELL(spell_control_weather); break;
    case SPELL_FEAR: 		MANUAL_SPELL(spell_fear); break;
    case SPELL_GATE: 		MANUAL_SPELL(spell_gate); break;
@


1.71
log
@Artus> Primal scream will no longer attack !KILL mobs.
@
text
@d112 2
a113 2
  if (SINFO.mana_perc[GET_CLASS(ch)] > 0)
    mana = (int)((100 * mana) / SINFO.mana_perc[GET_CLASS(ch)]);
d454 1
a454 1
  int ability;
d518 1
a518 1
  struct char_data *tch = NULL, *next_tch;
d783 1
a783 1
  amt = MIN(GET_LEVEL(tch) * 100, mag_manacost(ch, spellnum) * MAX(1, GET_LEVEL(ch) - SINFO.min_level[GET_CLASS(ch)]));
d788 2
a789 1
	    mag_manacost(ch, spellnum), SINFO.min_level[GET_CLASS(ch)], amt);
d808 2
a809 2
  int retval = 0;
  if (spellnum < 0 || spellnum > TOP_SPELL_DEFINE) {
d888 1
a888 1
  int mana, spellnum, i, target = 0, spell_cost = 0;
a1355 1
  extern struct index_data *obj_index;
a1364 4
  // Battlecry
  bool kick = FALSE, bearhug = FALSE, headbutt = FALSE, piledrive = FALSE, 
       bash = FALSE;

d2125 1
a2125 1
      int attempt, i;
@


1.70
log
@Artus> Conditionals for IGNORE_DEBUG.
       Fixes for SPECIAL_PRIEST.
@
text
@a1854 1
        skip = 0;
d1856 15
a1870 13
          skip = 1; /* ch is the victim skip to next person */
        if (IS_NPC(ch) && IS_NPC(vict) && !IS_AFFECTED(vict, AFF_CHARM))
          skip = 1; /* if ch is a mob only hit other mobs if they are charmed */
        if (!IS_NPC(vict) && !LR_FAIL(vict, LVL_IS_GOD))
          skip = 1; /* dont bother gods with it */
        if ((GET_MOB_SPEC(vict) == postmaster) && LR_FAIL(ch, LVL_GOD))
          skip = 1;
        if ((GET_MOB_SPEC(vict) == receptionist) && LR_FAIL(ch, LVL_GOD))
          skip = 1;
        if (!IS_NPC(ch) && !IS_NPC(vict))
          skip = 1; /* dont hit players with it */
        if (!IS_NPC(ch) && IS_NPC(vict) && IS_AFFECTED(vict, AFF_CHARM))
          skip = 1; /* dont hit charmed mobs */
d1872 3
a1874 6
        if (!(skip)) 
	{
          performed = TRUE;
          dam = calc_dam_amt(ch,vict,SKILL_PRIMAL_SCREAM);
          damage(ch,vict,dam,SKILL_PRIMAL_SCREAM,FALSE);
        }
@


1.69
log
@Artus> Fixed bug in wands.
@
text
@d35 1
a35 1
void say_spell(struct char_data * ch, int spellnum, struct char_data * tch, struct obj_data * tobj);
d120 1
a120 1
	            struct obj_data * tobj)
d186 1
a186 1
    if ((GET_CLASS(ch) == CLASS_PRIEST) && !IS_NPC(tch))
d652 142
d807 1
a854 1
  say_spell(ch, spellnum, tch, tobj);
d856 16
a871 1
  return (call_magic(ch, tch, tobj, spellnum, GET_LEVEL(ch), CAST_SPELL));
d1069 3
a1071 1
  } else {
d1077 1
d1107 2
a1108 2
    if (cast_spell(ch, tch, tobj, spellnum)) {
  
d1110 3
a1112 1
      if ((GET_CLASS(ch) == CLASS_PRIEST) && (tch != ch) && !IS_NPC(tch)) {
d1114 2
a1115 1
        if( (GET_GOLD(tch) + GET_BANK_GOLD(tch)) < spell_cost) {
d1120 2
a1121 1
        if( GET_GOLD(tch) < 0 ) {
d1125 2
a1126 1
      }  
d1283 1
d1290 1
@


1.68
log
@Continued development on manufacturing code
@
text
@d376 14
a389 13
  switch (casttype) {
  case CAST_STAFF:
  case CAST_SCROLL:
  case CAST_POTION:
  case CAST_WAND:
    savetype = SAVING_ROD;
    break;
  case CAST_SPELL:
    savetype = SAVING_SPELL;
    break;
  default:
    savetype = SAVING_BREATH;
    break;
a391 1

d523 8
a530 2
  k = generic_find(arg, FIND_CHAR_ROOM | FIND_OBJ_INV | FIND_OBJ_ROOM |
		   FIND_OBJ_EQUIP, ch, &tch, &tobj);
d532 20
a551 12
  switch (GET_OBJ_TYPE(obj)) {
  case ITEM_STAFF:
    act("You tap $p three times on the ground.", FALSE, ch, obj, 0, TO_CHAR);
    if (obj->action_description)
      act(obj->action_description, FALSE, ch, obj, 0, TO_ROOM);
    else
      act("$n taps $p three times on the ground.", FALSE, ch, obj, 0, TO_ROOM);

    if (GET_OBJ_VAL(obj, 2) <= 0) {
      send_to_char("It seems powerless.\r\n", ch);
      act("Nothing seems to happen.", FALSE, ch, obj, 0, TO_ROOM);
    } else {
a553 1
      /* Level to cast spell at. */
d555 15
a569 17

      /*
       * Problem : Area/mass spells on staves can cause crashes.
       * Solution: Remove the special nature of area/mass spells on staves.
       * Problem : People like that behavior.
       * Solution: We special case the area/mass spells here.
       */
      if (HAS_SPELL_ROUTINE(GET_OBJ_VAL(obj, 3), MAG_MASSES | MAG_AREAS)) {
        for (i = 0, tch = world[IN_ROOM(ch)].people; tch; tch = tch->next_in_room)
	  i++;
	while (i-- > 0)
	  call_magic(ch, NULL, NULL, GET_OBJ_VAL(obj, 3), k, CAST_STAFF);
      } else {
	for (tch = world[IN_ROOM(ch)].people; tch; tch = next_tch) {
	  next_tch = tch->next_in_room;
	  if (ch != tch)
	    call_magic(ch, tch, NULL, GET_OBJ_VAL(obj, 3), k, CAST_STAFF);
d571 2
a572 10
      }
    }
    break;
  case ITEM_WAND:
    if (k == FIND_CHAR_ROOM) {
      if (tch == ch) {
	act("You point $p at yourself.", FALSE, ch, obj, 0, TO_CHAR);
	act("$n points $p at $mself.", FALSE, ch, obj, 0, TO_ROOM);
      } else {
	act("You point $p at $N.", FALSE, ch, obj, tch, TO_CHAR);
d574 1
a574 1
	  act(obj->action_description, FALSE, ch, obj, tch, TO_ROOM);
d576 8
a583 1
	  act("$n points $p at $N.", TRUE, ch, obj, tch, TO_ROOM);
d585 27
a611 2
    } else if (tobj != NULL) {
      act("You point $p at $P.", FALSE, ch, obj, tobj, TO_CHAR);
d613 1
a613 1
	act(obj->action_description, FALSE, ch, obj, tobj, TO_ROOM);
d615 6
a620 9
	act("$n points $p at $P.", TRUE, ch, obj, tobj, TO_ROOM);
    } else if (IS_SET(spell_info[GET_OBJ_VAL(obj, 3)].routines, MAG_AREAS | MAG_MASSES)) {
      /* Wands with area spells don't need to be pointed. */
      act("You point $p outward.", FALSE, ch, obj, NULL, TO_CHAR);
      act("$n points $p outward.", TRUE, ch, obj, NULL, TO_ROOM);
    } else {
      act("At what should $p be pointed?", FALSE, ch, obj, NULL, TO_CHAR);
      return;
    }
d622 4
a625 22
    if (GET_OBJ_VAL(obj, 2) <= 0) {
      send_to_char("It seems powerless.\r\n", ch);
      act("Nothing seems to happen.", FALSE, ch, obj, 0, TO_ROOM);
      return;
    }
    GET_OBJ_VAL(obj, 2)--;
    WAIT_STATE(ch, PULSE_VIOLENCE);
    if (GET_OBJ_VAL(obj, 0))
      call_magic(ch, tch, tobj, GET_OBJ_VAL(obj, 3),
		 GET_OBJ_VAL(obj, 0), CAST_WAND);
    else
      call_magic(ch, tch, tobj, GET_OBJ_VAL(obj, 3),
		 DEFAULT_WAND_LVL, CAST_WAND);
    break;
  case ITEM_SCROLL:
    if (*arg) {
      if (!k) {
	act("There is nothing to here to affect with $p.", FALSE,
	    ch, obj, NULL, TO_CHAR);
	return;
      }
    } else
d627 5
d633 14
a646 38
    act("You recite $p which dissolves.", TRUE, ch, obj, 0, TO_CHAR);
    if (obj->action_description)
      act(obj->action_description, FALSE, ch, obj, NULL, TO_ROOM);
    else
      act("$n recites $p.", FALSE, ch, obj, NULL, TO_ROOM);

    WAIT_STATE(ch, PULSE_VIOLENCE);
    for (i = 1; i <= 3; i++)
      if (call_magic(ch, tch, tobj, GET_OBJ_VAL(obj, i),
		       GET_OBJ_VAL(obj, 0), CAST_SCROLL) <= 0)
	break;

    if (obj != NULL)
      extract_obj(obj);
    break;
  case ITEM_POTION:
    tch = ch;
    act("You quaff $p.", FALSE, ch, obj, NULL, TO_CHAR);
    if (obj->action_description)
      act(obj->action_description, FALSE, ch, obj, NULL, TO_ROOM);
    else
      act("$n quaffs $p.", TRUE, ch, obj, NULL, TO_ROOM);

    /* Artus> 20031013 - 6 Potions/Round if Adrenaline, else 5. */
    if (IS_AFFECTED(ch, AFF_ADRENALINE))
      WAIT_STATE(ch, (PULSE_VIOLENCE / 6));
    else
      WAIT_STATE(ch, (PULSE_VIOLENCE / 5));
    for (i = 1; i <= 3; i++)
      if (call_magic(ch, ch, NULL, GET_OBJ_VAL(obj, i),
		       GET_OBJ_VAL(obj, 0), CAST_POTION) <= 0)
	break;

    if (obj != NULL)
      extract_obj(obj);
    break;
  default:
    basic_mud_log("SYSERR: Unknown object_type %d in mag_objectmagic.",
d1166 2
a1167 1
    if (!IS_NPC(vict) && !IS_NPC(ch) && skillnum != SCMD_MURDER) {
@


1.67
log
@Artus> Fixes to backstab special.
       Cleaned up a little.
@
text
@d2779 5
@


1.66
log
@\Artus> Mainly debug fixes.
@
text
@d183 2
a184 2
  if ((tch != NULL) && (tch != ch) && (tch->desc) && 
      ((concealed == 0) || !LR_FAIL(tch, LVL_ANGEL)))
d295 2
a296 1
    if (number(0, 101) > GET_SKILL(ch, spellnum)) {
d299 4
a302 2
      else {
	switch (spellnum) {
d1382 2
a1383 1
      if (vict == NULL) { 
d1389 2
a1390 1
      if (!wielded) {
d1397 2
a1398 1
      if (GET_OBJ_VAL(wielded, 3) != TYPE_PIERCE - TYPE_HIT) {
d1405 13
a1417 4
      if (FIGHTING(vict) && (!IS_SET(GET_SPECIALS(ch), SPECIAL_BACKSTAB)) ) {
        send_to_char("You can't backstab a fighting person -- "
                     "they're too alert!\r\n", ch);
        return;
d1421 1
a1421 1
      if (!violence_check(ch, vict, skillnum)) {
a1422 1
      }
d1425 2
a1426 1
      if (IS_CLONE(vict)) {
d1432 2
a1433 1
      if (IS_ZOMBIE(vict)) {
d1439 6
a1444 4
      if (MOB_FLAGGED(vict, MOB_AWARE)) {
        switch (number(1,4)) {
        case 1:
          send_to_char("Your weapon hits an invisible barrier and fails to "
d1446 13
a1458 13
          break;
        case 2:
          act("$N skillfuly blocks your backstab and attacks with rage!", 
                         FALSE, ch, 0 , vict, TO_CHAR);
          break;
        case 3:
          act("$N cleverly avoids your backstab.", 
                        FALSE, ch, 0 , vict, TO_CHAR);
          break;
        case 4:
          act("$N steps to the side avoiding your backstab!", 
                        FALSE, ch, 0 , vict, TO_CHAR);
          break;
d2733 1
a2733 1
  skillo(SKILL_DETECT_DEATH, "detect death traps"); 
@


1.65
log
@Artus> No longer need skill backstab if you have special backstab.
@
text
@d289 1
a289 1
  if (!has_stats_for_skill(ch, spellnum, TRUE))
@


1.64
log
@Artus> Added TRAP_MAGIC, trap -> trap pit.
       Fixed crash in axethrow.
@
text
@d458 1
a458 1
  if (spellnum == SKILL_TRACK)
d460 10
a469 4
    if (IS_SET(GET_SPECIALS(ch), SPECIAL_TRACKER))
      ability = MAX(1, GET_SKILL(ch, spellnum));
  } else
    ability = GET_SKILL(ch, spellnum);
d1221 1
a1221 1
  if (!IS_NPC(ch) && IS_GHOST(ch))
d1223 6
a1228 3
    send_to_char("As a ghost, you find yourself unable to harm others.\r\n", ch);
    return;
  }
d1230 15
a1244 12
  // Check the chars skill ability 
  if (!IS_NPC(ch) && (skillnum != SCMD_HIT && skillnum != SCMD_MURDER && 
      skillnum != SCMD_KILL) && !GET_SKILL(ch, skillnum)) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }

  // Check stats for PCs using the skill
  if (!IS_NPC(ch) && (skillnum != SCMD_HIT && skillnum != SCMD_MURDER && 
      skillnum != SCMD_KILL) && !has_stats_for_skill(ch, subcmd, TRUE)) {
    return;
  }
d1249 2
a1250 1
  switch (skillnum) {
d1447 4
a1450 1
      prob = GET_SKILL(ch, SKILL_BACKSTAB);
@


1.63
log
@Artus> Fixed crash in bodyslam, <= NUM_OF_DIRS vs < NUM_OF_DIRS
@
text
@d1200 1
d1318 5
a1322 2
      dam = calc_dam_amt(ch, vict, SKILL_AXETHROW);
      if (dam < 0)
d1324 3
a1326 1

d1980 2
a1981 1
	      !ROOM_FLAGGED(EXIT(vict, attempt)->to_room, ROOM_DEATH)) 
d2736 1
a2736 1
  skillo(SKILL_TRAP_PIT, "trap");
d2744 1
@


1.62
log
@Artus> Bodyslam balanced better.
@
text
@d1973 1
a1973 1
	  if ((attempt <= NUM_OF_DIRS) && CAN_GO(vict, attempt) && 
@


1.61
log
@Artus> Notification when ability reaches max.
       95 -> MAX_SKILL_ABIL
       Lycanthropy -> lycanthropy.
@
text
@a1967 2
//	dam = (int)(GET_WEIGHT(ch) * 

d1971 4
a1974 1
          for (i = 0; i < NUM_OF_DIRS; i++) 
d1976 6
a1981 3
            attempt = number(0, NUM_OF_DIRS - 1);/* Select a random direction */
            if (CAN_GO(vict, attempt) && 
                !ROOM_FLAGGED(EXIT(vict, attempt)->to_room, ROOM_DEATH)) 
d1983 19
a2001 23
              performed = TRUE; // well moved from room acutally
	      dam = calc_dam_amt(ch, vict, SKILL_BODYSLAM);
              if (damage(ch, vict, dam, SKILL_BODYSLAM, FALSE) > 0)
	      {
		sprintf(buf, "You are bodyslammed out of the room, %s, by $n!", dirs[attempt]);
	        act(buf, TRUE, ch, 0, vict, TO_VICT);
		sprintf(buf, "$N is bodyslammed %s from the room by $n!", dirs[attempt]);
                act(buf, TRUE, ch, 0, vict, TO_ROOM);
		sprintf(buf, "You bodyslam $N out of the room, %s!", dirs[attempt]);
                act(buf, TRUE, ch, 0, vict, TO_CHAR);
	        // move the vict to room
	        char_from_room(vict);
	        char_to_room(vict, EXIT(ch, attempt)->to_room);
		look_at_room(vict, TRUE);

                GET_WAIT_STATE(ch) = 0;
                stop_fighting(vict);
		if (FIGHTING(ch) == vict)
		  stop_fighting(ch);
	      }
	      break;
            }
          }
d2003 2
a2004 1
          if (!performed) { // not moved from room
a2015 1

d2017 2
a2018 3
      }
      clan_rel_inc(ch, vict, -3);
      break;
@


1.60
log
@Artus> Added "Lycanthropy" Define.
@
text
@d465 1
a465 1
  if ((ability < 1) || (ability >= 95))
d479 6
a484 2
        sprintf(buf, "&0Your ability in using %s increases.&n\r\n", 
                      spell_info[spellnum].name);
d2631 1
a2631 1
  spello(SPELL_CHANGED, "Lycanthropy", 0, 0, 0, POS_SITTING, 
@


1.59
log
@Artus> LR_FAIL_MAX fix, SPECIAL_TRACKER now provides SKILL_TRACK.
       Track and hunt now increase.
@
text
@d2627 3
@


1.58
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d451 4
a456 4
  
  int ability = GET_SKILL(ch, spellnum);
  int chance = MAX(1, (int)((2 * ability)/3));
  int roll = number(1, chance);
d458 8
a465 1
  if (ability < 1)
d468 3
d472 2
a473 1
  if ((roll == 1) && (ability < 95)) {
d771 1
a771 1
  /* Can't cast whilest dual wielding.. -- Artus */
d773 5
a777 4
  {
    send_to_char("You can't possibly perform magical incantations whilst dual wielding!\r\n", ch);
    return;
  }
@


1.57
log
@Artus>
act.informative.c: Fixed bug where examining a container was always listng the
                   objects in the first container matched.
                   Gold rush finishing is now only displayed within the same
		   world.
act.movement.c   : Environmental damage is now passed through damage().
act.offensive.c  : Throw() now calls damage().
act.other.c      : When you fail to create a torch, it hurts.
dg_mobcmd.c      : mdamage() now calls damage().
dg_objcmd.c      : odamage() now calls damage().
dg_wldcmd.c      : wdamage() now calls damage().
fight.c          : Changed damage() to allow a NULL ch.
interpreter.c    : Falling because fly has worn off now calls damage().
limits.c         : No waterbreathe underwater now calls damage().
magic.c          : Added handle_fireball() for fire breathing, fireball, type
                   stuff..
                   Random chance of objs in inventory/open containers burning
                   up :o)
spec_assign.c    : Removed some unused/wasted assigns: corridor_guard,
                   receiptionist, virus, bacteria.
spec_procs.c     : Removed some unused/wasted procs. Changed lots of tali's
                   indenting.
                   Fixed gaping hole in deadlyblade proc.
                   Replaced GET_HIT(vict) -= with damage(ch, vict...
spell_parser.c   : Added awake and can_see checks to magic fail = mob attacks.
@
text
@d175 1
a175 1
	((concealed==1) && (GET_LEVEL(i) < LVL_ANGEL)))
d184 1
a184 1
      ((concealed == 0) || (GET_LEVEL(tch) >= LVL_ANGEL)))
d335 1
a335 1
  if (IS_NPC(caster) || (GET_LEVEL(caster) < LVL_IMPL))
d439 1
a439 1
  if (ovict == NULL)
d761 1
a761 1
  if (IS_DUAL_WIELDING(ch) && (GET_LEVEL(ch) < LVL_IMPL))
d872 1
a872 1
	  (GET_LEVEL(tch) < LVL_NEWBIE) && (GET_LEVEL(ch) < LVL_IMPL))
d899 1
a899 1
  if ((mana > 0) && (GET_MANA(ch) < mana) && (GET_LEVEL(ch) < LVL_IMMORT)) {
d906 1
a906 1
  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_NOMAGIC) && (GET_LEVEL(ch) < LVL_IMPL)) {
d995 1
a995 1
  if (!IS_NPC(ch) && (GET_LEVEL(ch) >= LVL_IMPL))
d1183 1
a1183 1

d1236 1
a1236 1
      if (skillnum == SCMD_KILL && !IS_NPC(ch) && GET_LEVEL(ch) >= LVL_IMPL) {
a1292 7
      dam = (int)(200 + (GET_LEVEL(ch) / MAX(1, 21 - GET_STR(ch))));
      skip = 0;
      if (vict == NULL) {
	sprintf(buf, "You throw your axe up into the %s and catch it again.\r\n", (UNDERWATER(ch)) ? "water" : "air");
	send_to_char(buf, ch);
	return;
      }
d1294 1
a1294 1
      if (!ch->carrying)
d1296 1
a1296 1
	send_to_char("You don't have any axes to throw.\r\n", ch);
a1298 10
      boots = NULL;
      for (boots = ch->carrying; boots; boots = boots->next_content)
	if (is_axe(boots))
	  break;
      if (boots == NULL)
      {
	send_to_char("You don't have any axes to throw.\r\n", ch);
	return;
      }
      
d1301 3
d1305 1
d1480 3
a1482 1
        if (damage(ch, vict, GET_LEVEL(ch), SKILL_BASH, FALSE) > 0) {
d1484 2
a1485 1
          if (IN_ROOM(ch) == IN_ROOM(vict)) {
d1550 1
a1550 2
	dam = GET_LEVEL(ch);

d1553 3
a1555 2
	if (basic_skill_test(ch, SKILL_POWERKICK, FALSE)) {
	  if ((boots = GET_EQ(ch, WEAR_FEET))) {
a1556 1
	  }
d1641 1
a1641 1
        if (!IS_NPC(vict) && GET_LEVEL(vict) >= LVL_IS_GOD)
d1643 1
a1643 1
        if ((GET_LEVEL(ch) < LVL_GOD) && (GET_MOB_SPEC(vict) == postmaster))
d1645 1
a1645 1
        if ((GET_LEVEL(ch) < LVL_GOD) && (GET_MOB_SPEC(vict) == receptionist))
d1655 1
a1655 1
          dam = dice(4, GET_AFF_DEX(ch)) + 6; /* max dam of around 90 */
d1709 1
a1709 13
      dam = (int)((GET_LEVEL(ch) + str_app[GET_STR(ch)].todam) * 2 * 
	          SPELL_EFFEC(ch, skillnum) / 100 +
                  (GET_EQ_WEIGHT(ch, WEAR_HEAD) * 2));
                 
      dam = MAX(0, (int)(dam-dam/20+number(0, (int)(dam/10))));
      if (!GET_EQ(ch, WEAR_HEAD))
      {
	if (GET_EQ(vict, WEAR_HEAD))
	  dam /= 2;
      } else {
	if (!GET_EQ(vict, WEAR_HEAD))
	  dam *= 2;
      }
d1749 1
a1749 19
      dam = GET_HEIGHT(ch) + GET_WEIGHT(ch) + str_app[GET_STR(ch)].todam;
      if (GET_DEBUG(ch))
      {
	sprintf(buf, "DEBUG: Dam: %d\r\n", dam);
	send_to_char(buf, ch);
      }
      dam = (int)(dam * (GET_LEVEL(ch)/66));
      if (GET_DEBUG(ch))
      {
	sprintf(buf, "DEBUG: Dam: %d, Effec: %d\r\n", dam, SPELL_EFFEC(ch,SKILL_PILEDRIVE));
	send_to_char(buf, ch);
      }
      dam = (int)(dam * (SPELL_EFFEC(ch,SKILL_PILEDRIVE)/100));
      dam = MIN(800, MAX(0, (int)(dam-dam/10+number(0, (int)(dam/5)))));
      if (GET_DEBUG(ch))
      {
	sprintf(buf, "DEBUG: Dam: %d.\r\n", dam);
	send_to_char(buf, ch);
      }
d1791 2
a1792 1
      if (damage(ch, vict, (int)(GET_LEVEL(ch) * 2 * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), SKILL_TRIP, FALSE) > 0) 
a1829 3
      /* Artus> Lets do this a little differently.. 
       * if (damage(ch, vict, (int)(GET_LEVEL(ch) * (SPELL_EFFEC(ch, SKILL_BEARHUG) / 100) + str_app[GET_STR(ch)].todam), SKILL_BEARHUG, FALSE) > 0)
       *   GET_WAIT_STATE(vict) = PULSE_VIOLENCE * 2; */
d1831 1
a1831 1
      dam = (int)(GET_WEIGHT(ch)/5 * GET_STR(ch) * SPELL_EFFEC(ch, SKILL_BEARHUG)/100 * GET_LEVEL(ch) / 100);
d1964 2
a1965 1
              if (damage(ch, vict, (int)(GET_LEVEL(ch) * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), SKILL_BODYSLAM, FALSE) > 0)
a1978 1
		damage(ch, vict, 0, SKILL_BODYSLAM, FALSE);
d1988 3
a1990 1
            if (damage(ch, vict, (int)(GET_LEVEL(ch) * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), SKILL_BODYSLAM, FALSE) > 0) {
a1996 1
	      damage(ch, vict, 0, SKILL_BODYSLAM, FALSE);
d2038 2
a2039 1
        if (damage(ch, vict, (int)((GET_LEVEL(ch) / 2) * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), SKILL_FLYINGTACKLE, FALSE)) {
@


1.56
log
@act.item.c    : Fixed bug that was causing slip to constantly fail.
act.other.c   : Steal and Sneak now call apply_spell_skill_abil()
interpreter.c : Can no longer pick remort classes when creating characters.
@
text
@d921 2
a922 1
    if (SINFO.violent && tch && IS_NPC(tch))
@


1.55
log
@Artus> Intermittent build.
act.informative.c: Affect/Timers now display something when no affects/timers
                   are present.
                   Sense curse now senses objects inside containers.
act.movement.c   : Optimised the aggravate stuff a little.
act.offensive.c  : Logging death by pit trap.
act.other.c      : Logging death by suicide.
                   Superman now sets affects rather than actual stats, for STR
                   and CON (CON bonus is +1, STR is 21 - GET_REAL_STR
                   Logging death by arrow.
clan.c           : Removed aggravate_check() function, no longer used.
db.c             : Now initialising character specials.
dg_mobcmd.c      : Logging death by mdamage.
dg_objcmd.c      : Logging death by odamage.
dg_wldcmd.c      : Logging death by wdamage.
fight.c          : New optional msg paramater to die(), for if the death was
                   not caused by a character.
                   Deaths are now logged to info channel.
handler.c        : Modified ability affect function to permit more than one
                   affect modifier per special. (Required for superman)
spec_procs.c     : Logging death by pit trap, archers and room blast.
spells.h         : Added SPELL_SUPERMAN for special affect modifiers.
utils.h          : Updated die() prototype to match changes in fight.c.
@
text
@d282 1
a282 1
	if (perform) {
a283 1
	}
@


1.54
log
@Artus> Fixed say_spell() to work properly with and without concealing.
@
text
@d1721 2
a1722 2
	          (SPELL_EFFEC(ch, skillnum) / 100)) +
                 (GET_EQ_WEIGHT(ch, WEAR_HEAD) * 2);
d1874 2
a1875 3
      dam = (int)(GET_WEIGHT(ch) * (SPELL_EFFEC(ch, SKILL_BEARHUG)/100) *
	     (GET_LEVEL(ch) / 66));
      dam = MAX(0, (int)(dam-dam/20+number(0, (int)(dam/10))));
d1971 2
a1972 1
      if (IS_NPC(vict) && GET_MOB_VZNUM(vict) == CLAN_ZONE) {
d1974 2
a1975 2
	    "You resist yourself from performing a bodyslam on %s.\r\n", 
	    GET_NAME(vict));
d1995 1
d2670 4
@


1.53
log
@Artus> Mostly just cosmetic changes, mostly for underwater stuff..
       Added some more stuff to dg_scripts:

       %actor.affected(aff_bit)% - Is actor affected by whatever.
       %self.people(countpc)%    - (Rooms): Count players.
       %self.people(countnpc)%   - (Rooms): Count npcs.
       %self.people(countall)%   - (Rooms): Count chars.
       %firstchar.<room_vnum>%   - First character in room <vnum>

       Possibly a bugfix to one of the forest specials that was attacking you
       if you were affected by poison.
@
text
@a124 1

d131 6
a136 3
  while (lbuf[ofs]) {
    for (j = 0; *(syls[j].org); j++) {
      if (!strncmp(syls[j].org, lbuf + ofs, strlen(syls[j].org))) {
d142 2
a143 2
    /* i.e., we didn't find a match in syls[] */
    if (!*syls[j].org) {
d149 3
a151 1
  if (tch != NULL && IN_ROOM(tch) == IN_ROOM(ch)) {
a160 1

d164 31
a194 1
  // HIde the casting
d197 8
a204 9
	if (number(1, 100) > GET_SKILL(ch, SKILL_CONCEAL_SPELL_CASTING))
	  for (i = world[IN_ROOM(ch)].people; i; i = i->next_in_room) {
    		if (i == ch || i == tch || !i->desc || !AWAKE(i))
      			continue;
    		if (GET_CLASS(ch) == GET_CLASS(i))
      		        perform_act(buf1, ch, tobj, tch, i);
    		else
      			perform_act(buf2, ch, tobj, tch, i);
  	  }
d206 6
a211 4
        {
	  send_to_char("You manage to conceal your casting.\r\n", ch);
  	  concealed = 1;
	}
d213 4
a216 5

  if (tch != NULL && tch != ch && IN_ROOM(tch) == IN_ROOM(ch)) {
    if( GET_CLASS(ch) == CLASS_PRIEST && tch != ch && !IS_NPC(tch) )
      sprintf(buf1, "$n takes your money, stares at you, and utters the words, '%s'.",
            GET_CLASS(ch) == GET_CLASS(tch) ? skill_name(spellnum) : buf);
d220 2
a221 3
 
   if (!concealed)
     act(buf1, FALSE, ch, NULL, tch, TO_VICT); 
d223 1
@


1.52
log
@Artus>
\r\n appended to gold rush message: act.informative.c

Imms no longer affected by underwater: act.movement.c, limits.c

Changed remort some more.. New special, tracker (SPECIAL_TRACKER):
act.other.c, act.wizard.c, constants.c, graph.c, structs.h, utils.c

Object and Room triggers can now %send% <room vnum> <message>:
dg_objcmd.c, dg_wldcmd.c

%self.direction% now has a vnum subfield to return the exit room's vnum.
(Eg: %self.north(vnum)%): dg_scripts.c

%actor.hisher%, %actor.himher%, %actor.heshe% implemented: dg_scripts.c

vnum, name, can_see, can_see_me added to %actor.next_in_room%, returning char
vnum, char name, if actor can see char, and if char can see actor respectively:
dg_scripts.c

Changed "do not know that spell" to "do not know of that spell": spell_parser.c

Changed "do not of know that skill/spell" to "do not know of..": utils.c

SECT_UNDERWATER and SECT_INSIDE now checked in OUTSIDE() macro: utils.h
@
text
@d1263 2
a1264 1
	send_to_char("You throw your axe up into the air and catch it again.\r\n", ch);
@


1.51
log
@Artus> Fixed error when store_mail called with non-existant playerid;
       Can no longer cast spells whilst dual wielding.
@
text
@d709 1
a709 1
    send_to_char("You do not know that spell!\r\n", ch);
@


1.50
log
@Artus>
act.informative.c: Added Sense Wounds.
constants.c      : Added Sense Wounds.
db.c             : Fixed spell effectiveness.
dg_mobcmd.c      : mpurge will no longer purge player corpses.
dg_objcmd.c      : opurge will no longer purge player corpses.
dg_wldcmd.c      : wpurge will no longer purge player corpses.
fight.c          : Added Sense Wounds.
magic.c          : Added Sense Wounds.
spell_parser.c   : Added Sense Wounds.. Trialling changes do damage
                   done by headbutt, flytackle, piledrive.
spells.h         : Added Sense Wounds.
structs.h        : Added Sense Wounds.
@
text
@d728 7
d874 1
a874 1
  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_NOMAGIC)) {
@


1.49
log
@Artus> Changed the way remort processes ability args.. Should be more sane
       now..

       TODO notes in spell_parser.c..
@
text
@d787 1
a787 1
    if (!target && IS_SET(SINFO.targets, TAR_OBJ_EQUIP)) {
d789 2
a790 1
	if (GET_EQ(ch, i) && isname(t, GET_EQ(ch, i)->name)) {
d794 1
a794 1
    }
a1645 2
      // Artus> TODO - Base on Weight and Helmet Weight.

d1676 19
a1694 2
        if (damage(ch, vict, (int)(GET_LEVEL(ch) * 2 * (SPELL_EFFEC(ch, skillnum) / 100) + GET_EQ_WEIGHT(ch, WEAR_HEAD) + str_app[GET_STR(ch)].todam), SKILL_HEADBUTT, FALSE) > 0) 
	  GET_WAIT_STATE(vict) = PULSE_VIOLENCE;
d1701 3
a1703 4
      // Artus> TODO: Base on Height and Weight.
      
      if (!(vict)) {
        if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
a1708 1
      }
d1711 1
a1711 1
      if (!violence_check(ch, vict, skillnum)) {
a1712 1
      }
d1728 23
a1750 1
      if (damage(ch, vict, (int)(GET_LEVEL(ch) * 3 * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), SKILL_PILEDRIVE, FALSE)) 
d1802 3
a1804 4
      // Artus> TODO: Base on weight.
      
      if (!(vict)) {
        if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
a1809 1
      }
d1829 10
a1838 2
      if (damage(ch, vict, (int)(GET_LEVEL(ch) * (SPELL_EFFEC(ch, SKILL_BEARHUG) / 100) + str_app[GET_STR(ch)].todam), SKILL_BEARHUG, FALSE) > 0)
	  GET_WAIT_STATE(vict) = PULSE_VIOLENCE * 2;
d2404 3
@


1.48
log
@Artus> Added imm check to allow impl to cast in !magic :o)
@
text
@d1644 3
d1685 2
d1767 2
d1976 2
@


1.47
log
@Artus> Added !KILL flag for mobs... Things like gamina, postmaster, etc, can
       have this set, which should make it pretty damn impossible for them to
       die..
       Modified more stuff for dark ritual and vampires.. Have added a switch
       statement to affect_remove, which should be a good central place to
       handle triggers on affect removal.. Mainly to reset mana/move/hit to
       make sure they're not higher than max values when removing werewolf/
       vampire.
@
text
@d303 19
a321 13
  if (caster->nr != real_mobile(DG_CASTER_PROXY)) {
    if (ROOM_FLAGGED(IN_ROOM(caster), ROOM_NOMAGIC)) {
      send_to_char("Your magic fizzles out and dies.\r\n", caster);
      act("$n's magic fizzles out and dies.", FALSE, caster, 0, 0, TO_ROOM);
      return (0);
    }
    if (ROOM_FLAGGED(IN_ROOM(caster), ROOM_PEACEFUL) &&
         (SINFO.violent || IS_SET(SINFO.routines, MAG_DAMAGE))) {
      send_to_char("A flash of white light fills the room, dispelling your "
                   "violent magic!\r\n", caster);
      act("White light from no particular source suddenly fills the room, "
          "then vanishes.", FALSE, caster, 0, 0, TO_ROOM);
      return (0);
@


1.46
log
@Artus> Fixed primal scream.
       Added sanity checking to clan_rel_inc().
       do_cast() no longer resets mana to maxmana(), fixes dark ritual and
	 vampire.
       Reports should no longer mail the same person twice.
@
text
@d967 11
d994 27
a1020 3
  /* Moved from damage(): shopkeeper protection */
  if (!ok_damage_shopkeeper(ch, vict))
    return (0);
d1022 7
a1028 6
  // Moved from damage(): Quest Mobs.
  if (!imm && IS_NPC(vict) && MOB_FLAGGED(vict,MOB_QUEST))
  {
    send_to_char("Sorry, they are part of a quest.\r\n",ch);
    return FALSE;
  } 
d1031 2
a1032 1
  if (AFF_FLAGGED(ch, AFF_CHARM) && (ch->master == vict)) {
a1037 14
  // postmaster protection
  if (!imm && (GET_MOB_SPEC(vict) == postmaster)) 
  {
    send_to_char("You cannot attack the postmaster!!\r\n", ch);
    return FALSE;
  } 

  // receptionist protection
  if (!imm && (GET_MOB_SPEC(vict) == receptionist))
  {
    send_to_char("You cannot attack the Receptionist!\r\n", ch); 
    return FALSE;
  } 
    
@


1.45
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@d873 2
a874 1
      GET_MANA(ch) = MAX(0, MIN(GET_MAX_MANA(ch), GET_MANA(ch) - (mana / 2)));
d898 2
a899 1
	GET_MANA(ch) = MAX(0, MIN(GET_MAX_MANA(ch), GET_MANA(ch) - mana));
d1532 2
a1533 1
      if (FIGHTING(ch)) {
d1540 2
a1541 1
      if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
d1546 2
a1547 1
      if (percent > prob) {
d1561 2
a1562 1
      for (door = 0; door < NUM_OF_DIRS; door++) { 
a1564 1

d1572 2
a1573 1
      for (vict = world[ch->in_room].people; vict; vict = next_vict) {
d1592 2
a1593 1
        if (!(skip)) {
d1609 1
a1609 1
      clan_rel_inc(ch, vict, 1);
@


1.44
log
@Artus>>
Breakin: him/her -> he/she.
Remort: Now updates wimpy.
Show Snoop: Fixed colour bleed.
do_simple_move: Now displays failure messages.
House_boot: Now subtracts subtracts objects from obj_index.number when loading
            objs into houses.. Fixes issue where objs in houses were preventing
	    that obj from being created in the game where zone command Max: 1.
@
text
@d142 1
a142 1
      log("No entry in syllable table for substring of '%s'", lbuf);
d589 1
a589 1
    log("SYSERR: Unknown object_type %d in mag_objectmagic.",
d609 1
a609 1
    log("SYSERR: cast_spell trying to call spellnum %d/%d.\n", spellnum,
d968 1
a968 1
    log("SYSERR: Attempt to damage corpse '%s' in room #%d by '%s'.",
d1121 1
a1121 1
    log("SYSERR: NPC (%s) using skill (%d)", GET_NAME(ch), skillnum);
d1965 1
a1965 1
      log("SYSERR: Invalid skill (%d) number passed to do_violent_skill", 
d1983 1
a1983 1
    log("SYSERR: attempting assign to illegal spellnum %d/%d", spell, TOP_SPELL_DEFINE);
d1988 1
a1988 1
    log("SYSERR: assigning '%s' to illegal class %d/%d.", skill_name(spell),
d1994 1
a1994 1
    log("SYSERR: assigning '%s' to illegal level %d/%d.", skill_name(spell),
@


1.43
log
@Artus> Sorry, Dish.. Another bastard change..

       has_stats_for_skill now takes an extra arg (bool) to determine whether
       or not to display messages.

       new routine: has_stats_for_prac.. Basically the same as
       has_stas_for_skill, without GET_SKILL(ch, i) == 0 check..

       Force is now restricted for <GRGOD.

       Score no longer displays punishment lines twice.

       New macro: IS_SKILL(skillnum) .. Used to determine whether skillnum is
                  a skill.
@
text
@d820 14
@


1.42
log
@Artus> Dual Wielding Wear/Remove/Display/Fighting Fixes.
       Cursed items can no longer be sold.
       Bodyslam message now appears in the right spot (hopefully).

       NOTE: IS_DUAL_WIELDING(ch) and IS_DUAL_CAPABLE(ch) defines in utils.h
             have been modified... If you plan to use them, check out how they
	     have changed first :o)
@
text
@d257 1
a257 1
  if (!has_stats_for_skill(ch, spellnum))
d260 2
a261 1
  if (perform) {
d700 3
a702 1
  if (GET_LEVEL(ch) < SINFO.min_level[(int) GET_CLASS(ch)]) {
d706 1
d710 1
a710 1
  }
d713 1
a713 1
  if (!has_stats_for_skill(ch, spellnum))
d1127 1
a1127 1
      skillnum != SCMD_KILL) && !has_stats_for_skill(ch, subcmd)) {
d2183 1
a2183 1
         POS_STANDING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
d2186 1
a2186 1
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
d2207 1
a2207 1
         POS_STANDING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
d2210 1
a2210 1
         POS_STANDING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
d2213 1
a2213 1
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
d2234 1
a2234 1
         POS_STANDING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
d2252 1
a2252 1
         POS_STANDING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
d2318 1
a2318 1
         POS_STANDING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
d2330 1
a2330 1
         POS_FIGHTING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
@


1.41
log
@Artus> (Hopefully) Fixed all cases where the skill message would display after
       the victim had fled.

       Moved remaining violence checks from damage() to violence_check().

       damage() now takes an additional boolean arg, vcheck, when true,
       violence_check() will be called.

       added GET_EQ_WEIGHT(ch, wear_pos) define.
@
text
@d1863 1
a1863 1
              if (damage(ch, vict, (int)(GET_LEVEL(ch) * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), SKILL_BODYSLAM, FALSE))
d1865 6
a1870 7
	        act("You are bodyslammed out of the room by $n!",
		    TRUE, ch, 0, vict, TO_VICT);
                act("$N is bodyslammed from the room by $n!", 
                    TRUE, ch, 0, vict, TO_ROOM);
                act("You bodyslam $N out of the room!", 
                    TRUE, ch, 0, vict, TO_CHAR);

d1876 2
d1879 2
a1880 3
                stop_fighting(ch);
                GET_WAIT_STATE(ch) = 0;
                break;
d1882 1
d1887 1
a1887 1
            if (damage(ch, vict, (int)(GET_LEVEL(ch) * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), SKILL_BODYSLAM, FALSE)) {
d1894 1
d2560 1
@


1.40
log
@Artus> Gravity, Some minor changes to clan messages, Violence check for
       violent spells.
@
text
@d41 1
a47 1
bool violence_check(struct char_data *ch, struct char_data *vict, int skillnum);
d49 1
d925 5
a930 7
  if (!IS_NPC(ch) && GET_DEBUG(ch))
  {
    if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) 
      send_to_char("DEBUG: Room is peaceful.", ch);
    else
      send_to_char("DEBUG: Room is not peaceful.", ch);
  }
d934 5
a938 1
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
d944 1
a944 1
  if (vict == NULL) {
d946 8
d955 1
a955 1
  
d957 2
a958 1
  if (vict == ch) {
d963 11
d982 2
a983 1
  if ((GET_LEVEL(ch) < LVL_GOD) && (GET_MOB_SPEC(vict) == postmaster)) {
d989 2
a990 1
  if ((GET_LEVEL(ch) < LVL_GOD) && (GET_MOB_SPEC(vict) == receptionist)) {
d997 2
a998 1
  if ((!IS_NPC(ch)) && (!IS_NPC(vict))) {
d1006 2
a1007 1
  if (IS_NPC(vict) && MOUNTING(vict)) {
d1014 2
a1015 1
    if (MOUNTING(vict) == ch) {
d1019 6
d1036 1
a1036 1
  // Artus - Pkill Flag/Clan Checking...
d1042 1
a1042 1
  }
d1046 2
a1047 1
                  !IS_NPC(vict) && !IS_NPC(ch)) {
d1054 2
a1055 1
  if (!pk_allowed) {
d1073 2
a1074 2
ACMD(do_violent_skill) {

d1253 1
a1253 1
      damage(ch, vict, dam, SKILL_AXETHROW);
d1337 1
a1337 1
        damage(ch, vict, 0, SKILL_BACKSTAB);
d1376 1
a1376 1
      if (!violence_check(ch, vict, skillnum)) {
a1377 1
      }
d1394 1
a1394 1
        damage(ch, vict, 0, SKILL_BASH);
d1402 1
a1402 1
        if (damage(ch, vict, GET_LEVEL(ch), SKILL_BASH) > 0) {
d1453 1
a1453 1
      if (!violence_check(ch, vict, skillnum)) {
a1454 1
      }
d1467 1
a1467 1
        damage(ch, vict, 0, SKILL_KICK);
d1482 7
a1488 4
	if (damage(ch, vict, dam, type) > 0) {
          if (GET_SKILL(ch, SKILL_DOUBLE_KICK) &&
              number(1, 101 - (GET_LEVEL(vict) - GET_LEVEL(ch))) < 
                   GET_SKILL(ch, SKILL_DOUBLE_KICK)) {
d1495 1
a1495 1
            damage(ch, vict, GET_LEVEL(ch), SKILL_KICK);
d1571 1
a1571 1
          damage(ch,vict,dam,SKILL_PRIMAL_SCREAM);
d1590 4
a1593 3

      if (!(vict)) {
        if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
d1602 1
a1602 1
      if (!violence_check(ch, vict, skillnum)) {
a1603 1
      }
d1615 3
a1617 8
      if (percent > prob) {
        act("$N moves avoiding your headbutt!",
            FALSE, ch, 0, vict, TO_CHAR);
        act("You move avoiding a headbutt by $n!",
            TRUE, ch, 0, vict, TO_VICT);
        act("$N moves avoiding $n's headbutt!", 
            TRUE, ch, 0, vict, TO_NOTVICT);
        damage(ch, vict, 0, SKILL_HEADBUTT);
d1619 2
a1620 10
      } else {

	int helmet_bonus = (GET_EQ(ch, WEAR_HEAD)) ? GET_OBJ_WEIGHT(GET_EQ(ch, WEAR_HEAD)) : 0;
        if (damage(ch, vict, (int)(GET_LEVEL(ch) * 2 * (SPELL_EFFEC(ch, skillnum) / 100) + helmet_bonus + str_app[GET_STR(ch)].todam), SKILL_HEADBUTT)) {
          act("You headbutt $N. Muhaha!",
              FALSE, ch, 0, vict, TO_CHAR);
          act("$n drives $s head into yours! OUCH!",
              TRUE, ch, 0, vict, TO_VICT);
          act("$n headbutts $N!",
              TRUE, ch, 0, vict, TO_NOTVICT);
a1621 2
	}
      }
d1653 1
a1653 7
        act("$N dodges your piledrive attempt!",
            FALSE, ch, 0, vict, TO_CHAR);
        act("You dodge $n's piledrive attempt!",
            TRUE, ch, 0, vict, TO_VICT);
        act("$N dodges $n's piledrive attempt!",
            TRUE, ch, 0, vict, TO_NOTVICT);
        damage(ch, vict, 0, SKILL_PILEDRIVE);
a1654 10
      } else {
        if (damage(ch, vict, (int)(GET_LEVEL(ch) * 3 * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), skillnum)) {
          act("You grab $N turning $M upside down and pildrive $M!", 
              FALSE, ch, 0, vict, TO_CHAR);
          act("You are piledrived into the ground by $n! OUCH!", 
              TRUE, ch, 0, vict, TO_VICT);
          act("$n piledrives $N into the ground!", 
              TRUE, ch, 0, vict, TO_NOTVICT);
          GET_WAIT_STATE(vict) = PULSE_VIOLENCE * 3;
	}
d1656 2
d1668 1
a1668 1
          send_to_char("Piledrive who?\r\n", ch);
d1679 1
a1679 1
      if (!violence_check(ch, vict, skillnum)) {
a1680 1
      }
d1692 3
a1694 8
      if (percent > prob) {
        act("$N jumps over your trip attempt!",
            FALSE, ch, 0, vict, TO_CHAR);
        act("You jump over $n's trip attempt!",
            TRUE, ch, 0, vict, TO_VICT);
        act("$N jumps over $n's trip attempt!",
            TRUE, ch, 0, vict, TO_NOTVICT);
        damage(ch, vict, 0, SKILL_TRIP);
d1696 4
a1699 9
      } else {
        if (damage(ch, vict, (int)(GET_LEVEL(ch) * 2 * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), skillnum)) {
          act("You trip $N bringing $M to the ground!",
              FALSE, ch, 0, vict, TO_CHAR);
          act("You crash to the ground as $n trips you!",
              TRUE, ch, 0, vict, TO_VICT);
          act("$N falls to the ground as $n trips $M!",
              TRUE, ch, 0, vict, TO_NOTVICT);
          GET_POS(vict) = POS_SITTING;
a1700 1
	}
d1718 1
a1718 1
      if (!violence_check(ch, vict, skillnum)) {
a1719 1
      }
d1730 3
a1732 8
      if (percent > prob) {
        act("$N slips from your grasp!",
            FALSE, ch, 0, vict, TO_CHAR);
        act("You slip from $n's bearhug!",
            TRUE, ch, 0, vict, TO_VICT);
        act("$N slips from $n's bearhug!",
            TRUE, ch, 0, vict, TO_NOTVICT);
        damage(ch, vict, 0, SKILL_BEARHUG);
d1734 2
a1735 8
      } else {
        if (damage(ch, vict, (int)(GET_LEVEL(ch) * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), SKILL_BEARHUG)) {
          act("You squeeze the living shit out of $N!",
              FALSE, ch, 0, vict, TO_CHAR);
          act("$n squeezes the living shit out of you!",
              TRUE, ch, 0, vict, TO_VICT);
          act("$n squeezes the living shit out of $N!",
              TRUE, ch, 0, vict, TO_NOTVICT);
a1736 2
	}
      }
d1824 4
d1850 1
a1850 1
        damage(ch, vict, 0, SKILL_BODYSLAM);
d1854 4
a1857 2
        if (vict && IN_ROOM(ch) == IN_ROOM(vict)) {
          for (i = 0; i < NUM_OF_DIRS; i++) {
d1860 2
a1861 2
                !ROOM_FLAGGED(EXIT(vict, attempt)->to_room, ROOM_DEATH)) {

d1863 2
a1864 1
              if (damage(ch, vict, (int)(GET_LEVEL(ch) * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), SKILL_BODYSLAM)) {
d1875 1
a1875 1
		look_at_room(vict, TRUE); // TODO ignore brief?
d1886 1
a1886 1
            if (damage(ch, vict, (int)(GET_LEVEL(ch) * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), SKILL_BODYSLAM)) {
d1914 1
a1914 1
      if (!violence_check(ch, vict, skillnum)) {
a1915 1
      }
d1929 1
a1929 7
        damage(ch, vict, 0, SKILL_FLYINGTACKLE);
	act("You jump through the air missing $N in a fly tackle attempt.",
	    TRUE, ch, 0, vict, TO_CHAR);
	act("$n jumps through the air missing you in a fly tackle attempt.",
	    TRUE, ch, 0, vict, TO_VICT);
	act("$n jumps through the air missing $N in a fly tackle attempt.",
	    TRUE, ch, 0, vict, TO_ROOM);
d1932 1
a1932 1
        if (damage(ch, vict, (int)((GET_LEVEL(ch) / 2) * (SPELL_EFFEC(ch, skillnum) / 100) + str_app[GET_STR(ch)].todam), SKILL_FLYINGTACKLE)) {
d1938 1
a1938 10
	  /* Artus> 20031013 - Is this supposed to be here? DM?
	   * I'm going to assume not since it makes the adrenaline check
	   * redundant.
             GET_WAIT_STATE(vict) = PULSE_VIOLENCE * 3; */
	  act("You jump through the air and grab $N in a fly tackle!",
	      TRUE, ch, 0, vict, TO_CHAR);
  	  act("$n jumps through the air grabbing you in a fly tackle!",
  	      TRUE, ch, 0, vict, TO_VICT);
	  act("$n jumps through the air grabbing $N in a fly tackle!",
	      TRUE, ch, 0, vict, TO_ROOM);
@


1.39
log
@Artus> Added mortal kombat check in voilence_check().
@
text
@d648 4
d697 1
d816 4
d856 2
a857 1
      if (violence_check(ch, tch, spellnum))
d925 15
a969 6
  // peaceful rooms
  if (ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char(PEACEROOM, ch);
    return FALSE;
  }
 
d2138 1
a2138 1
         POS_STANDING, TAR_CHAR_ROOM | TAR_NOT_SELF, FALSE, MAG_AFFECTS);
@


1.38
log
@Artus> A3_0_315
@
text
@d952 1
a952 1
  // pk code do that for us
d954 3
a956 1
    if ((GET_CLAN(ch) || EXT_FLAGGED(ch, EXT_PKILL)) && (GET_CLAN(vict) || EXT_FLAGGED(vict, EXT_PKILL)))
@


1.37
log
@Artus>
Adrenaline : (Potion Quaffing): 6 per fight Round instead of 5.
             (Flying Tackle)  : 2 fight rounds vs 3.
Balance    : QEQ no longer gets written to the log file when unbalanced.
Colour     : &f is no longer flash, &@@ is. Keep it quiet(tm).
Corpse File: Flush()ing after write().
Double Kick: Now calls apply_spell_skill_abil()
Echo       : No longer sends text to mobs calling it.
Fighting   : Is only possible if STATE = CON_PLAYING
Glance     : Fixed erroneous dex check.
OLC        : No longer possible while fighting.
           : LVL_IMPL+ (150+) can now edit mob levels up to 120.
Pit Trap   : Now logs deaths.
             No longer says "theoretically" on creation.
Report File: Flush()ing after write().
Spell/Skill: Now allows up to NUM_CLASSES class lines in primal_spskls
             (Used to only allow up to 10)
@
text
@d960 6
a965 3
    sprintf(buf, "DEBUG: Ch: %s Vict: %s Mounting(ch): %s\r\n",
        GET_NAME(ch), GET_NAME(vict), GET_NAME(MOUNTING(vict)));
    send_to_char(buf, ch);
d982 6
a987 3
  if (((GET_CLAN(ch) > 0) || (EXT_FLAGGED(ch, EXT_PKILL))) &&
            ((GET_CLAN(vict) > 0) || (EXT_FLAGGED(vict, EXT_PKILL))))
        return TRUE;
d2561 1
a2561 1
  skillo(SKILL_BERSERK, "beserk");
d2608 2
@


1.36
log
@Work done at artus house a while ago
@
text
@d573 5
a577 6
    // TODO: Add other bonuses here
    if (IS_AFFECTED(ch, AFF_ADRENALINE)) {
    }
    // Currently 5 potions per round, add bonus like adrenaline etc in due
    // cause.
    WAIT_STATE(ch, (PULSE_VIOLENCE / 5));
d1432 1
d1929 4
a1932 1
          GET_WAIT_STATE(vict) = PULSE_VIOLENCE * 3;
@


1.35
log
@Latest Version
@
text
@d2150 1
a2150 1
         POS_STANDING, TAR_CHAR_ROOM | TAR_OBJ_INV, TRUE, MAG_AFFECTS);
@


1.34
log
@
: ----------------------------------------------------------------------
: Enter Log.  Lines beginning with `CVS:' are removed automatically
:
: Committing in .
:
: Modified Files:
: 	act.informative.c act.other.c act.wizard.c balance.c class.c
: 	constants.c db.c fight.c handler.c interpreter.c magic.c
: 	oedit.c redit.c spec_procs.c spell_parser.c spells.h
: 	update_revisions
: ----------------------------------------------------------------------

Modified: DM

Changed:
- heaps: mostly minor bug fixes.
@
text
@d260 1
d399 2
a400 1
  apply_spell_skill_abil(caster, spellnum);
d840 1
@


1.33
log
@
Modified: DM

Changed:
- Don't ask (large group checkin) - lots of bug fixes mainly.
- Use cvs diff if you really wanna see the changes.
@
text
@d2210 1
a2210 1
         POS_STANDING, TAR_IGNORE, FALSE, MAG_GROUPS);
d2225 1
a2225 1
         POS_STANDING, TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
@


1.32
log
@
Modified: DM

Added:
- NPC check at start of apply_spell_skill_abil
@
text
@d761 5
d2219 1
a2219 1
         POS_STANDING, TAR_CHAR_WORLD | TAR_NOT_SELF, FALSE, MAG_MANUAL);  
d2312 1
a2312 1
         POS_STANDING, TAR_CHAR_WORLD | TAR_NOT_SELF, FALSE, MAG_MANUAL);
@


1.31
log
@
Modified: DM

Changed:
- added a positive ability check in spell/skill ability gains
- changed wait state from quaffing potions from 1 to 1/5 violence rounds
@
text
@d408 4
@


1.30
log
@Artus> Added ghosts.. Newbies no longer die, they become ghosts.
@
text
@d412 3
d567 6
a572 1
    WAIT_STATE(ch, PULSE_VIOLENCE);
@


1.29
log
@Jus> Changed score display again. Commiting to move to another machine.
     These changes are not final, this is an intermediate build.
@
text
@d1025 7
@


1.28
log
@
Modified: DM

Changed:
- debug message using GETDEBUG
@
text
@d44 1
a44 1
int compute_armor_class(struct char_data *ch);
d1370 1
a1370 1
      percent = ((10 - compute_armor_class(vict)) * 2) + number(1, 101);
d1515 1
a1515 1
      percent = ((10 - compute_armor_class(vict)) * 2) + number(1, 101);
d1567 1
a1567 1
      percent = ((10 - compute_armor_class(vict)) * 2) + number(1, 101);
d1622 1
a1622 1
      percent = ((10 - compute_armor_class(vict)) * 2) + number(1, 101);
d1673 1
a1673 1
      percent = ((10 - compute_armor_class(vict)) * 2) + number(1, 101);
d1798 1
a1798 1
      percent = ((10 - compute_armor_class(vict)) * 2) + number(1, 101);
d1876 1
a1876 1
      percent = ((10 - compute_armor_class(vict)) * 2) + number(1, 101);
@


1.27
log
@Art> Modified compute_armor_class() and thaco().. Most notable, thaco() now
expects ch, victim (victim may be null), for mob thaco calculations. Probably
should have done it with FIGHTING(ch) but oh well. :o). Also added in some
debug stuff, including a debug flag. A byte sized bitvector that's not saved,
char_special_data.small_bits or SMALL_BITS(ch).. GET_DEBUG() for debug.
@
text
@d801 4
a804 2
    sprintf(buf, "DEBUG: target is (%s)\r\n", (tch) ? GET_NAME(tch) : "None");
    send_to_char(buf, ch);
@


1.26
log
@Modified: DM

Changed:
- fix a desbug message causing a crash
@
text
@d1368 1
a1368 1
      percent = ((10 - (compute_armor_class(vict) / 10)) * 2) + number(1, 101);
d1513 1
a1513 1
      percent = ((10 - (compute_armor_class(vict) / 10)) * 2) + number(1, 101);
d1565 1
a1565 1
      percent = ((10 - (compute_armor_class(vict) / 10)) * 2) + number(1, 101);
d1620 1
a1620 1
      percent = ((10 - (compute_armor_class(vict) / 10)) * 2) + number(1, 101);
d1671 1
a1671 1
      percent = ((10 - (compute_armor_class(vict) / 10)) * 2) + number(1, 101);
d1796 1
a1796 1
      percent = ((10 - (compute_armor_class(vict) / 10)) * 2) + number(1, 101);
d1874 1
a1874 1
      percent = ((10 - (compute_armor_class(vict) / 10)) * 2) + number(1, 101);
@


1.25
log
@Modified: DM

Changed:
- added a perform check on displaying You don't know how message
@
text
@d801 1
a801 1
    sprintf(buf, "DEBUG: target is (%s)\r\n", GET_NAME(tch));
@


1.24
log
@Modified: DM

Changed:
- debug target output for looking at summon bug
@
text
@d248 4
a251 1
        send_to_char("You don't know how.\r\n", ch);
@


1.23
log
@Modified: Artus

Added:
- axe throw and perception
@
text
@d797 3
@


1.22
log
@*** empty log message ***
@
text
@d48 1
d243 7
a249 1
    send_to_char("You don't know how.\r\n", ch);
d265 1
d987 1
d1104 61
@


1.21
log
@Modified: DM

Changed:
- offensive skill damage formulas and finished battlecry
@
text
@d108 1
@


1.20
log
@Artus- Modified a number of spells/skills to call clan_rel_inc.
@
text
@d869 3
a871 1
 * TODO: add another argument - bool to display or not display verbal shit
d986 4
a989 3
  // DM: TODO: need to be updated when battlecry is completed
  bool kick = TRUE, bearhug = FALSE, headbutt = TRUE, piledrive = FALSE, 
       bash = TRUE;
a1444 1
      // DM - TODO refine damage 
d1456 2
a1457 5
	// TODO - increase damage if wearing a helmet - also base it on helmet 
	// weight
        if (damage(ch, vict, 
	    (int)(GET_LEVEL(ch) * 2 * (SPELL_EFFEC(ch, skillnum) / 100)), 
	    skillnum)) {
a1496 1
      // DM - TODO refine damage 
d1507 1
a1507 3
        if (damage(ch, vict, 
	    (int)(GET_LEVEL(ch) * 3 * (SPELL_EFFEC(ch, skillnum) / 100)), 
	    skillnum)) {
a1551 1
      // DM - TODO refine damage 
d1562 1
a1562 3
        if (damage(ch, vict, 
	    (int)(GET_LEVEL(ch) * 2 * (SPELL_EFFEC(ch, skillnum) / 100)), 
	    skillnum)) {
a1601 1
      // DM - TODO refine damage
d1612 1
a1612 3
        if (damage(ch, vict, 
	    (int)(GET_LEVEL(ch) * (SPELL_EFFEC(ch, skillnum) / 100)), 
	    SKILL_BEARHUG)) {
d1642 1
a1642 8
      prob = GET_SKILL(ch, SKILL_BATTLECRY);
      percent=number(1,101);

      // DM - TODO - decide on chances of getting skills
      // kick, bearhug, headbutt, piledrive, trip, bash
      // dex   str      str       str        dex   str
      // include ability as part of formula
      if (percent > prob) {
d1660 2
a1661 2
        if (kick && vict && IN_ROOM(ch) == IN_ROOM(vict) &&
            GET_SKILL(ch, SKILL_KICK) && has_stats_for_skill(ch, SKILL_KICK)) {
d1666 2
a1667 3
        if (bearhug && vict && IN_ROOM(ch) == IN_ROOM(vict) &&
            GET_SKILL(ch, SKILL_BEARHUG) && 
            has_stats_for_skill(ch, SKILL_BEARHUG)) {
d1672 2
a1673 3
        if (headbutt && vict && IN_ROOM(ch) == IN_ROOM(vict) &&
            GET_SKILL(ch, SKILL_HEADBUTT) &&
            has_stats_for_skill(ch, SKILL_HEADBUTT)) {
d1678 2
a1679 3
        if (piledrive && vict && IN_ROOM(ch) == IN_ROOM(vict) &&
            GET_SKILL(ch, SKILL_PILEDRIVE) &&
            has_stats_for_skill(ch, SKILL_PILEDRIVE)) {
d1684 2
a1685 3
        if (bash && vict && IN_ROOM(ch) == IN_ROOM(vict) &&
            GET_SKILL(ch, SKILL_BASH) && has_stats_for_skill(ch, SKILL_BASH) &&
            wielded != NULL) {
a1723 1
      // DM - TODO refine damage
d1741 2
a1742 5

              performed = TRUE; // well moved acutally
              if (damage(ch, vict, 
	          (int)(GET_LEVEL(ch) * (SPELL_EFFEC(ch, skillnum) / 100)), 
		        SKILL_BODYSLAM)) {
d1764 1
a1764 3
            if (damage(ch, vict, 
	        (int)(GET_LEVEL(ch) * (SPELL_EFFEC(ch, skillnum) / 100)), 
	        SKILL_BODYSLAM)) {
a1801 1
      // DM - TODO refine damage formula 
d1817 1
a1817 3
        if (damage(ch, vict, 
	    (int)((GET_LEVEL(ch) / 2) * (SPELL_EFFEC(ch, skillnum) / 100)), 
		  SKILL_FLYINGTACKLE)) {
@


1.19
log
@Artus - Modified that apply_spell_skill_abil routine so perceiving eye message
        is not displayed - Was causing where not to function correctly..
@
text
@d46 1
d1170 2
d1240 1
d1327 1
d1411 1
d1468 1
d1521 1
d1580 1
d1632 1
d1713 1
d1803 1
d1862 1
@


1.18
log
@Artus - Perceiving eye.
@
text
@d402 5
a406 1
    sprintf(buf, "&0Your ability in using %s increases.&n\r\n", 
d408 2
a409 1
    send_to_char(buf, ch);
@


1.17
log
@Modified: DM

Added:
- new skills
@
text
@d236 2
a237 2
  if (IS_NPC(ch)) 
    return 0; 
d256 2
d2504 1
@


1.16
log
@Added: basic_skill_test, meditate, torch, shieldmastery, powerkick, suicide..
@
text
@d2450 1
a2450 1
  skillo(SKILL_ARMOURCRAFT, "armourcraft");
d2456 1
a2456 1
  skillo(SKILL_BERSERK, "berserk");
d2496 6
@


1.15
log
@Artus - Modified basic_skill_test
@
text
@d25 1
a46 1
bool basic_skill_test(struct char_data * ch, int spellnum, bool mod_abil);
d107 4
a110 2
  // DM - mana percentage 
  mana = (int)((100 * mana) / SINFO.mana_perc[GET_CLASS(ch)]);
d234 1
a234 1
bool basic_skill_test(struct char_data * ch, int spellnum, bool mod_abil)
d247 15
a261 6
  if (number(0, 101) > GET_SKILL(ch, spellnum)) {
    if (spellnum < MAX_SPELLS) 
      send_to_char("You lost your concentration.\r\n", ch);
    else
      send_to_char("You fail.\r\n", ch);
    return 0;
d264 1
a264 1
  if (mod_abil)
d980 4
d1242 1
a1242 1
      if (number(0, 101) > GET_SKILL(ch, AFF_BERSERK)) { // 101 - Fail
a1261 1

d1288 26
a1313 11
      } else if (damage(ch, vict, GET_LEVEL(ch) / 2, SKILL_KICK) > 0) {
        if (GET_SKILL(ch, SKILL_DOUBLE_KICK) &&
            number(1, 101 - (GET_LEVEL(vict) - GET_LEVEL(ch))) < 
                 GET_SKILL(ch, SKILL_DOUBLE_KICK)) {
          act("...$n jumps delivering a quick and powerful second kick!", 
                          FALSE, ch, 0, 0, TO_ROOM);
          act("...$n jumps delivering another powerful kick to you!", 
                          FALSE, ch, 0, vict, TO_VICT);
          act("...you quickly jump and deliver another powerful kick to $N!", 
                          FALSE, ch, 0, vict, TO_CHAR);
          damage(ch, vict, GET_LEVEL(ch), SKILL_KICK);
d2491 5
a2496 1

@


1.14
log
@Artus - Added basic_skill_test
@
text
@d46 1
a46 1
bool basic_skill_test(struct char_data * ch, int spellnum);
d232 1
a232 1
bool basic_skill_test(struct char_data * ch, int spellnum)
d234 1
a234 1
  if (!IS_NPC(ch)) 
d253 3
a255 1
  apply_spell_skill_abil(ch, spellnum);
@


1.13
log
@Modified: DM

Added:
- skill assigns, and any related skill code for:
  tumble
  flytackle
  firstaid
  poison blade
  dark ritual
  mount
@
text
@d46 1
d231 10
d242 2
d245 12
a1216 1
      int bi;
a1220 1

d1225 1
a1225 2
      GET_WAIT_STATE(ch) = PULSE_VIOLENCE;
      if (((bi = number(0,20)) > (GET_LEVEL(ch) / 4)) && (bi != 0)) {
a1230 1

d1232 1
@


1.12
log
@Artus - Berserk
@
text
@a39 1
void apply_spell_skill_abil(struct char_data *ch, int spellnum); 
d102 1
a102 1
  return MAX(SINFO.mana_max[(int) GET_CLASS(ch)] - 
d106 2
a748 16
  // Priests charge for their services
  if ((GET_CLASS(ch) == CLASS_PRIEST) && (tch != ch) && !IS_NPC(tch))
  {
        spell_cost = (int) (mana * GET_MODIFIER(ch) * GET_LEVEL(ch));
        if( (GET_GOLD(tch) + GET_BANK_GOLD(tch)) < spell_cost)
        {
          send_to_char("They dont have enough money to pay for your services!\r\n", ch);
          return;
        }
        GET_GOLD(tch) -= spell_cost;
        if( GET_GOLD(tch) < 0 )
        {
           GET_BANK_GOLD(tch) -= GET_GOLD(tch);
           GET_GOLD(tch) = 0;
        }
  }  
d769 15
d1349 1
a1349 1
    // ********************** KICK ********************************************
d1376 1
a1376 3
      // DM - TODO determine percent, make it damage ch if they are not wearing
      // a helmet, determine damage inflicted (make ability part of formula), 
      // messages 
d1378 6
d1387 14
a1400 1
        damage(ch, vict, GET_LEVEL(ch) / 2, SKILL_HEADBUTT);
d1431 1
a1431 2
      // DM - TODO determine percent, determine damage inflicted (make ability
      // part of formula), messages 
d1433 6
d1442 11
a1452 1
        damage(ch, vict, GET_LEVEL(ch) / 2, SKILL_PILEDRIVE);
d1488 1
a1488 2
      // DM - TODO determine percent, determine damage inflicted (include
      // ability as part of formula), messages 
d1490 6
d1499 12
a1510 4
        // Fix so vict cant flee as they should be sitting ...
        GET_POS(vict) = POS_SITTING;
        GET_WAIT_STATE(vict) = PULSE_VIOLENCE * 2;
        damage(ch, vict, GET_LEVEL(ch) / 2, SKILL_TRIP);
d1533 1
a1533 1
      prob = GET_SKILL(ch, SKILL_HEADBUTT);
d1540 1
a1540 2
      // DM - TODO determine percent, determine damage inflicted (include
      // ability as part of formula), messages 
d1542 6
d1551 11
a1561 1
        damage(ch, vict, GET_LEVEL(ch) / 2, SKILL_BEARHUG);
d1591 6
d1659 9
d1674 1
a1674 2
      // DM - TODO determine percent, determine damage inflicted (include
      // ability as part of formula), messages 
d1676 6
a1682 1
        return;
a1683 1
        damage(ch, vict, GET_LEVEL(ch) / 2, SKILL_BODYSLAM);
d1685 1
a1685 1
        // DM: TODO: needs looking over .... too tired atm ;p
d1691 8
a1698 3
              if (do_simple_move(vict, attempt, TRUE)) {
                act("You are bodyslammed out of the room by $n!", 
                                TRUE, ch, 0, vict, TO_VICT);
d1700 1
a1700 1
                                TRUE, ch, 0, vict, TO_ROOM);
d1702 6
a1707 1
                                TRUE, ch, 0, vict, TO_CHAR);
d1712 2
a1713 3
                performed = TRUE;
                continue;
              }
d1717 11
a1727 7
          if (!performed) {
            act("$N bounces back into the room from $n's bodyslam!",
                TRUE, ch, 0, vict, TO_ROOM);
            act("$N bounces back into the room from your bodyslam!",
                TRUE, ch, 0, vict, TO_CHAR);
            act("You bounce back into the room from $n's bodyslam!",
                TRUE, ch, 0, vict, TO_VICT);
d1729 14
d1745 45
d1798 1
a1798 1
  // We made it - useage of skill was a success - now apply ability gains ....
d2432 6
@


1.11
log
@Artus - Added in clan/pkflag checking.. Clannies/Pk players can brawl amongst
        themselves wherever they feel like =)
@
text
@d634 6
d1190 31
d2253 1
@


1.10
log
@Artus - Some checks for mounts, zombie/clone backstabbing, pkill stuff too.
@
text
@d888 5
@


1.9
log
@Modifieid: DM

Removed:
- debug line ...
@
text
@d24 1
a853 7
  
  // mounts
  if (IS_NPC(vict) && MOUNTING(vict) && !(FIGHTING(ch) == vict)) {
    send_to_char("That's someone's mount! Use 'murder' to attack another "
                 "player.\r\n", ch);
    return FALSE;
  } 
d860 27
d890 2
a891 2
                  !IS_NPC(vict)) {
    send_to_char("Player Killing is not allowed in this Zone.", ch);
d933 1
a933 1
  if (!IS_NPC(ch) && MOUNTING(ch) && !FIGHTING(MOUNTING(ch))) {
d935 1
a935 1
  }
d1065 12
@


1.8
log
@
Added:
- greater remove curse
@
text
@a356 2
  log("spell/skill chance = 1/%d, ability = %d, roll = %d", chance, ability, roll);

@


1.7
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d1907 1
a1907 1
         POS_STANDING, TAR_CHAR_ROOM | TAR_OBJ_INV, FALSE, MAG_UNAFFECTS | MAG_ALTER_OBJS);
d1909 3
@


1.6
log
@
Removed:
- removed debug info on spell casting
@
text
@d23 1
d245 16
d274 1
@


1.5
log
@
Changed:
- moved offence skills to go through new function do_violent_skill
@
text
@a599 3
  sprintf(buf,"spellnum %d\r\n", spellnum);
  send_to_char(buf,ch);

@


1.4
log
@
Added:
- Ahh, too much stuff, sorry was ages since this stuff was last checked in
@
text
@d38 10
d257 1
d324 3
d331 20
d656 2
a657 2
  sprintf(buf,"targets : %d\r\n", SINFO.targets);
  send_to_char(buf,ch);
d745 7
d754 1
a754 1
    WAIT_STATE(ch, PULSE_VIOLENCE);
d760 2
a761 1
      hit(tch, ch, TYPE_UNDEFINED);
d771 796
a2132 4
  skillo(SKILL_ADRENALINE, "adrenaline");
  skillo(SKILL_AMBUSH, "ambush");
  skillo(SKILL_ATTEND_WOUNDS, "attend wounds");
  skillo(SKILL_BATTLECRY, "battlecry");
a2134 3
  skillo(SKILL_BEARHUG, "bearhug");
  skillo(SKILL_BODYSLAM, "bodyslam");
  skillo(SKILL_CLOT_WOUNDS, "clot wounds");
a2135 3
  skillo(SKILL_DETECT_DEATH, "detect death traps"); 
  skillo(SKILL_DISARM, "disarm"); 
  skillo(SKILL_HEADBUTT, "headbutt");
a2139 2
  skillo(SKILL_PILEDRIVE, "piledrive");
  skillo(SKILL_PURSE, "purse evaluation");
a2150 1
  skillo(SKILL_TRIP, "trip");
d2153 3
d2157 25
d2183 6
a2189 3
  skillo(SKILL_AXEMASTERY, "axemastery");
  skillo(SKILL_BLADEMASTERY, "blademastery");
  skillo(SKILL_BARGAIN,	"bargain");
@


1.3
log
@
Added:
- timers (like affects)
- new skills, fixes

TODO:
- test timers on objects - add to stat obj screen
@
text
@d142 1
a142 1
  if (GET_SKILL(ch, SKILL_CONCEAL_SPELL_CASTING) && (GET_LEVEL(tch) < LVL_ANGEL))
d566 3
d621 4
d957 1
a957 1
  spello(SPELL_ENCHANT_WEAPON, "enchanct weapon", 150, 100, 10,
@


1.2
log
@my new skills!


Added:
-
-

Removed:
-
-

Changed:
-
-

TODO:
-
-
@
text
@d1296 1
d1299 1
d1306 1
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d104 1
d141 17
a157 7
  for (i = world[IN_ROOM(ch)].people; i; i = i->next_in_room) {
    if (i == ch || i == tch || !i->desc || !AWAKE(i))
      continue;
    if (GET_CLASS(ch) == GET_CLASS(i))
      perform_act(buf1, ch, tobj, tch, i);
    else
      perform_act(buf2, ch, tobj, tch, i);
d168 2
a169 1
    act(buf1, FALSE, ch, NULL, tch, TO_VICT); 
d1319 5
a1323 2


@

