head	1.18;
access;
symbols
	A3_0_59:1.2
	LATEST:1.2
	A3_0_1:1.2;
locks; strict;
comment	@ * @;


1.18
date	2005.06.10.05.08.34;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.09.06.27.38;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.09.05.50.31;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	2004.08.27.01.46.28;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.14.05.51.23;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.10.12.02.25;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.17.02.25.06;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.24.00.14.49;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.16.03.19.09;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.12.11.00.13;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.10.10.48.30;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.14.06.10.18;	author primal;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.15.11.36.49;	author artus;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.03.05.19.45;	author artus;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.02.07.59.45;	author primal;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.02.04.34.45;	author primal;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.14.00.52.55;	author primal;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.57;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Artus> Fixed bug where clan enhance <guard|healer> was double-charging.
@
text
@/* ************************************************************************
*   File: boards.c                                      Part of CircleMUD *
*  Usage: handling of multiple bulletin boards                            *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */


/* FEATURES & INSTALLATION INSTRUCTIONS ***********************************

This board code has many improvements over the infamously buggy standard
Diku board code.  Features include:

- Arbitrary number of boards handled by one set of generalized routines.
  Adding a new board is as easy as adding another entry to an array.
- Safe removal of messages while other messages are being written.
- Does not allow messages to be removed by someone of a level less than
  the poster's level.


TO ADD A NEW BOARD, simply follow our easy 4-step program:

1 - Create a new board object in the object files

2 - Increase the NUM_OF_BOARDS constant in boards.h

3 - Add a new line to the board_info array below.  The fields, in order, are:

	Board's virtual number.
	Min level one must be to look at this board or read messages on it.
	Min level one must be to post a message to the board.
	Min level one must be to remove other people's messages from this
		board (but you can always remove your own message).
	Filename of this board, in quotes.
	Last field must always be 0.

4 - In spec_assign.c, find the section which assigns the special procedure
    gen_board to the other bulletin boards, and add your new one in a
    similar fashion.

*/


#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "boards.h"
#include "interpreter.h"
#include "handler.h"
#include "clan.h"

/* Board appearance order. */
#define	NEWEST_AT_TOP	FALSE

extern struct room_data *world;
extern struct descriptor_data *descriptor_list;

/*
format:	vnum, read lvl, write lvl, remove lvl, filename, 0 at end
Be sure to also change NUM_OF_BOARDS in board.h
*/

struct board_info_type board_info[NUM_OF_BOARDS] = {
  {1198, LVL_GOD  ,    LVL_GOD  , LVL_GRGOD, LIB_ETC_BOARD "builder", 0},
  {1294,         0,            5, LVL_GOD  , LIB_ETC_BOARD "mortal" , 0},
  {1293, LVL_CHAMP,    LVL_CHAMP, LVL_GRGOD, LIB_ETC_BOARD "immort" , 0},
  {1292,         0,            5, LVL_ANGEL, LIB_ETC_BOARD "quest"  , 0},
  {1291, LVL_IMPL ,    LVL_IMPL , LVL_IMPL , LIB_ETC_BOARD "god"    , 0},
  {1290,         0,            5, LVL_ANGEL, LIB_ETC_BOARD "master" , 0},
  {1289,         0,            5, LVL_ANGEL, LIB_ETC_BOARD "social" , 0},
  {25500,        0, LVL_CLAN_MIN, LVL_ANGEL, LIB_ETC_BOARD "clan0"  , 0},
  {25501,        0, LVL_CLAN_MIN, LVL_ANGEL, LIB_ETC_BOARD "clan1"  , 0},
  {25502,        0, LVL_CLAN_MIN, LVL_ANGEL, LIB_ETC_BOARD "clan2"  , 0},
  {25503,        0, LVL_CLAN_MIN, LVL_ANGEL, LIB_ETC_BOARD "clan3"  , 0},
  {25504,        0, LVL_CLAN_MIN, LVL_ANGEL, LIB_ETC_BOARD "clan4"  , 0},
  {25505,        0, LVL_CLAN_MIN, LVL_ANGEL, LIB_ETC_BOARD "clan5"  , 0},
  {25506,        0, LVL_CLAN_MIN, LVL_ANGEL, LIB_ETC_BOARD "clan6"  , 0},
  {25507,        0, LVL_CLAN_MIN, LVL_ANGEL, LIB_ETC_BOARD "clan7"  , 0},
};

/* local functions */
SPECIAL(gen_board);
int find_slot(void);
int find_board(struct char_data * ch);
void init_boards(void);

char *msg_storage[INDEX_SIZE];
int msg_storage_taken[INDEX_SIZE];
int num_of_msgs[NUM_OF_BOARDS];
int ACMD_READ, ACMD_LOOK, ACMD_EXAMINE, ACMD_WRITE, ACMD_REMOVE;
int Board_clan_check(struct char_data *ch, int board_type, int minrel);
struct board_msginfo msg_index[NUM_OF_BOARDS][MAX_BOARD_MESSAGES];

void assign_boards(void)
{
  ASSIGNOBJ(1198, gen_board);   /* builders board */
  ASSIGNOBJ(1294, gen_board);	/* mortal board */
  ASSIGNOBJ(1293, gen_board);	/* immortal board */
  ASSIGNOBJ(1292, gen_board);	/* quest board */
  ASSIGNOBJ(1291, gen_board);	/* gods board */
  ASSIGNOBJ(1290, gen_board);	/* master board */
  ASSIGNOBJ(1289, gen_board);	/* social board */

  ASSIGNOBJ(25500, gen_board);	/* clan board */
  ASSIGNOBJ(25501, gen_board);	/* clan board */
  ASSIGNOBJ(25502, gen_board);	/* clan board */
  ASSIGNOBJ(25503, gen_board);	/* clan board */
  ASSIGNOBJ(25504, gen_board);	/* clan board */
  ASSIGNOBJ(25505, gen_board);	/* clan board */
  ASSIGNOBJ(25506, gen_board);	/* clan board */
  ASSIGNOBJ(25507, gen_board);	/* clan board */
}

int find_slot(void)
{
  int i;

  for (i = 0; i < INDEX_SIZE; i++)
    if (!msg_storage_taken[i]) {
      msg_storage_taken[i] = 1;
      return (i);
    }
  return (-1);
}


/* search the room ch is standing in to find which board he's looking at */
int find_board(struct char_data * ch)
{
  struct obj_data *obj;
  int i;

  for (obj = world[ch->in_room].contents; obj; obj = obj->next_content)
    for (i = 0; i < NUM_OF_BOARDS; i++)
      if (BOARD_RNUM(i) == GET_OBJ_RNUM(obj))
	return (i);

  return (-1);
}


void init_boards(void)
{
  int i, j, fatal_error = 0;

  for (i = 0; i < INDEX_SIZE; i++) {
    msg_storage[i] = 0;
    msg_storage_taken[i] = 0;
  }

  for (i = 0; i < NUM_OF_BOARDS; i++) {
    if ((BOARD_RNUM(i) = real_object(BOARD_VNUM(i))) == -1) {
      basic_mud_log("SYSERR: Fatal board error: board vnum %d does not exist!",
	      BOARD_VNUM(i));
      fatal_error = 1;
    }
    num_of_msgs[i] = 0;
    for (j = 0; j < MAX_BOARD_MESSAGES; j++) {
      memset((char *) &(msg_index[i][j]), 0, sizeof(struct board_msginfo));
      msg_index[i][j].slot_num = -1;
    }
    Board_load_board(i);
  }

  ACMD_READ = find_command("read");
  ACMD_WRITE = find_command("write");
  ACMD_REMOVE = find_command("remove");
  ACMD_LOOK = find_command("look");
  ACMD_EXAMINE = find_command("examine");

  if (fatal_error)
    exit(1);
}


SPECIAL(gen_board)
{
  int board_type;
  static int loaded = 0;
  struct obj_data *board = (struct obj_data *)me;

  if (!loaded) 
  {
    init_boards();
    loaded = 1;
  }
  if ((!ch) || (!ch->desc))
    return (0);

  if (cmd != ACMD_WRITE && cmd != ACMD_LOOK && cmd != ACMD_EXAMINE &&
      cmd != ACMD_READ && cmd != ACMD_REMOVE)
    return (0);

  if ((board_type = find_board(ch)) == -1) {
    basic_mud_log("SYSERR:  degenerate board!  (what the hell...)");
    return (0);
  }
  if (cmd == ACMD_WRITE)
    return (Board_write_message(board_type, ch, argument, board));
  else if (cmd == ACMD_LOOK || cmd == ACMD_EXAMINE)
    return (Board_show_board(board_type, ch, argument, board));
  else if (cmd == ACMD_READ)
    return (Board_display_msg(board_type, ch, argument, board));
  else if (cmd == ACMD_REMOVE)
    return (Board_remove_msg(board_type, ch, argument, board));
  else
    return (0);
}

// Helper function, determines whether the luser has priveledges to write
// on the board.
int Board_clan_check(struct char_data *ch, int board_type, int minrel)
{
  int c = -1, myclan = -1;
  if (!LR_FAIL(ch, LVL_CLAN_GOD)) // Gods are supreme.
    return 1;
  c = find_clan_by_id(board_info[board_type].vnum -(CLAN_ZONE * 100) + 1);
  myclan = find_clan_by_id(GET_CLAN(ch));
  if (!(CLAN_HASOPT(c, CO_BOARD)))
  { // Board is disabled. (clan enable board)
    send_to_char("This clan board is currently not operational.\r\n", ch);
    return (0);
  }
  if (myclan < 0) 
  { // Luser is not in a clan.
    send_to_char("But you're not even part of a clan!\r\n", ch);
    return (0);
  }
  if ((myclan != c) && (GET_CLAN_REL(c, myclan) < minrel))
  { // Luser is in another (not allied) clan.
    sprintf(buf, "I don't think %s would like that!\r\n", clan[c].name);
    send_to_char(buf, ch);
    return (0);
  }
  return (1);
}

int Board_write_message(int board_type, struct char_data * ch, char *arg, struct obj_data *board)
{
  char *tmstr;
#ifdef NO_LOCALTIME
  struct tm lt;
#else
  time_t ct;
#endif
  char buf[MAX_INPUT_LENGTH], buf2[MAX_INPUT_LENGTH];

  if (IS_CLAN_BOARD(board_type))
  {
    if (Board_clan_check(ch, board_type, CLAN_REL_ALLIANCE) == 0)
      return (1);
  } else if (LR_FAIL_MAX(ch, WRITE_LVL(board_type))) {
    send_to_char("You are unable to write in the language used on this board.\r\n", ch);
    return (1);
  }
  if (num_of_msgs[board_type] >= MAX_BOARD_MESSAGES) {
    send_to_char("The board is full.\r\n", ch);
    return (1);
  }
  if ((NEW_MSG_INDEX(board_type).slot_num = find_slot()) == -1) {
    send_to_char("The board is malfunctioning - sorry.\r\n", ch);
    basic_mud_log("SYSERR: Board: failed to find empty slot on write.");
    return (1);
  }
  /* skip blanks */
  skip_spaces(&arg);
  delete_doubledollar(arg);

  /* JE 27 Oct 95 - Truncate headline at 80 chars if it's longer than that */
  arg[80] = '\0';

  if (!*arg) {
    send_to_char("Messages must have a title!\r\n", ch);
    return (1);
  }
#ifndef NO_LOCALTIME
  ct = time(0);
  tmstr = (char *) asctime(localtime(&ct));
  *(tmstr + strlen(tmstr) - 1) = '\0';
#else
  if (jk_localtime_now(&lt))
  {
    basic_mud_log("Error in jk_localtime_now [%s:%d]", __FILE__, __LINE__);
    strcpy(tmstr, "ERROR!");
  } else {
    tmstr = (char *) asctime(&lt);
  }
#endif

  sprintf(buf2, "(&7%s&n)", GET_NAME(ch));
  sprintf(buf, "%6.10s %-12s :: &0%s&n", tmstr, buf2, arg);
  NEW_MSG_INDEX(board_type).heading = str_dup(buf);
  NEW_MSG_INDEX(board_type).level = GET_LEVEL(ch);

  send_to_char("Write your message. "
               "(/s or @@ on newline saves, /h for help)\r\n\r\n", ch);
  act("$n starts to write a message.", TRUE, ch, 0, 0, TO_ROOM);

  string_write(ch->desc, &(msg_storage[NEW_MSG_INDEX(board_type).slot_num]),
		MAX_MESSAGE_LENGTH, board_type + BOARD_MAGIC, NULL);

  num_of_msgs[board_type]++;
  return (1);
}


int Board_show_board(int board_type, struct char_data * ch, char *arg, struct obj_data *board)
{
  int i;
  char tmp[MAX_STRING_LENGTH], buf[MAX_STRING_LENGTH];
  char *boardDesc = board->short_description; 

  if (!ch->desc)
    return (0);

  one_argument(arg, tmp);

  if (!*tmp || !isname(tmp, board->name))
    return (0);

  if (IS_CLAN_BOARD(board_type))
  {
    if (LR_FAIL(ch, LVL_CLAN_GOD))
    {
      if (Board_clan_check(ch, board_type, CLAN_REL_PEACEFUL) == 0)
	return 1;
    }
  } else if (LR_FAIL_MAX(ch, READ_LVL(board_type))) {
    send_to_char("You try but fail to understand the holy words.\r\n", ch);
    return (1);
  }
  sprintf(buf, "$n studies %s.", boardDesc); 
  act(buf, TRUE, ch, 0, 0, TO_ROOM); 

  strcpy(buf,
         "&g[ Primal Message System ]&n\r\n"
         "&y         Usage: &cRead&n or &cremove&n <messg #>\r\n"
         "                &cWrite&n <title>\r\n"
         "You will need to look at this again to save your message.\r\n");
  // Higher level info on boards
  if(!LR_FAIL(ch, LVL_IS_GOD))
  {
    sprintf(buf1, "( &c%d&n others have sought wisdom here ) \r\n", GET_OBJ_VAL(board, 0));
    strcat(buf, buf1);
  }
  GET_OBJ_VAL(board, 0)++;
 
  if (!num_of_msgs[board_type])
  {
    sprintf(buf1, "%s is empty.\r\n", boardDesc);
    strcat(buf, buf1);
  } else {
    sprintf(buf + strlen(buf), "There are &W%d&n messages on %s.\r\n",
            num_of_msgs[board_type], boardDesc); 
#if NEWEST_AT_TOP
    for (i = num_of_msgs[board_type] - 1; i >= 0; i--)
#else
    for (i = 0; i < num_of_msgs[board_type]; i++)
#endif
    {
      if (MSG_HEADING(board_type, i))
#if NEWEST_AT_TOP
	sprintf(buf + strlen(buf), "%-2d : %s\r\n",
		num_of_msgs[board_type] - i, MSG_HEADING(board_type, i));
#else
	sprintf(buf + strlen(buf), "%-2d : %s\r\n", i + 1, MSG_HEADING(board_type, i));
#endif
      else {
	basic_mud_log("SYSERR: The board is fubar'd.");
	send_to_char("Sorry, the board isn't working.\r\n", ch);
	return (1);
      }
    }
  }
  page_string(ch->desc, buf, 1);

  return (1);
}


int Board_display_msg(int board_type, struct char_data * ch, char *arg, struct obj_data *board)
{
  char number[MAX_STRING_LENGTH], buffer[MAX_STRING_LENGTH];
  int msg, ind;

  one_argument(arg, number);
  if (!*number)
    return (0);
  if (isname(number, board->name))	/* so "read board" works */
    return (Board_show_board(board_type, ch, arg, board));
  if (strchr(number, '.'))	/* read 2.mail, look 2.sword */
    return (0);
  if (!isdigit(*number) || (!(msg = atoi(number))))
    return (0);

  if (IS_CLAN_BOARD(board_type))
  {
    if (Board_clan_check(ch, board_type, CLAN_REL_PEACEFUL) == 0)
      return (1);
  } else if (LR_FAIL_MAX(ch, READ_LVL(board_type))) {
    send_to_char("You try but fail to understand the holy words.\r\n", ch);
    return (1);
  }
  if (!num_of_msgs[board_type]) {
    send_to_char("The board is empty!\r\n", ch);
    return (1);
  }
  if (msg < 1 || msg > num_of_msgs[board_type]) {
    send_to_char("That message exists only in your imagination.\r\n",
		 ch);
    return (1);
  }
#if NEWEST_AT_TOP
  ind = num_of_msgs[board_type] - msg;
#else
  ind = msg - 1;
#endif
  if (MSG_SLOTNUM(board_type, ind) < 0 ||
      MSG_SLOTNUM(board_type, ind) >= INDEX_SIZE) {
    send_to_char("Sorry, the board is not working.\r\n", ch);
    basic_mud_log("SYSERR: Board is screwed up. (Room #%d)", GET_ROOM_VNUM(IN_ROOM(ch)));
    return (1);
  }
  if (!(MSG_HEADING(board_type, ind))) {
    send_to_char("That message appears to be screwed up.\r\n", ch);
    return (1);
  }
  if (!(msg_storage[MSG_SLOTNUM(board_type, ind)])) {
    send_to_char("That message seems to be empty.\r\n", ch);
    return (1);
  }
  sprintf(buffer, "Message &y%d&n : %s\r\n\r\n%s\r\n", msg,
          MSG_HEADING(board_type, ind),
          msg_storage[MSG_SLOTNUM(board_type, ind)]); 

  page_string(ch->desc, buffer, 1);

  return (1);
}


int Board_remove_msg(int board_type, struct char_data * ch, char *arg, struct obj_data *board)
{
  int ind, msg, slot_num;
  char number[MAX_INPUT_LENGTH], buf[MAX_INPUT_LENGTH];
  struct descriptor_data *d;

  one_argument(arg, number);

  if (!*number || !isdigit(*number))
    return (0);
  if (!(msg = atoi(number)))
    return (0);

  if (!num_of_msgs[board_type]) {
    send_to_char("The board is empty!\r\n", ch);
    return (1);
  }
  if (msg < 1 || msg > num_of_msgs[board_type]) {
    send_to_char("That message exists only in your imagination.\r\n", ch);
    return (1);
  }
#if NEWEST_AT_TOP
  ind = num_of_msgs[board_type] - msg;
#else
  ind = msg - 1;
#endif
  if (!MSG_HEADING(board_type, ind)) {
    send_to_char("That message appears to be screwed up.\r\n", ch);
    return (1);
  }
  sprintf(buf, "(&7%s&n)", GET_NAME(ch));

  if (IS_CLAN_BOARD(board_type))
  {
    int c = find_clan_by_id(1+board_info[board_type].vnum - (CLAN_ZONE * 100));

    if (((LR_FAIL(ch, LVL_CLAN_GOD)) &&
	 !(strstr(MSG_HEADING(board_type, ind), buf)) &&
	 ((find_clan_by_id(GET_CLAN(ch)) != c) ||
	  (GET_CLAN_RANK(ch) < clan[c].ranks)))) {
      send_to_char("Only the clan leader may remove other peoples post.\r\n",
	           ch);
      return (1);
    }
  } else if (LR_FAIL(ch, REMOVE_LVL(board_type)) &&
             !(strstr(MSG_HEADING(board_type, ind), buf))) {
    send_to_char("You are not holy enough to remove other people's messages.\r\n", ch);
    return (1);
  } else if (GET_LEVEL(ch) < MSG_LEVEL(board_type, ind) && (GET_LEVEL(ch) < LVL_IMPL) ) {
    send_to_char("You can't remove a message holier than yourself.\r\n", ch);
    return (1);
  } 
  slot_num = MSG_SLOTNUM(board_type, ind);
  if (slot_num < 0 || slot_num >= INDEX_SIZE) {
    send_to_char("That message is majorly screwed up.\r\n", ch);
    basic_mud_log("SYSERR: The board is seriously screwed up. (Room #%d)", GET_ROOM_VNUM(IN_ROOM(ch)));
    return (1);
  }
  for (d = descriptor_list; d; d = d->next)
    if (STATE(d) == CON_PLAYING && d->str == &(msg_storage[slot_num])) {
      send_to_char("It's still being written!\r\n", ch); 
      return (1);
    }
  if (msg_storage[slot_num])
    free(msg_storage[slot_num]);
  msg_storage[slot_num] = 0;
  msg_storage_taken[slot_num] = 0;
  if (MSG_HEADING(board_type, ind))
    free(MSG_HEADING(board_type, ind));

  for (; ind < num_of_msgs[board_type] - 1; ind++) {
    MSG_HEADING(board_type, ind) = MSG_HEADING(board_type, ind + 1);
    MSG_SLOTNUM(board_type, ind) = MSG_SLOTNUM(board_type, ind + 1);
    MSG_LEVEL(board_type, ind) = MSG_LEVEL(board_type, ind + 1);
  }
  num_of_msgs[board_type]--;
  send_to_char("&BMessage removed.&n\r\n", ch);
  sprintf(buf, "$n just removed message %d.", msg);
  act(buf, FALSE, ch, 0, 0, TO_ROOM);
  Board_save_board(board_type);

  return (1);
}


void Board_save_board(int board_type)
{
  FILE *fl;
  int i;
  char *tmp1, *tmp2 = NULL;

  if (!num_of_msgs[board_type]) {
    remove(FILENAME(board_type));
    return;
  }
  if (!(fl = fopen(FILENAME(board_type), "wb"))) {
    perror("SYSERR: Error writing board");
    return;
  }
  fwrite(&(num_of_msgs[board_type]), sizeof(int), 1, fl);

  for (i = 0; i < num_of_msgs[board_type]; i++) {
    if ((tmp1 = MSG_HEADING(board_type, i)) != NULL)
      msg_index[board_type][i].heading_len = strlen(tmp1) + 1;
    else
      msg_index[board_type][i].heading_len = 0;

    if (MSG_SLOTNUM(board_type, i) < 0 ||
	MSG_SLOTNUM(board_type, i) >= INDEX_SIZE ||
	(!(tmp2 = msg_storage[MSG_SLOTNUM(board_type, i)])))
      msg_index[board_type][i].message_len = 0;
    else
      msg_index[board_type][i].message_len = strlen(tmp2) + 1;

    fwrite(&(msg_index[board_type][i]), sizeof(struct board_msginfo), 1, fl);
    if (tmp1)
      fwrite(tmp1, sizeof(char), msg_index[board_type][i].heading_len, fl);
    if (tmp2)
      fwrite(tmp2, sizeof(char), msg_index[board_type][i].message_len, fl);
  }

  fclose(fl);
}


void Board_load_board(int board_type)
{
  FILE *fl;
  int i, len1, len2;
  char *tmp1, *tmp2;

  if (!(fl = fopen(FILENAME(board_type), "rb"))) {
    if (errno != ENOENT)
      perror("SYSERR: Error reading board");
    return;
  }
  fread(&(num_of_msgs[board_type]), sizeof(int), 1, fl);
  if (num_of_msgs[board_type] < 1 || num_of_msgs[board_type] > MAX_BOARD_MESSAGES) {
    basic_mud_log("SYSERR: Board file %d corrupt.  Resetting.", board_type);
    Board_reset_board(board_type);
    return;
  }
  for (i = 0; i < num_of_msgs[board_type]; i++) {
    fread(&(msg_index[board_type][i]), sizeof(struct board_msginfo), 1, fl);
    if ((len1 = msg_index[board_type][i].heading_len) <= 0) {
      basic_mud_log("SYSERR: Board file %d corrupt!  Resetting.", board_type);
      Board_reset_board(board_type);
      return;
    }
    CREATE(tmp1, char, len1);
    fread(tmp1, sizeof(char), len1, fl);
    MSG_HEADING(board_type, i) = tmp1;

    if ((MSG_SLOTNUM(board_type, i) = find_slot()) == -1) {
      basic_mud_log("SYSERR: Out of slots booting board %d!  Resetting...", board_type);
      Board_reset_board(board_type);
      return;
    }
    if ((len2 = msg_index[board_type][i].message_len) > 0) {
      CREATE(tmp2, char, len2);
      fread(tmp2, sizeof(char), len2, fl);
      msg_storage[MSG_SLOTNUM(board_type, i)] = tmp2;
    } else
      msg_storage[MSG_SLOTNUM(board_type, i)] = NULL;
  }

  fclose(fl);
}


void Board_reset_board(int board_type)
{
  int i;

  for (i = 0; i < MAX_BOARD_MESSAGES; i++) {
    if (MSG_HEADING(board_type, i))
      free(MSG_HEADING(board_type, i));
    if (msg_storage[MSG_SLOTNUM(board_type, i)])
      free(msg_storage[MSG_SLOTNUM(board_type, i)]);
    msg_storage_taken[MSG_SLOTNUM(board_type, i)] = 0;
    memset((char *)&(msg_index[board_type][i]),0,sizeof(struct board_msginfo));
    msg_index[board_type][i].slot_num = -1;
  }
  num_of_msgs[board_type] = 0;
  remove(FILENAME(board_type));
}
@


1.17
log
@Artus> Moved all clan checks into Board_clan_check().
@
text
@d484 1
a484 1
    int c = (board_info[board_type].vnum - (CLAN_ZONE * 100));
d490 2
a491 1
      send_to_char("Only clan leaders may remove other peoples post.\r\n", ch);
@


1.16
log
@Artus> Fixed bug where after destroying one clan and creating another, the
       boards did not always function correctly.
@
text
@d99 1
d218 27
d258 2
a259 22
    if (LR_FAIL(ch, LVL_CLAN_GOD))
    {
      int c = find_clan_by_id(board_info[board_type].vnum -(CLAN_ZONE * 100)
	                      + 1);
      int myclan = find_clan_by_id(GET_CLAN(ch));
      if (!(CLAN_HASOPT(c, CO_BOARD)))
      {
	send_to_char("This clan board is currently not operational.\r\n", ch);
	return (1);
      }
      if (myclan < 0) 
      {
	send_to_char("But you're not even part of a clan!\r\n", ch);
	return (1);
      }
      if ((myclan != c) && (!CLAN_ALLIED(c, myclan)))
      {
	sprintf(buf, "I don't think %s would like that!\r\n", clan[c].name);
	send_to_char(buf, ch);
	return (1);
      }
    }
d333 2
a334 18
      int c = (board_info[board_type].vnum - (CLAN_ZONE * 100));
      int myclan = find_clan_by_id(GET_CLAN(ch));
      if (!(CLAN_HASOPT(c, CO_BOARD)))
      {
	send_to_char("This clan board is currently not operational.\r\n", ch);
	return (1);
      }
      if (myclan < 0) 
      {
	send_to_char("But you're not even part of a clan!\r\n", ch);
	return (1);
      }
      if ((myclan != c) && (!CLAN_AT_PEACE(c, myclan)))
      {
	sprintf(buf, "I don't think %s would like that!\r\n", clan[c].name);
	send_to_char(buf, ch);
	return (1);
      }
d406 2
a407 21
    if (LR_FAIL(ch, LVL_CLAN_GOD))
    {
      int c = (board_info[board_type].vnum - (CLAN_ZONE * 100));
      int myclan = find_clan_by_id(GET_CLAN(ch));
      if (!(CLAN_HASOPT(c, CO_BOARD)))
      {
	send_to_char("This clan board is currently not operational.\r\n", ch);
	return (1);
      }
      if (myclan < 0) 
      {
	send_to_char("But you're not even part of a clan!\r\n", ch);
	return (1);
      }
      if ((myclan != c) && (!CLAN_AT_PEACE(c, myclan)))
      {
	sprintf(buf, "I don't think %s would like that!\r\n", clan[c].name);
	send_to_char(buf, ch);
	return (1);
      }
    }
@


1.15
log
@Artus> Changed immort board so it may be read/written by LVL_CHAMP or higher.
@
text
@d232 2
a233 1
      int c = (board_info[board_type].vnum - (CLAN_ZONE * 100));
@


1.14
log
@Artus> Added (ch) check.
@
text
@d72 15
a86 15
  {1198, LVL_GOD, LVL_GOD, LVL_GRGOD, LIB_ETC_BOARD "builder", 0},
  {1294, 0, 5, LVL_GOD, LIB_ETC_BOARD "mortal", 0},
  {1293, LVL_IMMORT, LVL_IMMORT, LVL_GRGOD, LIB_ETC_BOARD "immort", 0},
  {1292, 0, 5, LVL_ANGEL, LIB_ETC_BOARD "quest", 0},
  {1291, LVL_IMPL, LVL_IMPL, LVL_IMPL, LIB_ETC_BOARD "god", 0},
  {1290, 0, 5, LVL_ANGEL, LIB_ETC_BOARD "master", 0},
  {1289, 0, 5, LVL_ANGEL, LIB_ETC_BOARD "social", 0},
  {25500, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan0", 0},
  {25501, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan1", 0},
  {25502, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan2", 0},
  {25503, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan3", 0},
  {25504, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan4", 0},
  {25505, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan5", 0},
  {25506, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan6", 0},
  {25507, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan7", 0},
@


1.13
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d189 2
a190 1
  if (!loaded) {
d194 1
a194 1
  if (!ch->desc)
@


1.12
log
@Artus> Mostly just cosmetic changes, mostly for underwater stuff..
       Added some more stuff to dg_scripts:

       %actor.affected(aff_bit)% - Is actor affected by whatever.
       %self.people(countpc)%    - (Rooms): Count players.
       %self.people(countnpc)%   - (Rooms): Count npcs.
       %self.people(countall)%   - (Rooms): Count chars.
       %firstchar.<room_vnum>%   - First character in room <vnum>

       Possibly a bugfix to one of the forest specials that was attacking you
       if you were affected by poison.
@
text
@d70 1
d73 1
a73 1
  {1294, 0, 0, LVL_GOD, LIB_ETC_BOARD "mortal", 0},
d75 1
a75 1
  {1292, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "quest", 0},
d77 2
a78 2
  {1290, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "master", 0},
  {1289, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "social", 0},
d229 1
a229 1
    if (GET_LEVEL(ch) < LVL_CLAN_GOD)
d250 2
a251 2
  } else if (GET_LEVEL(ch) < WRITE_LVL(board_type)) {
    send_to_char("You are not holy enough to write on this board.\r\n", ch);
d321 1
a321 1
    if (GET_LEVEL(ch) < LVL_CLAN_GOD)
d342 1
a342 1
  } else if (GET_LEVEL(ch) < READ_LVL(board_type)) {
d355 4
a358 3
  if( GET_LEVEL(ch) >= LVL_ANGEL ) {
        sprintf(buf1, "( &c%d&n others have sought wisdom here ) \r\n", GET_OBJ_VAL(board, 0));
        strcat(buf, buf1);
d362 2
a363 1
  if (!num_of_msgs[board_type]){
d366 1
a366 2
  } 
  else {
d412 1
a412 1
    if (GET_LEVEL(ch) < LVL_CLAN_GOD)
d433 1
a433 1
  } else if (GET_LEVEL(ch) < READ_LVL(board_type)) {
d511 1
a511 1
    if (((GET_LEVEL(ch) < LVL_CLAN_GOD) &&
d518 2
a519 2
  } else if (GET_LEVEL(ch) < REMOVE_LVL(board_type) &&
      !(strstr(MSG_HEADING(board_type, ind), buf)) ) {
@


1.11
log
@Artus> Changed remort, in particular, list remort abilities to char.. Also,
       spellsword was incorrectly being listed as a possible path for a
       warrior.

       Replaced #ifdef USE_LOCALTIME with #ifndef NO_LOCALTIME..

       Added define NOTELL_SOUNDPROOF .. Define this to stop people telling
       to/from soundproof rooms.

       Removed extraneous level checking from do_wear.. This is handled
       better by perform_wear.
@
text
@d71 1
d102 1
@


1.10
log
@Artus>
Trap Obj is now VNUM 25599 aka TRAP_OBJ
Modified board code to handle clan boards.
Reduced number of clans to 8 (was 32).
Added a few new clan defines.. GET_CLAN_REL(us, them); CLAN_AT_PEACE(us, them),
  CLAN_AT_WAR(us, them); CLAN_ALLIED(us, them);...
Fixed up the clan destroy routine.
Set slowns to default on.
Remove loop for assigning clan mobs, replaced with sequential assigns.
@
text
@d217 1
a217 1
#ifndef USE_LOCALTIME
d271 1
a271 1
#ifdef USE_LOCALTIME
@


1.9
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@a70 6
  //{3099, 0, 0, LVL_GOD, LIB_ETC_BOARD "mortal", 0},
  //{3098, LVL_IMMORT, LVL_IMMORT, LVL_GRGOD, LIB_ETC_BOARD "immort", 0},
  //{3097, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "quest", 0},
  //{3096, LVL_IMPL, LVL_IMPL, LVL_IMPL, LIB_ETC_BOARD "god", 0},
  //{3095, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "master", 0},
  //{3094, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "social", 0},
a84 24
  {25508, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan8", 0},
  {25509, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan9", 0},
  {25510, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan10", 0},
  {25511, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan11", 0},
  {25512, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan12", 0},
  {25513, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan13", 0},
  {25514, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan14", 0},
  {25515, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan15", 0},
  {25516, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan16", 0},
  {25517, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan17", 0},
  {25518, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan18", 0},
  {25519, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan19", 0},
  {25520, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan20", 0},
  {25521, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan21", 0},
  {25522, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan22", 0},
  {25523, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan23", 0},
  {25524, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan24", 0},
  {25525, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan25", 0},
  {25526, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan26", 0},
  {25527, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan27", 0},
  {25528, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan28", 0},
  {25529, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan29", 0},
  {25530, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan30", 0},
  {25531, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "clan31", 0}
a115 24
  ASSIGNOBJ(25508, gen_board);	/* clan board */
  ASSIGNOBJ(25509, gen_board);	/* clan board */
  ASSIGNOBJ(25510, gen_board);	/* clan board */
  ASSIGNOBJ(25511, gen_board);	/* clan board */
  ASSIGNOBJ(25512, gen_board);	/* clan board */
  ASSIGNOBJ(25513, gen_board);	/* clan board */
  ASSIGNOBJ(25514, gen_board);	/* clan board */
  ASSIGNOBJ(25515, gen_board);	/* clan board */
  ASSIGNOBJ(25516, gen_board);	/* clan board */
  ASSIGNOBJ(25517, gen_board);	/* clan board */
  ASSIGNOBJ(25518, gen_board);	/* clan board */
  ASSIGNOBJ(25519, gen_board);	/* clan board */
  ASSIGNOBJ(25520, gen_board);	/* clan board */
  ASSIGNOBJ(25521, gen_board);	/* clan board */
  ASSIGNOBJ(25522, gen_board);	/* clan board */
  ASSIGNOBJ(25523, gen_board);	/* clan board */
  ASSIGNOBJ(25524, gen_board);	/* clan board */
  ASSIGNOBJ(25525, gen_board);	/* clan board */
  ASSIGNOBJ(25526, gen_board);	/* clan board */
  ASSIGNOBJ(25527, gen_board);	/* clan board */
  ASSIGNOBJ(25528, gen_board);	/* clan board */
  ASSIGNOBJ(25529, gen_board);	/* clan board */
  ASSIGNOBJ(25530, gen_board);	/* clan board */
  ASSIGNOBJ(25531, gen_board);	/* clan board */
d224 24
a247 1
  if (GET_LEVEL(ch) < WRITE_LVL(board_type)) {
d316 24
a339 1
  if (GET_LEVEL(ch) < READ_LVL(board_type)) {
d406 24
a429 1
  if (GET_LEVEL(ch) < READ_LVL(board_type)) {
d503 2
a504 1
  if (IS_CLAN_BOARD(board_type)) {
d507 4
a510 4
    if ( ((GET_LEVEL(ch) < LVL_CLAN_GOD) 
	  && !(strstr(MSG_HEADING(board_type, ind), buf))
	  && ((find_clan_by_id(GET_CLAN(ch)) != c)
	      || (GET_CLAN_RANK(ch) < clan[c].ranks)))) {
@


1.8
log
@Artus> Localtime fix.
@
text
@d211 1
a211 1
      log("SYSERR: Fatal board error: board vnum %d does not exist!",
d252 1
a252 1
    log("SYSERR:  degenerate board!  (what the hell...)");
d288 1
a288 1
    log("SYSERR: Board: failed to find empty slot on write.");
d309 1
a309 1
    log("Error in jk_localtime_now [%s:%d]", __FILE__, __LINE__);
d387 1
a387 1
	log("SYSERR: The board is fubar'd.");
d435 1
a435 1
    log("SYSERR: Board is screwed up. (Room #%d)", GET_ROOM_VNUM(IN_ROOM(ch)));
d509 1
a509 1
    log("SYSERR: The board is seriously screwed up. (Room #%d)", GET_ROOM_VNUM(IN_ROOM(ch)));
d592 1
a592 1
    log("SYSERR: Board file %d corrupt.  Resetting.", board_type);
d599 1
a599 1
      log("SYSERR: Board file %d corrupt!  Resetting.", board_type);
d608 1
a608 1
      log("SYSERR: Out of slots booting board %d!  Resetting...", board_type);
@


1.7
log
@
Modified: DM

Changed:
- Don't ask (large group checkin) - lots of bug fixes mainly.
- Use cvs diff if you really wanna see the changes.
@
text
@d271 3
d275 1
d302 1
d306 9
@


1.6
log
@Artus - Modified for clan boards..
@
text
@d71 12
a82 6
  {3099, 0, 0, LVL_GOD, LIB_ETC_BOARD "mortal", 0},
  {3098, LVL_IMMORT, LVL_IMMORT, LVL_GRGOD, LIB_ETC_BOARD "immort", 0},
  {3097, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "quest", 0},
  {3096, LVL_IMPL, LVL_IMPL, LVL_IMPL, LIB_ETC_BOARD "god", 0},
  {3095, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "master", 0},
  {3094, 0, 0, LVL_ANGEL, LIB_ETC_BOARD "social", 0},
d131 6
a136 6
  ASSIGNOBJ(3099, gen_board);	/* mortal board */
  ASSIGNOBJ(3098, gen_board);	/* immortal board */
  ASSIGNOBJ(3097, gen_board);	/* quest board */
  ASSIGNOBJ(3096, gen_board);	/* gods board */
  ASSIGNOBJ(3095, gen_board);	/* master board */
  ASSIGNOBJ(3094, gen_board);	/* social board */
@


1.5
log
@Modified: DM

Added:
- clan boards, updated old stock boards
@
text
@d58 1
d467 12
a478 1
  if (GET_LEVEL(ch) < REMOVE_LVL(board_type) &&
d482 1
a482 2
  }
  if (GET_LEVEL(ch) < MSG_LEVEL(board_type, ind) && (GET_LEVEL(ch) < LVL_IMPL) ) {
@


1.4
log
@
Changed:
- board colouring to use colourcodes,
- fixed remove message checking (name) -> (&7name&n)
@
text
@d70 38
a107 7
  {3099, 0, 0, LVL_GOD, LIB_ETC "board.mort", 0},
  {3098, LVL_IMMORT, LVL_IMMORT, LVL_GRGOD, LIB_ETC "board.immort", 0},
  {3097, LVL_IMMORT, LVL_FREEZE, LVL_IMPL, LIB_ETC "board.freeze", 0},
  {3096, 0, 0, LVL_IMMORT, LIB_ETC "board.social", 0},
  {3095, 0, 0, LVL_IMMORT, LIB_ETC "board.guardians", 0},
  {3094, 0, 0, LVL_IMMORT, LIB_ETC "board.avengers", 0},
  {3093, 0, 0, LVL_IMMORT, LIB_ETC "board.jedi", 0},
d122 42
@


1.3
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d222 2
a223 2
  sprintf(buf2, "(&y%s&n)", GET_NAME(ch));
  sprintf(buf, "%6.10s %-12s :: &g%s&n", tmstr, buf2, arg);
d228 1
a228 1
               "(/s or @@ on newline saves, /h for help.\r\n\r\n", ch);
d392 1
a392 1
  sprintf(buf, "(%s)", GET_NAME(ch));
@


1.2
log
@
Added:
- Ahh, too much stuff, sorry was ages since this stuff was last checked in
@
text
@d227 2
a228 1
  send_to_char("Write your message.  Terminate with a @@ on a new line.\r\n\r\n", ch);
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d74 3
@

