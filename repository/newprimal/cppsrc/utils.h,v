head	1.74;
access;
symbols
	LATEST:1.13
	A3_0_1:1.13;
locks; strict;
comment	@ * @;


1.74
date	2004.12.06.05.55.11;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	2004.11.24.01.55.26;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	2004.08.27.02.13.48;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	2004.07.10.03.30.01;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	2004.06.05.08.31.43;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	2004.05.18.11.08.50;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	2004.05.16.07.02.05;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	2004.05.10.03.26.22;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	2004.05.06.02.23.30;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	2004.05.05.01.06.01;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	2004.05.02.08.38.01;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	2004.04.30.00.39.31;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	2004.04.29.08.02.36;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	2004.04.21.07.10.39;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.11.00.26.31;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	2004.01.31.08.42.17;	author john;	state Exp;
branches;
next	1.58;

1.58
date	2004.01.30.04.09.19;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.11.03.49.09;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.10.13.04.50;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.10.12.02.27;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.04.10.35.01;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	2003.12.31.22.20.28;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.17.02.25.07;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	2003.12.09.05.42.45;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	2003.11.27.06.16.00;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	2003.11.24.00.14.49;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	2003.11.12.11.00.14;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	2003.11.06.03.47.16;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	2003.11.05.12.17.14;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	2003.11.05.03.39.27;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	2003.11.03.17.01.12;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	2003.10.20.12.01.50;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	2002.10.01.10.26.03;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	2002.07.20.08.17.56;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	2002.04.10.10.48.30;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	2002.02.26.06.49.04;	author primal;	state Exp;
branches;
next	1.38;

1.38
date	2002.02.14.06.10.19;	author primal;	state Exp;
branches;
next	1.37;

1.37
date	2002.01.25.03.56.41;	author primal;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.23.06.39.01;	author primal;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.09.12.23.33;	author rod;	state Exp;
branches;
next	1.34;

1.34
date	2001.12.07.01.05.34;	author karma;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.25.04.07.01;	author karma;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.20.05.54.49;	author rod;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.11.04.58.47;	author primal;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.28.12.31.55;	author rod;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.28.06.37.48;	author karma;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.11.13.08.36;	author artus;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.15.11.42.01;	author artus;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.09.03.20.49;	author artus;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.03.05.33.30;	author artus;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.02.02.30.06;	author primal;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.28.07.45.51;	author artus;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.26.07.59.31;	author primal;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.11.15.13.16;	author artus;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.11.03.33.01;	author primal;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.08.15.31.55;	author primal;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.06.08.19.42;	author primal;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.02.07.05.45;	author primal;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.02.04.34.51;	author primal;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.31.10.51.06;	author primal;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.31.10.41.32;	author primal;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.22.22.19.10;	author primal;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.20.16.32.11;	author primal;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.17.14.04.47;	author primal;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.14.00.52.58;	author primal;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.28.21.12.26;	author primal;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.26.07.52.32;	author primal;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.14.10.03.18;	author primal;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.13.00.59.22;	author primal;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.27.11.26.40;	author talisman;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.22.09.22.36;	author talisman;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.12.29.22;	author talisman;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.13.14.25.15;	author mbd;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.44.00;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Artus> Added calc_modifier function.
@
text
@/* ************************************************************************
*   File: utils.h                                       Part of CircleMUD *
*  Usage: header file: utility macros and prototypes of utility funcs     *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

// DM - To inform the compiler that the crypt function has been compiled in
// C, (C does not encode function names for type-safe linkage)
extern "C" char *crypt(const char *, const char *);

/* external declarations and prototypes **********************************/

extern struct weather_data weather_info;
extern FILE *logfile;

#if 0 // Artus> This is a math function, no?
#define log			basic_mud_log
#endif

extern struct spell_info_type spell_info[];

/* public functions in utils.c */
int train_cost(struct char_data *ch, int stat, int curr_value);
int max_stat_value(struct char_data *ch, int stat);
int can_wear_finger(struct char_data *ch, int where);
int eq_pos_ok(struct char_data *ch, int where);
char *toUpper(char *oStr);
int     is_wearing(struct char_data *ch, int item_type);
int     is_carrying(struct char_data *ch, int item_type);
char	*str_dup(const char *source);
int	str_cmp(const char *arg1, const char *arg2);
int	strn_cmp(const char *arg1, const char *arg2, int n);
void	basic_mud_log(const char *format, ...) __attribute__ ((format (printf, 1, 2)));
int	touch(const char *path);
void	mudlog(const char *str, int type, int level, int file);
void    info_channel( char *str, struct char_data *ch);
bool    is_death_room(room_rnum nr);
void	log_death_trap(struct char_data *ch, int type);
int	number(int from, int to);
int	dice(int number, int size);
void	sprintbit(bitvector_t vektor, const char *names[], char *result);
void	sprinttype(int type, const char *names[], char *result);
int	get_line(FILE *fl, char *buf);
int	get_filename(char *orig_name, char *filename, int mode);
struct time_info_data *age(struct char_data *ch);
int	num_pc_in_room(struct room_data *room);
void	core_dump_real(const char *, int);
int 	has_stats_for_skill(struct char_data *ch, int skillnum, bool show);
int     get_world(room_rnum room); 
int     same_world(struct char_data *ch,struct char_data *ch2);  
float 	special_modifier(struct char_data *ch);
float 	elitist_modifier(struct char_data *ch);
double  unholiness_modifier(struct char_data *ch);
double  calc_modifier(struct char_data *ch);
void    show_lots (struct char_data *ch);
int     check_seller(struct char_data *ch);
void    remove_lot(int lot);
int     add_lot(struct obj_data *obj, struct char_data *ch, long amount);
void    die_clone(struct char_data *ch, struct char_data *killer);
void    die_follower(struct char_data * ch);
void    add_follower(struct char_data * ch, struct char_data * leader);
bool    quest_obj_ok(struct char_data *, struct obj_data *);
struct  char_data *is_valid_char(struct char_data *ch);

// DM - temp localtime fix struct tm *localtime(const time_t *timer);
#ifdef NO_LOCALTIME
int jk_localtime(struct tm *lt, long int t);
int jk_localtime_now(struct tm *lt);
#endif

void ASSIGNROOM(room_vnum room, SPECIAL(fname));
void ASSIGNMOB(mob_vnum mob, SPECIAL(fname));
void ASSIGNOBJ(obj_vnum obj, SPECIAL(fname));

#define core_dump()		core_dump_real(__FILE__, __LINE__)

/* random functions in random.c */
void circle_srandom(unsigned long initial_seed);
unsigned long circle_random(void);

/* undefine MAX and MIN so that our functions are used instead */
#ifdef MAX
#undef MAX
#endif

#ifdef MIN
#undef MIN
#endif

int MAX(int a, int b);
int MIN(int a, int b);
int MINMAX(int min, int max, int val);
char *CAP(char *txt);

/* in act.comm.c */
int scan_buffer_for_xword(char* buf); 

/* in magic.c */
bool	circle_follow(struct char_data *ch, struct char_data * victim);

/* in act.informative.c */
void	look_at_room(struct char_data *ch, int mode);

/* in act.movmement.c */
int	do_simple_move(struct char_data *ch, int dir, int need_specials_check,
                       int subcmd = SCMD_MOVE, bool show = true);
int	perform_move(struct char_data *ch, int dir, int following);

/* in ban.c */
int Valid_Name(char *newname, bool desc_check);

/* in limits.c */
int	mana_gain(struct char_data *ch);
int	hit_gain(struct char_data *ch);
int	move_gain(struct char_data *ch);
void	advance_level(struct char_data *ch);
void    demote_level(struct char_data *ch,int newlevel, const char *reason);
void	set_title(struct char_data *ch, char *title);
int     gain_exp(struct char_data *ch, int gain);
void	gain_exp_regardless(struct char_data *ch, int gain);
void	gain_condition(struct char_data *ch, int condition, int value);
void	check_idling(struct char_data *ch);
void	point_update(void);
void	update_pos(struct char_data *victim);

/* class.c */
float	exp_modifiers(int classnum);
int     thaco(struct char_data *ch, struct char_data *vict);

/* in fight.c */
void raw_kill(struct char_data * ch, struct char_data *killer);
void die(struct char_data * ch, struct char_data *killer, char *msg = NULL);

/* in genolc.c */
int files_need_saving(void);


/* in spell_parser.c */
void apply_spell_skill_abil(struct char_data *ch, int spellnum); 
bool basic_skill_test(struct char_data * ch, int spellnum, bool perform);

/* various constants *****************************************************/

/* Spec MOB used mainly in magic.c, moved for access in other modules */
#define MOB_CLONE               22300
#define MOB_ZOMBIE              22301

/* defines for mudlog() */
#define OFF	0
#define BRF	1
#define NRM	2
#define CMP	3
#define DBG     9	// Artus> This should always be last.

/* get_filename() */
#define CRASH_FILE	0
#define ETEXT_FILE	1
#define ALIAS_FILE	2
#define SCRIPT_VARS_FILE 3

/* breadth-first searching */
#define BFS_ERROR		-1
#define BFS_ALREADY_THERE	-2
#define BFS_NO_PATH		-3

/*
 * XXX: These constants should be configurable. See act.informative.c
 *	and utils.c for other places to change.
 */
/* mud-life time */
#define SECS_PER_MUD_HOUR	45
#define SECS_PER_MUD_DAY	(24*SECS_PER_MUD_HOUR)
#define SECS_PER_MUD_MONTH	(35*SECS_PER_MUD_DAY)
#define SECS_PER_MUD_YEAR	(17*SECS_PER_MUD_MONTH)

/* real-life time (remember Real Life?) */
#define SECS_PER_REAL_MIN	60
#define SECS_PER_REAL_HOUR	(60*SECS_PER_REAL_MIN)
#define SECS_PER_REAL_DAY	(24*SECS_PER_REAL_HOUR)
#define SECS_PER_REAL_YEAR	(365*SECS_PER_REAL_DAY)


/* string utils **********************************************************/


#define YESNO(a) ((a) ? "YES" : "NO")
#define ONOFF(a) ((a) ? "ON" : "OFF")

#define LOWER(c)   (((c)>='A'  && (c) <= 'Z') ? ((c)+('a'-'A')) : (c))
#define UPPER(c)   (((c)>='a'  && (c) <= 'z') ? ((c)+('A'-'a')) : (c) )

#define ISNEWL(ch) ((ch) == '\n' || (ch) == '\r') 
#define IF_STR(st) ((st) ? (st) : "\0")

#define AN(string) (strchr("aeiouAEIOU", *string) ? "an" : "a")


/* memory utils **********************************************************/


#define CREATE(result, type, number)  do {\
	if ((number) * sizeof(type) <= 0)	\
		basic_mud_log("SYSERR: Zero bytes or less requested at %s:%d.", __FILE__, __LINE__);	\
	if (!((result) = (type *) calloc ((number), sizeof(type))))	\
		{ perror("SYSERR: malloc failure"); abort(); } } while(0)

#define RECREATE(result,type,number) do {\
  if (!((result) = (type *) realloc ((result), sizeof(type) * (number))))\
		{ perror("SYSERR: realloc failure"); abort(); } } while(0)

/*
 * the source previously used the same code in many places to remove an item
 * from a list: if it's the list head, change the head, else traverse the
 * list looking for the item before the one to be removed.  Now, we have a
 * macro to do this.  To use, just make sure that there is a variable 'temp'
 * declared as the same type as the list to be manipulated.  BTW, this is
 * a great application for C++ templates but, alas, this is not C++.  Maybe
 * CircleMUD 4.0 will be...
 */
#define REMOVE_FROM_LIST(item, head, next)	\
   if ((item) == (head))		\
      head = (item)->next;		\
   else {				\
      temp = head;			\
      while (temp && (temp->next != (item))) \
	 temp = temp->next;		\
      if (temp)				\
         temp->next = (item)->next;	\
   }					\


/* basic bitvector utils *************************************************/


#define IS_SET(flag,bit)  ((flag) & (bit))
#define SET_BIT(var,bit)  ((var) |= (bit))
#define REMOVE_BIT(var,bit)  ((var) &= ~(bit))
#define TOGGLE_BIT(var,bit) ((var) = (var) ^ (bit))

/*
 * Accessing player specific data structures on a mobile is a very bad thing
 * to do.  Consider that changing these variables for a single mob will change
 * it for every other single mob in the game.  If we didn't specifically check
 * for it, 'wimpy' would be an extremely bad thing for a mob to do, as an
 * example.  If you really couldn't care less, change this to a '#if 0'.
 */
#if 1
/* Subtle bug in the '#var', but works well for now. */
#define CHECK_PLAYER_SPECIAL(ch, var) \
	(*(((ch)->player_specials == &dummy_mob) ? (basic_mud_log("SYSERR: Mob using '"#var"' at %s:%d.", __FILE__, __LINE__), &(var)) : &(var)))
#else
#define CHECK_PLAYER_SPECIAL(ch, var)	(var)
#endif

#define CHAR_TIMERS(ch)  ((ch)->timers)
#define OBJ_TIMERS(obj)  ((obj)->timers)        
        
#define MOB_FLAGS(ch)	((ch)->char_specials.saved.act)
#define PLR_FLAGS(ch)	((ch)->char_specials.saved.act)
#define PRF_FLAGS(ch)   CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.pref))
#define EXT_FLAGS(ch)   CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->primalsaved.ext_flag)) 
#define PUN_FLAGS(ch)   ((ch)->player_specials->saved.ptype) // Punish - ARTUS
#define SPEC_FLAGS(ch)  CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->primalsaved.misc_specials)) 
#define GET_SPECIALS(ch) CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->primalsaved.abilities))
#define CHAR_MEMORISED(ch) CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->primalsaved.char_memorised))
#define CHAR_DISGUISED(ch) CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->primalsaved.char_disguised))

#define AFF_FLAGS(ch)	((ch)->char_specials.saved.affected_by)
#define ROOM_FLAGS(loc)	(world[(loc)].room_flags)
#define RMSM_FLAGS(loc) (world[(loc)].small_bits)
#define SPELL_ROUTINES(spl)	(spell_info[spl].routines)
#define BURGLE_FLAGS(loc) (world[(loc)].burgle_flags)
 
/* See http://www.circlemud.org/~greerga/todo.009 to eliminate MOB_ISNPC. */
#define IS_NPC(ch)	(IS_SET(MOB_FLAGS(ch), MOB_ISNPC))
#define IS_MOB(ch)  (IS_NPC(ch) && GET_MOB_RNUM(ch) >= 0)
#define IS_GHOST(ch) (!IS_NPC(ch) && IS_SET(EXT_FLAGS(ch), EXT_GHOST))

#define IS_BUILDING(ch) (!IS_NPC(ch) && (ch->desc) && \
                         (STATE((ch)->desc) >= CON_OEDIT && \
                         STATE((ch)->desc) <= CON_TEDIT))

/* DM - clone utils */
#define IS_CLONE(ch) (IS_NPC(ch) && (GET_MOB_VNUM(ch) == MOB_CLONE))
#define IS_CLONE_ROOM(ch) (IS_CLONE(ch) && \
                ((ch)->in_room == (ch->master)->in_room))
  
/* Artus - Zombies */
#define IS_ZOMBIE(ch) (IS_NPC(ch) && (GET_MOB_VNUM(ch) == MOB_ZOMBIE))

#define MOB_FLAGGED(ch, flag) (IS_NPC(ch) && IS_SET(MOB_FLAGS(ch), (flag)))
#define PLR_FLAGGED(ch, flag) (!IS_NPC(ch) && IS_SET(PLR_FLAGS(ch), (flag)))
#define AFF_FLAGGED(ch, flag) (IS_SET(AFF_FLAGS(ch), (flag)))
#define PRF_FLAGGED(ch, flag) (IS_SET(PRF_FLAGS(ch), (flag)))
#define EXT_FLAGGED(ch, flag) (IS_SET(EXT_FLAGS(ch), (flag)))
#define SPEC_FLAGGED(ch,flag) (IS_SET(SPEC_FLAGS(ch),(flag)))
#define PUN_FLAGGED(ch, flag) (IS_SET(PUN_FLAGS(ch), (1 << flag))) // Punish

#define ROOM_FLAGGED(loc, flag) (IS_SET(ROOM_FLAGS(loc), (flag)))
#define RMSM_FLAGGED(loc, flag) (IS_SET(RMSM_FLAGS(loc), (flag)))
#define BURGLE_FLAGGED(loc, flag) (IS_SET(BURGLE_FLAGS(loc), (flag)))

#define EXIT_FLAGGED(exit, flag) (IS_SET((exit)->exit_info, (flag)))
#define OBJVAL_FLAGGED(obj, flag) (IS_SET(GET_OBJ_VAL((obj), 1), (flag)))
#define OBJWEAR_FLAGGED(obj, flag) (IS_SET((obj)->obj_flags.wear_flags, (flag)))
#define OBJ_FLAGGED(obj, flag) (IS_SET(GET_OBJ_EXTRA(obj), (flag)))
#define HAS_SPELL_ROUTINE(spl, flag) (IS_SET(SPELL_ROUTINES(spl), (flag)))

#define SPELL_EFFEC(ch, spl)  (spell_info[spl].spell_effec[(int)GET_CLASS(ch)])
#define APPLY_SPELL_EFFEC(ch, spl, amt) (amt * (float)(SPELL_EFFEC(ch, spl)) / 100)

/* IS_AFFECTED for backwards compatibility */
#define IS_AFFECTED(ch, skill) (AFF_FLAGGED((ch), (skill)))

#define PLR_TOG_CHK(ch,flag) ((TOGGLE_BIT(PLR_FLAGS(ch), (flag))) & (flag))
#define PRF_TOG_CHK(ch,flag) ((TOGGLE_BIT(PRF_FLAGS(ch), (flag))) & (flag))
#define EXT_TOG_CHK(ch,flag) ((TOGGLE_BIT(EXT_FLAGS(ch), (flag))) & (flag))
 
/* Punish related defines - ARTUS */
#define PUN_TOG_CHK(ch,flag) ((TOGGLE_BIT(PUN_FLAGS(ch), (1 << flag))) & (1 << flag))
#define PUN_HOURS(ch, pun) ((ch)->player_specials->saved.phours[pun])
#define HAS_OFFENDED(ch, off) ((ch)->player_specials->saved.offences[off])
#define INSTIGATOR(ch)          CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->instigator))

#define GET_UNHOLINESS(ch) ((ch)->player_specials->saved.unholiness)
/* room utils ************************************************************/


#define SECT(room)	(world[(room)].sector_type)

#define IS_DARK(room)  ( !world[room].light && \
                         (ROOM_FLAGGED(room, ROOM_DARK) || \
                          ( ( SECT(room) != SECT_INSIDE && \
                              SECT(room) != SECT_CITY ) && \
                            (weather_info.sunlight == SUN_SET || \
			     weather_info.sunlight == SUN_DARK)) ) )

#define IS_LIGHT(room)  (!IS_DARK(room))

#define VALID_RNUM(rnum)	((rnum) >= 0 && (rnum) <= top_of_world)
#define GET_ROOM_VNUM(rnum) \
	((room_vnum)(VALID_RNUM(rnum) ? world[(rnum)].number : NOWHERE))
#define GET_ROOM_SPEC(room) (VALID_RNUM(room) ? world[(room)].func : NULL)

/* char utils ************************************************************/


#define IN_ROOM(ch)	((ch)->in_room)
#define LASTROOM(ch)	((ch)->last_room)
#define GET_WAS_IN(ch)	((ch)->was_in_room)
#define GET_AGE(ch)     (age(ch)->year)

#define GET_PC_NAME(ch)	((ch)->player.name)
#define GET_NAME(ch)    (IS_NPC(ch) ? \
			 (ch)->player.short_descr : GET_PC_NAME(ch))
#define GET_TITLE(ch)   ((ch)->player.title)
#define GET_LEVEL(ch)   ((ch)->player.level)
#define GET_MAX_LVL(ch) (MAX(GET_LEVEL(ch), MAX(GET_REM_ONE(ch), GET_REM_TWO(ch))))
#define GET_REM_ONE(ch) ((ch)->player_specials->primalsaved.remort_one) 
#define GET_REM_TWO(ch) ((ch)->player_specials->primalsaved.remort_two) 

// Last remort level ...
#define GET_LAST_LVL(ch) (GET_REM_TWO((ch)) != 0 ? GET_REM_ONE((ch)) : \
    (GET_REM_ONE((ch)) != 0 ? GET_REM_ONE((ch)) : GET_LEVEL((ch))))

#define GET_WHO_STR(ch) ((ch)->player_specials->primalsaved.spesh_who)
#define GET_PASSWD(ch)	((ch)->player.passwd)
#define GET_PFILEPOS(ch)((ch)->pfilepos)
#define GET_EMAIL(ch)   ((ch)->player.email)
#define GET_WEBPAGE(ch) ((ch)->player.webpage)
#define GET_PERSONAL(ch)((ch)->player.personal)

#define GET_REMORT_LEVEL(ch) ((GET_CLASS(ch) == CLASS_MASTER) ? 3 : \
        ((GET_CLASS(ch) > CLASS_WARRIOR) ? 2 : 1))

#define MAX_STAT_VALUE(ch) (IS_NPC(ch) ? 25 : ( \
        (GET_LEVEL(ch) >= LVL_GOD) ? 25 : ( \
        (GET_REMORT_LEVEL(ch) == 3) ? 24 : ( \
        (GET_REMORT_LEVEL(ch) == 2) ? 23 : 21))))

#define GET_PROMPT(ch)  ((ch)->player.prompt_string)
#define GET_FIGHT_PROMPT(ch) ((ch)->player_specials->primalsaved.fight_prompt)

/*
 * I wonder if this definition of GET_REAL_LEVEL should be the definition
 * of GET_LEVEL?  JE
 */
#define GET_REAL_LEVEL(ch) \
   (ch->desc && ch->desc->original ? GET_LEVEL(ch->desc->original) : \
    GET_LEVEL(ch))

#define GET_MODIFIER(ch)	((ch)->char_specials.modifier)

#define GET_CLASS(ch)   ((ch)->player.chclass)
#define GET_HOME(ch)	((ch)->player.hometown)
#define GET_HEIGHT(ch)	((ch)->player.height)
#define GET_WEIGHT(ch)	((ch)->player.weight)
#define GET_SEX(ch)	((ch)->player.sex)

// Artus> Level Restrict Macros..
#define LR_FAIL(ch, lvl) (GET_LEVEL(ch) < lvl)
#define LR_FAIL_MAX(ch, lvl) ((GET_LEVEL(ch) < lvl) && ((lvl > LVL_ISNOT_GOD) || ((GET_REM_ONE(ch) < lvl) && (GET_REM_TWO(ch) < lvl))))
#define CAN_LEVEL(ch) (LR_FAIL(ch, RONE_MAX_LVL) || \
                       ((GET_CLASS(ch) > CLASS_WARRIOR) && \
			LR_FAIL(ch, RTWO_MAX_LVL)) || \
		       ((GET_CLASS(ch) == CLASS_MASTER) && \
			LR_FAIL(ch, LVL_CHAMP + MIN(5, GET_UNHOLINESS(ch)))))

#define GET_STR(ch)     ((ch)->aff_abils.str)
#define GET_ADD(ch)     ((ch)->aff_abils.str_add)
#define GET_DEX(ch)     ((ch)->aff_abils.dex)
#define GET_INT(ch)     ((ch)->aff_abils.intel)
#define GET_WIS(ch)     ((ch)->aff_abils.wis)
#define GET_CON(ch)     ((ch)->aff_abils.con)
#define GET_CHA(ch)     ((ch)->aff_abils.cha)

#define DEX_CHECK(ch, min)   ((number(min, 22) > (ch)->aff_abils.dex))
  
#define GET_REAL_STR(ch)	((ch)->real_abils.str)
#define GET_REAL_ADD(ch)	((ch)->real_abils.str_add)
#define GET_REAL_DEX(ch)	((ch)->real_abils.dex)
#define GET_REAL_INT(ch)    	((ch)->real_abils.intel)
#define GET_REAL_WIS(ch)     	((ch)->real_abils.wis)
#define GET_REAL_CON(ch)     	((ch)->real_abils.con)
#define GET_REAL_CHA(ch)     	((ch)->real_abils.cha)

#define GET_REAL_STAT(ch, stat) \
        (((stat) == STAT_INT) ? ((ch)->real_abils.intel) : ( \
         ((stat) == STAT_WIS) ? ((ch)->real_abils.wis) : ( \
         ((stat) == STAT_STR) ? ((ch)->real_abils.str) : ( \
         ((stat) == STAT_CON) ? ((ch)->real_abils.con) : ( \
         ((stat) == STAT_DEX) ? ((ch)->real_abils.dex) : ( \
         ((stat) == STAT_CHA) ? ((ch)->real_abils.cha) : ( \
         ((stat) == STAT_HIT) ? ((ch)->points.max_hit) : ( \
         ((stat) == STAT_MANA) ? ((ch)->points.max_mana) : ((ch)->points.max_move)))))))))

#define GET_AFF_STR(ch)     ((ch)->aff_abils.str)
#define GET_AFF_ADD(ch)     ((ch)->aff_abils.str_add)
#define GET_AFF_DEX(ch)     ((ch)->aff_abils.dex)
#define GET_AFF_INT(ch)     ((ch)->aff_abils.intel)
#define GET_AFF_WIS(ch)     ((ch)->aff_abils.wis)
#define GET_AFF_CON(ch)     ((ch)->aff_abils.con)
#define GET_AFF_CHA(ch)     ((ch)->aff_abils.cha)

#define GET_EXP(ch)	  ((ch)->points.exp)
#define GET_AC(ch)        ((ch)->points.armor)
#define GET_HIT(ch)	  ((ch)->points.hit)
#define GET_MAX_HIT(ch)	  ((ch)->points.max_hit)
#define GET_MOVE(ch)	  ((ch)->points.move)
#define GET_MAX_MOVE(ch)  ((ch)->points.max_move)
#define GET_MANA(ch)	  ((ch)->points.mana)
#define GET_MAX_MANA(ch)  ((ch)->points.max_mana)
#define GET_GOLD(ch)	  ((ch)->points.gold)
#define GET_BANK_GOLD(ch) ((ch)->points.bank_gold)
#define GET_HITROLL(ch)	  ((ch)->points.hitroll)
#define GET_DAMROLL(ch)   ((ch)->points.damroll)

#define GET_POS(ch)	  ((ch)->char_specials.position)
#define SMALL_BITS(ch)    ((ch)->char_specials.small_bits)
#define GET_IDNUM(ch)	  ((ch)->char_specials.saved.idnum)
#define GET_ID(x)         ((x)->id)
#define IS_CARRYING_W(ch) ((ch)->char_specials.carry_weight)
#define IS_CARRYING_N(ch) ((ch)->char_specials.carry_items)
#define FIGHTING(ch)	  ((ch)->char_specials.fighting)
#define VALID_FIGHT(ch,vict)	((ch) && (vict) && \
				(ch->in_room != NOWHERE) && \
				(ch->in_room == vict->in_room))
#define VALID_FIGHTING(ch)	((ch) && VALID_FIGHT(ch, FIGHTING(ch)))
#define HUNTING(ch)	  ((ch)->char_specials.hunting)
#define MOUNTING(ch)      ((ch)->char_specials.mounting)
#define MOUNTING_OBJ(ch)  ((ch)->char_specials.mounting_obj)
#define GET_SAVE(ch, i)	  ((ch)->char_specials.saved.apply_saving_throw[i])
#define GET_ALIGNMENT(ch) ((ch)->char_specials.saved.alignment)

#define GET_COLOUR(ch, i) CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->primalsaved.colour_settings[(i)]))

/* DM - Autoassist (who this char is autoassisting, max 1)
      - Autoassisted (who is autoassisting this char, list) */
#define AUTOASSIST(ch)    ((ch)->char_specials.autoassist)
#define AUTOASSISTED(ch)  ((ch)->char_specials.autoassisted)  

#define GET_IMMKILLS(ch)	((ch)->player_specials->player_kills.immkills)
#define GET_MOBKILLS(ch)	((ch)->player_specials->player_kills.mobkills)
#define GET_PCKILLS(ch)		((ch)->player_specials->player_kills.pckills)
#define GET_KILLSBYIMM(ch)      ((ch)->player_specials->player_kills.killedbyimms)
#define GET_KILLSBYMOB(ch)      ((ch)->player_specials->player_kills.killedbymobs)
#define GET_KILLSBYPC(ch)	((ch)->player_specials->player_kills.killedbypcs)

#define GET_RACE(ch)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->primalsaved.race))
//#define GET_MODIFIER(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->primalsaved.modifier))
#define GET_COND(ch, i)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.conditions[(i)]))
#define GET_LOADROOM(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.load_room))
#define GET_PRACTICES(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.spells_to_learn))
#define GET_INVIS_TYPE(ch)      CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->primalsaved.invis_type_flag))
#define GET_INVIS_LEV(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.invis_level))
#define GET_WIMP_LEV(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.wimp_level))
#define GET_FREEZE_LEV(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.freeze_level))
#define GET_BAD_PWS(ch)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.bad_pws))
#define GET_TALK(ch, i)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.talks[i]))
#define POOFIN(ch)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->poofin))
#define POOFOUT(ch)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->poofout))
#define GET_LAST_OLC_TARG(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->last_olc_targ))
#define GET_LAST_OLC_MODE(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->last_olc_mode))
#define GET_VOTED(ch)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->has_voted))
#define GET_ALIASES(ch)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->aliases))
#define GET_LAST_TELL(ch)       CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->last_tell))
#define GET_SOCIAL_STATUS(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.social_status))
#define GET_SOCIAL_POINTS(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.social_points))
#define GET_WORSHIP_POINTS(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.worship_points))
#define SCORE_SETTINGS(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->primalsaved.score_flag))
//#define GET_QP(ch)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->primalsaved.quest_points))

/* Extended primal macros */
#ifdef IGNORE_DEBUG
#define GET_DEBUG(ch)		(0)
#else
#define GET_DEBUG(ch)		(!IS_NPC(ch) && IS_SET(SMALL_BITS(ch), SMB_DEBUG))
#endif
#define GET_IGNORE(ch, i)       ((ch)->player_specials->primalsaved.ignore[(i)].playerid)
#define GET_IGNORE_ALL(ch, i)   ((ch)->player_specials->primalsaved.ignore[(i)].allFlag)
#define GET_IGN_LVL(ch)         ((ch)->player_specials->primalsaved.ignorelvl)
#define GET_IGN_LVL_ALL(ch)     ((ch)->player_specials->primalsaved.ignorelvlall)
#define GET_FRIEND(ch, i)       ((ch)->player_specials->primalsaved.friends[(i)]) 
#define GET_STAT_POINTS(ch)   ((ch)->player_specials->primalsaved.stat_points)

#define ENTRY_ROOM(ch, wrld)    ((ch)->player_specials->primalsaved.world_entry[wrld])
#define START_WORLD(ch)         ((ch)->player_specials->primalsaved.start_world)
#define GET_PAGE_WIDTH(ch)	((ch)->player_specials->primalsaved.page_width)
#define GET_PAGE_LENGTH(ch)	((ch)->player_specials->primalsaved.page_length)
#define GET_QUEST_ITEM_DATA(ch,i) ((ch)->player_specials->primalsaved.quest_eq[(i)])
#define GET_QUEST_ITEM_NUMB(ch,i) ((ch)->player_specials->primalsaved.quest_eq[(i)].max_number)
#define GET_QUEST_ITEM(ch,i)	((ch)->player_specials->primalsaved.quest_eq[(i)].vnum)
#define GET_QUEST_ITEM_OBJ(ch,i) ((ch)->player_specials->primalsaved.quest_eq[(i)].owner)
#define GET_QUEST_ENHANCEMENT(ch, i, j) ((ch)->player_specials->primalsaved.quest_eq[(i)].enh_setting[(j)])
#define GET_QUEST_ENHANCEMENT_VALUE(ch, i, j, k) ((ch)->player_specials->primalsaved.quest_eq[(i)].enhancements[(j)][(k)])
#define GET_SKILL(ch, i)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.skills[i]))
#define SET_SKILL(ch, i, pct)	do { CHECK_PLAYER_SPECIAL((ch), (ch)->player_specials->saved.skills[i]) = pct; } while(0)
#define IS_SKILL(i)		((i > MAX_SPELLS) && (i <= MAX_SKILLS))
#define APPLY_SKILL(ch, skill, amt) (amt * (float)(GET_SKILL(ch, skill)) / 100)
#define GET_EQ(ch, i)		((ch)->equipment[i])
#define GET_EQ_WEIGHT(ch, i)    ((GET_EQ(ch, i) ? (GET_EQ(ch, i))->obj_flags.wear_flags : 0))

//Artus> Dual Wielding by EITHER Ambidex or MultiWepon. Not BOTH.
//       Seems silly to require both a special and a skill...
/* #define IS_DUAL_WIELDING(ch)    (!IS_NPC(ch) && \
      			(GET_SKILL(ch, SKILL_AMBIDEXTERITY) || \
			 IS_SET(GET_SPECIALS(ch), SPECIAL_MULTIWEAPON)) && \
			GET_EQ(ch, WEAR_WIELD) && \
			GET_EQ(ch, WEAR_HOLD) && \
	    		CAN_WEAR(GET_EQ(ch, WEAR_HOLD), ITEM_WEAR_WIELD) && \
			!GET_EQ(ch, WEAR_SHIELD)) */
#define IS_DUAL_WIELDING(ch)    (!IS_NPC(ch) && \
			IS_SET(GET_SPECIALS(ch), SPECIAL_MULTIWEAPON) && \
			GET_EQ(ch, WEAR_WIELD) && \
			GET_EQ(ch, WEAR_HOLD) && \
	    		CAN_WEAR(GET_EQ(ch, WEAR_HOLD), ITEM_WEAR_WIELD) && \
			!GET_EQ(ch, WEAR_SHIELD))


// DM - add extra check for special
/*#define IS_DUAL_CAPABLE(ch)	(!IS_NPC(ch) && \
      			(GET_SKILL(ch, SKILL_AMBIDEXTERITY) || \
                         IS_SET(GET_SPECIALS(ch), SPECIAL_MULTIWEAPON))) */
#define IS_DUAL_CAPABLE(ch)	(!IS_NPC(ch) && \
                         IS_SET(GET_SPECIALS(ch), SPECIAL_MULTIWEAPON))

#define GET_MOB_SPEC(ch)	(IS_MOB(ch) ? mob_index[(ch)->nr].func : NULL)
#define GET_MOB_RNUM(mob)	((mob)->nr)
#define GET_MOB_VNUM(mob)	(IS_MOB(mob) ? \
                                mob_index[GET_MOB_RNUM(mob)].vnum : NOBODY) 
#define GET_MOB_VZNUM(mob)      (IS_MOB(mob) ? \
                                mob_index[GET_MOB_RNUM(mob)].vznum : NOWHERE)

#define GET_DEFAULT_POS(ch)	((ch)->mob_specials.default_pos)
#define MEMORY(ch)		((ch)->mob_specials.memory)

#define STRENGTH_REAL_APPLY_INDEX(ch) \
        ( ((GET_REAL_ADD(ch)==0) || (GET_REAL_STR(ch) != 18)) ? GET_REAL_STR(ch) :\
          (GET_REAL_ADD(ch) <= 50) ? 26 :( \
          (GET_REAL_ADD(ch) <= 75) ? 27 :( \
          (GET_REAL_ADD(ch) <= 90) ? 28 :( \
          (GET_REAL_ADD(ch) <= 99) ? 29 :  30 ) ) )                   \
        ) 

#define STRENGTH_AFF_APPLY_INDEX(ch) \
        ( ((GET_AFF_ADD(ch)==0) || (GET_AFF_STR(ch) != 18)) ? GET_AFF_STR(ch) :\
          (GET_AFF_ADD(ch) <= 50) ? 26 :( \
          (GET_AFF_ADD(ch) <= 75) ? 27 :( \
          (GET_AFF_ADD(ch) <= 90) ? 28 :( \
          (GET_AFF_ADD(ch) <= 99) ? 29 :  30 ) ) )                   \
        )

#define STRTODAM(ch) (str_app[GET_STR(ch)].todam)

#define CAN_CARRY_W(ch) (str_app[STRENGTH_AFF_APPLY_INDEX(ch)].carry_w)
#define CAN_CARRY_N(ch) (5 + (GET_AFF_DEX(ch) >> 1) + (GET_LEVEL(ch) >> 1))
#define AWAKE(ch) (GET_POS(ch) > POS_SLEEPING)
#define CAN_SEE_IN_DARK(ch) \
   (AFF_FLAGGED(ch, AFF_INFRAVISION) || (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_HOLYLIGHT)))

#define IS_GOOD(ch)    (GET_ALIGNMENT(ch) >= 350)
#define IS_EVIL(ch)    (GET_ALIGNMENT(ch) <= -350)
#define IS_NEUTRAL(ch) (!IS_GOOD(ch) && !IS_EVIL(ch))

/* These three deprecated. */
#define WAIT_STATE(ch, cycle) do { GET_WAIT_STATE(ch) = (cycle); } while(0)
#define CHECK_WAIT(ch)                ((ch)->wait > 0)
#define GET_MOB_WAIT(ch)      GET_WAIT_STATE(ch)
/* New, preferred macro. */
#define GET_WAIT_STATE(ch)    ((ch)->wait)


/* descriptor-based utils ************************************************/

/* Hrm, not many.  We should make more. -gg 3/4/99 */
#define STATE(d)	((d)->connected)

#define IS_PLAYING(d)   (STATE(d) == CON_PLAYING || \
			 STATE(d) == CON_REPORT_ADD || \
                         STATE(d) == CON_REPORT_EDIT || \
			 STATE(d) == CON_REDIT || STATE(d) == CON_TEDIT || \
                         STATE(d) == CON_MEDIT || STATE(d) == CON_OEDIT || \
                         STATE(d) == CON_ZEDIT || STATE(d) == CON_SEDIT)

/* object utils **********************************************************/
#define GET_OBJ_DAMAGE(obj)	((obj)->damage)
#define GET_OBJ_MAX_DAMAGE(obj) ((obj)->max_damage)
#define OBJ_RIDDEN(obj) 	((obj)->ridden_by) 
#define GET_OBJ_LEVEL(obj)	((obj)->obj_flags.level)
#define GET_OBJ_PERM(obj)	((obj)->obj_flags.bitvector) 
#define GET_OBJ_TYPE(obj)	((obj)->obj_flags.type_flag)
#define GET_OBJ_COST(obj)	((obj)->obj_flags.cost)
#define GET_OBJ_RENT(obj)	((obj)->obj_flags.cost_per_day)
#define GET_OBJ_EXTRA(obj)	((obj)->obj_flags.extra_flags)
// Backward compatiblity
#define GET_OBJ_LR(obj)		(GET_OBJ_LEVEL((obj)))
//#define GET_OBJ_LR(obj)		((obj)->obj_flags.level_flags)
#define GET_OBJ_WEAR(obj)	((obj)->obj_flags.wear_flags)
#define GET_OBJ_VAL(obj, val)	((obj)->obj_flags.value[(val)])
#define GET_OBJ_WEIGHT(obj)	((obj)->obj_flags.weight)
#define GET_OBJ_TIMER(obj)	((obj)->obj_flags.timer)
#define GET_OBJ_RNUM(obj)	((obj)->item_number)
#define GET_OBJ_VNUM(obj)	(GET_OBJ_RNUM(obj) >= 0 ? \
                                obj_index[GET_OBJ_RNUM(obj)].vnum : NOTHING) 
#define GET_OBJ_VZNUM(obj)      (GET_OBJ_RNUM(obj) >= 0 ? \
                                obj_index[GET_OBJ_RNUM(obj)].vznum : NOWHERE)
#define IS_OBJ_STAT(obj,stat)	(IS_SET((obj)->obj_flags.extra_flags,stat))
#define IS_CORPSE(obj)		(GET_OBJ_TYPE(obj) == ITEM_CONTAINER && \
					GET_OBJ_VAL((obj), 3) == 1)
#define GET_CORPSEID(obj)       (IS_CORPSE((obj)) && \
                                        GET_OBJ_VAL((obj), 2) > 0 ? \
                                        GET_OBJ_VAL((obj), 2) : 0)

#define GET_OBJ_SPEC(obj) ((obj)->item_number >= 0 ? \
	(obj_index[(obj)->item_number].func) : NULL)

#define CAN_WEAR(obj, part) (IS_SET((obj)->obj_flags.wear_flags, (part))) 

#define CAN_WEAR_POS(ch, obj, part, pos) (CAN_WEAR((obj), (part)) \
                && eq_pos_ok((ch), (pos)))


/* compound utilities and other macros **********************************/

/*
 * Used to compute CircleMUD version. To see if the code running is newer
 * than 3.0pl13, you would use: #if _CIRCLEMUD > CIRCLEMUD_VERSION(3,0,13)
 */
#define CIRCLEMUD_VERSION(major, minor, patchlevel) \
	(((major) << 16) + ((minor) << 8) + (patchlevel))

#define HSHR(ch) (GET_SEX(ch) ? (GET_SEX(ch)==SEX_MALE ? "his":"her") :"its")
#define HSSH(ch) (GET_SEX(ch) ? (GET_SEX(ch)==SEX_MALE ? "he" :"she") : "it")
#define HMHR(ch) (GET_SEX(ch) ? (GET_SEX(ch)==SEX_MALE ? "him":"her") : "it")

#define ANA(obj) (strchr("aeiouyAEIOUY", *(obj)->name) ? "An" : "A")
#define SANA(obj) (strchr("aeiouyAEIOUY", *(obj)->name) ? "an" : "a")


/* Various macros building up to CAN_SEE */

#define LIGHT_OK(sub)	(!AFF_FLAGGED(sub, AFF_BLIND) && \
   (IS_LIGHT((sub)->in_room) || AFF_FLAGGED((sub), AFF_INFRAVISION)))

  // DM - added Advanced invis check
#define INVIS_OK(sub, obj) \
 ((!AFF_FLAGGED((obj),AFF_INVISIBLE) || AFF_FLAGGED(sub,AFF_DETECT_INVIS)) && \
 (!AFF_FLAGGED((obj), AFF_HIDE) || AFF_FLAGGED(sub, AFF_SENSE_LIFE)) && \
 (!AFF_FLAGGED((obj), AFF_ADVANCED_INVIS) || \
  AFF_FLAGGED(sub, AFF_DETECT_ADVANCED)))

#define MORT_CAN_SEE(sub, obj) ((LIGHT_OK(sub) && INVIS_OK(sub, obj)) || \
    				(!IS_NPC(sub) && !IS_NPC(obj) && \
    				 PRF_FLAGGED(sub, PRF_TAG) && \
				 PRF_FLAGGED(obj, PRF_TAG)))

#define IMM_CAN_SEE(sub, obj) \
   (MORT_CAN_SEE(sub, obj) || (!IS_NPC(sub) && PRF_FLAGGED(sub, PRF_HOLYLIGHT)))

#define SELF(sub, obj)  ((sub) == (obj))

#define INVIS_RANGE(sub, obj) (GET_INVIS_TYPE(obj) == 0 ? GET_INVIS_LEV(obj) : \
    (GET_INVIS_TYPE(obj) >= 1 ? (GET_REAL_LEVEL(sub) > GET_INVIS_LEV(obj) ? \
    (GET_REAL_LEVEL(sub) < GET_INVIS_TYPE(obj) ? GET_LEVEL(obj) : 0 ) : 0) : \
    (GET_INVIS_TYPE(obj) == -2 ? ( GET_IDNUM(sub) == GET_INVIS_LEV(obj) ? \
     GET_LEVEL(obj) : 0) : \
    (GET_REAL_LEVEL(sub) == GET_INVIS_LEV(obj) ? GET_LEVEL(obj) : 0 ))))
  
/* Can subject see character "obj"? */
#define CAN_SEE(sub, obj) (SELF(sub, obj) || \
   ((GET_REAL_LEVEL(sub) >= (IS_NPC(obj) ? 0 : INVIS_RANGE(sub, obj))) && \
    IMM_CAN_SEE(sub, obj)))

/* End of CAN_SEE */

#define INVIS_OK_OBJ(sub, obj) \
  ( (!IS_OBJ_STAT((obj), ITEM_INVISIBLE) || AFF_FLAGGED((sub), AFF_DETECT_INVIS))\
   && (!IS_OBJ_STAT((obj), ITEM_HIDDEN)) || (!IS_NPC(sub) && GET_SKILL((sub), SKILL_PERCEPTION)) )
  
  // && (!IS_OBJ_STAT((obj), ITEM_HIDDEN)) || (!IS_NPC(sub) && basic_skill_test((sub), SKILL_PERCEPTION, 1)) )

/* Is anyone carrying this object and if so, are they visible? */
#define CAN_SEE_OBJ_CARRIER(sub, obj) \
  ((!obj->carried_by || CAN_SEE(sub, obj->carried_by)) &&	\
   (!obj->worn_by || CAN_SEE(sub, obj->worn_by)))

#define MORT_CAN_SEE_OBJ(sub, obj) \
  (LIGHT_OK(sub) && INVIS_OK_OBJ(sub, obj) && CAN_SEE_OBJ_CARRIER(sub, obj))

#define CAN_SEE_OBJ(sub, obj) \
   (MORT_CAN_SEE_OBJ(sub, obj) || (!IS_NPC(sub) && PRF_FLAGGED((sub), PRF_HOLYLIGHT)))

#define CAN_CARRY_OBJ(ch,obj)  \
   (((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) <= CAN_CARRY_W(ch)) &&   \
    ((IS_CARRYING_N(ch) + 1) <= CAN_CARRY_N(ch)))

#define CAN_GET_OBJ(ch, obj)   \
   (CAN_WEAR((obj), ITEM_WEAR_TAKE) && CAN_CARRY_OBJ((ch),(obj)) && \
    CAN_SEE_OBJ((ch),(obj)))

#define PERS(ch, vict)   (CAN_SEE(vict, ch) ? GET_NAME(ch) : "someone")

#define OBJS(obj, vict) (CAN_SEE_OBJ((vict), (obj)) ? \
	(obj)->short_description  : "something")


/*#define CAN_SEE_OBJ_N(sub, obj) \
  	( LIGHT_OK(sub) && CAN_SEE_OBJ_CARRIER(sub, obj) \
  	  && !IS_OBJ_STAT((obj), ITEM_HIDDEN) \
  	  && (!IS_OBJ_STAT((obj), ITEM_INVISIBLE) \
  	       || AFF_FLAGGED((sub), AFF_DETECT_INVIS)) ) */

#define OBJN(obj, vict) (CAN_SEE_OBJ((vict), (obj)) ? \
	fname((obj)->name) : "something")

#define EXIT(ch, door)         (world[(ch)->in_room].dir_option[door])
#define W_EXIT(room, num)      (world[(room)].dir_option[(num)])
#define R_EXIT(room, num)      ((room)->dir_option[(num)])

#define CAN_GO(ch, door) (EXIT(ch,door) && \
			 (EXIT(ch,door)->to_room != NOWHERE) && \
			 !IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED))


#define CLASS_ABBR(ch) (IS_NPC(ch) ? "--" : class_abbrevs[(int)GET_CLASS(ch)])
#define CLASS_NAME(i)  (pc_class_types[(int)(i)]) 

#define RACE_ABBR(ch)  (IS_NPC(ch) ? "--" : race_abbrevs[(int)GET_RACE(ch)])

#define IS_MAGIC_USER(ch)	(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_MAGIC_USER) || \
				(GET_CLASS(ch) == CLASS_SPELLSWORD) || \
				(GET_CLASS(ch) == CLASS_DRUID)      || \
				(GET_CLASS(ch) == CLASS_BATTLEMAGE) || \
				(GET_CLASS(ch) == CLASS_MASTER) )

#define IS_CLERIC(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_CLERIC)     || \
				(GET_CLASS(ch) == CLASS_PRIEST)     || \
				(GET_CLASS(ch) == CLASS_DRUID)      || \
				(GET_CLASS(ch) == CLASS_PALADIN)    || \
				(GET_CLASS(ch) == CLASS_MASTER) )

#define IS_THIEF(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_THIEF)	    || \
				(GET_CLASS(ch) == CLASS_PRIEST)     || \
				(GET_CLASS(ch) == CLASS_NIGHTBLADE) || \
				(GET_CLASS(ch) == CLASS_SPELLSWORD) || \
				(GET_CLASS(ch) == CLASS_MASTER) )

#define IS_WARRIOR(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_WARRIOR)    || \
				(GET_CLASS(ch) == CLASS_BATTLEMAGE) || \
				(GET_CLASS(ch) == CLASS_NIGHTBLADE) || \
				(GET_CLASS(ch) == CLASS_PALADIN)    || \
				(GET_CLASS(ch) == CLASS_MASTER) )

#define IS_NIGHTBLADE(ch)	(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_NIGHTBLADE))
#define IS_BATTLEMAGE(ch)	(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_BATTLEMAGE))
#define IS_DRUID(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_DRUID))
#define IS_PRIEST(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_PRIEST))
#define IS_PALADIN(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_PALADIN))
#define IS_SPELLSWORD(ch)	(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_SPELLSWORD))

#define IS_MASTER(ch)		(!IS_NPC(ch) && \
				(GET_CLASS(ch) == CLASS_MASTER))


#define OUTSIDE(ch) ((!ROOM_FLAGGED((ch)->in_room, ROOM_INDOORS) && \
    		     (BASE_SECT(SECT((ch)->in_room)) != SECT_INSIDE) && \
		     (BASE_SECT(SECT((ch)->in_room)) != SECT_UNDERWATER)))

#define UNDERWATER(ch) (BASE_SECT(SECT((ch)->in_room)) == SECT_UNDERWATER)


/* OS compatibility ******************************************************/


/* there could be some strange OS which doesn't have NULL... */
#ifndef NULL
#define NULL (void *)0
#endif

#if !defined(FALSE)
#define FALSE 0
#endif

#if !defined(TRUE)
#define TRUE  (!FALSE)
#endif

/* defines for fseek */
#ifndef SEEK_SET
#define SEEK_SET	0
#define SEEK_CUR	1
#define SEEK_END	2
#endif

/*
 * NOCRYPT can be defined by an implementor manually in sysdep.h.
 * CIRCLE_CRYPT is a variable that the 'configure' script
 * automatically sets when it determines whether or not the system is
 * capable of encrypting.
 */
#if defined(NOCRYPT) || !defined(CIRCLE_CRYPT)
#define CRYPT(a,b) ((const char *)(a))
#else
#define CRYPT(a,b) ((char *) crypt((const char *)(a),(const char *)(b)))
#endif

/* Gun defines */
#define BASE_GUN_TYPE           20
#define MAX_GUN_TYPES           30
#define GUN_BIT                 0x8000 /* 1000 0000 0000 0000 */
#define GUN_BITS                0x7fff /* 0111 1111 1111 1111 */
#define AMMO_BIT                0x4000 /* 0100 0000 0000 0000 */
#define AMMO_BITS               0x3fff /* 0011 1111 1111 1111 */
 
#define OBJ_IS_GUN(x)   ((GET_OBJ_VAL((x),3) & GUN_BITS) >= BASE_GUN_TYPE \
                        && (GET_OBJ_VAL((x),3) & GUN_BITS) <= \
                        (BASE_GUN_TYPE + MAX_GUN_TYPES))

#define OBJ_IS_AMMO(x)  (GET_OBJ_VAL((x),3) & AMMO_BIT)

#define AMMO_BELONGS_TO(x,y)    (OBJ_IS_AMMO((x)) && OBJ_IS_GUN((y)) && \
          ((GET_OBJ_VAL((x),3) & AMMO_BITS) == (GET_OBJ_VAL((y),3) & GUN_BITS)))

/* macros to decode the bit map in the sect type */
#define BASE_SECT(n) ((n) & 0x000f)

#define ATMOSPHERE(n)  (((n) & 0x0070) >> 4)
#define TEMPERATURE(n) (((n) & 0x0380) >> 7)
#define GRAVITY(n)     (((n) & 0x1c00) >> 10)
#define ENVIRON(n)     (((n) & 0xe000) >> 13)

/* JA new sector types, ther are 4 types of sector attributes
 *    each taking up 3 bits in the sector type integer, the lower
 *       4 bits remain as the base for the movement loss */
#define SECT_THIN             1
#define SECT_UNBREATHABLE     2
#define SECT_VACUUM           3
#define SECT_CORROSIVE        4
#define SECT_HOT              1
#define SECT_SCORCH           2
#define SECT_INCINERATE       3
#define SECT_COLD             4
#define SECT_FREEZING         5
#define SECT_ABSZERO          6
#define SECT_DOUBLEGRAV       1
#define SECT_TRIPLEGRAV       2
#define SECT_CRUSH            3
#define SECT_RAD1             1
#define SECT_DISPELL          2
#define SECT_DISPAIR1         3
#define SECT_DISPAIR2         4 
#define SECT_DISPAIR3         5

#define SECT_TYPE_BASE          0
#define SECT_TYPE_ATMOS         1
#define SECT_TYPE_TEMP          2
#define SECT_TYPE_GRAV          3
#define SECT_TYPE_ENVIRO        4

// long revision bit victor description
// XCMM MMMM MMMM BBBB BBBB BBNN NNNN NNNN
// X - UNUSED, M - MAJOR, B - BRANCH, N - MINOR 
#define REV_MINOR(n)  (((n) & 0x000003ff) >> 10)
#define REV_BRANCH(n)  (((n) & 0x000ffc00) >> 20)
#define REV_MAJOR(n)  (((n) & 0x3ff00000) >> 30)
#define REV_CVSUPTODATE(n)  (((n) & 0x40000000) >> 31)

#define SENDOK(ch) ((ch) && (ch)->desc && (to_sleeping || AWAKE(ch)) && \
                        (IS_NPC(ch) || \
                         !PLR_FLAGGED((ch), \
                          PLR_WRITING | PLR_MAILING | PLR_ODDWRITE)))
  
// Dm - added this so acts only go to playing chars - if acts arn't 
// working correctly, check this ... 
#define SENDTOOK(ch)    (SENDOK((ch)) && STATE((ch)->desc) == CON_PLAYING)
@


1.73
log
@Artus> Finished off movement changes.
@
text
@d58 1
@


1.72
log
@Artus> Changed LR_FAIL_MAX to respect UNHOLINESS.
@
text
@d108 2
a109 1
int	do_simple_move(struct char_data *ch, int dir, int following);
@


1.71
log
@Artus> GET_QUEST_ITEM_DATA() for quest_obj_data struct.
@
text
@d404 1
a404 1
#define LR_FAIL_MAX(ch, lvl) ((GET_LEVEL(ch) < lvl) && ((lvl > LVL_IMMORT) || ((GET_REM_ONE(ch) < lvl) && (GET_REM_TWO(ch) < lvl))))
d409 1
a409 1
			LR_FAIL(ch, LVL_IMMORT)))
@


1.70
log
@Artus> Optimised IS_PLAYING() a little.
@
text
@d532 1
@


1.69
log
@Artus> Unholy Vengeance.
@
text
@d619 6
a624 6
#define IS_PLAYING(d)   (STATE(d) == CON_TEDIT || STATE(d) == CON_REDIT || \
                        STATE(d) == CON_MEDIT || STATE(d) == CON_OEDIT || \
                        STATE(d) == CON_ZEDIT || STATE(d) == CON_SEDIT || \
                        STATE(d) == CON_REPORT_ADD || \
                        STATE(d) == CON_REPORT_EDIT || \
                        STATE(d) == CON_PLAYING)
@


1.68
log
@Artus> Anyone can now become a ghost.
@
text
@d57 1
d327 1
@


1.67
log
@Artus> Prototype for is_valid_char().
@
text
@d278 1
a278 1
#define IS_GHOST(ch) (!IS_NPC(ch) && (IS_SET(EXT_FLAGS(ch), EXT_GHOST)) && (GET_LEVEL(ch) <= LVL_NEWBIE))
@


1.66
log
@Artus> Now warning free :o)
@
text
@d65 1
@


1.65
log
@Artus> Added (ch) check in SENDOK.
@
text
@d309 1
a309 1
#define SPELL_EFFEC(ch, spl)  (spell_info[spl].spell_effec[GET_CLASS(ch)])
d543 1
a543 1
// #define IS_DUAL_WIELDING(ch)    (!IS_NPC(ch) && \
d549 1
a549 1
			!GET_EQ(ch, WEAR_SHIELD))
d559 1
a559 1
//#define IS_DUAL_CAPABLE(ch)	(!IS_NPC(ch) && \
d561 1
a561 1
                         IS_SET(GET_SPECIALS(ch), SPECIAL_MULTIWEAPON)))
d745 5
a749 5
//#define CAN_SEE_OBJ_N(sub, obj) \
//	( LIGHT_OK(sub) && CAN_SEE_OBJ_CARRIER(sub, obj) \
//	  && !IS_OBJ_STAT((obj), ITEM_HIDDEN) \
//	  && (!IS_OBJ_STAT((obj), ITEM_INVISIBLE) \
//	       || AFF_FLAGGED((sub), AFF_DETECT_INVIS)) )
@


1.64
log
@Artus> One more log bug.
@
text
@d916 1
a916 1
#define SENDOK(ch) ((ch)->desc && (to_sleeping || AWAKE(ch)) && \
@


1.63
log
@Artus> Modifications for tag.
@
text
@d691 2
a692 1
    				(PRF_FLAGGED(sub, PRF_TAG) && \
@


1.62
log
@Artus> Conditionals for IGNORE_DEBUG.
@
text
@d690 3
a692 1
#define MORT_CAN_SEE(sub, obj) (LIGHT_OK(sub) && INVIS_OK(sub, obj))
@


1.61
log
@Artus> Added LASTROOM macro.
@
text
@d513 3
d517 1
@


1.60
log
@Artus> Added VALID_FIGHT and VALID_FIGHTING macros.
@
text
@d41 2
a42 1
void	log_death_trap(struct char_data *ch);
d348 1
@


1.59
log
@Added BACKWARD roomflag
Added DISPAIR environ flag
Added code for objects which make objects
@
text
@d462 4
@


1.58
log
@Artus> Added DBG define for mudlog.
@
text
@d885 3
@


1.57
log
@Artus> APPLY_SPELL_EFFEC, APPLY_SKILL
@
text
@d152 1
@


1.56
log
@Artus> LR_FAIL_MAX fix, SPECIAL_TRACKER now provides SKILL_TRACK.
       Track and hunt now increase.
@
text
@d308 1
d398 1
a398 1
#define LR_FAIL_MAX(ch, lvl) ((GET_LEVEL(ch) < lvl) && (lvl <= LVL_IMMORT) && (GET_REM_ONE(ch) < lvl) && (GET_REM_TWO(ch) < lvl))
d526 1
@


1.55
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d397 1
a397 1
#define LR_FAIL_MAX(ch, lvl) ((GET_LEVEL(ch) < lvl) || ((lvl <= LVL_IMMORT) && (GET_REM_ONE(ch) < lvl) && (GET_REM_TWO(ch) < lvl)))
@


1.54
log
@Artus> Intermittent build.
act.informative.c: Affect/Timers now display something when no affects/timers
                   are present.
                   Sense curse now senses objects inside containers.
act.movement.c   : Optimised the aggravate stuff a little.
act.offensive.c  : Logging death by pit trap.
act.other.c      : Logging death by suicide.
                   Superman now sets affects rather than actual stats, for STR
                   and CON (CON bonus is +1, STR is 21 - GET_REAL_STR
                   Logging death by arrow.
clan.c           : Removed aggravate_check() function, no longer used.
db.c             : Now initialising character specials.
dg_mobcmd.c      : Logging death by mdamage.
dg_objcmd.c      : Logging death by odamage.
dg_wldcmd.c      : Logging death by wdamage.
fight.c          : New optional msg paramater to die(), for if the death was
                   not caused by a character.
                   Deaths are now logged to info channel.
handler.c        : Modified ability affect function to permit more than one
                   affect modifier per special. (Required for superman)
spec_procs.c     : Logging death by pit trap, archers and room blast.
spells.h         : Added SPELL_SUPERMAN for special affect modifiers.
utils.h          : Updated die() prototype to match changes in fight.c.
@
text
@d268 1
d298 1
d395 9
d578 2
@


1.53
log
@Artus> Moving stuff across to live.

act.informative.c:
  Info on it's own will now display the info file. Use me or self to see your
own info.
  Score and Exp now both show gained and remaining exp.
  Gold value is now to a max of 30000. (60000 in lvl 40+ zones, 120 in 70+)
  Gold rushes no longer occur in !GOLDRUSH zones, city sectors, etc.

act.other.c:
  Mana retained on remort is now floored at 100 instead of 50.
  Added elitist bonus for chars who play past the earliest remort point(s).

act.wizard.c:
  Gold rush events are now only advertised within the world they occur.

genolc.h:
  Added special #defines for different OLC levels whether running live or test.
  (Noted by compiling with -DPRIMAL_LIVE)

interpreter.c:
  Aliases will now be saved automatically, when added or remoed.
  Added elitist_modifier() to modifier calculation.
  Replaced Huh?!? with HUH.

limits.c:
  NPC corpses are no longer emptied before they are purged. Too much clutter.

spells.c:
  Reduced the amount of weight applied by create water to 1/3 of what it was.

comm.c:       Added send_to_not_zone_world()
db.c:         Added elitist_modifier() to modifier calculation.
dg_mobcmd.c:  Replaced Huh?!? with the define, HUH.
dg_scripts.h: Changed version string so it will fit on one line :o)
fight.c:      Eq should no longer be damaged when a hit fails.
handler.c:    Now, when the sleep spell wears of an NPC, it will wake up.
structs.h:    Added HUH define.
utils.c:      Added elitist_modifier() calculation.
utils.h:      Added elitist_modifier() prototype.
@
text
@d131 1
a131 1
void die(struct char_data * ch, struct char_data *killer);
@


1.52
log
@Artus> Mostly just cosmetic changes, mostly for underwater stuff..
       Added some more stuff to dg_scripts:

       %actor.affected(aff_bit)% - Is actor affected by whatever.
       %self.people(countpc)%    - (Rooms): Count players.
       %self.people(countnpc)%   - (Rooms): Count npcs.
       %self.people(countall)%   - (Rooms): Count chars.
       %firstchar.<room_vnum>%   - First character in room <vnum>

       Possibly a bugfix to one of the forest specials that was attacking you
       if you were affected by poison.
@
text
@d55 1
@


1.51
log
@Artus>
\r\n appended to gold rush message: act.informative.c

Imms no longer affected by underwater: act.movement.c, limits.c

Changed remort some more.. New special, tracker (SPECIAL_TRACKER):
act.other.c, act.wizard.c, constants.c, graph.c, structs.h, utils.c

Object and Room triggers can now %send% <room vnum> <message>:
dg_objcmd.c, dg_wldcmd.c

%self.direction% now has a vnum subfield to return the exit room's vnum.
(Eg: %self.north(vnum)%): dg_scripts.c

%actor.hisher%, %actor.himher%, %actor.heshe% implemented: dg_scripts.c

vnum, name, can_see, can_see_me added to %actor.next_in_room%, returning char
vnum, char name, if actor can see char, and if char can see actor respectively:
dg_scripts.c

Changed "do not know that spell" to "do not know of that spell": spell_parser.c

Changed "do not of know that skill/spell" to "do not know of..": utils.c

SECT_UNDERWATER and SECT_INSIDE now checked in OUTSIDE() macro: utils.h
@
text
@d784 4
a787 2
    		     (BASE_SECT((ch)->in_room) != SECT_INSIDE) && \
		     (BASE_SECT((ch)->in_room) != SECT_UNDERWATER)))
@


1.50
log
@Artus> Breakin now requires mount skill, and is tested vs it.
       Remort ability list changed some more, also remort ability parser.
       DGScript Force/Teleport commands now tell >=LVL_ANGEL what they were
       trying to do..
       MultiWeapon is once more required for dual wield.
       Lowered exp gained whilst grouping by about 30%.
@
text
@d783 3
a785 1
#define OUTSIDE(ch) (!ROOM_FLAGGED((ch)->in_room, ROOM_INDOORS))
@


1.49
log
@Artus> Changed remort, in particular, list remort abilities to char.. Also,
       spellsword was incorrectly being listed as a possible path for a
       warrior.

       Replaced #ifdef USE_LOCALTIME with #ifndef NO_LOCALTIME..

       Added define NOTELL_SOUNDPROOF .. Define this to stop people telling
       to/from soundproof rooms.

       Removed extraneous level checking from do_wear.. This is handled
       better by perform_wear.
@
text
@d518 1
a518 1
#define IS_DUAL_WIELDING(ch)    (!IS_NPC(ch) && \
d525 7
d534 1
a534 1
#define IS_DUAL_CAPABLE(ch)	(!IS_NPC(ch) && \
d537 2
@


1.48
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@d65 1
a65 1
#ifndef USE_LOCALTIME
@


1.47
log
@Artus> Changes to do_simple_move().
       Added char_can_enter() -- Tests room levels, zone levels, water/fly/etc.

       Changes to die(): Exp lost is now whichever is lesser of half earned
       exp and quater max exp. When autocorpse, instead of doubling it, we
       multiply by 1.5.

       pc killed by char now logged in die(), with lost_exp display.

       gain_exp now returns the amount of exp that was gained rather than void.
@
text
@d20 1
d22 1
d200 1
a200 1
		log("SYSERR: Zero bytes or less requested at %s:%d.", __FILE__, __LINE__);	\
d247 1
a247 1
	(*(((ch)->player_specials == &dummy_mob) ? (log("SYSERR: Mob using '"#var"' at %s:%d.", __FILE__, __LINE__), &(var)) : &(var)))
@


1.46
log
@Artus> Sorry, Dish.. Another bastard change..

       has_stats_for_skill now takes an extra arg (bool) to determine whether
       or not to display messages.

       new routine: has_stats_for_prac.. Basically the same as
       has_stas_for_skill, without GET_SKILL(ch, i) == 0 check..

       Force is now restricted for <GRGOD.

       Score no longer displays punishment lines twice.

       New macro: IS_SKILL(skillnum) .. Used to determine whether skillnum is
                  a skill.
@
text
@d115 1
a115 1
void	gain_exp(struct char_data *ch, int gain);
@


1.45
log
@Artus> Dual Wielding Wear/Remove/Display/Fighting Fixes.
       Cursed items can no longer be sold.
       Bodyslam message now appears in the right spot (hopefully).

       NOTE: IS_DUAL_WIELDING(ch) and IS_DUAL_CAPABLE(ch) defines in utils.h
             have been modified... If you plan to use them, check out how they
	     have changed first :o)
@
text
@d49 1
a49 1
int 	has_stats_for_skill(struct char_data *ch, int skillnum);
d510 1
a510 1

@


1.44
log
@Artus> (Hopefully) Fixed all cases where the skill message would display after
       the victim had fled.

       Moved remaining violence checks from damage() to violence_check().

       damage() now takes an additional boolean arg, vcheck, when true,
       violence_check() will be called.

       added GET_EQ_WEIGHT(ch, wear_pos) define.
@
text
@d514 2
d517 2
a518 1
    			GET_SKILL(ch, SKILL_AMBIDEXTERITY) && \
d521 2
a522 1
	    		CAN_WEAR(GET_EQ(ch, WEAR_HOLD), ITEM_WEAR_WIELD))
d526 2
a527 2
    			GET_SKILL(ch, SKILL_AMBIDEXTERITY) && IS_SET(GET_SPECIALS(ch), SPECIAL_MULTIWEAPON) && \
			!GET_EQ(ch, WEAR_SHIELD))
@


1.43
log
@Artus> A3_0_315
@
text
@d512 1
@


1.42
log
@Work done at artus house a while ago
@
text
@d601 1
a601 1
                                obj_index[GET_OBJ_RNUM(obj)].zvnum : NOWHERE)
@


1.41
log
@Latest Version
@
text
@d89 1
@


1.40
log
@Artus> Localtime fix.
@
text
@d490 1
a490 1
#define GET_DEBUG(ch)		(IS_SET(SMALL_BITS(ch), SMB_DEBUG))
@


1.39
log
@
Modified: DM

Changed: (This is a group checkin)
- many many bug fixes
@
text
@d62 5
a66 2
// DM - temp localtime fix
struct tm *localtime(const time_t *timer);
d518 1
d520 1
a520 1
    			GET_SKILL(ch, SKILL_AMBIDEXTERITY) && \
@


1.38
log
@
Modified: DM

Changed:
- Don't ask (large group checkin) - lots of bug fixes mainly.
- Use cvs diff if you really wanna see the changes.
@
text
@d124 1
@


1.37
log
@
Modified: DM

Added:
- overridden localtime() definition
@
text
@d102 1
a102 1
int Valid_Name(char *newname);
d346 5
d664 3
a666 1
   && (!IS_OBJ_STAT((obj), ITEM_HIDDEN)) || (!IS_NPC(sub) && basic_skill_test((sub), SKILL_PERCEPTION, 1)) )
d689 1
a689 1
#define OBJS(obj, vict) (CAN_SEE_OBJ_N((vict), (obj)) ? \
a691 5
#define CAN_SEE_OBJ_N(sub, obj) \
	( LIGHT_OK(sub) && CAN_SEE_OBJ_CARRIER(sub, obj) \
	  && !IS_OBJ_STAT((obj), ITEM_HIDDEN) \
	  && (!IS_OBJ_STAT((obj), ITEM_INVISIBLE) \
	       || AFF_FLAGGED((sub), AFF_DETECT_INVIS)) )
d693 7
a699 1
#define OBJN(obj, vict) (CAN_SEE_OBJ_N((vict), (obj)) ? \
@


1.36
log
@
Modifed: DM

Added:
- INVIS_RANGE - old macro previously used in CAN_SEE

Changed:
- IS_GHOST to include a !IS_NPC check
@
text
@d62 3
@


1.35
log
@
Modified: DM

Added:
- quest_obj_ok function declaration
@
text
@d263 1
a263 1
#define IS_GHOST(ch) ((IS_SET(EXT_FLAGS(ch), EXT_GHOST)) && (GET_LEVEL(ch) <= LVL_NEWBIE))
d640 7
d649 2
a650 2
   ((GET_REAL_LEVEL(sub) >= (IS_NPC(obj) ? 0 : GET_INVIS_LEV(obj))) && \
   IMM_CAN_SEE(sub, obj)))
@


1.34
log
@Artus> Added ghosts.. Newbies no longer die, they become ghosts.
@
text
@d60 1
@


1.33
log
@Jus> Fixed a bunch of badly written for loops.. Modified who list to show all
     three levels. Modified who list to allow a string to be placed instead of
     level/class/etc. This string can be set with the
     set <player> whostring [string] command (LR_GRGOD+).
     If [string] is blank, level/class/etc will be displayed.
@
text
@d262 1
@


1.32
log
@
Modified: DM

Changed:
- quest points -> stat points
@
text
@d341 1
@


1.31
log
@*** empty log message ***
@
text
@d157 1
a157 1
#define SECS_PER_MUD_HOUR	75
d472 1
a472 1
#define GET_QP(ch)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->primalsaved.quest_points))
d481 1
a481 1
#define GET_QUEST_POINTS(ch)   ((ch)->player_specials->primalsaved.quest_points)
@


1.30
log
@
Modified: DM

Changed:
- GET_OBJ_LR (obsolete?, level_flags) to GET_OBJ_LEVEL (new, level)
@
text
@d623 1
d626 3
a628 1
 (!AFF_FLAGGED((obj), AFF_HIDE) || AFF_FLAGGED(sub, AFF_SENSE_LIFE)))
@


1.29
log
@Art> Modified compute_armor_class() and thaco().. Most notable, thaco() now
expects ch, victim (victim may be null), for mob thaco calculations. Probably
should have done it with FIGHTING(ch) but oh well. :o). Also added in some
debug stuff, including a debug flag. A byte sized bitvector that's not saved,
char_special_data.small_bits or SMALL_BITS(ch).. GET_DEBUG() for debug.
@
text
@d573 3
a575 1
#define GET_OBJ_LR(obj)		((obj)->obj_flags.level_flags)
@


1.28
log
@Modified: DM

Added: few more macros
@
text
@d116 1
a116 1
int     thaco(struct char_data *ch);
d424 1
d475 1
@


1.27
log
@Artus - Modified CAN_SEE_OBJ, OBJN, OBJS..
@
text
@d338 3
d382 2
d494 10
@


1.26
log
@Added: basic_skill_test define..
@
text
@a621 1

d624 1
a624 1
   && (!IS_OBJ_STAT((obj), ITEM_HIDDEN)) )
d647 1
a647 1
#define OBJS(obj, vict) (CAN_SEE_OBJ((vict), (obj)) ? \
d650 7
a656 1
#define OBJN(obj, vict) (CAN_SEE_OBJ((vict), (obj)) ? \
a657 1

@


1.25
log
@Modified: DM

Added:
- ASSIGNXXX protos
- define for SPELL_EFFECT: the spell effeciency for a particular spell a ch has
@
text
@d22 2
d127 1
@


1.24
log
@Artus - Added a couple of defines for offences and punishments. eg HAS_OFFENDED
@
text
@d59 3
d122 4
d288 2
@


1.23
log
@Artus - GET_MOBKILLS/GET_KILLSBYMOB etc..
@
text
@d288 3
a290 2
#define PUN_TOG_CHK(ch,flag) ((TOGGLE_BIT(PUN_FLAGS(ch), (1 << flag))) & (1 << flag)) // Punish - ARTUS 

d292 2
a293 1
#define INSTIGATOR(ch)          CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->instigator))                 /* ARTUS - Who initiated combat? */
@


1.22
log
@Artus - Mob_Zombie, Is_Zombie..
@
text
@d424 6
@


1.21
log
@Modified: Artus - Clans, Punish..
@
text
@d123 1
d261 3
@


1.20
log
@
Added:
- GET_FIGHT_PROMPT
@
text
@d237 1
d267 1
d284 1
d286 2
a451 2
#define GET_CLAN_NUM(ch)	((ch)->player_specials->primalsaved.clan_num)
#define GET_CLAN_LEV(ch)	((ch)->player_specials->primalsaved.clan_level)
@


1.19
log
@
Added:
- GET_PROMPT macro for user definable prompts
@
text
@d330 1
@


1.18
log
@

Added:
- START_WORLD(ch) macro

Changed:
- declaration of get_world(struct char_data *ch) -> get_world(room_rnum room)
@
text
@d329 2
@


1.17
log
@
Added:
- RACE_ABBREV macro
@
text
@d48 1
a48 1
int     get_world(struct char_data *ch); 
d447 1
@


1.16
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d636 2
@


1.15
log
@
Changed:
- another IS_BUILDING fix (had to check ch->desc is not NULL before using it in
  other macros)
@
text
@d134 1
d394 1
d776 9
@


1.14
log
@
Changed:
- fixed IS_BUILDING macro (typo on IS_NPC(ch) -> !IS_NPC(ch))
@
text
@d250 3
a252 2
#define IS_BUILDING(ch) (!IS_NPC(ch) && (STATE((ch)->desc) >= CON_OEDIT && \
                                        STATE((ch)->desc) <= CON_TEDIT))
@


1.13
log
@
Added:
- IS_BUILDING macro
@
text
@d250 1
a250 1
#define IS_BUILDING(ch) (IS_NPC(ch) && (STATE((ch)->desc) >= CON_OEDIT && \
@


1.12
log
@
Added:
- Revisions, stat, state macros
@
text
@d250 3
@


1.11
log
@
Added:
- function declarations of new eq functions, files_need_saving (olc)
- new macros:
  - GET_FRIEND
  - GET_MOB_VZNUM
  - GET_OBJ_VZNUM
  - GET_CORPSE_ID
  - CAN_WEAR_POS
- reason argument to demote_level function declaration
@
text
@d23 2
d356 10
d436 1
d502 5
a506 3
#define IS_PLAYING(d)   (STATE(d) == CON_TEDIT || STATE(d) == CON_REDIT ||      \
                        STATE(d) == CON_MEDIT || STATE(d) == CON_OEDIT ||       \
                        STATE(d) == CON_ZEDIT || STATE(d) == CON_SEDIT ||       \
d763 7
@


1.10
log
@
Added:
- Ahh, too much stuff, sorry was ages since this stuff was last checked in
@
text
@d23 2
d98 1
a98 1
void    demote_level(struct char_data *ch,int newlevel);
d114 3
d418 1
a418 1
/* Extended primal character variables */
d423 1
d444 2
d512 2
d517 3
d524 4
a527 1
#define CAN_WEAR(obj, part) (IS_SET((obj)->obj_flags.wear_flags, (part)))
@


1.9
log
@
Added:
- newbie logging
- random hint channel

Changed:
- Rewrote the ignore code, ignore char all/tells, ignore level all/tells
@
text
@d11 3
d677 1
a677 1
#define CRYPT(a,b) (a)
d679 1
a679 1
#define CRYPT(a,b) ((char *) crypt((a),(b)))
d685 4
d690 8
a697 3
#define OBJ_IS_GUN(x)                   ((GET_OBJ_VAL((x),3) & 0x7fff) >= BASE_GUN_TYPE \
                                                                                                          && (GET_OBJ_VAL((x),3) & 0x7fff) <= \
                                                                                                         (BASE_GUN_TYPE + MAX_GUN_TYPES))
@


1.8
log
@
Added:
- timers (like affects)
- new skills, fixes

TODO:
- test timers on objects - add to stat obj screen
@
text
@d411 5
a415 5
#define GET_IGN1(ch) 		((ch)->player_specials->primalsaved.ignore1)
#define GET_IGN2(ch)		((ch)->player_specials->primalsaved.ignore2)
#define GET_IGN3(ch)		((ch)->player_specials->primalsaved.ignore3)
#define GET_IGN_LEVEL(ch)	((ch)->player_specials->primalsaved.ignorelev)
#define GET_IGN_NUM(ch)		((ch)->player_specials->primalsaved.ignorenum)
@


1.7
log
@
Added:

- Changes on the latest circle snapshot:
========================================
1/23/2000

no -- gg - constants.c/structs.h: Welcome to bpl18.

no -- gg - Makefile.lcc: Remove some constants I have to change every patch.

no -- gg - doc/README.CYGWIN: bpl17 -> bpl18

7/3/2000

no -- gg - doc/license.doc: Add copyright information that seems lacking
        elsewhere.

no -- gg - build_circlemud.com: Update from author.

yes -- gg - utils.h: -1 => NOBODY/NOWHERE/NOTHING cleanups.

yes (and other relevant ROOM flags)
-- gg - spells.c: spell_teleport(): No teleporting into ROOM_GODROOM.

yes -- gg - spec_procs.c: Restrict pets to NPCs.

yes? -- gg - interpreter.c: is_abbrev(): s/returnss/returns/

yes -- gg - handler.c: affect_join(): Keep 'next' pointer for extracted
        objects in list.

no -- gg - act.wizard.c: perform_immort_invis(): Remove redundant
        IS_NPC check.

yes ? -- gg - utils.c: basic_mud_log(): Cancel message if stream hasn't
        been initialized.

7/7/2000

yes ? -- gg - utils.c: mudlog(): log(var) => log("%s", var); to avoid
        interpreting %% codes.

yes - drink aliases no -- gg - db.c: parse_object(): Print the offending character.
        check_object(): Drink aliases should last now.  The code
        to remove the aliases shouldn't care where it is, though.

no -- gg - act.item.c: name_from_drinkcon()/name_to_drinkcon():
        Much more intelligent support for removing/adding the
        drink name to containers.

no -- gg - lib/world/obj/0.obj: An extra ~ escaped the removal of
        object #99.
@
text
@d219 3
@


1.6
log
@
Added:
- olc stuff - sectors, zone flags

Changed:
- Heaps of little fixes ....
@
text
@d431 1
a431 1
				 mob_index[GET_MOB_RNUM(mob)].vnum : -1)
d497 1
a497 1
				 obj_index[GET_OBJ_RNUM(obj)].vnum : -1)
@


1.5
log
@

Added:
- more shite
@
text
@d710 7
@


1.4
log
@

Added:
- Events
-

Changed:
- Score command
-

TODO:
- Finish the base
-
@
text
@d405 1
@


1.3
log
@my new skills!


Added:
-
-

Removed:
-
-

Changed:
-
-

TODO:
-
-
@
text
@d231 2
a232 1
  
d250 2
d398 1
d400 6
a405 1
#define GET_LAST_TELL(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->last_tell))
@


1.2
log
@
Added:
- Some initial colour coding for mobs and objects

Changed:
- Various inclusions from the existing primal base ...
- Including Sector fixes, clan guards, listing items

TODO:
- Fix colours for mobs/objects - A player comes up as a mob colour
@
text
@d20 1
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d299 8
d672 27
@

