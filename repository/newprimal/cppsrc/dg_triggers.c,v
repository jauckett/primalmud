head	1.9;
access;
symbols;
locks; strict;
comment	@ * @;


1.9
date	2004.03.11.00.24.22;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.23.11.53.16;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.17.23.24.09;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.17.12.36.24;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.26.06.49.04;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.07.09.00.50;	author primal;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.07.08.50.19;	author karma;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.27.12.48.30;	author primal;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.02.04.34.48;	author primal;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Artus> fight_mtrigger now returns an int rather than void.
       -- returns 1 in the case that the trigger executed. Mostly
          so death checks can be performed.
@
text
@/**************************************************************************
*  File: triggers.c                                                       *
*                                                                         *
*  Usage: contains all the trigger functions for scripts.                 *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Death's Gate MUD is based on CircleMUD, Copyright (C) 1993, 94.        *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
*                                                                         *
*  $Author: mud $
*  $Date: 2004/01/23 11:53:16 $
*  $Revision: 1.8 $
**************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "oasis.h"

extern struct index_data **trig_index;
extern struct room_data *world;
extern char *dirs[];

#ifndef LVL_BUILDER
#define LVL_BUILDER LVL_GOD
#endif


/* external functions from scripts.c */
void add_var(struct trig_var_data **var_list, char *name, char *value, long id);
int script_driver(void *go, trig_data *trig, int type, int mode);
char *matching_quote(char *p);
char *str_str(char *cs, char *ct);


/* mob trigger types */
char *trig_types[] = {
  "Global", 
  "Random",
  "Command",
  "Speech",
  "Act",
  "Death",
  "Greet",
  "Greet-All",
  "Entry",
  "Receive",
  "Fight",
  "HitPrcnt",
  "Bribe",
  "Load",
  "Memory",
  "\n"
};


/* obj trigger types */
char *otrig_types[] = {
  "Global",
  "Random",
  "Command",
  "UNUSED",
  "UNUSED",
  "Timer",
  "Get",
  "Drop",
  "Give",
  "Wear",
  "UNUSED",
  "Remove",
  "UNUSED",
  "Load",
  "UNUSED",
  "\n"
};


/* wld trigger types */
char *wtrig_types[] = {
  "Global",
  "Random",
  "Command",
  "Speech",
  "UNUSED",
  "Zone Reset",
  "Enter",
  "Drop",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "\n"
};


/*
 *  General functions used by several triggers
 */


/*
 * Copy first phrase into first_arg, returns rest of string
 */
char *one_phrase(char *arg, char *first_arg)
{
    skip_spaces(&arg);

    if (!*arg)
       *first_arg = '\0';

    else if (*arg == '"')
    {
       char *p, c;

       p = matching_quote(arg);
       c = *p;
       *p = '\0';
       strcpy(first_arg, arg + 1);
       if (c == '\0')
           return p;
       else
           return p + 1;
    }

    else
    {
       char *s, *p;

       s = first_arg;
       p = arg;
       
       while (*p && !isspace(*p) && *p != '"')
           *s++ = *p++;

       *s = '\0';
       return p;
    }

    return arg;
}


int is_substring(char *sub, char *string)
{
    char *s;

    if ((s = str_str(string, sub)))
    {
       int len = strlen(string);
       int sublen = strlen(sub);
       
       /* check front */
       if ((s == string || isspace(*(s - 1)) || ispunct(*(s - 1))) &&

           /* check end */
           ((s + sublen == string + len) || isspace(s[sublen]) ||
            ispunct(s[sublen])))
           return 1;
    }

    return 0;
}


/*
 * return 1 if str contains a word or phrase from wordlist.
 * phrases are in double quotes (").
 * if wrdlist is NULL, then return 1, if str is NULL, return 0.
 */
int word_check(char *str, char *wordlist)
{
    char words[MAX_INPUT_LENGTH], phrase[MAX_INPUT_LENGTH], *s;

    if (*wordlist=='*') return 1;

    strcpy(words, wordlist);
    
    for (s = one_phrase(words, phrase); *phrase; s = one_phrase(s, phrase))
       if (is_substring(phrase, str))
           return 1;

    return 0;
}

       

/*
 *  mob triggers
 */

void random_mtrigger(char_data *ch)
{
  trig_data *t;

  if (!SCRIPT_CHECK(ch, MTRIG_RANDOM) || AFF_FLAGGED(ch, AFF_CHARM))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_RANDOM) && 
       (number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

void bribe_mtrigger(char_data *ch, char_data *actor, int amount)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  
  if (!SCRIPT_CHECK(ch, MTRIG_BRIBE) || AFF_FLAGGED(ch, AFF_CHARM))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_BRIBE) && (amount >= GET_TRIG_NARG(t))) {

      sprintf(buf, "%d", amount);
      add_var(&GET_TRIG_VARS(t), "amount", buf, 0);
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

void greet_memory_mtrigger(char_data *actor)
{
  trig_data *t;
  char_data *ch;
  struct script_memory *mem;
  char buf[MAX_INPUT_LENGTH];
  int command_performed = 0;

  // Artus> Another crash fix.
  if (actor == NULL || IN_ROOM(actor) == NOWHERE)
    return;

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch->next_in_room) {
    if (!SCRIPT_MEM(ch) || !AWAKE(ch) || FIGHTING(ch) || (ch == actor) 
        || AFF_FLAGGED(ch, AFF_CHARM)) 
      continue;

    /* find memory line with command only */
    for (mem = SCRIPT_MEM(ch); mem && SCRIPT_MEM(ch); mem=mem->next) {
      if (GET_ID(actor)!=mem->id) continue;
      if (mem->cmd) {
        command_interpreter(ch, mem->cmd); /* no script */
        command_performed = 1;
        break;
      }
    }

    /* if a command was not performed execute the memory script */
    if (mem && !command_performed) {
      for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
        if (IS_SET(GET_TRIG_TYPE(t), MTRIG_MEMORY) &&
            CAN_SEE(ch, actor) &&
            !GET_TRIG_DEPTH(t) &&
            number(1, 100) <= GET_TRIG_NARG(t)) {
              ADD_UID_VAR(buf, t, actor, "actor", 0);
              script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
              break;
        }
      }
    }

    /* delete the memory */
    if (mem) {
      if (SCRIPT_MEM(ch)==mem) {
        SCRIPT_MEM(ch) = mem->next;
      } else {
        struct script_memory *prev;
        prev = SCRIPT_MEM(ch);
        while (prev->next != mem) prev = prev->next;
        prev->next = mem->next;
      }
      if (mem->cmd) free(mem->cmd);
      free(mem);
    }
  }
}


int greet_mtrigger(char_data *actor, int dir)
{
  trig_data *t;
  char_data *ch;
  char buf[MAX_INPUT_LENGTH];
  int rev_dir[] = { SOUTH, WEST, NORTH, EAST, DOWN, UP };
  int intermediate, final=TRUE;
 
  // DM - quick fix - had a crash due to next statement
  // Didnt look into a great deal - but I assume we just return
  // final as is (TRUE)...
  if (IN_ROOM(actor) == NOWHERE)
    return final;  

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch->next_in_room) {
    if (!SCRIPT_CHECK(ch, MTRIG_GREET | MTRIG_GREET_ALL) || 
       !AWAKE(ch) || FIGHTING(ch) || (ch == actor) || 
       AFF_FLAGGED(ch, AFF_CHARM))
      continue;
    
    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
      if (((IS_SET(GET_TRIG_TYPE(t), MTRIG_GREET) && CAN_SEE(ch, actor)) ||
          IS_SET(GET_TRIG_TYPE(t), MTRIG_GREET_ALL)) && 
         !GET_TRIG_DEPTH(t) && (number(1, 100) <= GET_TRIG_NARG(t))) {
        if (dir>=0)
          add_var(&GET_TRIG_VARS(t), "direction", dirs[rev_dir[dir]], 0);
       ADD_UID_VAR(buf, t, actor, "actor", 0);
       intermediate =  script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
        if (!intermediate) final = FALSE;
       continue;
      }
    }
  }
  return final;
}


void entry_memory_mtrigger(char_data *ch)
{
  trig_data *t;
  char_data *actor;
  struct script_memory *mem;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_MEM(ch) || AFF_FLAGGED(ch, AFF_CHARM))
    return;


  for (actor = world[IN_ROOM(ch)].people; actor && SCRIPT_MEM(ch);
       actor = actor->next_in_room) {
    if (actor!=ch && SCRIPT_MEM(ch)) {
      for (mem = SCRIPT_MEM(ch); mem && SCRIPT_MEM(ch); mem = mem->next) {
        if (GET_ID(actor)==mem->id) {
          struct script_memory *prev;
          if (mem->cmd) command_interpreter(ch, mem->cmd);
          else {
            for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
              if (TRIGGER_CHECK(t, MTRIG_MEMORY) && (number(1, 100) <=
                  GET_TRIG_NARG(t))){
                ADD_UID_VAR(buf, t, actor, "actor", 0);
                script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
                break;
              }
            }
          }
          /* delete the memory */
          if (SCRIPT_MEM(ch)==mem) {
            SCRIPT_MEM(ch) = mem->next;
          } else {
            prev = SCRIPT_MEM(ch);
            while (prev->next != mem) prev = prev->next;
            prev->next = mem->next;
          }
          if (mem->cmd) free(mem->cmd);
          free(mem);
        }
      } /* for (mem =..... */
    }
  }
}

int entry_mtrigger(char_data *ch)
{
  trig_data *t;
  
  if (!SCRIPT_CHECK(ch, MTRIG_ENTRY) || AFF_FLAGGED(ch, AFF_CHARM))
    return 1;
  
  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_ENTRY) && (number(1, 100) <= GET_TRIG_NARG(t))){
      return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }

  return 1;
}

int command_mtrigger(char_data *actor, char *cmd, char *argument)
{
  char_data *ch, *ch_next;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch_next) {
    ch_next = ch->next_in_room;

    if (SCRIPT_CHECK(ch, MTRIG_COMMAND) && !AFF_FLAGGED(ch, AFF_CHARM) &&
        (actor!=ch)) {
      for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
        if (!TRIGGER_CHECK(t, MTRIG_COMMAND))
          continue;
        
        if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
          sprintf(buf,"SYSERR: Command Trigger #%d has no text argument!",
            GET_TRIG_VNUM(t));
          mudlog(buf, NRM, LVL_BUILDER, TRUE);
          continue;
        }

        if (*GET_TRIG_ARG(t)=='*' ||
            !strn_cmp(GET_TRIG_ARG(t), cmd, strlen(GET_TRIG_ARG(t)))) {
         ADD_UID_VAR(buf, t, actor, "actor", 0);
         skip_spaces(&argument);
         add_var(&GET_TRIG_VARS(t), "arg", argument, 0);
         skip_spaces(&cmd);
         add_var(&GET_TRIG_VARS(t), "cmd", cmd, 0);
         
         if (script_driver(ch, t, MOB_TRIGGER, TRIG_NEW))
           return 1;
       }
      }
    }
  }

  return 0;
}
  

void speech_mtrigger(char_data *actor, char *str)
{
  char_data *ch, *ch_next;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch_next)
  {
    ch_next = ch->next_in_room;

    if (SCRIPT_CHECK(ch, MTRIG_SPEECH) && AWAKE(ch) &&
        !AFF_FLAGGED(ch, AFF_CHARM) && (actor!=ch))
      for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
        if (!TRIGGER_CHECK(t, MTRIG_SPEECH))
          continue;

        if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
          sprintf(buf,"SYSERR: Speech Trigger #%d has no text argument!",
            GET_TRIG_VNUM(t));
          mudlog(buf, NRM, LVL_BUILDER, TRUE);
          continue;
        }

        if (((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
             (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {
          ADD_UID_VAR(buf, t, actor, "actor", 0);
          add_var(&GET_TRIG_VARS(t), "speech", str, 0);
          script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
          break;
        }
      }
  }
}


void act_mtrigger(/*const*/ char_data *ch, char *str, char_data *actor, 
                 char_data *victim, obj_data *object,
                 obj_data *target, char *arg)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  
  if (SCRIPT_CHECK(ch, MTRIG_ACT) && !AFF_FLAGGED(ch, AFF_CHARM) &&
      (actor!=ch))
    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next)  {
      if (!TRIGGER_CHECK(t, MTRIG_ACT))
        continue;

      if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
        sprintf(buf,"SYSERR: Act Trigger #%d has no text argument!",
          GET_TRIG_VNUM(t));
        mudlog(buf, NRM, LVL_BUILDER, TRUE);
        continue;
      }

      if (((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
           (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {
       
       if (actor)
         ADD_UID_VAR(buf, t, actor, "actor", 0);
       if (victim)
         ADD_UID_VAR(buf, t, victim, "victim", 0);
       if (object)
         ADD_UID_VAR(buf, t, object, "object", 0);
       if (target)
         ADD_UID_VAR(buf, t, target, "target", 0);
       if (arg) {
         skip_spaces(&arg);
         add_var(&GET_TRIG_VARS(t), "arg", arg, 0);
       }         
       script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
       break;
      }        
    }
}


int fight_mtrigger(char_data *ch)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  
  if (!SCRIPT_CHECK(ch, MTRIG_FIGHT) || !FIGHTING(ch) || 
      AFF_FLAGGED(ch, AFF_CHARM))
    return 0;
  
  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next)
  {
    if (TRIGGER_CHECK(t, MTRIG_FIGHT) &&
       (number(1, 100) <= GET_TRIG_NARG(t)))
    {

      ADD_UID_VAR(buf, t, FIGHTING(ch), "actor", 0)
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      return 1;
    }
  }
  return 0;
}


void hitprcnt_mtrigger(char_data *ch)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  
  if (!SCRIPT_CHECK(ch, MTRIG_HITPRCNT) || !FIGHTING(ch) ||
      AFF_FLAGGED(ch, AFF_CHARM))
    return;
  
  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_HITPRCNT) && GET_MAX_HIT(ch) &&
       (((GET_HIT(ch) * 100) / GET_MAX_HIT(ch)) <= GET_TRIG_NARG(t))) {

      ADD_UID_VAR(buf, t, FIGHTING(ch), "actor", 0)
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


int receive_mtrigger(char_data *ch, char_data *actor, obj_data *obj)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(ch, MTRIG_RECEIVE) || AFF_FLAGGED(ch, AFF_CHARM))
    return 1;
  
  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_RECEIVE) &&
       (number(1, 100) <= GET_TRIG_NARG(t))){

      ADD_UID_VAR(buf, t, actor, "actor", 0);
      ADD_UID_VAR(buf, t, obj, "object", 0);
      return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int death_mtrigger(char_data *ch, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  
  if (!SCRIPT_CHECK(ch, MTRIG_DEATH) || AFF_FLAGGED(ch, AFF_CHARM))
    return 1;
  
  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_DEATH)) {

      if (actor)
       ADD_UID_VAR(buf, t, actor, "actor", 0);
      return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}

void load_mtrigger(char_data *ch)
{
  trig_data *t;

  if (!SCRIPT_CHECK(ch, MTRIG_LOAD))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_LOAD) && 
       (number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


/*
 *  object triggers
 */

void random_otrigger(obj_data *obj)
{
  trig_data *t;

  if (!SCRIPT_CHECK(obj, OTRIG_RANDOM))
    return;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_RANDOM) && 
       (number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


void timer_otrigger(struct obj_data *obj)
{
  trig_data *t;
      
  if (!SCRIPT_CHECK(obj, OTRIG_TIMER))
    return;
  
  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_TIMER))
      script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);       
  }  
     
  return;
}


int get_otrigger(obj_data *obj, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_GET))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_GET) && (number(1, 100) <= GET_TRIG_NARG(t))) {
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


/* checks for command trigger on specific object. assumes obj has cmd trig */
int cmd_otrig(obj_data *obj, char_data *actor, char *cmd,
             char *argument, int type)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  
  if (obj && SCRIPT_CHECK(obj, OTRIG_COMMAND))
    for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
      if (!TRIGGER_CHECK(t, OTRIG_COMMAND))
        continue;
 
      if (IS_SET(GET_TRIG_NARG(t), type) &&
          (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t))) {
        sprintf(buf,"SYSERR: O-Command Trigger #%d has no text argument!",
          GET_TRIG_VNUM(t));
        mudlog(buf, NRM, LVL_BUILDER, TRUE);
        continue;
      }
       
      if (IS_SET(GET_TRIG_NARG(t), type) &&
          (*GET_TRIG_ARG(t)=='*' ||
          !strn_cmp(GET_TRIG_ARG(t), cmd, strlen(GET_TRIG_ARG(t))))) {
       
       ADD_UID_VAR(buf, t, actor, "actor", 0);
       skip_spaces(&argument);
       add_var(&GET_TRIG_VARS(t), "arg", argument, 0);
       skip_spaces(&cmd);
       add_var(&GET_TRIG_VARS(t), "cmd", cmd, 0);
       
       if (script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW))
         return 1;
      }
    }

  return 0;
}


int command_otrigger(char_data *actor, char *cmd, char *argument)
{
  obj_data *obj;
  int i;

  for (i = 0; i < NUM_WEARS; i++)
    if (cmd_otrig(GET_EQ(actor, i), actor, cmd, argument, OCMD_EQUIP))
      return 1;
  
  for (obj = actor->carrying; obj; obj = obj->next_content)
    if (cmd_otrig(obj, actor, cmd, argument, OCMD_INVEN))
      return 1;

  for (obj = world[IN_ROOM(actor)].contents; obj; obj = obj->next_content)
    if (cmd_otrig(obj, actor, cmd, argument, OCMD_ROOM))
      return 1;

  return 0;
}


int wear_otrigger(obj_data *obj, char_data *actor, int where)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_WEAR))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) 
    if (TRIGGER_CHECK(t, OTRIG_WEAR)) 
    {
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    }

  return 1;
}


int remove_otrigger(obj_data *obj, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_REMOVE))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_REMOVE)) {
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int drop_otrigger(obj_data *obj, char_data *actor, int mode)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  void to_upper(char *s);

  if (!SCRIPT_CHECK(obj, OTRIG_DROP))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) 
  {
    if ((t) && TRIGGER_CHECK(t, OTRIG_DROP) && 
	(number(1, 100) <= GET_TRIG_NARG(t))) 
    {
      if ((GET_TRIG_ARG(t)) && (*GET_TRIG_ARG(t)) && 
	  (strlen(GET_TRIG_ARG(t)) > 2))
      {
	to_upper(GET_TRIG_ARG(t));
	switch (mode)
	{
	  case SCMD_JUNK: // Item Was Junked...
	    if (strstr(GET_TRIG_ARG(t), "JUNK") != NULL)
	    {
	      ADD_UID_VAR(buf, t, actor, "actor", 0);
	      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
	    }
	    break;
	  case SCMD_DROP: // Item Was Dropped...
	    if (strstr(GET_TRIG_ARG(t), "DROP") != NULL)
	    {
	      ADD_UID_VAR(buf, t, actor, "actor", 0);
	      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
	    }
	    break;
	  case SCMD_DONATE: // Item Was Donated...
	    if (strstr(GET_TRIG_ARG(t), "DONATE") != NULL)
	    {
	      ADD_UID_VAR(buf, t, actor, "actor", 0);
	      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
	    }
	    break;
	  case SCMD_IS_PUT: // Item Was Put Inside Container...
	    if (!(strstr(GET_TRIG_ARG(t), "PUT")))
	    {
	      ADD_UID_VAR(buf, t, actor, "actor", 0);
	      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
	    }
	    break;
	  default:
	    ADD_UID_VAR(buf, t, actor, "actor", 0);
	    return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
	} // Switch (mode)
	continue; // Argument present, Drop type not matched.
      } // Argument present.
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    } // Trigger Check
  }

  return 1;
}


int give_otrigger(obj_data *obj, char_data *actor, char_data *victim)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_GIVE))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_GIVE) && (number(1, 100) <= GET_TRIG_NARG(t))) {
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      ADD_UID_VAR(buf, t, victim, "victim", 0);
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}

void load_otrigger(obj_data *obj)
{
  trig_data *t;

  if (!SCRIPT_CHECK(obj, OTRIG_LOAD))
    return;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_LOAD) && 
       (number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
      break;
    }
  }
}



/*
 *  world triggers
 */

void reset_wtrigger(struct room_data *room)
{
  trig_data *t;

  if (!SCRIPT_CHECK(room, WTRIG_RESET))
    return;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_RESET) &&
       (number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

void random_wtrigger(struct room_data *room)
{
  trig_data *t;

  if (!SCRIPT_CHECK(room, WTRIG_RANDOM))
    return;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_RANDOM) &&
       (number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


int enter_wtrigger(struct room_data *room, char_data *actor, int dir)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  int rev_dir[] = { SOUTH, WEST, NORTH, EAST, DOWN, UP };

  if (!SCRIPT_CHECK(room, WTRIG_ENTER))
    return 1;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_ENTER) && 
       (number(1, 100) <= GET_TRIG_NARG(t))) {
      add_var(&GET_TRIG_VARS(t), "direction", dirs[rev_dir[dir]], 0);
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      return script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int command_wtrigger(char_data *actor, char *cmd, char *argument)
{
  struct room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_COMMAND))
    return 0;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (!TRIGGER_CHECK(t, WTRIG_COMMAND))
      continue;

    if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
      sprintf(buf,"SYSERR: W-Command Trigger #%d has no text argument!",
        GET_TRIG_VNUM(t));
      mudlog(buf, NRM, LVL_BUILDER, TRUE);
      continue;
    }

    if (*GET_TRIG_ARG(t)=='*' ||
        !strn_cmp(GET_TRIG_ARG(t), cmd, strlen(GET_TRIG_ARG(t)))) {
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      skip_spaces(&argument);
      add_var(&GET_TRIG_VARS(t), "arg", argument, 0);
      skip_spaces(&cmd);
      add_var(&GET_TRIG_VARS(t), "cmd", cmd, 0);
      
      return script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
    }
  }
  
  return 0;
}


void speech_wtrigger(char_data *actor, char *str)
{
  struct room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_SPEECH))
    return;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (!TRIGGER_CHECK(t, WTRIG_SPEECH))
      continue;

    if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
      sprintf(buf,"SYSERR: W-Speech Trigger #%d has no text argument!",
        GET_TRIG_VNUM(t));
      mudlog(buf, NRM, LVL_BUILDER, TRUE);
      continue;
    }

    if (((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
         (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      add_var(&GET_TRIG_VARS(t), "speech", str, 0);
      script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

int drop_wtrigger(obj_data *obj, char_data *actor)
{
  struct room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_DROP))
    return 1;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) 
    if (TRIGGER_CHECK(t, WTRIG_DROP) &&
       (number(1, 100) <= GET_TRIG_NARG(t))) { 
      
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      ADD_UID_VAR(buf, t, obj, "object", 0);
      return script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }  

  return 1;
}
@


1.8
log
@Artus> Gravity fix.
@
text
@d12 2
a13 2
*  $Date: 2003/11/17 23:24:09 $
*  $Revision: 1.7 $
d513 1
a513 1
void fight_mtrigger(char_data *ch)
d520 1
a520 1
    return;
d522 2
a523 1
  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
d525 2
a526 1
       (number(1, 100) <= GET_TRIG_NARG(t))){
d530 1
a530 1
      break;
d533 1
@


1.7
log
@Artus> Fixed drop_otrigger with arguments.. Hopefully ;o).
       Fixed debug message in remove_curse, curse, and suchlike.
@
text
@d12 2
a13 2
*  $Date: 2003/11/17 12:36:24 $
*  $Revision: 1.6 $
d308 1
a308 1
  if (IN_ROOM(actor) == NOWHERE) {
a309 1
  }
@


1.6
log
@Artus>
---
drop_otrigger takes an extra paramater for subcmd. With drop triggers you can
now specify whether the trigger is for drop, junk, donate and put. Specify
in the argument either/combination of 'junk', 'drop', 'donate', 'put'. No
argument means any type will be triggered:

act.item.c, dg_scripts.h, dg_triggers.c, interpreter.h
---
fixed colour bleed in dc:

act.wizard.c
---
Not reapplying empty timers in char_to_store:
Not calling object triggers from char_to_store:

db.c
---
Modified hunt so that with special_elf you can track through !TRACK rooms
(Modifier for Elf has been increased from 0.02 to 0.07%):

graph.c, utils.c
---
Timers should only show remove messages when being removed because they're
wearing off (duration = 0):

handler.c
---
Not calling object triggers when auto_equipping.

objsave.c
---
#defined around love_ring specproc. What a joke. define DRAX_IS_TEH_SUXOR if
you want it back ;o)

spec_assign.c, spec_procs.c
---
@
text
@d11 3
a13 3
*  $Author: primal $
*  $Date: 2002/02/26 06:49:04 $
*  $Revision: 1.5 $
d778 1
a778 1
  if ((GET_TRIG_ARG(t)) && (*GET_TRIG_ARG(t)))
d780 2
a781 2
    to_upper(GET_TRIG_ARG(t));
    switch (mode)
d783 40
a822 21
      case SCMD_JUNK: // Item Was Junked...
	if (!(strstr(GET_TRIG_ARG(t), "JUNK")))
	  return 1;
	break;
      case SCMD_DROP: // Item Was Dropped...
	if (!(strstr(GET_TRIG_ARG(t), "DROP")))
	  return 1;
        break;
      case SCMD_DONATE: // Item Was Donated...
        if (!(strstr(GET_TRIG_ARG(t), "DONATE")))
	  return 1;
        break;
      case SCMD_IS_PUT: // Item Was Put Inside Container...
        if (!(strstr(GET_TRIG_ARG(t), "PUT")))
	  return 1;
        break;
    }
  }

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_DROP) && (number(1, 100) <= GET_TRIG_NARG(t))) {
d825 1
a825 1
    }
@


1.5
log
@
Modified: DM

Changed: (This is a group checkin)
- many many bug fixes
@
text
@d12 2
a13 2
*  $Date: 2001/12/07 09:00:50 $
*  $Revision: 1.4 $
d739 3
a741 2
  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_WEAR)) {
a744 1
  }
d769 1
a769 1
int drop_otrigger(obj_data *obj, char_data *actor)
d773 1
d778 24
@


1.4
log
@*** empty log message ***
@
text
@d11 3
a13 3
*  $Author: karma $
*  $Date: 2001/12/07 08:50:19 $
*  $Revision: 1.3 $
d248 1
a248 1
  if (IN_ROOM(actor) == NOWHERE)
@


1.3
log
@Artus> Hopefully fixed a bug which was causing crashes, with NPC checks..
@
text
@d11 3
a13 3
*  $Author: primal $
*  $Date: 2001/11/27 12:48:30 $
*  $Revision: 1.2 $
d247 4
d252 2
a253 3
    /* Artus - Added NPC Checks.. Should fix a crash. */
    if (!IS_NPC(ch) || IS_NPC(actor) || !SCRIPT_MEM(ch) || !AWAKE(ch) 
	|| FIGHTING(ch) || (ch == actor) || AFF_FLAGGED(ch, AFF_CHARM)) 
@


1.2
log
@*** empty log message ***
@
text
@d12 2
a13 2
*  $Date: 2001/02/02 04:34:48 $
*  $Revision: 1.1 $
d248 3
a250 2
    if (!SCRIPT_MEM(ch) || !AWAKE(ch) || FIGHTING(ch) || (ch == actor) || 
       AFF_FLAGGED(ch, AFF_CHARM))
@


1.1
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d11 3
a13 3
*  $Author: galion $
*  $Date: 1996/08/05 23:32:08 $
*  $Revision: 3.9 $
d301 7
@

