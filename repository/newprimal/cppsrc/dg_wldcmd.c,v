head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	2004.01.23.06.39.02;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.10.12.02.26;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.06.04.32.51;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.04.10.35.01;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.17.02.25.06;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.09.05.42.45;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.27.06.16.00;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.21.02.48.06;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.13.01.05.29;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.26.06.49.04;	author primal;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.02.04.34.48;	author primal;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Artus> Cleaned up.
@
text
@/**************************************************************************
*  File: wldcmd.c                                                         *
*  Usage: contains the command_interpreter for rooms,                     *
*         room commands.                                                  *
*                                                                         *
*                                                                         *
*  $Author: mud $
*  $Date: 2004/01/10 12:02:26 $
*  $Revision: 1.10 $
**************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "screen.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"

extern struct room_data *world;
extern const char *dirs[];
extern struct zone_data *zone_table;
extern int top_of_zone_table;

void sub_write(char *arg, char_data *ch, byte find_invis, int targets);
void send_to_zone(char *messg, int zone_rnum);
long asciiflag_conv(char *flag);
char_data *get_char_by_room(room_data *room, char *name);
room_data *get_room(char *name);
obj_data *get_obj_by_room(room_data *room, char *name);

#define WCMD(name)  \
    void (name)(room_data *room, char *argument, int cmd, int subcmd)


struct wld_command_info {
    char *command;
    void (*command_pointer)
           (room_data *room, char *argument, int cmd, int subcmd);
    int        subcmd;
};


/* do_wsend */
#define SCMD_WSEND        0
#define SCMD_WECHOAROUND  1



/* attaches room vnum to msg and sends it to script_log */
void wld_log(room_data *room, char *msg)
{
    char buf[MAX_INPUT_LENGTH + 100];

    void script_log(char *msg);

    sprintf(buf, "Wld (room %d): %s", room->number, msg);
    script_log(buf);
}


/* sends str to room */
void act_to_room(char *str, room_data *room)
{
    /* no one is in the room */
    if (!room->people)
       return;

    /*
     * since you can't use act(..., TO_ROOM) for an room, send it
     * TO_ROOM and TO_CHAR for some char in the room.
     * (just dont use $n or you might get strange results)
     */
    act(str, FALSE, room->people, 0, 0, TO_ROOM);
    act(str, FALSE, room->people, 0, 0, TO_CHAR);
}



/* World commands */

/* prints the argument to all the rooms aroud the room */
WCMD(do_wasound)
{
    int  door;
 
    skip_spaces(&argument);

    if (!*argument) {
       wld_log(room, "wasound called with no argument");
       return;
    }
  
    for (door = 0; door < NUM_OF_DIRS; door++) {
       struct room_direction_data *exit;
       
       if ((exit = room->dir_option[door]) && (exit->to_room != NOWHERE) &&
           room != &world[exit->to_room])
           act_to_room(argument, &world[exit->to_room]);
    }
}


WCMD(do_wecho)
{
    skip_spaces(&argument);

    if (!*argument) 
       wld_log(room, "wecho called with no args");

    else 
       act_to_room(argument, room);
}


WCMD(do_wsend)
{
    char buf[MAX_INPUT_LENGTH], *msg;
    char_data *ch;
    room_rnum tr = -1;
  
    msg = any_one_arg(argument, buf);

    if (!*buf)
    {
       wld_log(room, "wsend called with no args");
       return;
    }

    skip_spaces(&msg);

    if (!*msg)
    {
       wld_log(room, "wsend called without a message");
       return;
    }

    if ((ch = get_char_by_room(room, buf)))
    {
      if (subcmd == SCMD_WSEND)
        sub_write(msg, ch, TRUE, TO_CHAR);
      else if (subcmd == SCMD_WECHOAROUND)
        sub_write(msg, ch, TRUE, TO_ROOM);
    } else if (is_number(buf) && ((tr = real_room(atoi(buf))) >= 0)) {
      strcat(msg, "\r\n");
      send_to_room(msg, tr);
    }

    else
       wld_log(room, "no target found for wsend");
}

static int real_zone(int number)
{
  int counter;
      
  for (counter = 0; counter <= top_of_zone_table; counter++)
    if ((number >= (zone_table[counter].number * 100)) &&
      (number <= (zone_table[counter].top)))
      return counter;
 
  return -1;
}

WCMD(do_wzoneecho)
{
    int zone;
    char zone_name[MAX_INPUT_LENGTH], buf[MAX_INPUT_LENGTH], *msg;
  
    msg = any_one_arg(argument, zone_name);
    skip_spaces(&msg);

    if (!*zone_name || !*msg)
       wld_log(room, "wzoneecho called with too few args");

    else if ((zone = real_zone(atoi(zone_name))) < 0)
       wld_log(room, "wzoneecho called for nonexistant zone");

    else { 
       sprintf(buf, "%s\r\n", msg);
       send_to_zone(buf, zone);
    }
}


WCMD(do_wdoor)
{
    char target[MAX_INPUT_LENGTH], direction[MAX_INPUT_LENGTH];
    char field[MAX_INPUT_LENGTH], *value;
    room_data *rm;
    struct room_direction_data *exit;
    int dir, fd, to_room;

    const char *door_field[] = {
       "purge",
       "description",
       "flags",
       "key",
       "name",
       "room",
       "\n"
    };


    argument = two_arguments(argument, target, direction);
    value = one_argument(argument, field);
    skip_spaces(&value);

    if (!*target || !*direction || !*field) {
       wld_log(room, "wdoor called with too few args");
       return;
    }
  
    if ((rm = get_room(target)) == NULL) {
       wld_log(room, "wdoor: invalid target");
       return;
    }
  
    if ((dir = search_block(direction, dirs, FALSE)) == -1) {
       wld_log(room, "wdoor: invalid direction");
       return;
    }

    if ((fd = search_block(field, door_field, FALSE)) == -1) {
       wld_log(room, "wdoor: invalid field");
       return;
    }

    exit = rm->dir_option[dir];

    /* purge exit */
    if (fd == 0) {
       if (exit) {
           if (exit->general_description)
               free(exit->general_description);
           if (exit->keyword)
               free(exit->keyword);
           free(exit);
           rm->dir_option[dir] = NULL;
       }
    }

    else {
       if (!exit) {
           CREATE(exit, struct room_direction_data, 1);
           rm->dir_option[dir] = exit; 
       }
    
       switch (fd) {
       case 1:  /* description */
           if (exit->general_description)
               free(exit->general_description);
           CREATE(exit->general_description, char, strlen(value) + 3);
           strcpy(exit->general_description, value);
           strcat(exit->general_description, "\r\n");
           break;
       case 2:  /* flags       */
           exit->exit_info = (sh_int)asciiflag_conv(value);
           break;
       case 3:  /* key         */
           exit->key = atoi(value);
           break;
       case 4:  /* name        */
           if (exit->keyword)
               free(exit->keyword);
           CREATE(exit->keyword, char, strlen(value) + 1);
           strcpy(exit->keyword, value);
           break;
       case 5:  /* room        */
           if ((to_room = real_room(atoi(value))) != NOWHERE)
               exit->to_room = to_room;
           else
               wld_log(room, "wdoor: invalid door target");
           break;
       }
    }
}


WCMD(do_wteleport)
{
    char_data *ch, *next_ch;
    sh_int target, nr;
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

    two_arguments(argument, arg1, arg2);
  
    if (!*arg1 || !*arg2) {
       wld_log(room, "wteleport called with too few args");
       return;
    }

    nr = atoi(arg2);
    target = real_room(nr);
  
    if (target == NOWHERE) 
       wld_log(room, "wteleport target is an invalid room");
  
    else if (!str_cmp(arg1, "all")) {
       if (nr == room->number) {
           wld_log(room, "wteleport all target is itself");
           return;
       }

       for (ch = room->people; ch; ch = next_ch)
       {
           next_ch = ch->next_in_room;

           if (LR_FAIL(ch, LVL_IS_GOD))
	   {
	     char_from_room(ch);
	     char_to_room(ch, target);
	   } else if (ch->desc) {
	     sprintf(buf, "The room tried to teleport you to room #%d.\r\n", 
		     world[target].number);
	     send_to_char(buf, ch);
	   }
       }
    } else {
       if ((ch = get_char_by_room(room, arg1))) {
         if (LR_FAIL(ch, LVL_IS_GOD))
	 {
           char_from_room(ch);
           char_to_room(ch, target);
	 } else if (ch->desc) {
	   sprintf(buf, "The room tried to teleport you to room #%d.\r\n", 
		   world[target].number);
	   send_to_char(buf, ch);
	 }
       }
       
       else
           wld_log(room, "wteleport: no target found");
    }
}


WCMD(do_wforce)
{
    char_data *ch, *next_ch;
    char arg1[MAX_INPUT_LENGTH], *line;

    line = one_argument(argument, arg1);
  
    if (!*arg1 || !*line) {
       wld_log(room, "wforce called with too few args");
       return;
    }
  
    if (!str_cmp(arg1, "all"))
    {
       for (ch = room->people; ch; ch = next_ch)
       {
           next_ch = ch->next_in_room;
      
           if (LR_FAIL(ch, LVL_IS_GOD))
           {
	     command_interpreter(ch, line);
           } else if (ch->desc) {
	     sprintf(buf, "The room tried to force you to %s.\r\n", line);
	     send_to_char(buf, ch);
	   }

       }
    }
  
    else
    {
       if ((ch = get_char_by_room(room, arg1)))
       {
           if (LR_FAIL(ch, LVL_IS_GOD))
           {
	     command_interpreter(ch, line);
           } else if (ch->desc) {
	     sprintf(buf, "The room tried to force you to %s.\r\n", line);
	     send_to_char(buf, ch);
	   }
       }
    
       else
           wld_log(room, "wforce: no target found");
    }
}


/* increases the target's exp */
WCMD(do_wexp)
{
    char_data *ch;
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

    two_arguments(argument, name, amount);

    if (!*name || !*amount) {
       wld_log(room, "wexp: too few arguments");
       return;
    }

    if ((ch = get_char_by_room(room, name))) 
       gain_exp(ch, atoi(amount));
    else {
       wld_log(room, "wexp: target not found");
       return;
    }
}


/* purge all objects an npcs in room, or specified object or mob */
WCMD(do_wpurge)
{
    char arg[MAX_INPUT_LENGTH];
    char_data *ch, *next_ch;
    obj_data *obj, *next_obj;

    one_argument(argument, arg);
  
    if (!*arg) {
       for (ch = room->people; ch; ch = next_ch ) {
           next_ch = ch->next_in_room;
           if (IS_NPC(ch))
               extract_char(ch);
       }
       
       for (obj = room->contents; obj; obj = next_obj ) 
       {
           next_obj = obj->next_content;
	   if (GET_CORPSEID(obj) == 0)
	     extract_obj(obj);
	   else
	     wld_log(room, "wpurge: Refusing to purge player's corpse.");
       }
    
       return;
    }
  
    if (!(ch = get_char_by_room(room, arg))) 
    {
      if ((obj = get_obj_by_room(room, arg))) 
      {
	if (!GET_CORPSEID(obj) != 0)
          extract_obj(obj);
	else
	  wld_log(room, "wpurge: Refusing to purge player's corpse.");
      } else 
        wld_log(room, "wpurge: bad argument");
      return;
    }
  
    if (!IS_NPC(ch)) 
    {
      wld_log(room, "wpurge: purging a PC");
      return;
    }
    
    extract_char(ch);
}


/* loads a mobile or object into the room */
WCMD(do_wload)
{
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int number = 0;
    char_data *mob;
    obj_data *object;
  

    two_arguments(argument, arg1, arg2);
  
    if (!*arg1 || !*arg2 || !is_number(arg2) || ((number = atoi(arg2)) < 0)) {
       wld_log(room, "wload: bad syntax");
       return;
    }

    if (is_abbrev(arg1, "mob")) {
       if ((mob = read_mobile(number, VIRTUAL)) == NULL) {
           wld_log(room, "wload: bad mob vnum");
           return;
       }
       char_to_room(mob, real_room(room->number));
        load_mtrigger(mob);
    }
  
    else if (is_abbrev(arg1, "obj")) {
       if ((object = read_object(number, VIRTUAL)) == NULL) {
           wld_log(room, "wload: bad object vnum");
           return;
       }

       obj_to_room(object, real_room(room->number)); 
        load_otrigger(object);
    }

    else
       wld_log(room, "wload: bad type");
}

WCMD(do_wdamage) {
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
    int dam = 0;
    char_data *ch;

    two_arguments(argument, name, amount);

    if (!*name || !*amount || !isdigit(*amount)) {
       wld_log(room, "wdamage: bad syntax");
       return;
    }

    dam = atoi(amount);

    if ((ch = get_char_by_room(room, name))) 
    {
       if (!LR_FAIL(ch, LVL_IS_GOD))
       {
           send_to_char("Being a god, you carefully avoid a trap.\r\n", ch);
           return;
       }
       
       if (!IS_NPC(ch) || !MOB_FLAGGED(ch, MOB_NOKILL))
       {
	 if (dam < 0) 
	 {
	   send_to_char("You feel rejuvinated.\r\n", ch);
	   return;
	 } else {
	   // Artus> Replaced with damage() call.
	   // GET_HIT(ch) -= dam;
	   damage(NULL, ch, dam, -1/*TYPE_UNDEFINED*/, FALSE);
	 }
       }

       update_pos(ch);
       switch (GET_POS(ch)) {
       case POS_MORTALLYW:
           act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
           send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
           break;
       case POS_INCAP:
           act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
           send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
           break;
       case POS_STUNNED:
           act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
           send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
           break;
       case POS_DEAD:
           act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
           send_to_char("You are dead!  Sorry...\r\n", ch);
           break;

       default:                        /* >= POSITION SLEEPING */
           if (dam > (GET_MAX_HIT(ch) >> 2))
               act("That really did HURT!", FALSE, ch, 0, 0, TO_CHAR);
           if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)) {
               sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
                       CCRED(ch, C_SPR), CCNRM(ch, C_SPR));
               send_to_char(buf2, ch);
           }
       }
       if (GET_POS(ch) == POS_DEAD) 
       {
	 /* Artus> This will now be handled by die()
	 if (!IS_NPC(ch)) {
	     sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
		     world[ch->in_room].name);
	     mudlog(buf2, BRF, 0, TRUE);
	 } */
	 if (!IS_NPC(ch))
	 {
	   char diemsg[MAX_STRING_LENGTH] = "";
	   sprintf(diemsg, "room #%d (%s)", room->number, room->name);
	   die(ch, NULL, diemsg);
	 } else 
	   die(ch, NULL);
       }
    }
    else
       wld_log(room, "wdamage: target not found");
}

WCMD(do_wat) {
    char location[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int vnum = 0;    
    room_data *r2;
 
    void wld_command_interpreter(room_data *room, char *argument);

    half_chop(argument, location, arg2);

    if (!*location || !*arg2 || !isdigit(*location)) {
       wld_log(room, "wat: bad syntax");
       return;
    }
    vnum = atoi(location);
    if (NOWHERE == real_room(vnum)) {
       wld_log(room, "wat: location not found");
       return;
    }

    r2 = &world[vnum];
    wld_command_interpreter(r2, arg2);
}

const struct wld_command_info wld_cmd_info[] = {
    { "RESERVED", 0, 0 },/* this must be first -- for specprocs */
    
    { "wasound"    , do_wasound   , 0 },
    { "wdoor"      , do_wdoor     , 0 },
    { "wecho"      , do_wecho     , 0 },
    { "wechoaround", do_wsend     , SCMD_WECHOAROUND },
    { "wexp"       , do_wexp      , 0 },
    { "wforce"     , do_wforce    , 0 },
    { "wload"      , do_wload     , 0 },
    { "wpurge"     , do_wpurge    , 0 },
    { "wsend"      , do_wsend     , SCMD_WSEND },
    { "wteleport"  , do_wteleport , 0 },
    { "wzoneecho"  , do_wzoneecho , 0 },
    { "wdamage"    , do_wdamage,    0 },
    { "wat"        , do_wat,        0 },
    { "\n", 0, 0 }     /* this must be last */
};


/*
 *  This is the command interpreter used by rooms, called by script_driver.
 */
void wld_command_interpreter(room_data *room, char *argument)
{
    int cmd, length;
    char *line, arg[MAX_INPUT_LENGTH];
  
    skip_spaces(&argument);
  
    /* just drop to next line for hitting CR */
    if (!*argument)
       return;

    line = any_one_arg(argument, arg);


    /* find the command */
    for (length = strlen(arg), cmd = 0;
        *wld_cmd_info[cmd].command != '\n'; cmd++)
       if (!strncmp(wld_cmd_info[cmd].command, arg, length))
           break;
  
    if (*wld_cmd_info[cmd].command == '\n') {
       sprintf(buf2, "Unknown world cmd: '%s'", argument);
       wld_log(room, buf2);
    } else
       ((*wld_cmd_info[cmd].command_pointer) 
        (room, line, cmd, wld_cmd_info[cmd].subcmd));
}
@


1.10
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d8 2
a9 2
*  $Date: 2004/01/06 04:32:51 $
*  $Revision: 1.9 $
d316 2
a317 2
             char_from_room(ch);
             char_to_room(ch, target);
@


1.9
log
@Artus>
act.informative.c: Fixed bug where examining a container was always listng the
                   objects in the first container matched.
                   Gold rush finishing is now only displayed within the same
		   world.
act.movement.c   : Environmental damage is now passed through damage().
act.offensive.c  : Throw() now calls damage().
act.other.c      : When you fail to create a torch, it hurts.
dg_mobcmd.c      : mdamage() now calls damage().
dg_objcmd.c      : odamage() now calls damage().
dg_wldcmd.c      : wdamage() now calls damage().
fight.c          : Changed damage() to allow a NULL ch.
interpreter.c    : Falling because fly has worn off now calls damage().
limits.c         : No waterbreathe underwater now calls damage().
magic.c          : Added handle_fireball() for fire breathing, fireball, type
                   stuff..
                   Random chance of objs in inventory/open containers burning
                   up :o)
spec_assign.c    : Removed some unused/wasted assigns: corridor_guard,
                   receiptionist, virus, bacteria.
spec_procs.c     : Removed some unused/wasted procs. Changed lots of tali's
                   indenting.
                   Fixed gaping hole in deadlyblade proc.
                   Replaced GET_HIT(vict) -= with damage(ch, vict...
spell_parser.c   : Added awake and can_see checks to magic fail = mob attacks.
@
text
@d8 2
a9 2
*  $Date: 2004/01/04 10:35:01 $
*  $Revision: 1.8 $
d314 1
a314 1
           if (GET_LEVEL(ch) < LVL_ANGEL) 
d326 1
a326 1
         if (GET_LEVEL(ch) < LVL_ANGEL) 
d361 1
a361 1
           if (GET_LEVEL(ch)<LVL_ANGEL)
d376 1
a376 1
           if (GET_LEVEL(ch)<LVL_ANGEL)
d519 1
a519 1
       if (GET_LEVEL(ch)>=LVL_ANGEL) 
@


1.8
log
@Artus> Intermittent build.
act.informative.c: Affect/Timers now display something when no affects/timers
                   are present.
                   Sense curse now senses objects inside containers.
act.movement.c   : Optimised the aggravate stuff a little.
act.offensive.c  : Logging death by pit trap.
act.other.c      : Logging death by suicide.
                   Superman now sets affects rather than actual stats, for STR
                   and CON (CON bonus is +1, STR is 21 - GET_REAL_STR
                   Logging death by arrow.
clan.c           : Removed aggravate_check() function, no longer used.
db.c             : Now initialising character specials.
dg_mobcmd.c      : Logging death by mdamage.
dg_objcmd.c      : Logging death by odamage.
dg_wldcmd.c      : Logging death by wdamage.
fight.c          : New optional msg paramater to die(), for if the death was
                   not caused by a character.
                   Deaths are now logged to info channel.
handler.c        : Modified ability affect function to permit more than one
                   affect modifier per special. (Required for superman)
spec_procs.c     : Logging death by pit trap, archers and room blast.
spells.h         : Added SPELL_SUPERMAN for special affect modifiers.
utils.h          : Updated die() prototype to match changes in fight.c.
@
text
@d8 2
a9 2
*  $Date: 2003/12/17 02:25:06 $
*  $Revision: 1.7 $
d532 3
a534 1
	   GET_HIT(ch) -= dam;
@


1.7
log
@Artus> Mostly just cosmetic changes, mostly for underwater stuff..
       Added some more stuff to dg_scripts:

       %actor.affected(aff_bit)% - Is actor affected by whatever.
       %self.people(countpc)%    - (Rooms): Count players.
       %self.people(countnpc)%   - (Rooms): Count npcs.
       %self.people(countall)%   - (Rooms): Count chars.
       %firstchar.<room_vnum>%   - First character in room <vnum>

       Possibly a bugfix to one of the forest specials that was attacking you
       if you were affected by poison.
@
text
@d8 2
a9 2
*  $Date: 2003/12/09 05:42:45 $
*  $Revision: 1.6 $
d564 15
a578 7
       if (GET_POS(ch) == POS_DEAD) {
           if (!IS_NPC(ch)) {
               sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
                       world[ch->in_room].name);
               mudlog(buf2, BRF, 0, TRUE);
           }
           die(ch, NULL);
@


1.6
log
@Artus>
\r\n appended to gold rush message: act.informative.c

Imms no longer affected by underwater: act.movement.c, limits.c

Changed remort some more.. New special, tracker (SPECIAL_TRACKER):
act.other.c, act.wizard.c, constants.c, graph.c, structs.h, utils.c

Object and Room triggers can now %send% <room vnum> <message>:
dg_objcmd.c, dg_wldcmd.c

%self.direction% now has a vnum subfield to return the exit room's vnum.
(Eg: %self.north(vnum)%): dg_scripts.c

%actor.hisher%, %actor.himher%, %actor.heshe% implemented: dg_scripts.c

vnum, name, can_see, can_see_me added to %actor.next_in_room%, returning char
vnum, char name, if actor can see char, and if char can see actor respectively:
dg_scripts.c

Changed "do not know that spell" to "do not know of that spell": spell_parser.c

Changed "do not of know that skill/spell" to "do not know of..": utils.c

SECT_UNDERWATER and SECT_INSIDE now checked in OUTSIDE() macro: utils.h
@
text
@d8 2
a9 2
*  $Date: 2003/11/27 06:16:00 $
*  $Revision: 1.5 $
d432 1
a432 1
	   if (GET_CORPSEID(obj) != 0)
@


1.5
log
@Artus> Breakin now requires mount skill, and is tested vs it.
       Remort ability list changed some more, also remort ability parser.
       DGScript Force/Teleport commands now tell >=LVL_ANGEL what they were
       trying to do..
       MultiWeapon is once more required for dual wield.
       Lowered exp gained whilst grouping by about 30%.
@
text
@d8 2
a9 2
*  $Date: 2003/11/21 02:48:06 $
*  $Revision: 1.4 $
d125 1
d145 7
a151 4
       if (subcmd == SCMD_WSEND)
           sub_write(msg, ch, TRUE, TO_CHAR);
       else if (subcmd == SCMD_WECHOAROUND)
           sub_write(msg, ch, TRUE, TO_ROOM);
@


1.4
log
@Artus>
act.informative.c: Added Sense Wounds.
constants.c      : Added Sense Wounds.
db.c             : Fixed spell effectiveness.
dg_mobcmd.c      : mpurge will no longer purge player corpses.
dg_objcmd.c      : opurge will no longer purge player corpses.
dg_wldcmd.c      : wpurge will no longer purge player corpses.
fight.c          : Added Sense Wounds.
magic.c          : Added Sense Wounds.
spell_parser.c   : Added Sense Wounds.. Trialling changes do damage
                   done by headbutt, flytackle, piledrive.
spells.h         : Added Sense Wounds.
structs.h        : Added Sense Wounds.
@
text
@d8 2
a9 2
*  $Date: 2003/11/13 01:05:29 $
*  $Revision: 1.3 $
d310 2
a311 1
           if (GET_LEVEL(ch) < LVL_ANGEL) {
d314 4
d322 2
a323 1
         if (GET_LEVEL(ch) < LVL_ANGEL) {
d326 4
d359 6
a364 2
               command_interpreter(ch, line);
           }
d374 5
a378 2
               command_interpreter(ch, line);
           }
@


1.3
log
@Artus> Added !KILL flag for mobs... Things like gamina, postmaster, etc, can
       have this set, which should make it pretty damn impossible for them to
       die..
       Modified more stuff for dark ritual and vampires.. Have added a switch
       statement to affect_remove, which should be a good central place to
       handle triggers on affect removal.. Mainly to reset mana/move/hit to
       make sure they're not higher than max values when removing werewolf/
       vampire.
@
text
@d7 3
a9 3
*  $Author: primal $
*  $Date: 2002/02/26 06:49:04 $
*  $Revision: 1.2 $
d408 2
a409 1
       for (obj = room->contents; obj; obj = next_obj ) {
d411 4
a414 1
           extract_obj(obj);
d420 11
a430 7
    if (!(ch = get_char_by_room(room, arg))) {
       if ((obj = get_obj_by_room(room, arg))) {
           extract_obj(obj);
       } else 
           wld_log(room, "wpurge: bad argument");
    
       return;
d433 4
a436 3
    if (!IS_NPC(ch)) {
       wld_log(room, "wpurge: purging a PC");
       return;
@


1.2
log
@
Modified: DM

Changed: (This is a group checkin)
- many many bug fixes
@
text
@d8 2
a9 2
*  $Date: 2001/02/02 04:34:48 $
*  $Revision: 1.1 $
d487 4
a490 2
    if ((ch = get_char_by_room(room, name))) {
       if (GET_LEVEL(ch)>=LVL_ANGEL) {
d494 11
a504 5
        GET_HIT(ch) -= dam;
        if (dam < 0) {
          send_to_char("You feel rejuvinated.\r\n", ch);
          return;
        }
@


1.1
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d7 3
a9 3
*  $Author: galion $
*  $Date: 1996/08/05 03:27:07 $
*  $Revision: 3.12 $
a29 1
void die(struct char_data * ch, struct char_data * killer);
d310 4
a313 2
           char_from_room(ch);
           char_to_room(ch, target);
d315 1
a315 4
    }
  
    else
    {
d317 1
d320 1
d347 1
a347 1
           if (GET_LEVEL(ch)<LVL_IMMORT)
d358 1
a358 1
           if (GET_LEVEL(ch)<LVL_IMMORT)
d488 2
a489 2
       if (GET_LEVEL(ch)>=LVL_IMMORT) {
           send_to_char("Being a god, you carefully avoid a trap.", ch);
@

