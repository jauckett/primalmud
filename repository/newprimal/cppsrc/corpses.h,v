head	1.6;
access;
symbols
	A3_0_59:1.3
	LATEST:1.3
	A3_0_1:1.3;
locks; strict;
comment	@ * @;


1.6
date	2003.11.12.11.00.13;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.11.14.11.09;	author artus;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.09.03.38.29;	author artus;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.22.22.37.01;	author primal;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.20.23.37.16;	author primal;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.17.12.53.43;	author primal;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@#include <list>
#include <iostream>
#include <fstream>

using std::ifstream;
using std::ofstream;

// filename corpseData is stored to
#define CORPSE_FILENAME LIB_ETC"corpses" 

/**
 * This class is used to encapsulate the virtual number of an "obj" and
 * the "objs" that are contained within this "obj".
 */
class Contain {
  public:
    // Constructor - just initialise defaults
    Contain();

    // Constructor ...
    Contain(struct obj_data *obj, long playerId); 

    // Exception thrown when the "obj" could not be created from vnum itemNumber
    class NonExistantObject {};

    // Creates an "obj" based on the data encapsuled within this object
    struct obj_data *createObject();

    // returns the list of "objs" that this "obj" contains
    std::list<Contain> getContents() { return contains; } 

    // returns vnum of this "obj"
    obj_vnum getVNum() { return itemNumber; }               

    // Read the data associate with this "obj" to file
    void read(long playerId);

    // Write the data associate with this "obj" to file
    void write();

    // Destructor ...
    ~Contain() {}                       

  private:
    // idnum of owner 
    long playerId;

    // obj save data
    struct obj_file_elem save;

    // vnum of this "obj"	
    obj_vnum itemNumber;     

    // list of "objs" that this "obj" containts
    std::list<class Contain> contains;  
    
    // reads the data associate with this object from file
    void read();

};


/**
 * This class encapsulate the "static" data associated with a corpse including
 * the "objs" that the corpse contains. The class constructor copies the
 * "static" data contained within a corpse, and the toObj() function converts
 * this object to an "obj".
 */
class Corpse {
  public:
    // Default Constructor - just set default vals
    Corpse();

    // Constructor ...
    Corpse(struct obj_data *corpse, room_vnum inVRoom, long playerid, 
                    int weight);

    // Converts this object to an "obj"
    struct obj_data *toObj();

    // Exception thrown when the "obj" could not be created from vnum itemNumber
    class NonExistantObject {};

    // Returns the virtual number that the corpse was saved in
    room_vnum getVRoom(void) {
      return in_room;
    }

    // returns true if memory addresses are equal
    bool memoryEqual(struct obj_data *corpse) { 
      return ((int)corpse == memoryAddress);
    }

    void setMemory(int memAddress) {
      memoryAddress = memAddress;
    }

    int getWeight() {
      return weight;
    }

    // Writes the data to file associated with this corpse
    void write(); 

    // Reads the data from file associated with this corpse
    void read();

    // Desctructor ...
    ~Corpse() {}

  private:

    void initialise(long playerId, int inVRoom, int gold, int weight, 
                       struct obj_flag_data obj_flags);

    // The address of the corpse obj in memory
    int memoryAddress;

    // The virtual number of the room where the corpse is. If in_room is
    // NOWHERE, the corpse will be loaded to CORPSE_LOAD_ROOM.
    room_vnum in_room;      

    // Player idnum
    long playerId;

    // The amount of gold contained in the corpse
    int gold;

    // The base weight of the corpse
    int weight;
    
    // Name of "obj" - corpse
    char *name;

    // Description of "obj" - The corpse of <name> is lying here
    char *description;
    
    // Short Description of "obj" - the corpse of <name>
    char *short_description;

    // "Object" information 
    struct obj_flag_data obj_flags;

    // Wear it is worn - ITEM_WEAR_TAKE
    sh_int worn_on;                

    // The max durability of the corpse
    sh_int max_damage;       

    // State of "obj"
    sh_int damage;     

    // A list to encapsulate the "objs" contained within the corpse.
    // This is a list of the "root" items in the corpse, each of these items
    // includes the virtual number of the "obj". Each item may also be
    // a container, the contents of each item are stored within a list in the
    // Contain object.
    std::list<Contain> contains;  
};

/**
 * This class encapsulate the data associated with all the player corpses
 * currently active in the game. It contains a list of Corpse's, and functions
 * to add and remove corpse "objs". Serialize and deserialize functions
 * are used to save (when a change is made to a corpse) and load (at boot time)
 * to ensure that no corpses are lost in the event of a crash.
 */ 
class CorpseData {
  public:
    CorpseData();
    int load();
    void addCorpse(struct obj_data *corpse, room_vnum inVRoom, int weight);
    void removeCorpse(struct obj_data *corpse);
    void removeAllCorpses(void);
    void extractOriginalCorpses(int retainIDs);
    void extractCorpses(room_vnum, int retainIDs);
    ~CorpseData();
  private:
    void write();
    std::list<Corpse> corpses;
};
@


1.5
log
@Modified: DM

Changed:
- load() to return int for result
@
text
@d1 6
a6 3
#include <list.h>
#include <iostream.h>
#include <fstream.h>
d30 1
a30 1
    list<Contain> getContents() { return contains; } 
d55 2
a56 2
    list<class Contain> contains;  

d158 1
a158 1
    list<Contain> contains;  
d180 1
a180 1
    list<Corpse> corpses;
@


1.4
log
@Added: removeAllCorpses
@
text
@d168 1
a168 1
    void load();
@


1.3
log
@
Changed:
- corpses file to LIBETC
@
text
@d171 1
@


1.2
log
@
Changed:
- further evolution
@
text
@d6 1
a6 1
#define CORPSE_FILENAME LIB_MISC"corpses" 
@


1.1
log
@
Added:
- Initial corpse data implementation
@
text
@d2 5
d13 3
a15 3
  private:
    // idnum of owner 
    int playerId;
a16 7
    // vnum of this "obj"	
    obj_vnum itemNumber;     

    // list of "objs" that this "obj" containts
    list<class Contain> contains;  

  public:
d18 1
a18 1
    Contain(struct obj_data *obj, int playerId); 
d32 6
d40 17
d68 3
d72 2
a73 1
    Corpse(struct obj_data *corpse, room_vnum inVRoom, int playerid);
d91 14
d110 3
d121 1
a121 1
    int playerId;
d126 3
d168 2
a169 1
    void addCorpse(struct obj_data *corpse, room_vnum inVRoom);
d171 1
a171 1
    void extractCorpses(int retainIDs);
@

