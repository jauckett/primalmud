head	1.127;
access;
symbols
	A3_0_59:1.17
	LATEST:1.17
	A3_0_1:1.16;
locks; strict;
comment	@ * @;


1.127
date	2005.06.15.02.21.01;	author mud;	state Exp;
branches;
next	1.126;

1.126
date	2004.11.25.01.19.32;	author mud;	state Exp;
branches;
next	1.125;

1.125
date	2004.11.24.01.55.26;	author mud;	state Exp;
branches;
next	1.124;

1.124
date	2004.11.24.01.38.10;	author mud;	state Exp;
branches;
next	1.123;

1.123
date	2004.08.27.01.44.08;	author mud;	state Exp;
branches;
next	1.122;

1.122
date	2004.07.15.02.40.49;	author mud;	state Exp;
branches;
next	1.121;

1.121
date	2004.07.07.14.13.22;	author mud;	state Exp;
branches;
next	1.120;

1.120
date	2004.07.07.11.35.51;	author mud;	state Exp;
branches;
next	1.119;

1.119
date	2004.06.08.12.19.43;	author mud;	state Exp;
branches;
next	1.118;

1.118
date	2004.06.06.08.20.50;	author mud;	state Exp;
branches;
next	1.117;

1.117
date	2004.06.05.08.28.26;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	2004.06.05.03.46.08;	author mud;	state Exp;
branches;
next	1.115;

1.115
date	2004.06.04.12.20.48;	author mud;	state Exp;
branches;
next	1.114;

1.114
date	2004.05.29.01.00.13;	author mud;	state Exp;
branches;
next	1.113;

1.113
date	2004.05.26.12.01.02;	author mud;	state Exp;
branches;
next	1.112;

1.112
date	2004.05.24.11.39.39;	author mud;	state Exp;
branches;
next	1.111;

1.111
date	2004.05.23.07.20.12;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	2004.05.21.14.47.07;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	2004.05.21.14.13.15;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	2004.05.18.10.03.21;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	2004.05.16.14.30.20;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	2004.05.15.22.38.15;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	2004.05.07.06.08.07;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	2004.05.06.02.23.29;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	2004.04.29.07.55.23;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	2004.04.21.06.47.09;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	2004.02.23.02.59.15;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	2004.01.30.04.05.35;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	2004.01.29.13.16.32;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	2004.01.29.11.03.46;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	2004.01.27.09.45.08;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	2004.01.21.06.21.23;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	2004.01.16.00.41.55;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	2004.01.14.05.49.27;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	2004.01.12.04.32.39;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	2004.01.11.03.44.13;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	2004.01.10.12.14.07;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	2004.01.10.12.02.25;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	2004.01.06.04.32.50;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	2004.01.04.10.35.00;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	2004.01.02.13.59.50;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	2003.12.31.22.20.27;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	2003.12.09.05.42.45;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	2003.11.24.00.14.49;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	2003.11.21.05.04.13;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	2003.11.21.02.48.05;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	2003.11.15.01.42.16;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	2003.11.13.01.05.29;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	2003.11.12.11.00.13;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	2003.11.05.12.17.13;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	2003.11.05.04.18.04;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	2003.11.05.04.17.04;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	2003.11.05.03.39.27;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	2003.10.14.07.24.16;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	2002.07.20.08.17.56;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	2002.04.18.14.44.26;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	2002.04.10.10.45.22;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	2002.04.07.14.49.16;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	2002.04.07.11.11.17;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	2002.04.07.05.14.11;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	2002.02.14.06.10.17;	author primal;	state Exp;
branches;
next	1.66;

1.66
date	2002.01.25.03.45.01;	author primal;	state Exp;
branches;
next	1.65;

1.65
date	2002.01.23.05.50.30;	author primal;	state Exp;
branches;
next	1.64;

1.64
date	2002.01.17.04.17.23;	author rod;	state Exp;
branches;
next	1.63;

1.63
date	2001.12.07.01.05.33;	author karma;	state Exp;
branches;
next	1.62;

1.62
date	2001.11.30.13.33.50;	author rod;	state Exp;
branches;
next	1.61;

1.61
date	2001.11.29.08.14.27;	author karma;	state Exp;
branches;
next	1.60;

1.60
date	2001.11.25.04.07.00;	author karma;	state Exp;
branches;
next	1.59;

1.59
date	2001.11.25.00.11.30;	author artus;	state Exp;
branches;
next	1.58;

1.58
date	2001.11.24.13.40.42;	author rod;	state Exp;
branches;
next	1.57;

1.57
date	2001.11.20.14.41.13;	author rod;	state Exp;
branches;
next	1.56;

1.56
date	2001.11.20.06.28.41;	author karma;	state Exp;
branches;
next	1.55;

1.55
date	2001.11.20.05.15.59;	author rod;	state Exp;
branches;
next	1.54;

1.54
date	2001.11.15.04.21.09;	author rod;	state Exp;
branches;
next	1.53;

1.53
date	2001.11.13.15.44.18;	author rod;	state Exp;
branches;
next	1.52;

1.52
date	2001.11.13.12.07.46;	author rod;	state Exp;
branches;
next	1.51;

1.51
date	2001.11.11.16.27.25;	author rod;	state Exp;
branches;
next	1.50;

1.50
date	2001.11.11.15.34.08;	author rod;	state Exp;
branches;
next	1.49;

1.49
date	2001.11.11.02.12.46;	author rod;	state Exp;
branches;
next	1.48;

1.48
date	2001.10.28.07.26.56;	author rod;	state Exp;
branches;
next	1.47;

1.47
date	2001.10.28.06.35.15;	author karma;	state Exp;
branches;
next	1.46;

1.46
date	2001.10.27.22.03.06;	author primal;	state Exp;
branches;
next	1.45;

1.45
date	2001.10.05.04.38.30;	author artus;	state Exp;
branches;
next	1.44;

1.44
date	2001.08.13.10.04.05;	author primal;	state Exp;
branches;
next	1.43;

1.43
date	2001.08.12.01.42.08;	author artus;	state Exp;
branches;
next	1.42;

1.42
date	2001.08.11.14.18.02;	author artus;	state Exp;
branches;
next	1.41;

1.41
date	2001.07.01.12.03.32;	author primal;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.26.23.37.47;	author primal;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.21.13.40.13;	author artus;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.21.02.45.08;	author artus;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.12.10.36.36;	author artus;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.09.03.44.35;	author artus;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.27.06.52.09;	author primal;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.26.07.12.47;	author primal;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.26.06.45.55;	author primal;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.06.11.57.54;	author rod;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.05.12.07.56;	author rod;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.11.14.09.52;	author artus;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.10.06.45.50;	author primal;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.09.19.30.46;	author primal;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.08.15.16.38;	author primal;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.04.18.09.22;	author primal;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.02.21.24.24;	author primal;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.02.20.59.33;	author primal;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.02.20.45.27;	author primal;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.02.20.31.23;	author primal;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.02.07.00.53;	author primal;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.02.04.34.44;	author primal;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.31.09.40.39;	author primal;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.31.09.12.27;	author primal;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.29.21.45.55;	author primal;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.22.22.09.40;	author primal;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.20.23.58.54;	author primal;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.17.12.34.39;	author primal;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.14.00.52.53;	author primal;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.28.21.21.07;	author primal;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.28.21.18.58;	author primal;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.28.21.12.18;	author primal;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.26.17.20.29;	author primal;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.26.16.39.47;	author primal;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.13.00.59.17;	author primal;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.27.11.26.38;	author talisman;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.22.09.22.34;	author talisman;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.28.12.29.15;	author talisman;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.13.15.18.36;	author mbd;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.13.14.25.12;	author mbd;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.57;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.127
log
@Artus> Vanity.
@
text
@/**************************************************************************
*   File: act.informative.c                             Part of CircleMUD *
*  Usage: Player-level commands of an informative nature                  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "screen.h"
#include "constants.h"
#include "colour.h"
#include "clan.h" // New clan stuff - ARTUS
#include "dg_scripts.h"
#include "quest.h"

// Artus> Err.. ^= anyone? :o)
// #define SETREMOVE(flag, bit) if (IS_SET((flag), (bit))) REMOVE_BIT((flag), (bit)); else SET_BIT((flag),(bit))
#define SETREMOVE(flag, bit) (flag ^= bit)
// Make this room a bounty collection office or something more intersting
#define BOUNTY_RETURN_ROOM 	1115


/* extern variables */
extern int top_of_helpt;
extern struct help_index_element *help_table;
extern char *help;
extern struct time_info_data time_info;
extern struct room_data *world;
extern struct descriptor_data *descriptor_list;
extern struct user_data *user_list;
extern struct char_data *character_list;
extern struct obj_data *object_list;
extern long NUM_PLAYERS;
extern long top_idnum;
// extern struct clan_data clan_info[NUM_CLANS]; -- ARTUS: Old clan stuff.
extern ReleaseInfo release;

extern char *credits;
extern char *areas;
extern char *news;
extern char *info;
extern char *motd;
extern char *imotd;
extern char *wizlist;
extern char *immlist;
extern char *policies;
extern char *handbook;
extern char *hint_table[];
extern  struct index_data *mob_index;
extern struct event_list events;
extern struct zone_data *zone_table;
extern Burglary *burglaries;
extern struct index_data *obj_index;
extern const char *social_ranks[];
extern const char *quest_names[];
extern struct char_data *mob_proto;

extern int num_hints;


/* extern functions */
ACMD(do_track);
ACMD(do_action);
long find_class_bitvector(char arg);
int level_exp(struct char_data *ch, int level);
struct time_info_data *real_time_passed(time_t t2, time_t t1);
int compute_armor_class(struct char_data *ch, bool divide);
int is_colour(struct char_data *ch, char code, bool colour_code_only);
// int compute_thaco(struct char_data *ch); // Artus - Not Used ?
void add_mud_event(struct event_data *ev);
void remove_mud_event(struct event_data *ev);
void send_to_zone(const char *, zone_rnum);
void send_to_not_zone_world(const char *, zone_rnum);
sh_int find_clan_by_sid(char *test);
bool attach_rooms(long lFirst, long lSecond);
char *rand_desc(int nAreaType);
char *rand_name(int nAreaType);
void handle_quest_event(struct event_data *ev);

/* local functions */
void do_hint(void);
void do_zone_hint(void);
void store_mail(long, long, char *);
struct char_data *get_char_online(struct char_data *ch, char *name, int where);
void print_object_location(int num, struct obj_data * obj, struct char_data * ch, int recur, char *writeto);
void show_obj_to_char(struct obj_data * object, struct char_data * ch, int mode);
void list_obj_to_char(struct obj_data * list, struct char_data * ch, int mode, int show);
void list_obj_to_char2(struct obj_data * list, struct char_data * ch, int mode, int show);
int invalid_level(struct char_data *ch, struct obj_data *object, bool display);
int reverse_dir(int dir);
struct char_data *get_player_by_id(long id);
void remove_burglary(Burglary *target);
long is_room_burgled(int nRoom);
int get_burgle_area(room_rnum nRoom);
void apply_burglar_stats_to_mob(struct char_data *mob, long lBurglarID, float fStrength);

ACMD(do_bounties);
ACMD(do_sense);
ACMD(do_search);
ACMD(do_immlist);
ACMD(do_info);
ACMD(do_look);
ACMD(do_examine);
ACMD(do_gold);
ACMD(do_score);
ACMD(do_inventory);
ACMD(do_equipment);
ACMD(do_time);
ACMD(do_weather);
ACMD(do_help);
ACMD(do_who);
ACMD(do_users);
ACMD(do_gen_ps);
ACMD(do_setcolour);
ACMD(do_listen);
void perform_mortal_where(struct char_data * ch, char *arg);
void perform_immort_where(struct char_data * ch, char *arg);
ACMD(do_where);
ACMD(do_levels);
ACMD(do_consider);
ACMD(do_diagnose);
ACMD(do_color);
ACMD(do_toggle);
ACMD(do_show_hint);
void sort_commands(void);
ACMD(do_commands);
void diag_char_to_char(struct char_data * i, struct char_data * ch);
void look_at_char(struct char_data * i, struct char_data * ch);
void list_one_char(struct char_data * i, struct char_data * ch);
void list_char_to_char(struct char_data * list, struct char_data * ch);
void do_auto_exits(struct char_data * ch);
ACMD(do_events);
ACMD(do_exits);
void look_in_direction(struct char_data * ch, int dir);
void look_in_obj(struct char_data * ch, char *arg);
void show_contents_to(struct char_data *ch, struct obj_data *obj);
char *find_exdesc(char *word, struct extra_descr_data * list);
void look_at_target(struct char_data *ch, char *arg, 
                    struct char_data **tch=NULL, struct obj_data **tobj=NULL);
/* void display_clan_table(struct char_data *ch, struct clan_data *clan);
 * -- ARTUS: Old clan stuff. */
void toggle_display(struct char_data *ch, struct char_data *vict);  
void ch_trigger_trap(struct char_data *ch, struct obj_data *obj);

int compareAffectDuration(const void *x, const void *y);
int compareCharName(const void *x, const void *y);
int compareCharLevelA(const void *x, const void *y);
int compareCharLevelD(const void *x, const void *y);
void print_who_info(struct char_data *array[], int length, 
                    struct char_data *ch);
void show_ability_messages_to_char(struct char_data *ch);
long get_burgle_room_type(long lArea);
bool room_has_exit_to(int nFirst, int nSecond);

/* Burglary class and class types */
void Burglary::DescribeSelf(struct char_data *ch)
{
  char out[MAX_STRING_LENGTH];
  sprintf(out, "   %s is burgling %d rooms.\r\n",
	  get_name_by_id(chID), CountBurgledRooms());
  send_to_char(out, ch);
}

int Burglary::CountBurgledRooms()
{
  int nCount = 0;
  for (int i = 0; i < MAX_BURGLED_ROOMS; i++)
    if (burgledRooms[i].rNum != -1)
      nCount++;
  return nCount;
}

// Links the rooms up, and populates with goodies and baddies, 
// traps and hidden items etc.
int Burglary::Initialise(int nStart, int nDir)
{
  int nCount = CountBurgledRooms(), nRealCount = 0;;
  
  if (nCount <= 0)
	return -1;

  // One way link to the start room from the direction specified
  world[burgledRooms[0].rNum].dir_option[nDir]->to_room = nStart;
  world[burgledRooms[0].rNum].dir_option[nDir]->exit_info = EX_ISDOOR;
  world[burgledRooms[0].rNum].dir_option[nDir]->keyword = "exit";

  // Create the area (attach rooms)
  for (int i = 0; i < nCount; i++)
  {
    int nRoom = burgledRooms[number(0, nCount -1)].rNum;

    // Want to limit the amount of real rotations, there's a point
    // where the attachment is obviously just not going to work
    if (nRealCount > 10 * MAX_BURGLED_ROOMS)
    {
	// Shows up as just another case where player has failed
	mudlog("Breaking out of Burglary::Initialise - Unable to attach rooms properly.",
		NRM, LVL_GOD, TRUE);
	Clear();
	return NOWHERE;
    }

    // Check if we're trying to connect to ourselves
    if (nRoom == burgledRooms[i].rNum)
    {
	i--;
        nRealCount++;
	continue;
    }

    // Check if the two rooms are already attached
    if (room_has_exit_to(nRoom, burgledRooms[i].rNum))
    {
	i--; 
	nRealCount++;
	continue;
    }

    // Give this room a description - TODO, make this a member function
    int nTargetRoom = burgledRooms[i].rNum;
    long lArea = burgledRooms[i].lArea;

    world[nTargetRoom].name = rand_name(lArea);
    world[nTargetRoom].description =  rand_desc(lArea);
    SET_BIT(world[nTargetRoom].burgle_flags, get_burgle_room_type(lArea));

    if (!attach_rooms(GET_ROOM_VNUM(burgledRooms[i].rNum), GET_ROOM_VNUM(nRoom)))
	i--;
    nRealCount++;
  }

  initialArea = get_burgle_area(nStart);

  InitialiseMobs();
  InitialiseObjects();
  InitialiseTraps();
  InitialiseSpecials();

  return burgledRooms[0].rNum;
}

#define BURGLE_WAREHOUSE_BOSS		30902	// foreman
#define BURGLE_WAREHOUSE_SUB		30901	// worker
#define BURGLE_WAREHOUSE_UNDERLING	30903	// gofer

#define BURGLE_HOME_BOSS		0
#define BURGLE_HOME_SUB			0
#define BURGLE_HOME_UNDERLING		0

#define BURGLE_SHOP_BOSS		30904
#define BURGLE_SHOP_SUB			0
#define BURGLE_SHOP_UNDERLING		0

void Burglary::InitialiseMobs() 
{ 
  long lMob1=0,	// Boss
       lMob2=0,   // Sub
       lMob3=0;   // Underling

  if (initialArea == ROOM_AREA_WAREHOUSE_RICH || 
      initialArea == ROOM_AREA_WAREHOUSE_REGULAR || 
      initialArea == ROOM_AREA_WAREHOUSE_POOR)
  {
    lMob1 = BURGLE_WAREHOUSE_BOSS;
    lMob2 = BURGLE_WAREHOUSE_SUB;
    lMob3 = BURGLE_WAREHOUSE_UNDERLING;
  }
  else
  if (initialArea == ROOM_AREA_HOME_RICH ||
      initialArea == ROOM_AREA_HOME_REGULAR ||
      initialArea == ROOM_AREA_HOME_POOR)
  {
    lMob1 = BURGLE_HOME_BOSS;
    lMob2 = BURGLE_HOME_SUB;
    lMob3 = BURGLE_HOME_UNDERLING;
  }
  else
  if (initialArea == ROOM_AREA_SHOP_RICH ||
      initialArea == ROOM_AREA_SHOP_REGULAR ||
      initialArea == ROOM_AREA_SHOP_POOR)
  {
    lMob1 = BURGLE_SHOP_BOSS;
    lMob2 = BURGLE_SHOP_SUB;
    lMob3 = BURGLE_SHOP_UNDERLING;
  }

  // We have the mobs, now load some of them into the rooms, depending
  // on the time of day, basically, no mobs for warehouses after midnight,
  // same for shops. Shops should have other protections (items, traps, specials)
  if (lMob1 == BURGLE_WAREHOUSE_BOSS && time_info.hours >= 0 && time_info.hours < 6)
	return; // No mobs

  // For every room, some chance of either
  int nCount = CountBurgledRooms();
  for (int i = 0; i < nCount; i++)
  {
    int nRoom = burgledRooms[i].rNum;

    // Boss
    if (number(1, MAX_BURGLED_ROOMS) == 1)
    {
	struct char_data *m = read_mobile(lMob1, VIRTUAL);
        if (m != NULL)
        {
	  apply_burglar_stats_to_mob(m, chID, 1.2);
	  char_to_room(m, nRoom);
	}
	else
	  basic_mud_log("Boss Mobile #%ld cannot be burgle loaded.", lMob1);
    }

    // Subs
    for (int j = 0; j < 2; j++)
    {
      if (number(1, int((MAX_BURGLED_ROOMS * 2)/3)) == 1 && lMob2 != 0)
      {
    	struct char_data *m = read_mobile(lMob2, VIRTUAL);
	if (m != NULL)
	{
	  apply_burglar_stats_to_mob(m, chID, 1.0);
	  char_to_room(m, nRoom);
	}
	else
	  basic_mud_log("Sub Mobile #%ld cannot be burgle loaded.", lMob2);
      }
    }

    // Underlings
    for (int k = 0; k < 5; k++)
    {
      if (number(1, int(MAX_BURGLED_ROOMS/2)) == 1 && lMob3 != 0)
      {
  	struct char_data *m = read_mobile(lMob3, VIRTUAL);
	if (m != NULL)
	{
	  apply_burglar_stats_to_mob(m, chID, 0.95);
	  char_to_room(m, nRoom);
	}
	else
	  basic_mud_log("Underling Mobile #%ld cannot be burgle loaded.", lMob3);
      }
    }

  }
}

#define BURGLE_LOOT	30900
#define BURGLE_UNIQUE   0

// All objects are hidden, some are traps
void Burglary::InitialiseObjects() 
{ 
  int nCount = CountBurgledRooms();
  int nItem = 0;
  struct char_data *ch = get_player_by_id(chID);

  for (int i = 0; i < nCount; i++)
  {
    int nRoom = burgledRooms[i].rNum;
    struct obj_data *obj = NULL;

    // Some chance of loot
    if (number(1, nCount) == 1)
    {
	obj = read_object(BURGLE_LOOT, VIRTUAL);
	int nRange1, nRange2;
	nRange1 = int(float(GET_LEVEL(ch) * 10) * GET_MODIFIER(ch));
	nRange2 = int(float(GET_LEVEL(ch) * 50) * GET_MODIFIER(ch));

	GET_OBJ_COST(obj) = number(nRange1, nRange2);
	// Hide the object
        SET_BIT(GET_OBJ_EXTRA(obj), ITEM_HIDDEN);
	obj_to_room(obj, nRoom);
    }
    
    obj = NULL;
    // Some chance of rare object, must have 5 more at least existing and
    // they must be sequential after BURGLE_LOOT item (ie 901, 902 etc)
    // - Object will also depend on burglar's level
    if ((nItem = number(1, MAX_BURGLED_ROOMS * 100) <= 5)) // Very small chance
    {
      long lItem = 0;
      int nChance = 0;
      if (GET_LEVEL(ch) > 80)
	nChance = 5;			// Any up to and including ethereal blade
      else if (GET_LEVEL(ch) > 60)
	nChance = 4;			// Any up to and including golden shortsword
      else if (GET_LEVEL(ch) > 40)
	nChance = 3;			// Any up to and including thin rapier
      else if (GET_LEVEL(ch) > 20)
	nChance = 2;			// Any up to and including jagged scimitar
      else
	nChance = 1;			// Viscious dirk

      lItem = BURGLE_LOOT + number(1, nChance);	// Allocate Obj VNUM 
      obj = read_object(lItem, VIRTUAL);
      if (obj != NULL)
      {
        SET_BIT(GET_OBJ_EXTRA(obj), ITEM_HIDDEN);
        obj_to_room(obj, nRoom); 
      }
    }
    
    obj = NULL;
    // Little chance of unique object
    if (number(1, MAX_BURGLED_ROOMS * 1000) == 1 && BURGLE_UNIQUE != 0)
    {
      obj = read_object(BURGLE_UNIQUE, VIRTUAL);
      obj_to_room(obj, nRoom);
    }
  }
}
/* Looks through all the items in the rooms assigned, and 
 * can potentially trap them.
 */
void Burglary::InitialiseTraps() 
{ 
  int nCount = CountBurgledRooms();
  int chance = 0;
  struct char_data *burglar = get_player_by_id(chID);

  for (int i = 0; i < nCount; i++)
  {
    int nRoom = burgledRooms[i].rNum;
    struct obj_data *oNext = NULL;
    long lBurgleFlag = get_burgle_room_type(burgledRooms[i].lArea);
    for(struct obj_data *obj = world[nRoom].contents; obj; obj = oNext)
    {
      oNext = obj->next;
      if (lBurgleFlag == ROOM_SHOP)
        chance = 1; // Every item is a trap
      else if (lBurgleFlag == ROOM_HOME)
	chance = 2; // Every second
      else
	chance = 3;

      if (number(1, chance) != 1)
      {
	continue;
      }

      long lObjId = GET_OBJ_VNUM(obj);
      if (lObjId == BURGLE_LOOT)	// Loot isn't trapped
      {
	continue;
      }

      // Create a trap, set it to have the old objects vnum after 
      // it's triggered
      GET_OBJ_TYPE(obj) = ITEM_TRAP;
      GET_OBJ_VAL(obj, 0) = 1;	// Set to hurt person who sets it off only
      GET_OBJ_VAL(obj, 1) = 10;  // 10  size dice
      GET_OBJ_VAL(obj, 2) = GET_LEVEL(burglar); // Level damage dice
      GET_OBJ_VAL(obj, 3) = lObjId;	// Original item to load in place after trigger
    }
  }
}

/* TODO: Make some specials - depends on active quests etc */
void Burglary::InitialiseSpecials() { }


// Clears all objects, mobs, and sets all exits to NOWHERE
void Burglary::Clear()
{
  int nCount = CountBurgledRooms();
  
  for(int i = 0; i < nCount; i++)
  {
    int nRoom = burgledRooms[i].rNum;

    // Clear out the objects
    struct obj_data *objs;
    for (objs = world[nRoom].contents; objs; objs = world[nRoom].contents)
	extract_obj(objs);

    // Clear out the mobs
    struct char_data *mobs;
    for (mobs = world[nRoom].people; mobs; mobs = world[nRoom].people)
    {
      if (IS_NPC(mobs))
        extract_char(mobs);
      else
      {
        send_to_char("You are kicked out of the crime scene.\r\n", mobs);
        char_to_room(mobs, 1115); 
      }
    }

    // Reset the exits
    for (int j = 0; j < 4; j++)
    {
      world[nRoom].dir_option[j]->to_room = NOWHERE;
      world[nRoom].dir_option[j]->keyword = "";
      world[nRoom].dir_option[j]->exit_info = 0;      
    }

    // Reset the burgled flags
    BURGLE_FLAGS(nRoom) = 0;

    // Remove this room from the burgledRooms
    burgledRooms[i].rNum = -1;
    burgledRooms[i].lArea = 0;   
  }
}
// end burglary  and types 

void do_zone_hint(void)
{
  struct descriptor_data *d;
  int rnumb;
  zone_rnum zrnum;

  for (d = descriptor_list; d; d = d->next)
  {
    if (((STATE(d) == CON_PLAYING) && d->character) &&
        (!EXT_FLAGGED(d->character, EXT_NOHINTS)))
    {
      zrnum = world[d->character->in_room].zone;
      if (zone_table[zrnum].nohnts > 0)
      {
	rnumb = number(0, zone_table[zrnum].nohnts-1);
	sprintf(buf, "&W[ &bZone: &B%s &W]&n\r\n",
	        zone_table[zrnum].hints[rnumb]);
	send_to_char(buf,d->character); 
      }
    }
  } 
}

// Display a random hint stored in hint_table - called every PULSE_HINTS 
void do_hint(void)
{
  struct descriptor_data *d;
  int rnumb;

  rnumb = number(0, num_hints-1);
  sprintf(buf, "&W[ &B%s &W]&n\r\n", hint_table[rnumb]);
  for (d = descriptor_list; d; d = d->next)
  {
    if (((STATE(d) == CON_PLAYING) && d->character) &&
        (!EXT_FLAGGED(d->character, EXT_NOHINTS)))
      send_to_char(buf,d->character); 
  } 
}

ACMD(do_show_hint)
{
  int rnumb;
  char arg[MAX_INPUT_LENGTH];

  half_chop(argument, arg, argument);

  if (*arg)
  {
    if (!str_cmp(arg, "ON"))
    {
      send_to_char("You will now see the hint channel.\r\n", ch);
      REMOVE_BIT(EXT_FLAGS(ch), EXT_NOHINTS);
      save_char(ch, NOWHERE);
      return;
    } else if (!str_cmp(arg, "OFF")) {
      send_to_char("You will no longer see the hint channel.\r\n", ch);
      SET_BIT(EXT_FLAGS(ch), EXT_NOHINTS);
      save_char(ch, NOWHERE);
      return;
    }
  }
  rnumb = number(0, num_hints-1);
  sprintf(buf, "&W[ &B%s &W]&n\r\n", hint_table[rnumb]);
  send_to_char(buf, ch);
}

void mortal_detectcurses(struct char_data *ch)
{
  struct obj_data *obj;
  int curseCounter = 0;

  for (obj = world[ch->in_room].contents; obj; obj = obj->next_content)
  {
    if (IS_OBJ_STAT(obj, ITEM_NODROP) && (number(1, 101) < GET_SKILL(ch, SKILL_SENSE_CURSE)))
    {
      curseCounter++;
      act("You sense that $p is cursed.", FALSE, ch, obj, 0, TO_CHAR);
    }
    if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER)
      for (struct obj_data *inner = obj->contains; inner;
	   inner = inner->next_content)
	if ((IS_OBJ_STAT(inner, ITEM_NODROP) && 
	    (number (1, 101) < GET_SKILL(ch, SKILL_SENSE_CURSE))))
	{
	  curseCounter++;
	  act("You sense that $p contains cursed items.", FALSE, ch, obj, 0, TO_CHAR);
	  break;
	}
  }	
  if (!curseCounter)
    send_to_char("You sense nothing out of the ordinary.\r\n", ch);
}

void mortal_stat(struct char_data *ch, char *arg)
{
  struct char_data *victim;
  int diff = 0;

  if (!*arg)
  {
    send_to_char("Sense whose stats?\r\n", ch);
    return;
  }
  // Find the target
  if (!(victim = generic_find_char(ch, arg, FIND_CHAR_ROOM))) 
  {
    send_to_char("You sense a big empty spot where you think they should be!\r\n", ch);
    return;
  }
  /* If it's an npc, the amount of info they get varies according to 
   * relative power */
  if (IS_NPC(victim))
  {
    diff = GET_LEVEL(victim) - GET_LEVEL(ch);	
    // Give some basic info
    sprinttype(GET_CLASS(victim), npc_class_types, buf2);
    sprintf(buf, "%-20s %s\r\n%-20s %s \r\n%-20s %d\r\n", "Name:",
	    GET_NAME(victim), "Type:", buf2, "Level:", GET_LEVEL(victim));
    if (diff < 5) // Npc is possibly much more powerful
    {
      sprintf(buf + strlen(buf), "%-20s %s\r\n%-20s %d\r\n", "Special Powers:",
      GET_MOB_SPEC(victim) ? "Yes" : "No", "Gold:", GET_GOLD(victim));
    }
    if (diff <= 0)	// PC is somewhat more powerful
    {
      sprintf(buf + strlen(buf), "%-20s %d/%d \r\n%-20s %d\r\n", "Life Force:", 
	      GET_HIT(victim), GET_MAX_HIT(victim), "Combat Skill Rating:", 
	      thaco(victim, NULL));
    }
    if (diff < -5) // Player is way more powerful, give some good info
    {
      sprintf(buf + strlen(buf), "%-20s %d \r\n%-20s %d\r\n%-20s %d\r\n",
	      "Damage Bonus:", GET_DAMROLL(victim), 
	      "Hitroll Bonus:", GET_HITROLL(victim), 
	      "Armour Class:", compute_armor_class(victim, 0));
    }
    send_to_char(buf, ch);
    return;
  }
  // Okay they're sensing a player
  if ((GET_LEVEL(victim) >= LVL_ISNOT_GOD) && 
      (GET_LEVEL(victim) > GET_LEVEL(ch)))
  {
    send_to_char("You sense a mighty being, able to crush you with a snap of their fingers!\r\n",ch);
    act("$n just tried to sense your abilities, but failed, as mortals are wont to do.", FALSE, ch, 0, victim, TO_VICT);
    return;
  }
  // TODO - Artus> It looks like this is kind of unfinished.
}

ACMD(do_sense)
{
  two_arguments(argument, buf, buf1);
  if (!GET_SKILL(ch, SKILL_SENSE_CURSE) && !GET_SKILL(ch, SKILL_SENSE_STATS))
  {
    send_to_char("You have no idea how to.\r\n", ch);
    return;
  }
  if (!*buf)
  {
    strcpy(buf, "You are able to sense");
    if (GET_SKILL(ch, SKILL_SENSE_CURSE))
      strcat(buf, " &Bcurses&n");
    if (GET_SKILL(ch, SKILL_SENSE_CURSE) && GET_SKILL(ch, SKILL_SENSE_STATS))
      strcat(buf, " and");
    if (GET_SKILL(ch, SKILL_SENSE_STATS))
      strcat(buf, " &Bstats&n");
    strcat(buf, ".\r\n");
    send_to_char(buf, ch);
    return;
  }	
  toUpper((char *)buf);
  if (strcmp(buf, "STATS") == 0)
    mortal_stat(ch, buf1);
  else if (strcmp(buf, "CURSES") == 0)
    mortal_detectcurses(ch);
  else
    send_to_char("You have no idea how to sense for that.\r\n", ch);
  return;
}

void ch_trigger_trap(struct char_data *ch, struct obj_data *obj)
{
  struct obj_data *temp;
  struct descriptor_data *d;
  int dam;

  if (GET_OBJ_VAL(obj, 0) == 0)
  {
    send_to_char("&bPhew, it wasn't loaded.&n\r\n", ch);
    if (GET_OBJ_VAL(obj, 3) == 0)
      return;	// Nothing more to do
    temp = read_object(GET_OBJ_VAL(obj, 3), VIRTUAL);
    extract_obj(obj);
    obj_to_room(temp, ch->in_room);
    act("The trap was protecting $p!", FALSE, ch, temp, 0, TO_CHAR);
    act("$n triggered a trap, which was fortunately unloaded, finding $p.", FALSE, ch, temp, 0, TO_ROOM);
    return;
  }
  send_to_char("You trigger it!&n\r\n", ch);
  act("...$n triggers a trap!", FALSE, ch, 0, 0, TO_ROOM);
  dam = dice(GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 2));
  if (GET_OBJ_VAL(obj, 0) == 1) 
  {
     send_to_char("You take the brunt of the damage.\r\n", ch);
     // GET_HIT(ch) -= damage;
     damage(NULL, ch, dam, TYPE_UNDEFINED, FALSE);
     update_pos(ch);
  } else {   // Room affect
    send_to_char("The trap goes off, damaging everyone nearby.\r\n", ch);
    act("The trap goes off, damaging everyone in the vicinity!", 
	FALSE, ch, 0, 0, TO_ROOM);	
    for (d = descriptor_list; d; d = d->next)
    {
      if (d->character && (d->character->in_room == ch->in_room) &&
          (d->character != ch))
      damage(NULL, d->character, dam, TYPE_UNDEFINED, FALSE);
    } // Every descriptor
  } // Room affect
  // Check if we replace the obj
  if (GET_OBJ_VAL(obj, 3) >= 1)
  {
    temp = read_object(GET_OBJ_VAL(obj, 3), VIRTUAL);
    act("You find $p in the aftermath.", FALSE, ch, temp,0,TO_CHAR);
    act("You spot $p in the aftermath.", FALSE, ch, temp,0,TO_ROOM);
    obj_to_room(temp, ch->in_room);
  }
  // Get rid of the trap
  extract_obj(obj);
}

ACMD(do_search)
{
  int chance = 0, i, counter = 0, baseChance = 0;
  struct room_data *r;
  struct obj_data *o;

  if (IS_NPC(ch))
    return;
  if (AFF_FLAGGED(ch, AFF_PARALYZED))
  {
    send_to_char("Your limbs won't respond. You're paralysed!\r\n",ch);
    return;
  }
  if (!GET_SKILL(ch, SKILL_SEARCH))
  {
    send_to_char("You stumble around, but achieve nothing.\r\n",ch);
    return;
  }
  if (IS_THIEF(ch)) // Favour thief for multi-classed
    baseChance = 15;	// 15%
  else if (IS_MAGIC_USER(ch))
    baseChance = 5;	// 5%
  else
    baseChance = 2;	// 2%
  if (IS_SET(GET_SPECIALS(ch), SPECIAL_THIEF))
    baseChance += 40;	// +40% for enhanced thieves
  r = &world[ch->in_room];
  // first, check for exits
  for (i = 0; i < NUM_OF_DIRS; i++)
  {
    if (r->dir_option[i] == NULL)
      continue;
    if (EXIT_FLAGGED(EXIT(ch, i), EX_ISDOOR) &&
        EXIT_FLAGGED(EXIT(ch, i), EX_CLOSED))
    {
      sprintf(buf, "You find an exit leading %s.\r\n", dirs[i]);
      send_to_char(buf, ch);
      counter++;
    } 
  }
  // Change the basechance according to player level and class and modifier
  if (GET_LEVEL(ch) > 90) 
    chance = baseChance + 8;
  else if (GET_LEVEL(ch) > 50)
    chance = baseChance + 5;
  else if (GET_LEVEL(ch) > 25)
    chance = baseChance + 2;
  if (GET_CLASS(ch) == CLASS_MASTER)
    chance += 8;
  else if ((GET_CLASS(ch) == CLASS_NIGHTBLADE) ||
           (GET_CLASS(ch) == CLASS_SPELLSWORD))
    chance += 7;
  else if (GET_CLASS(ch) > CLASS_WARRIOR)
    chance += 3;
  chance += 4 + (int)(GET_MODIFIER(ch));

  /* Artus> The Old Way
  chance = baseChance + 
           (GET_LEVEL(ch) > 90 ? 10 :
	    GET_LEVEL(ch) > 50 ? 7  :
	    GET_LEVEL(ch) > 25 ? 4  : 2) +
	   (GET_CLASS(ch) == CLASS_MASTER     ? 10 : 
	    GET_CLASS(ch) == CLASS_NIGHTBLADE ? 9  :
	    GET_CLASS(ch) == CLASS_SPELLSWORD ? 9  :
	    GET_CLASS(ch) >  CLASS_WARRIOR    ? 5  : 2) +
	   int(GET_MODIFIER(ch)); */

  if (chance > 90)
    chance = 90;
  // Now do the real looking
  for (o=r->contents; o; o=o->next_content)
  {
    if (OBJ_FLAGGED(o, ITEM_HIDDEN))
      if (number(1, 100) > 100-chance)
      {
	act("You find $p, hidden nearby!", FALSE, ch, o, 0, TO_CHAR);
	act("$n finds $p, hidden nearby!", FALSE, ch, o, 0, TO_ROOM);
	counter++;
	REMOVE_BIT(o->obj_flags.extra_flags, ITEM_HIDDEN);
	// Check if it's a trap!
	if (GET_OBJ_TYPE(o) == ITEM_TRAP)
	{
	  send_to_char("&RIt's a trap! ", ch);
	  if (number(1, baseChance) == baseChance)  // favour thieves
	    ch_trigger_trap(ch, o);
	  else
          {
	    send_to_char("&g .. but you manage not to trigger it.&n\r\n",ch);
	    // Check if it was hiding an item
	    if (GET_OBJ_VAL(o, 3) != 0)
	    {
	      extract_obj(o);
	      o = read_object(GET_OBJ_VAL(o, 3), VIRTUAL);
	      act("... The trap was protecting $p!", FALSE, ch, o, 0, TO_CHAR);
	      act("$n found $p under a trap!", FALSE, ch, o, 0, TO_ROOM);
	      obj_to_room(o, ch->in_room);
	    }
	  }
	}
      }
  }
  if (!counter)
    send_to_char("You find nothing unusual.\r\n", ch);
}

void sort(long list[], long owners[], int num)
{
  int i, j;
  long hold;
  for (i = 0; i < num; i++)
    for (j = 0; j < num - 1; j++) 
      if (list[j] > list[j + 1])
      {
        hold = list[j];
        list[j] = list[j + 1];
        list[j + 1] = hold;
        // Move the owner with it
        hold = owners[j];
        owners[j] = owners[j + 1];
        owners[j + 1] = hold;
      }
}

ACMD(do_immlist) 
{
  int n = 0;
  extern struct imm_list_element *immlist_table;
  bool dark = false;

  // No Imms.
  if (!(immlist_table))
  {
    send_to_char("C'mon guys, stop being such a bunch of pussies.\r\n", ch);
    return;
  }

  // Now display the stats
  sprintf(buf, "\r\n        &r.-&R'-.&y_.&Y-'&w-&W Primal Immortals &w-&Y'-&y._.&R-'&r-.&n\r\n");
  sprintf(buf + strlen(buf), "\r\n\r\n       &BName                  Kills   Unholiness\r\n");
  for (struct imm_list_element *i = immlist_table; i; i = i->next)
  {
    sprintf(buf + strlen(buf), "       &%c%-20s%7ld%13d\r\n",
	    (dark ? 'C' : 'c'), i->name, i->kills, i->unholiness);
    dark = !(dark);
    n++;
  }
  sprintf(buf + strlen(buf), "\r\n       &B%d &bImmortal%s listed.\r\n&n",
          n, n == 1 ? "" : "s"); 	
  page_string(ch->desc, buf, TRUE);
}

/* Command to display and set player information */
ACMD(do_info)
{
  long tchid;
  struct char_data *tch = NULL;
  struct char_file_u tmp;
  char *newstr;

  if (IS_NPC(ch))
  {
    send_to_char("You already know everything there is to know!\r\n", ch);
    return;
  }

  // two_arguments(argument, arg, buf1);
  newstr = one_argument(argument, arg);

  if (!*arg) 
  {
    do_gen_ps(ch, argument, cmd, SCMD_INFO);
    return;
  }

  // Artus> Moved level restriction inside, so newbies can call with no params.
  if (LR_FAIL_MAX(ch, 10))
  {
    send_to_char("You need to be at least level 10 to set your info!\r\n", ch);
    return;
  }

  if (PLR_FLAGGED(ch, PLR_NOINFO) && LR_FAIL(ch, LVL_GRGOD))
  {
    send_to_char("You can't set your info. Privilidges have been revoked.\r\n",
                    ch);
    return;
  }

  // Just want to know about themselves?
  /* Artus> Info with no args can behave the way it used to behave :o)
  if (!*arg) {
    sprintf(buf, "&gYour current details are:&n\r\n"
            "&y Email:&n %s\r\n &yWebpage:&n %s\r\n&y Personal:&n %s&n\r\n",
            GET_EMAIL(ch) == NULL ? "None" : GET_EMAIL(ch), 
            GET_WEBPAGE(ch) == NULL ? "None" : GET_WEBPAGE(ch),
            GET_PERSONAL(ch) == NULL ? "None" : GET_PERSONAL(ch));
    send_to_char(buf, ch);
    return;
  } */

  if (*newstr)
    skip_spaces(&newstr);
  // Looking for someone?
  if (!*newstr) 
  {
    bool isonline = FALSE;
    if (!str_cmp(arg, "me") || !str_cmp(arg, "self"))
    { // Artus> Check for me/self/online players. .. Slack. :o)
      tch = ch;
      isonline = TRUE;
    } else {
      struct char_data *k;
      for (k = character_list; k; k = k->next)
      {
	if (IS_NPC(k))
	  continue;
	if (str_cmp(arg, GET_NAME(k)))
	  continue;
	tch = k;
	isonline = TRUE;
	break;
      } // Search Online List.
    } // Me/Self/Other Check.
    if (!isonline)
    {
      if ((tchid = get_id_by_name(arg)) < 1) 
      {
	send_to_char("No such player!\r\n", ch);
	return;
      }
      // Load the character up
      CREATE(tch, struct char_data, 1);
      clear_char(tch);
      load_char(arg, &tmp);
      store_to_char(&tmp, tch);
      char_to_room(tch, 0);
    }
    sprintf(buf, "&g%s is a level %d %s, socially ranked as '%s'.&n\r\n",
	GET_NAME(tch), GET_LEVEL(tch), pc_class_types[(int)GET_CLASS(tch)],
	social_ranks[GET_SOCIAL_STATUS(tch)]);
    send_to_char(buf, ch);
    sprintf(buf,"&y Email: &n%s\r\n&y Webpage:&n %s\r\n&y Personal: &n%s&n\r\n",
	    GET_EMAIL(tch) == NULL ? "None" : GET_EMAIL(tch), 
	    GET_WEBPAGE(tch) == NULL ? "None" : GET_WEBPAGE(tch),
	    GET_PERSONAL(tch) == NULL ? "None" : GET_PERSONAL(tch));
    send_to_char(buf, ch);
    if (!isonline)
      extract_char(tch);
    return;		 
  }

  //to_lower(arg);
  // We have both arguments
  if (is_abbrev(arg, "email"))
  {
    if (GET_EMAIL(ch))
      free(GET_EMAIL(ch));
    if (str_cmp(newstr, "clear") == 0 )
    {
      GET_EMAIL(ch) = str_dup("None");
      *newstr = '\0';
      send_to_char("You clear your email.\r\n", ch);
    } else {
      GET_EMAIL(ch) = str_dup(newstr);
      send_to_char("You set your email.\r\n", ch);
    }
    return;
  }

  if (is_abbrev(arg, "webpage"))
  {
    if (GET_WEBPAGE(ch))
      free(GET_WEBPAGE(ch));
    if (!str_cmp(newstr, "clear"))
    {
      GET_WEBPAGE(ch) = str_dup("None");
      send_to_char("You clear your webpage.\r\n", ch);
    } else {
      GET_WEBPAGE(ch) = str_dup(newstr);
      send_to_char("You set your webpage.\r\n", ch);
    }
    return;
  }

  if (is_abbrev(arg, "personal"))
  {
    if (GET_PERSONAL(ch))
      free(GET_PERSONAL(ch));
    if (!str_cmp(newstr, "clear"))
    {
      GET_PERSONAL(ch) = str_dup("None");
      send_to_char("You clear your personal info.\r\n",ch);
    } else {
      GET_PERSONAL(ch) = str_dup(newstr);
      send_to_char("You set your personal info.\r\n", ch);
    }
    return;
  }
  send_to_char("Set what?!\r\n", ch);
}


const char *show_object_damage(struct obj_data *obj)
{
  const char *damage_msgs[] =
  {
    "It is in &gperfect&n condition.\r\n",
    "It is &Bslightly damaged&n.\r\n",
    "It is &Ysomewhat damaged&n.\r\n",
    "It is &ymoderately damaged&n.\r\n",
    "It is &rquite damaged&n.\r\n",
    "It is &Rseverely damaged&n.\r\n",
    "It is &mbroken&n.\r\n",
    "It is &Gindestructable!&n\r\n"
  };
  int dmgno = 0;
  float damage;

  if (obj == NULL)
  {
    mudlog("SYSERR: Showing object damage on null object.", BRF, LVL_GRGOD, 
	   TRUE);
    return "-"; 
  }
  if (GET_OBJ_MAX_DAMAGE(obj) == 0)
    dmgno = 6;
  else if (GET_OBJ_MAX_DAMAGE(obj) <= -1)
    dmgno = 7;
  else
    damage = (GET_OBJ_DAMAGE(obj) *100) / GET_OBJ_MAX_DAMAGE(obj);
  if (dmgno != 0)
    dmgno = dmgno;	// Pre - allocated ( Broken or Indes )
  else if (damage == 0)   // Busted
    dmgno = 6;
  else if (damage <= 20)	// Severely damaged   (01 - 20%)
    dmgno = 5;
  else if (damage <= 50)  // Quite damaged      (21 - 50%)
    dmgno = 4;
  else if (damage <= 70)  // Moderately damaged (51 - 70%)
    dmgno = 3;
  else if (damage <= 85)  // Somewhat damaged   (71 - 85%)
    dmgno = 2;
  else if (damage <= 99)  // Slightly damaged   (86 - 99%) 
    dmgno = 1;
  else dmgno = 0;		// Perfect condition  (  100%  )
//	basic_mud_log("Item %s, %d*100/%d = %lf", obj->short_description, GET_OBJ_DAMAGE(obj),
//		GET_OBJ_MAX_DAMAGE(obj), damage);
  return damage_msgs[dmgno];
}


/*
 * This function screams bitvector... -gg 6/45/98
 */
void show_obj_to_char(struct obj_data * object, struct char_data * ch,
			int mode)
{
  *buf = '\0';
  if ((mode == 0) && object->description)
  {
    strcpy(buf, "&5");
    strcat(buf, object->description);
  } else if ((object->short_description) &&
             ((mode == 1) || (mode == 2) || (mode == 3) || (mode == 4)))
  {
    /* Can't use */
    if (invalid_level(ch, object, FALSE))
      strcpy(buf, "&R");
    /* Is Quest */
    else if (OBJ_FLAGGED(object, ITEM_QEQ))
      strcpy(buf, "&Y");
    /* Anything else. */
    else
      strcpy(buf, "&5");
    strcat(buf, object->short_description);
  } else if (mode == 5) {
    if (GET_OBJ_TYPE(object) == ITEM_NOTE)
    {
      if (object->action_description)
      {
	strcpy(buf, "There is something written upon it:\r\n\r\n");
	strcat(buf, object->action_description);
	page_string(ch->desc, buf, 1);
      } else
	send_to_char("It's blank.\r\n", ch);
      // Artus> This probably shouldn't be here.
      // sprintf(buf, "%s\r\n", show_object_damage(object));
      // send_to_char(buf, ch);
      return;
    } else if (GET_OBJ_TYPE(object) != ITEM_DRINKCON) {
      strcpy(buf, "You see nothing special..");
    } else			/* ITEM_TYPE == ITEM_DRINKCON||FOUNTAIN */
      strcpy(buf, "It looks like a drink container.");

  }
  // Artus> Couldn't see any point to this.
  // show_object_damage(object);
  if (mode != 3)
  {
    if( IS_OBJ_STAT(object, ITEM_HIDDEN))
      strcat(buf, " (hidden)");
    if (OBJ_RIDDEN(object))
	strcat(buf, " (ridden)");
    if (IS_OBJ_STAT(object, ITEM_INVISIBLE))
      strcat(buf, " (invisible)");
    if (IS_OBJ_STAT(object, ITEM_BLESS) && AFF_FLAGGED(ch, AFF_DETECT_ALIGN))
      strcat(buf, " ..It glows blue!");
    if (IS_OBJ_STAT(object, ITEM_MAGIC) && AFF_FLAGGED(ch, AFF_DETECT_MAGIC))
      strcat(buf, " ..It glows yellow!");
    if (IS_OBJ_STAT(object, ITEM_GLOW))
      strcat(buf, " ..It has a soft glowing aura!");
    if (IS_OBJ_STAT(object, ITEM_HUM))
      strcat(buf, " ..It emits a faint humming sound!");
  }
  strcat(buf, "&n\r\n");
  page_string(ch->desc, buf, TRUE);
}

/*
void list_obj_to_char(struct obj_data * list, struct char_data * ch, int mode,
		           int show)
{
  struct obj_data *i;
  bool found = FALSE;

  for (i = list; i; i = i->next_content) {
    if (CAN_SEE_OBJ(ch, i)) {
      show_obj_to_char(i, ch, mode);
      found = TRUE;
    }
  }
  if (!found && show)
    send_to_char(" Nothing.\r\n", ch);
}
*/
void list_obj_to_char2(struct obj_data * list, struct char_data * ch, int mode,
                      int show)
{
  // Artus> What the fuck is this supposed to do?
}

void list_obj_to_char(struct obj_data * list, struct char_data * ch, int mode,
                      int show)
{
  struct obj_data *i;
  bool found, exists;
  sh_int *unique=NULL, item_num;
  struct obj_data **u_item_ptrs = NULL;
  int size=0, num, num_unique;
 
  for (i = list; i; i = i->next_content, size++);
 
  if (size != 0)
    CREATE(unique,sh_int,size*2);

  if (unique == NULL)
  {
    list_obj_to_char2(list, ch, mode, show);
    return;
  }
  
  if (size != 0)
    CREATE(u_item_ptrs,struct obj_data*,size);

  if (u_item_ptrs == NULL)
  {
    if (unique != NULL)
      free(unique);
    list_obj_to_char2(list, ch, mode, show);
    return;
  }

  found=FALSE;
  num_unique=0;
  for (i = list; i; i = i->next_content)
  {
    item_num = i->item_number;
    if (item_num < 0)
    {
      if (CAN_SEE_OBJ(ch, i))
      {
        show_obj_to_char(i, ch, mode);
        found = TRUE;
      }
    } else {
      found=TRUE;         
      exists=FALSE;
      num=num_unique;
      while (num && !exists)
      {
        if (unique[(num-1)*2] == item_num)
	{
          exists=TRUE;
          unique[(num-1)*2+1]++;
        }
        num--;
      }
      if (!exists)
      {
        u_item_ptrs[num_unique]=i;
        unique[num_unique*2]=item_num;
        unique[num_unique*2+1]=1;
        num_unique++;
      }
    }
  }
  for (num=0; num<num_unique; num++)
    if (CAN_SEE_OBJ(ch,u_item_ptrs[num]))
    {
      if (unique[num*2+1]>1)
      {
        sprintf(buf2, "&b(&5%d&b)&5 ", unique[num*2+1]);
        send_to_char(buf2, ch);
      }
      show_obj_to_char(u_item_ptrs[num], ch, mode);
    }
  if (!found && show)
    send_to_char(" Nothing.\r\n", ch);

  if (unique != NULL)
    free(unique);
  if (u_item_ptrs != NULL)
    free(u_item_ptrs);
}

void diag_char_to_char(struct char_data * i, struct char_data * ch)
{
  int percent;

  if (GET_MAX_HIT(i) > 0)
    percent = (100 * GET_HIT(i)) / GET_MAX_HIT(i);
  else
    percent = -1;		/* How could MAX_HIT be < 1?? */

  strcpy(buf, PERS(i, ch));
  CAP(buf);

  if (percent >= 100)
    strcat(buf, " is in &Gexcellent&n condition.\r\n");
  else if (percent >= 90)
    strcat(buf, " has &ga few scratches&n.\r\n");
  else if (percent >= 75)
    strcat(buf, " has some &Ysmall wounds and bruises&n.\r\n");
  else if (percent >= 50)
    strcat(buf, " has &yquite a few wounds&n.\r\n");
  else if (percent >= 30)
    strcat(buf, " has some &Rbig nasty wounds&n and scratches.\r\n");
  else if (percent >= 15)
    strcat(buf, " looks &rpretty hurt&n.\r\n");
  else if (percent >= 0)
    strcat(buf, " is in &Mawful&n condition.\r\n");
  else
    strcat(buf, " is &mbleeding awfully&n from big wounds.\r\n");

   // Some mount information
   if (MOUNTING(i))
   {
      if (IS_NPC(i))
	sprintf(buf1, "Mounted by %s.\r\n", GET_NAME(MOUNTING(i)));
      else
	sprintf(buf1, "Mounted on %s.\r\n", GET_NAME(MOUNTING(i)));	
      strcat(buf, buf1);
   }
   if (MOUNTING_OBJ(i))
   {
      sprintf(buf1, "Mounted on %s.\r\n", MOUNTING_OBJ(i)->short_description);
      strcat(buf, buf1);
   }

  send_to_char(buf, ch);
}


void look_at_char(struct char_data * i, struct char_data * ch)
{
  int j, found;
  struct char_data *tch;

  if (!ch->desc)
    return;

  // Disguise special
  if (!IS_NPC(i) && IS_SET(GET_SPECIALS(i), SPECIAL_DISGUISE) && 
      CHAR_DISGUISED(i) && !IS_SET(PRF_FLAGS(i), PRF_HOLYLIGHT))
  {
    tch = read_mobile(CHAR_DISGUISED(i), VIRTUAL);
    char_to_room(tch, i->in_room);
    look_at_char(tch, ch);
    extract_char(tch);
    return;       	
  }

  // Artus> Vanity.
  if (!IS_NPC(i) && (GET_IDNUM(i) == 1) && (GET_LEVEL(ch) < LVL_IMPL))
  {
    act("You attempt to gaze upon the mighty $n, but your eyes fail to focus.\r\nYou feel humbled by the radiant essence that eminates from $m.\r\nYou cannot deny that this is one being not to be reckoned with.\r\n", FALSE, i, 0, ch, TO_VICT);
    return;
  }

  if (i->player.description)
    send_to_char(i->player.description, ch);
  else
    act("You see nothing special about $m.", FALSE, i, 0, ch, TO_VICT);

  diag_char_to_char(i, ch);

  found = FALSE;
  for (j = 0; !found && j < NUM_WEARS; j++)
    if (GET_EQ(i, j) && CAN_SEE_OBJ(ch, GET_EQ(i, j)))
      found = TRUE;

  
  if (found)
  {
    send_to_char("\r\n", ch);	/* act() does capitalization. */
    act("$n is using:", FALSE, i, 0, ch, TO_VICT);
    for (j = 0; j < NUM_WEARS; j++)
      if (GET_EQ(i, wear_positions[j]) && 
	  CAN_SEE_OBJ(ch, GET_EQ(i, wear_positions[j])))
      {
	/* Artus -- This works :o) */
        if ((wear_positions[j] == WEAR_HOLD) && IS_DUAL_WIELDING(i))
    	  send_to_char("<wielded (2nd)>      ", ch);
	else
	  send_to_char(where[wear_positions[j]], ch);
	show_obj_to_char(GET_EQ(i, wear_positions[j]), ch, 1);
      }
  }
  if (ch != i && (IS_THIEF(ch) || !LR_FAIL(ch, LVL_CHAMP)))
  {
    act("\r\nYou attempt to peek at $s inventory:", FALSE, i, 0, ch, TO_VICT);
    list_obj_to_char(i->carrying, ch, 1, FALSE);
  }
}

void list_rider(struct char_data *i, struct char_data *ch, int mode)
{
  if (!(CAN_SEE(ch, i) && MOUNTING(i)))
    return;
  if (IS_NPC(i))
  {
    sprintf(buf2, "...ridden by %s.", 
	    (MOUNTING(i) == ch ? "you" :
	     CAN_SEE(ch,MOUNTING(i)) ? GET_NAME(MOUNTING(i)) : "someone"));
    if (mode == 1)
      strcat(buf, buf2);
    if (mode == 0)
      act(buf2, FALSE, i, 0, ch, TO_VICT);
  } else {
    if (mode == 1)
      strcat(buf2, " (mounted)");
    if (mode == 0)
      act(" (mounted)", FALSE, i, 0, ch, TO_VICT);
  }
}

void list_one_char(struct char_data * i, struct char_data * ch)
{
  const char *positions[] =
  {
    " is lying here, dead.",
    " is lying here, mortally wounded.",
    " is lying here, incapacitated.",
    " is lying here, stunned.",
    " is sleeping here.",
    " is resting here.",
    " is sitting here.",
    "!FIGHTING!",
    " is standing here."
  };

  if (IS_NPC(i) && i->player.long_descr && GET_POS(i) == GET_DEFAULT_POS(i))
  {
    if (AFF_FLAGGED(i, AFF_INVISIBLE))
      strcpy(buf, "&6*");
    else
      strcpy(buf, "&6");
    if (AFF_FLAGGED(ch, AFF_DETECT_ALIGN))
    {
      if (IS_EVIL(i))
	strcat(buf, "&r(Red Aura) &6");
      else if (IS_GOOD(i))
	strcat(buf, "&b(Blue Aura) &6");
    }
    if (!IS_NPC(i))
	list_rider(i, ch, 1);
    //strcat(buf, "&6");
    strcat(buf, i->player.long_descr);
    send_to_char(buf, ch);
    if (AFF_FLAGGED(i, AFF_SANCTUARY))
      act("...$e glows with a bright light!", FALSE, i, 0, ch, TO_VICT);
    if (AFF_FLAGGED(i, AFF_BLIND))
      act("...$e is groping around blindly!", FALSE, i, 0, ch, TO_VICT);
    if (IS_AFFECTED(i, AFF_REFLECT))
      act("...You can see your reflection in $s skin!",FALSE,i,0,ch,TO_VICT);
    if (IS_NPC(i))
      list_rider(i, ch, 0);
    return;
  }
  if (IS_NPC(i))
  {
    strcpy(buf, "&6");
    strcat(buf, i->player.short_descr);
    CAP(buf);
  } else {
/* make it so ya can see they are a wolf/vampire - Vader */
    if(PRF_FLAGGED(i,PRF_WOLF) && affected_by_spell(i,SPELL_CHANGED))
      sprintf(buf,"&7%s the Werewolf",i->player.name);
    else if(PRF_FLAGGED(i,PRF_VAMPIRE) && affected_by_spell(i,SPELL_CHANGED))
      sprintf(buf,"&7%s %s&7",i->player.name,
              (GET_SEX(i) == SEX_MALE ? "the Vampire" : "the Vampiress"));
    else if(EXT_FLAGGED(i,EXT_GHOST))
      sprintf(buf,"&7%s the Ghost", i->player.name);
    else 
    {
      if (strlen(GET_TITLE(i)) > 0)
        sprintf(buf, "&7%s %s&7", i->player.name, GET_TITLE(i));
      else
	sprintf(buf, "&7%s", i->player.name);
    }
  }
  if (char_affected_by_timer(i, TIMER_MEDITATE))
    strcat(buf, " (meditating)");
  if (char_affected_by_timer(i, TIMER_HEAL_TRANCE))
    strcat(buf, " (entranced)");
  if (AFF_FLAGGED(i, AFF_INVISIBLE))
    strcat(buf, " (invisible)");
  if (AFF_FLAGGED(i, AFF_HIDE))
    strcat(buf, " (hidden)");
  if (!IS_NPC(i) && !i->desc)
    strcat(buf, " (linkless)");
  if (!IS_NPC(i) && PLR_FLAGGED(i, PLR_WRITING))
    strcat(buf, " (writing)");
  if (GET_POS(i) != POS_FIGHTING)
  {
    if(IS_AFFECTED(i,AFF_FLY))
      strcat(buf, " is floating here.");
    else
      strcat(buf, positions[(int) GET_POS(i)]);
  } else {
    if (FIGHTING(i))
    {
      strcat(buf, " is here, fighting ");
      if (FIGHTING(i) == ch)
	strcat(buf, "YOU!");
      else
      {
	if (i->in_room == FIGHTING(i)->in_room)
	  strcat(buf, PERS(FIGHTING(i), ch));
	else
	  strcat(buf, "someone who has already left");
	strcat(buf, "!");
      }
    } else			/* NIL fighting pointer */
      strcat(buf, " is here struggling with thin air.");
  }
  if (AFF_FLAGGED(ch, AFF_DETECT_ALIGN))
  {
    if (IS_EVIL(i))
      strcat(buf, " &r(Red Aura)&7");
    else if (IS_GOOD(i))
      strcat(buf, " &b(Blue Aura)&n");
  }
  if (!IS_NPC(i))
    list_rider(i, ch, 1);

  strcat(buf, "&n\r\n");
  send_to_char(buf, ch);

  if (AFF_FLAGGED(i, AFF_SANCTUARY))
    act("...$e glows with a bright light!", FALSE, i, 0, ch, TO_VICT);
  if (IS_AFFECTED(i, AFF_BLIND))
    act("...$e is groping around blindly!", FALSE, i, 0, ch, TO_VICT);
  if (IS_AFFECTED(i, AFF_REFLECT))
    act("...You can see your reflection in $s skin!",FALSE,i,0,ch,TO_VICT);
  if (IS_NPC(i))
    list_rider(i, ch, 0);
}

void list_char_to_char(struct char_data * list, struct char_data * ch)
{
  struct char_data *i;

  for (i = list; i; i = i->next_in_room)
    if (ch != i)
    {
      if (CAN_SEE(ch, i))
      {
	if (IS_NPC(ch))
	  continue;

        if (IS_NPC(i) || !CHAR_DISGUISED(i))
	 list_one_char(i, ch);
        else
        {
 	  struct char_data *mob = read_mobile(CHAR_DISGUISED(i), VIRTUAL);
	  sprintf(buf, "&6%s", mob->player.long_descr);
 	  send_to_char(buf, ch);
        }
      }
      else if (IS_DARK(ch->in_room) && !CAN_SEE_IN_DARK(ch) &&
	       AFF_FLAGGED(i, AFF_INFRAVISION))
	send_to_char("You see a pair of glowing red eyes looking your way.\r\n",
	             ch);
    }
}

void do_auto_exits(struct char_data * ch)
{
  int door, slen = 0;

  *buf = '\0';
  if (!IS_NPC(ch) && !PRF_FLAGGED(ch, PRF_BRIEF))
    do_exits(ch, 0, 0, 0);
  for (door = 0; door < NUM_OF_DIRS; door++)
    if (EXIT(ch, door) && EXIT(ch, door)->to_room != NOWHERE &&
	!EXIT_FLAGGED(EXIT(ch, door), EX_CLOSED))
      slen += sprintf(buf + slen, "%c ", LOWER(*dirs[door]));
  sprintf(buf2, "&8[ Exits: %s]&n\r\n", *buf ? buf : "None! ");
  send_to_char(buf2, ch);
}


ACMD(do_exits)
{
  int door;

  *buf = '\0';

  if (AFF_FLAGGED(ch, AFF_BLIND))
  {
    send_to_char("You can't see a damned thing, you're blind!\r\n", ch);
    return;
  }
  for (door = 0; door < NUM_OF_DIRS; door++)
    if (EXIT(ch, door) && EXIT(ch, door)->to_room != NOWHERE &&
	!EXIT_FLAGGED(EXIT(ch, door), EX_CLOSED))
    {
      if (!LR_FAIL(ch, LVL_IS_GOD))
	sprintf(buf2, "%-5s - [%5d] %s\r\n", dirs[door],
		GET_ROOM_VNUM(EXIT(ch, door)->to_room),
		world[EXIT(ch, door)->to_room].name);
      else
      {
	sprintf(buf2, "%-5s - ", dirs[door]);
	if (IS_DARK(EXIT(ch, door)->to_room) && !CAN_SEE_IN_DARK(ch))
	  strcat(buf2, "Too dark to tell\r\n");
	else
	{
	  strcat(buf2, world[EXIT(ch, door)->to_room].name);
	  strcat(buf2, "\r\n");
	}
      }
      strcat(buf, CAP(buf2));
    }
  send_to_char("Obvious exits:\r\n", ch);
  if (*buf)
    send_to_char(buf, ch);
  else
    send_to_char(" None.\r\n", ch);
}

void show_wounded_to_char(struct char_data *ch)
{
  struct char_data *pers;
  for (pers = world[ch->in_room].people; pers; pers = pers->next_in_room)
  {
    int perc; 
    if (IS_NPC(pers) || (pers == ch) || !CAN_SEE(ch, pers))
      continue;
    if ((pers == FIGHTING(ch)) || (FIGHTING(pers) == ch))
      continue;
    perc = (int)((100 * GET_HIT(pers)) / GET_MAX_HIT(pers));
    if (perc > 90)
      continue;
    if (perc > 75)
    {
      act("$N&r could use a little healing!&n", TRUE, ch, NULL, pers, TO_CHAR);
      continue;
    }
    if (perc > 50)
    {
      act("$N&r could use some healing!&n", TRUE, ch, NULL, pers, TO_CHAR);
      continue;
    }
    if (perc > 25)
    {
      act("$N&r could use alot of healing!&n", TRUE, ch, NULL, pers, TO_CHAR);
      continue;
    }
    if (perc > 10)
    {
      act("$N&r could use some major healing!&n", TRUE, ch, NULL, pers, TO_CHAR);
      continue;
    }
    act("$N&r could use some miraculous healing, or $E will surely die!!&n\r\n",
	TRUE, ch, NULL, pers, TO_CHAR);
  }
}

void look_at_room(struct char_data * ch, int ignore_brief)
{
  int i = 0;

  if (!ch->desc)
    return;

  // Artus> This is bad(tm).
  if (IN_ROOM(ch) == NOWHERE)
  {
    sprintf(buf, "SYSERR: NOWHERE while %s looking at room.", GET_NAME(ch));
    mudlog(buf, NRM, LVL_IMPL, TRUE);
    send_to_char("You are NOWHERE?!?! This is a bug.\r\n"
	         "Please email a report to bugs@@mud.alphalink.com.au.\r\n", ch);
    core_dump();
    return;
  }

  if (IS_DARK(ch->in_room) && !CAN_SEE_IN_DARK(ch))
  {
    send_to_char("It is pitch black...\r\n", ch);
    return;
  } else if (AFF_FLAGGED(ch, AFF_BLIND)) {
    send_to_char("You see nothing but infinite darkness...\r\n", ch);
    return;
  }

  send_to_char(/*CCCYN(ch, C_NRM)*/"&8", ch);
  // If the room is a burgled area, it will have varying descriptions, reget
  long lBurgleFlag;
  if ((lBurgleFlag = is_room_burgled(ch->in_room)) != 0)
  {
     world[ch->in_room].name = rand_name(lBurgleFlag);
     world[ch->in_room].description = rand_desc(lBurgleFlag);
  }
  if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_ROOMFLAGS))
  {
    sprintbit(ROOM_FLAGS(ch->in_room), room_bits, buf);
    sprintbit(BURGLE_FLAGS(ch->in_room), burgle_rooms, buf1);
    sprintf(buf2, "[%5d] %s [ %s] [ %s]", GET_ROOM_VNUM(IN_ROOM(ch)),
	    world[ch->in_room].name, buf, buf1);
    send_to_char(buf2, ch);
  } else
    send_to_char(world[ch->in_room].name, ch);

  send_to_char(CCNRM(ch, C_NRM), ch);
  send_to_char("\r\n", ch);

  if ((!IS_NPC(ch) && !PRF_FLAGGED(ch, PRF_BRIEF)) || ignore_brief ||
      ROOM_FLAGGED(ch->in_room, ROOM_DEATH))
    send_to_char(world[ch->in_room].description, ch);

  /* autoexits */
  if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_AUTOEXIT))
    do_auto_exits(ch);

  if ((has_stats_for_skill(ch, SKILL_DETECT_DEATH, FALSE)) && 
      (number(1, 101) < GET_SKILL(ch, SKILL_DETECT_DEATH)))
  {
    bool found=FALSE;
    for (i = 0; i < NUM_OF_DIRS; i++)
      if (EXIT(ch, i) && (EXIT(ch, i)->to_room != NOWHERE) &&
	  ROOM_FLAGGED(EXIT(ch, i)->to_room, ROOM_DEATH))
      {
	found=TRUE;
	if (i < DOWN)
	  sprintf(buf, "&rYou sense death to your %s.&n\r\n", dirs[i]);
	else
	  sprintf(buf, "&rYou sense death %s you.&n\r\n", (i == DOWN) ? "below" : "above");
	send_to_char(buf, ch);
      }
    if (found)
      apply_spell_skill_abil(ch, SKILL_DETECT_DEATH);
  }

  if (RMSM_FLAGGED(IN_ROOM(ch), RMSM_BURNED))
    send_to_char("&cThe ground here is laden with ash.&n\r\n", ch);

  /* now list characters & objects */
  //send_to_char(CCGRN(ch, C_NRM), ch);
  list_obj_to_char(world[ch->in_room].contents, ch, 0, FALSE);
  //send_to_char(CCYEL(ch, C_NRM), ch);
  list_char_to_char(world[ch->in_room].people, ch);

  //Artus> Sense Wounds.
  if(!IS_NPC(ch) && AFF_FLAGGED(ch, AFF_SENSE_WOUNDS))
    show_wounded_to_char(ch);

  if(HUNTING(ch)) 
  {
    send_to_char(CCRED(ch, C_NRM), ch);
    do_track(ch, "", 0, SCMD_AUTOHUNT);
  }
  send_to_char(CCNRM(ch, C_NRM), ch);
}

void look_in_direction(struct char_data * ch, int dir)
{
  if (EXIT(ch, dir))
  {
    if (EXIT(ch, dir)->general_description)
      send_to_char(EXIT(ch, dir)->general_description, ch);
    else
      send_to_char("You see nothing special.\r\n", ch);

    if (EXIT_FLAGGED(EXIT(ch, dir), EX_CLOSED) && EXIT(ch, dir)->keyword) {
      sprintf(buf, "The %s is closed.\r\n", fname(EXIT(ch, dir)->keyword));
      send_to_char(buf, ch);
    } else if ((EXIT_FLAGGED(EXIT(ch, dir), EX_ISDOOR)) &&
	       (EXIT(ch, dir)->keyword))
    {
      sprintf(buf, "The %s is open.\r\n", fname(EXIT(ch, dir)->keyword));
      send_to_char(buf, ch);
    }
  } else
    send_to_char("Nothing special there...\r\n", ch);
}

void look_in_obj(struct char_data * ch, char *arg)
{
  struct obj_data *obj = NULL;
  struct char_data *dummy = NULL;

  if (!*arg)
  {
    send_to_char("Look in what?\r\n", ch);
    return;
  }
  if (!(generic_find(arg, FIND_OBJ_INV | FIND_OBJ_ROOM | FIND_OBJ_EQUIP, 
	             ch, &dummy, &obj))) 
  {
    sprintf(buf, "There doesn't seem to be %s %s here.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
    return;
  }
  show_contents_to(ch, obj);
}

// Artus> Helper function for look_in_obj() and examine_obj().
void show_contents_to(struct char_data *ch, struct obj_data *obj)
{
  int amt;

  if (!(obj))
  {
    mudlog("SYSERR: show_contents_to() called with no obj.", NRM, LVL_IMPL,
	   TRUE);
    return;
  }
  if (!(ch))
  {
    mudlog("SYSERR: show_contents_to() called with no char.", NRM, LVL_IMPL,
	   TRUE);
    return;
  }
  
  if ((GET_OBJ_TYPE(obj) != ITEM_DRINKCON) &&
      (GET_OBJ_TYPE(obj) != ITEM_FOUNTAIN) &&
      (GET_OBJ_TYPE(obj) != ITEM_CONTAINER))
  {
    send_to_char("It's solid!\r\n", ch);
    return;
  }
  if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER) 
  {
    if (OBJVAL_FLAGGED(obj, CONT_CLOSED))
    {
      send_to_char("It is closed.\r\n", ch);
      return;
    }
    send_to_char(fname(obj->name), ch);
    if (obj->worn_by == ch)
      send_to_char(" (worn):\r\n", ch);
    else if (obj->carried_by == ch)
      send_to_char(" (carried):\r\n", ch);
    else 
      send_to_char(" (here):\r\n", ch);
    list_obj_to_char(obj->contains, ch, 2, TRUE);
    return;
  }
  /* item must be a fountain or drink container */
  if (GET_OBJ_VAL(obj, 1) <= 0)
  {
    send_to_char("It is empty.\r\n", ch);
    return;
  }
  if (GET_OBJ_VAL(obj,0) <= 0 || GET_OBJ_VAL(obj,1)>GET_OBJ_VAL(obj,0)) 
  {
    send_to_char("Its contents seem somewhat murky.\r\n", ch); /* BUG */
    return;
  }
  amt = (GET_OBJ_VAL(obj, 1) * 3) / GET_OBJ_VAL(obj, 0);
  sprinttype(GET_OBJ_VAL(obj, 2), color_liquid, buf2);
  sprintf(buf, "It's %sfull of a %s liquid.\r\n", fullness[amt], buf2);
  send_to_char(buf, ch);
}



char *find_exdesc(char *word, struct extra_descr_data * list)
{
  struct extra_descr_data *i;

  for (i = list; i; i = i->next)
    if (isname(word, i->keyword))
      return (i->description);
  return (NULL);
}


/*
 * Given the argument "look at <target>", figure out what object or char
 * matches the target.  First, see if there is another char in the room
 * with the name.  Then check local objs for exdescs.
 *
 * Thanks to Angus Mezick <angus@@EDGIL.CCMAIL.COMPUSERVE.COM> for the
 * suggested fix to this problem.
 *
 * Artus> Modified to allow target to be read by calling functions.
 */
void look_at_target(struct char_data *ch, char *arg, 
                    struct char_data **tch, struct obj_data **tobj)
{
  int bits, found = FALSE, j, fnum, i = 0;
  struct char_data *found_char = NULL;
  struct obj_data *obj, *found_obj = NULL;
  char *desc;
  bool glancing = FALSE;

  if (tch)
    *tch = NULL;
  if (tobj)
    *tobj = NULL;

  if (!ch->desc)
    return;

  if (!*arg)
  {
    send_to_char("Look at what?\r\n", ch);
    return;
  }

  bits = generic_find(arg, FIND_OBJ_INV | FIND_OBJ_ROOM | FIND_OBJ_EQUIP |
		      FIND_CHAR_ROOM, ch, &found_char, &found_obj);

  /* Is the target a character? */
  if (found_char != NULL) 
  {
    if (tch)
      *tch = found_char;
    look_at_char(found_char, ch);
    if (ch == found_char) 
      return; // Don't display look/self messages, don't apply glance.
    if (!IS_NPC(ch) && (GET_SKILL(ch, SKILL_GLANCE)))
      glancing = (number(0, 101) < GET_SKILL(ch, SKILL_GLANCE));
    if (glancing)
    {
      apply_spell_skill_abil(ch, SKILL_GLANCE);
      if (GET_LEVEL(found_char) > LVL_ISNOT_GOD)
	act("$n glances at you", TRUE, ch, 0, found_char, TO_VICT);
      return; // Don't display look at message if glancing.
    }
    if (CAN_SEE(found_char, ch))
      act("$n looks at you.", TRUE, ch, 0, found_char, TO_VICT);
    act("$n looks at $N.", TRUE, ch, 0, found_char, TO_NOTVICT);
    return;
  }

  /* Strip off "number." from 2.foo and friends. */
  if (!(fnum = get_number(&arg)))
  {
    send_to_char("Look at what?\r\n", ch);
    return;
  }

  /* Does the argument match an extra desc in the room? */
  if (((desc = find_exdesc(arg, world[ch->in_room].ex_description)) != NULL) &&
      (++i == fnum))
  {
    page_string(ch->desc, desc, FALSE);
    return;
  }

  /* Does the argument match an extra desc in the char's equipment? */
  for (j=0; j < NUM_WEARS && !found; j++)
    if (GET_EQ(ch, j) && CAN_SEE_OBJ(ch, GET_EQ(ch, j)))
      if (((desc = find_exdesc(arg, GET_EQ(ch, j)->ex_description)) != NULL) &&
	  (++i == fnum))
      {
	send_to_char(desc, ch);
	send_to_char(show_object_damage(GET_EQ(ch, j)), ch);
	found = TRUE;
	if (tobj)
	  *tobj = GET_EQ(ch, j);
      }
  /* Does the argument match an extra desc in the char's inventory? */
  for (obj=ch->carrying; obj && !found; obj = obj->next_content)
  {
    if (CAN_SEE_OBJ(ch, obj))
      if (((desc = find_exdesc(arg, obj->ex_description)) != NULL) &&
	  (++i == fnum))
      {
	send_to_char(desc, ch);
	send_to_char(show_object_damage(obj), ch);
	found = TRUE;
	if (tobj)
	  *tobj = obj;
      }
  }
  /* Does the argument match an extra desc of an object in the room? */
  for (obj=world[ch->in_room].contents; obj && !found; obj=obj->next_content)
    if (CAN_SEE_OBJ(ch, obj))
      if (((desc = find_exdesc(arg, obj->ex_description)) != NULL) &&
	  (++i == fnum))
      {
	send_to_char(desc, ch);	
	send_to_char(show_object_damage(obj), ch);
	found = TRUE;
	if (tobj)
	  *tobj = obj;
      }
  /* If an object was found back in generic_find */
  if (bits) 
  {
    if (!found)
      show_obj_to_char(found_obj, ch, 5);	/* Show no-description */
    else
      show_obj_to_char(found_obj, ch, 6);	/* Find hum, glow etc */
    if ((tobj) && !(*tobj))
      *tobj = found_obj;
  } else if (!found)
    send_to_char("You do not see that here.\r\n", ch);
  desc = NULL;
}


ACMD(do_look)
{
  char arg2[MAX_INPUT_LENGTH];
  int look_type;

  if (!ch->desc)
    return;

  if (GET_POS(ch) < POS_SLEEPING)
    send_to_char("You can't see anything but stars!\r\n", ch);
  else if (AFF_FLAGGED(ch, AFF_BLIND))
    send_to_char("You can't see a damned thing, you're blind!\r\n", ch);
  else if (IS_DARK(ch->in_room) && !CAN_SEE_IN_DARK(ch)) {
    send_to_char("It is pitch black...\r\n", ch);
    list_char_to_char(world[ch->in_room].people, ch);	/* glowing red eyes */
  } else {
    half_chop(argument, arg, arg2);

    if (subcmd == SCMD_READ) {
      if (!*arg)
	send_to_char("Read what?\r\n", ch);
      else
	look_at_target(ch, arg);
      return;
    }
    if (!*arg)			/* "look" alone, without an argument at all */
      look_at_room(ch, 1);
    else if (is_abbrev(arg, "in"))
      look_in_obj(ch, arg2);
    /* did the char type 'look <direction>?' */
    else if ((look_type = search_block(arg, dirs, FALSE)) >= 0)
      look_in_direction(ch, look_type);
    else if (is_abbrev(arg, "at"))
      look_at_target(ch, arg2);
    else
      look_at_target(ch, arg);
  }
}

ACMD(do_examine)
{
  struct char_data *tmp_char;
  struct obj_data *tmp_object;

  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Examine what?\r\n", ch);
    return;
  }
  look_at_target(ch, arg, &tmp_char, &tmp_object);

//  generic_find(arg, FIND_OBJ_INV | FIND_OBJ_ROOM | FIND_CHAR_ROOM |
//		      FIND_OBJ_EQUIP, ch, &tmp_char, &tmp_object);

  if (tmp_object) 
  {
    if ((GET_OBJ_TYPE(tmp_object) == ITEM_DRINKCON) ||
	(GET_OBJ_TYPE(tmp_object) == ITEM_FOUNTAIN) ||
	(GET_OBJ_TYPE(tmp_object) == ITEM_CONTAINER)) 
    {
      send_to_char("When you look inside, you see:\r\n", ch);
      show_contents_to(ch, tmp_object);
    }
  }
}

ACMD(do_gold)
{
  long total = GET_GOLD(ch) + GET_BANK_GOLD(ch);

  // No Gold.
  if (total < 1)
  {
    send_to_char("You're dead broke!\r\n", ch);
    return;
  }
  // One pathetic coin.
  if (total == 1) 
  {
    if (GET_GOLD(ch) < 1)
      send_to_char("You have one miserable little gold coin, banked away.\r\n", ch);
    else
      send_to_char("You fumble around in your pockets to make sure you haven't lost your one coin.\r\n", ch);
    return;
  }
  // All on hand.
  if (GET_BANK_GOLD(ch) < 1)
  {
    sprintf(buf, "You have &Y%d&n gold coins all on hand.\r\n", GET_GOLD(ch));
    if (GET_GOLD(ch) >= 250000)
      strcat(buf, "Perhaps you should put some in the bank?\r\n");
    send_to_char(buf, ch);
    return;
  }
  // All in bank.
  if (GET_GOLD(ch) < 1)
  {
    sprintf(buf, "You have &Y%d&n gold coins, all kept safely in the bank.\r\n", GET_BANK_GOLD(ch));
    send_to_char(buf, ch);
    return;
  }
  // Combination.
  sprintf(buf, "You have &Y%d&n gold coin%s, and &Y%d&n in the bank, totalling &Y%ld&n.\r\n", GET_GOLD(ch), (GET_GOLD(ch) > 1 ? "s" : ""), GET_BANK_GOLD(ch), total);
  if (GET_GOLD(ch) > GET_BANK_GOLD(ch))
    strcat(buf, "Maybe you should put some more in the bank?\r\n");
  send_to_char(buf, ch);
}

#if 0 // Artus> Currently Unused.
// Sets the bits in the bitvector according to user choice
long getScoreDetail(char *argument, struct char_data *ch)
{
  long lVector=0;
  int nLevel;

  if (!strcmp(argument, "brief"))
    nLevel = 1;
  else if (!strcmp(argument, "long"))
    nLevel = 3;
  else if (!strcmp(argument, "regular"))
    nLevel = 2;
  else
    return -1;

  if (nLevel >= 1) 		// Bare
  {	
    SET_BIT(lVector, SCORE_DAMROLL);
    SET_BIT(lVector, SCORE_HITROLL);
    SET_BIT(lVector, SCORE_NAME);
    SET_BIT(lVector, SCORE_AC);
    SET_BIT(lVector, SCORE_HMV);
  }
  if (nLevel >= 2)		// Other stuff
  {
    SET_BIT(lVector, SCORE_ALIGN);
    SET_BIT(lVector, SCORE_THACO);
    SET_BIT(lVector, SCORE_LEVEL);
    SET_BIT(lVector, SCORE_RACE);
    SET_BIT(lVector, SCORE_CLASS);
    SET_BIT(lVector, SCORE_STATS);
  }
  if (nLevel >= 3)		// The whole deal
  {
    SET_BIT(lVector, SCORE_AFFECTS);
    SET_BIT(lVector, SCORE_ABILITIES);
    SET_BIT(lVector, SCORE_INVENTORY);
    SET_BIT(lVector, SCORE_AGE);
    SET_BIT(lVector, SCORE_HEIGHTWEIGHT);
    SET_BIT(lVector, SCORE_SEX);
    SET_BIT(lVector, SCORE_GOLD);
    SET_BIT(lVector, SCORE_TIME);
    SET_BIT(lVector, SCORE_CARRYING);
  }
  SCORE_SETTINGS(ch) = lVector;
  return lVector;
}

void score_help_to_char(struct char_data *ch)
{
  send_to_char("The valid score settings are:\r\n"
               "  damroll  hitroll    age        level    affects\r\n"
               "  name     abilities  inventory  height   hmv\r\n"
               "  sex      gold       stats      class    ac\r\n"
               "  align    thaco      carrying   none\r\n"
               "In addition, the following sets are available:\r\n"
               "  brief    regular    long\r\n", ch);
}

void setScore(struct char_data *ch, char *argument)
{
  if (getScoreDetail(argument, ch) != -1)
    return;
  else if (strcmp(argument, "damroll") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_DAMROLL);
  else if (strcmp(argument, "hitroll") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_HITROLL);
  else if (strcmp(argument, "age") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_AGE);
  else if (strcmp(argument, "level") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_LEVEL);
  else if (strcmp(argument, "affects") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_AFFECTS);
  else if (strcmp(argument, "name") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_NAME);
  else if (strcmp(argument, "abilities") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_ABILITIES);
  else if (strcmp(argument, "inventory") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_INVENTORY);
  else if (strcmp(argument, "height") == 0 || strcmp(argument, "weight") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_HEIGHTWEIGHT);
  else if (strcmp(argument, "race") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_RACE);
  else if (strcmp(argument, "sex") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_SEX);
  else if (strcmp(argument, "gold") == 0 || strcmp(argument, "bank") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_GOLD);
  else if (strcmp(argument, "stats") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_STATS);
  else if (strcmp(argument, "class") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_CLASS);
  else if (strcmp(argument, "ac") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_AC);
  else if (strcmp(argument, "align") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_ALIGN);
  else if (strcmp(argument, "thac0") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_THACO);
  else if (strcmp(argument, "hmv") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_HMV);
  else if ((strcmp(argument, "quest") == 0) ||
	   (strcmp(argument, "questpoints") == 0))
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_QUESTPOINTS);
  else if (strcmp(argument, "carrying") == 0)
    SETREMOVE(SCORE_SETTINGS(ch), SCORE_CARRYING);
  else if (strcmp(argument, "list") == 0)
  {
    score_help_to_char(ch);
    return;
  }
  else if (strcmp(argument, "none") == 0)
  {
    send_to_char("All score settings removed.\r\n", ch);
    SCORE_SETTINGS(ch) = 0;
    return;
  }
  else
    strcpy(argument, "unknown");

  // Inform player
  if (strcmp(argument, "unknown") == 0)
    send_to_char("Unknown score setting...Try '&yscore set list&n'...\r\n", ch);
  else
  {
    sprintf(buf2, "Score setting for &B%s&n updated...\r\n", argument);
    send_to_char(buf2, ch);
  }
}

char *getColorType(int current, int max)
{
  basic_mud_log("%d, %d", current, max);

  if (current < (max / 4))
    return "&r";
  if (current < (max / 2))
    return "&R";
  if (current < max)
    return "&Y";
  
  return "&G";
}

void showScoreItem(struct char_data *ch, int item, bool show)
{
  bool bFound = TRUE;

  if (!show) 
    return;
  switch(item)
  {
    case 0:	//  Damroll
      sprintf(buf, "Damroll: %d\r\n", GET_DAMROLL(ch));
      break;
    case 1:	// Hitroll
      sprintf(buf, "Hitroll: %d\r\n", GET_HITROLL(ch));
      break;
    case 2: // Age
      sprintf(buf, "Age: %d\r\n", GET_AGE(ch));
      break;
    case 3: // Name
      sprintf(buf, "Character Name: %s\r\n", GET_NAME(ch));
      break;
    case 4: // Level
      sprintf(buf, "Level: %d\r\n", GET_LEVEL(ch));
      break;
    case 5: // Stats
      sprintf(buf, "Strength    :  %2d (%2d)\r\n"
		   "Intelligence:  %2d (%2d)\r\n"
		   "Wisdom      :  %2d (%2d)\r\n"
		   "Dexterity   :  %2d (%2d)\r\n"
		   "Constitution:  %2d (%2d)\r\n"
		   "Charisma    :  %2d (%2d)\r\n",
	      GET_REAL_STR(ch), GET_AFF_STR(ch), 
	      GET_REAL_INT(ch), GET_AFF_INT(ch),
	      GET_REAL_WIS(ch), GET_AFF_WIS(ch),
	      GET_REAL_DEX(ch), GET_AFF_DEX(ch),
	      GET_REAL_CON(ch), GET_AFF_CON(ch),
	      GET_REAL_CHA(ch), GET_AFF_CHA(ch));
      break;
    case 6: // Race
      sprinttype(GET_RACE(ch), pc_race_types, buf2);
      sprintf(buf, "Race: %s\r\n", buf2);
      break;
    case 7: // Class
      sprinttype(GET_CLASS(ch), pc_class_types, buf2);
      sprintf(buf, "Class: %s\r\n", buf2);
      break;
    case 8: // HMV
      sprintf(buf, "Hit Points: %s%5d&n / %-5d\r\n"
		   "Mana      : %s%5d&n / %-5d\r\n"
		   "Movement  : %s%5d&n / %-5d\r\n",
		   getColorType(GET_HIT(ch), GET_MAX_HIT(ch)),
		   GET_HIT(ch), GET_MAX_HIT(ch),
		   getColorType(GET_MANA(ch), GET_MAX_MANA(ch)),
		   GET_MANA(ch), GET_MAX_MANA(ch),
		   getColorType(GET_MOVE(ch), GET_MAX_MOVE(ch)),
		   GET_MOVE(ch), GET_MAX_MOVE(ch));
      break;
    case 9: // AC
//      sprintf(buf, "Armour Class: %d\r\n", GET_AC(ch));
      sprintf(buf, "Armour Class: %d\r\n", compute_armor_class(ch, 0));
      break;
    case 10: // THAC0
      sprintf(buf, "THAC0: %d\r\n", thaco(ch, NULL));
      break;
    case 11: // Height & Weight
      sprintf(buf, "Height: %d, Weight: %d\r\n",
	      GET_HEIGHT(ch), GET_WEIGHT(ch));
      break;
    case 12: // Align
      sprintf(buf, "Alignment: %d\r\n", GET_ALIGNMENT(ch));
      break;
    case 13: // Gold & Bank
      sprintf(buf, "Gold: %d, Bank: %d\r\n", GET_GOLD(ch), GET_BANK_GOLD(ch));
      break;
    case 14: // Time
      sprintf(buf, "Time played: %s\r\n", "TODO!");
      break;
    case 15: // Inv
      sprintf(buf, "Inventory stats: %s\r\n", "TODO!");
      break;
    case 16: // Affects
      sprintf(buf, "Affected by: %s\r\n", "TODO!");
      break;
    case 17: // Abilities
      sprintf(buf, "Abilities: %s\r\n", "TODO!");
      break;
    case 18: // Sex
      sprintf(buf, "Sex: %s\r\n", (GET_SEX(ch) == SEX_MALE   ? "Male"   :
	                           GET_SEX(ch) == SEX_FEMALE ? "Female" :
				   "N/A"));
      break; 
    case 19: // Quest points
      sprintf(buf, "Stat points: %d\r\n", GET_STAT_POINTS(ch));
      break;
    default: 
      bFound = FALSE;
      break;
  }
  if (bFound)
    send_to_char(buf, ch);
}
#endif

/* Primal score:
 * 	- Allows for brief/regular/detailed score commands
 *	- Allows complete customisation
 *	- Information limited by level
 */
void primal_score(struct char_data *ch, char *argument)
{
   //byte crap=0;
   void old_primal_score(struct char_data *ch);
   
   // DM - TEMP, use old score page
   old_primal_score(ch);
   return;

#if 0 // Artus> Not Used.
   half_chop(argument, arg, buf1);

   if (*argument && strcmp(arg, "set") == 0)
   {
	setScore(ch, buf1);
	return;
   }
   /*
   if (!*argument)
	lScoreDetail = getScoreDetail("regular");
   else  
	lScoreDetail = getScoreDetail(arg);
   */

   /* Old 
   send_to_char("--( TODO: Refine format  )--\r\n", ch);
   for( int i = 0; i < NUM_SCORE_SETTINGS; i++)
   {
      // Do they want to see it, and is it in their detail level chosen?
      if (IS_SET(SCORE_SETTINGS(ch), (1 << i)) / *&& IS_SET(lScoreDetail, (1 << i))* /)
	showScoreItem(ch, i, TRUE);
      else
	showScoreItem(ch, i, FALSE);	  
   }
   */
   sprintf(buf, "\r\n&r.-&R'-.&y_.&Y-'-&y._");
   for (int i = 0; i < 5; i++) 
     strcat(buf, "&r.-&R'-.&y_.&Y-'-&y._");
   strcat(buf, "&r,-&R'-.&n\r\n\r\n");

   // Line 2: Lvl sex race, name class: age:
   
   if (IS_SET(SCORE_SETTINGS(ch), SCORE_LEVEL)) {
     crap = 1;
     sprintf(buf, "%s  &0Lvl&n %3d", buf, GET_LEVEL(ch));      
   }

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_SEX)) {
     if (crap <1) 
       strcat (buf, "  ");
     else
       strcat (buf, " ");
     crap = 1;
     switch (GET_SEX(ch)) {
       case SEX_MALE:
         strcat(buf, "Male");
         break;
       case SEX_FEMALE:
         strcat(buf, "Female");
         break;
       default:
         strcat(buf, "Sexless");
     }
   }

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_RACE)) {
     if (crap <1) 
       strcat (buf, "  ");
     else
       strcat (buf, " ");
     crap = 1;
     sprintf(buf, "%s%s", buf, pc_race_types[GET_RACE(ch)]);
   }

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_NAME)) {
     if (crap <1) 
       strcat (buf, "  ");
     else
       strcat(buf, ", ");
     crap = 1;
     sprintf(buf, "%s%s", buf, GET_NAME(ch));
   }

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_CLASS)) {
     if (crap <1) 
       strcat (buf, "  ");
     else
       strcat(buf, " ");
     crap = 1;
     sprintf(buf, "%s&0Class:&n %s", buf, pc_class_types[(int)GET_CLASS(ch)]);
   }

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_AGE)) {
     if (crap <1) 
       strcat (buf, "  ");
     else
       strcat(buf, " ");
     crap = 1;
     sprintf(buf, "%s&0Age:&n %d", buf, GET_AGE(ch));
   }

   if (crap == 1)
     strcat(buf, "\r\n");

   // Line 3: 

   crap = 0;
   if (IS_SET(SCORE_SETTINGS(ch), SCORE_HMV)) {
     crap = 1;
     sprintf (buf, "%s  &9Hit:&n %d&4/&n%d&4+&n%d &9Mana:&n %d&4/&n%d&4+&n%d &9Move:&n %d&4/&n%d&4+&n%d", buf, GET_HIT(ch), GET_MAX_HIT(ch), hit_gain(ch), GET_MANA(ch), GET_MAX_MANA(ch), mana_gain(ch), GET_MOVE(ch), GET_MAX_MOVE(ch), move_gain(ch));
   }

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_THACO)) {
     if (crap < 1)
       sprintf(buf, "%s  &9THAC0:&n %-5d", buf, thaco(ch, NULL));
     else  
       sprintf(buf, "%s &9THAC0:&n %-5d", buf, thaco(ch, NULL));
     crap = 1;
   } 
   if (crap == 1)
     strcat(buf, "\r\n");

   // Line 4:

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_STATS)) {
     sprintf (buf, "%s  &9Str:&n %d&4(&n%d&4)&n &9Int:&n %d&4(&n%d&4)&n &9Wis:&n %d&4(&n%d&4)&9 Dex:&n %d&4(&n%d&4)&9 Con:&n %d&4(&n%d&4)&9 Cha:&n %d&4(&n%d&4)&n\r\n", buf, GET_REAL_STR(ch), GET_AFF_STR(ch), GET_REAL_INT(ch), GET_AFF_INT(ch), GET_REAL_WIS(ch), GET_AFF_WIS(ch), GET_REAL_DEX(ch), GET_AFF_DEX(ch), GET_REAL_CON(ch), GET_AFF_CON(ch), GET_REAL_CHA(ch), GET_AFF_CHA(ch));
   }

   // Line 5:
   crap = 0;

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_DAMROLL)) { 
     sprintf(buf, "%s  &9Damroll:&n %-11d", buf, GET_DAMROLL(ch));
     crap = 1;
   } else
     sprintf(buf, "%s%22s", buf, " ");

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_HITROLL)) { 
     sprintf(buf, "%s&9Hitroll: &n%-4d", buf, GET_HITROLL(ch));
     crap = 1;
   } else 
     sprintf(buf, "%s%13s", buf, " ");

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_AC)) { 
     sprintf(buf, "%s&9Ac:&n %4d&n  ", buf, GET_AC(ch));
     crap = 1;
   } else
     sprintf(buf, "%s%13s", buf, " ");

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_ALIGN)) { 
     crap = 1;
     if (GET_ALIGNMENT(ch) > 350) {
       sprintf(buf1, "&cGood");
       sprintf(buf2, "&c");
     } else if (GET_ALIGNMENT(ch) < -350) {
       sprintf(buf1, "&rEvil");
       sprintf(buf2, "&r");
     } else {
       sprintf(buf1, "&WNeutral");
       sprintf(buf2, "&W");
     }     
     sprintf(buf, "%s&9Align:&n %s&b(%s%d&b)&n", buf, buf1, buf2, GET_ALIGNMENT(ch)); 
   }

   if (crap == 1)
     strcat(buf, "\r\n");

   // Line 6: Gold,Bank,Height,Weight

   crap = 0;

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_GOLD)) {
     sprintf(buf,"%s  &9Gold   : &Y%-14d&9Bank: &Y%-16d&n", buf, GET_GOLD(ch), GET_BANK_GOLD(ch));
     crap = 1;
   }

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_HEIGHTWEIGHT)) {
     if (crap < 1)
       strcat(buf, "  ");
     sprintf(buf,"%s&9Height:&n %d &9Weight:&n %d", buf, GET_HEIGHT(ch), GET_WEIGHT(ch));
     crap = 1;
   }
   
   if (crap > 0)
     strcat(buf, "\r\n");

   // Line 7: Carrying Weight/Items

   if (IS_SET(SCORE_SETTINGS(ch), SCORE_CARRYING))
     sprintf(buf, "%s  &9Carrying Items:&n %3d&4/&n%-16d&9Carrying Weight:&n %d&4/&n%d\r\n", buf, IS_CARRYING_N(ch), CAN_CARRY_N(ch), IS_CARRYING_W(ch), CAN_CARRY_W(ch));

   send_to_char(buf, ch);
   
/* Score flags
#define SCORE_DAMROLL		(1 << 0) 	/ * Damroll * /  
#define SCORE_HITROLL		(1 << 1) 	/ * Hitroll * /
#define SCORE_AGE		(1 << 2)	/ * Age * /
#define SCORE_NAME		(1 << 3)	/ * Character name * /
#define SCORE_LEVEL		(1 << 4)	/ * Character Level  * /
#define SCORE_STATS		(1 << 5)	/ * Character's stats * /
#define SCORE_RACE		(1 << 6)	/ * Race * /
#define SCORE_CLASS		(1 << 7)	/ * Class * /
#define SCORE_HMV		(1 << 8)	/ * Hit/mana/move * /
#define SCORE_AC		(1 << 9)	/ * Armour class * /
#define SCORE_THACO		(1 << 10)	/ * THAC0 * /
#define SCORE_HEIGHTWEIGHT	(1 << 11)	/ * Height & Weight * /
#define SCORE_ALIGN		(1 << 12)	/ * Alignment * /
#define SCORE_GOLD		(1 << 13)	/ * Gold & Bank gold * /
#define SCORE_TIME		(1 << 14)	/ * Time played * /
#define SCORE_INVENTORY		(1 << 15)	/ * Inv details * /
#define SCORE_AFFECTS		(1 << 16)	/ * Affected by  * /
#define SCORE_ABILITIES		(1 << 17)	/ * Abilities they have * /
#define SCORE_SEX		(1 << 18)	/ * Not what you're thinking * /
#define SCORE_QUESTPOINTS	(1 << 19)	/ * Qp's * /
#define SCORE_CARRYING          (1 << 20)       / * carrying... * /
// Must be number of SCORE_ thingies
    */
#endif
}

#if 0 // Artus> Unused.
int compute_damage_roll(struct char_data *ch)
{
  int nRaw = GET_DAMROLL(ch);
  double dbTmp = 0.0;
  
  if (IS_SET(GET_SPECIALS(ch), SPECIAL_MINOTAUR))
    dbTmp += MAX(5, (int)(GET_DAMROLL(ch) * 0.1));

  if (IS_SET(GET_SPECIALS(ch), SPECIAL_SUPERMAN))
    dbTmp += MAX(5, (int)(GET_DAMROLL(ch) * 0.1));

  return (int)(dbTmp + nRaw);
}
#endif

int digits(long number)
{
  char tmp[80];
  sprintf(tmp, "%ld", number);
  return (strlen(tmp));
}

/* DM - snazzed up score, just change these defines for the given colors */
#define CCSTAR(ch,lvl) CCBLU(ch,lvl)	/* Stars 			*/
#define CCHEAD(ch,lvl) CCBRED(ch,lvl)	/* Main headings 		*/
#define CCSUB(ch,lvl)  CCRED(ch,lvl)	/* Sub headings 		*/
#define CCNUMB(ch,lvl) CCCYN(ch,lvl)	/* Numbers - Age, Time		*/
#define CCTEXT(ch,lvl) CCBWHT(ch,lvl)	/* Text				*/
#define CCNAME(ch,lvl) CCBBLU(ch,lvl)	/* Name, Title			*/
#define CCSEP(ch,lvl)  CCBBLU(ch,lvl)	/* Seperators / ( ) d h 	*/
#define CCSTAT(ch,lvl) CCCYN(ch,lvl)	/* Stats			*/
#define CCDH(ch,lvl)   CCBRED(ch,lvl)	/* Damroll, Hitroll		*/
#define CCACT(ch,lvl)  CCCYN(ch,lvl)	/* AC, Thac0			*/
#define CCGAIN(ch,lvl) CCCYN(ch,lvl)	/* Hit/Mana/Move gain		*/

void old_primal_score(struct char_data *ch)
{
  char *line="%s*******************************************************************************%s\r\n";
  char *star="%s*%s";
  char cline[MAX_INPUT_LENGTH], cstar[MAX_INPUT_LENGTH];
  char ch_name[MAX_NAME_LENGTH+1];
  //extern int thaco(struct char_data *);
  //extern struct str_app_type str_app[];
  char buf3[80],alignbuf[15];
  struct time_info_data playing_time;
  //struct time_info_data *real_time_passed(time_t t2, time_t t1);
  unsigned int i,j;
 
  if (IS_NPC(ch))
  {
    send_to_char("You're never going to score.\r\n",ch);
    return;
  }

  sprintf(buf2,line,CCSTAR(ch,C_NRM),CCNRM(ch,C_NRM));
  strcpy(cline,buf2);
  sprintf(buf2,star,CCSTAR(ch,C_NRM),CCNRM(ch,C_NRM));
  strcpy(cstar,buf2);

  send_to_char("\r\n", ch);

/* First Line - *** */
  strcpy(ch_name,GET_NAME(ch)); 

  send_to_char(cline,ch);

/* Second Line - Char Name */

  sprintf(buf,"%s &0Name&n: &7%s&n", cstar, ch_name);

  for (i=strlen(ch_name); i<27; i++)
    strcat(buf," ");
/*  for (i=1;i<(28-strlen(ch_name));i++)
      strcat(buf," "); Artus -- Norty inefficient bois :o) */

  sprintf(buf2,"%s &0Title&n: %s&n", cstar, GET_TITLE(ch));
  strcat(buf,buf2);

  for (i=strdisplen(GET_TITLE(ch)); i<34; i++)
    strcat(buf," ");

  sprintf(buf2,"%s\r\n",cstar);
  strcat(buf,buf2);
  send_to_char(buf,ch); 

  /* Clan Rank, Clan Name - ARTUS */
  if (GET_CLAN(ch) > 0)
  {
    sprintf(buf2, "%s &0Clan&n: &g%s&n", cstar,
	    clan[find_clan_by_id(GET_CLAN(ch))].name);
    strcpy(buf, buf2);
    for(i=strlen(buf2); i<52; i++)
      strcat(buf, " ");
    sprintf(buf2, "%s &0Rank&n: &g%s&n", cstar, 
	   (GET_CLAN_RANK(ch) < 1) ? "Applying" :
	    clan[find_clan_by_id(GET_CLAN(ch))].rank_name[GET_CLAN_RANK(ch)-1]);
    strcat(buf, buf2);
    for(i=strlen(buf2); i<60; i++)
      strcat(buf, " ");
    strcat(buf, cstar);
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
  }
  send_to_char(cline, ch);
  // Disguise
  char mobname[80];
  if (!IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_DISGUISE))
  {
    if (CHAR_MEMORISED(ch) > 0)
      strcpy(mobname, 
	     mob_proto[real_mobile(CHAR_MEMORISED(ch))].player.short_descr);
    else
      strcpy(mobname, "None");
    sprintf(buf, "%s &0Mob memorised&n: &6%s&n", cstar, mobname); 
    for (i=strlen(mobname); i<18; i++)
      strcat(buf, " ");
    sprintf(buf2, "%s &0Disguised&n: %s&n", cstar,
	    CHAR_DISGUISED(ch) == 0 ? "No" : "Yes");
    if (CHAR_DISGUISED(ch))
    {
      for (i=1; i < 28; i++)
        strcat(buf2, " ");
    } else {
      for (i=1; i < 29; i++)
        strcat(buf2, " ");
    }
    strcat(buf2, cstar);
    strcat(buf2, "\r\n");
    strcat(buf, buf2);
    send_to_char(buf, ch);
  }

  /* Kill Counts - Artus */
  sprintf(buf2, "%s &0Kills&n        : &1Imm&n[&c%ld&n] &1By Imm&n[&c%ld&n] "
		"&1Mob&n[&c%ld&n] &1By Mob&n[&c%ld&n] &1PC&n[&c%ld&n] "
		"&1By PC&n[&c%ld&n]", cstar, GET_IMMKILLS(ch),
	  GET_KILLSBYIMM(ch), GET_MOBKILLS(ch), GET_KILLSBYMOB(ch),
	  GET_PCKILLS(ch), GET_KILLSBYPC(ch));
  sprintf(buf, "%s", buf2);
  for (i=strdisplen(buf2); i<78; i++)
    strcat(buf, " ");
  strcat(buf, cstar);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
  /* Remort Levels - ARTUS */
  sprintf(buf2, "%s &0Remort Levels&n: &1One&n[&c%3d&n] &1Two&n[&c%3d&n] "
		"&1Max&n[&c%3d&n] &1Total&n[&c%3d&n]", 
	  cstar, GET_REM_ONE(ch), GET_REM_TWO(ch), GET_MAX_LVL(ch), 
      	  (GET_REM_ONE(ch) + GET_REM_TWO(ch) + GET_LEVEL(ch)));
  sprintf(buf, "%s", buf2);
  for(i=strlen(buf2); i<123; i++)
    strcat(buf, " ");
  strcat(buf, cstar);
  strcat(buf, "\r\n");
  if (GET_REM_ONE(ch) > 0)
    send_to_char(buf, ch);
  // creation date and invis info
  time_t ct;
  char *tmpstr;
  // Char creation date
  ct = ch->player.time.birth;
#ifndef NO_LOCALTIME
  tmpstr = asctime(localtime(&ct));
#else
  struct tm lt;
  if (jk_localtime(&lt, ch->player.time.birth))
    tmpstr = NULL;
  else
    tmpstr = asctime(&lt);
#endif
  sprintf(buf, "%s &0Creation Date&n: %s", cstar, tmpstr);
  // remove /n from asctime date...
  buf[strlen(buf)-1] = '\0';
  strcat(buf, "  ");
  if (GET_INVIS_LEV(ch) > 0)
  {
    if (GET_INVIS_TYPE(ch) == INVIS_SPECIFIC)
      sprintf(buf3,"&0Invis to &n[&c%s&n]", get_name_by_id(GET_INVIS_LEV(ch)));
    else if( GET_INVIS_TYPE(ch) == INVIS_SINGLE)
      sprintf(buf3,"&0Invis to Lvl &n[&c%ds&n]", GET_INVIS_LEV(ch)); 
    else if (GET_INVIS_TYPE(ch) == INVIS_NORMAL)
      sprintf(buf3,"&0Invis Lvl &n[&c%d&n]", GET_INVIS_LEV(ch));
    else
      sprintf(buf3,"&0Invis to Lvls &n[&c%d-%d&n]", GET_INVIS_LEV(ch), 
	      GET_INVIS_TYPE(ch)); 
    sprintf(buf2, " %s %s&n", cstar, buf3);
    strcat(buf, buf2);
    for (i=strlen(buf2); i<54; i++)
      strcat(buf, " ");
  } else {
    for (i=1; i < 36; i++)
      strcat(buf, " ");
  }
  
  strcat(buf, cstar);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

/* Third Line - ****** */
  send_to_char(cline,ch);

/* Fourth Line - Headings */
  strcpy(buf,"%s               &0Other&n              %s     &0Description&n        %s    &0Statistics&n   %s\r\n");
  sprintf(buf2, buf, cstar, cstar, cstar, cstar);
  send_to_char(buf2,ch);

/* Fifth Line - ****** */
  send_to_char(cline,ch);

  // DM - added class
  strcpy(buf,"");
  sprinttype(GET_CLASS(ch), pc_class_types, buf3);
  sprintf(buf,"%s &1Class&n        : %s%-18s&n%s &1Stat Points&n: &c%-9d &n%s"
	      "    &1Base App Max&n %s\r\n", 
	  cstar, CCTEXT(ch,C_NRM), buf3, cstar, GET_STAT_POINTS(ch), cstar,
	  cstar);

  //for (i=strlen(buf3); i<2; i++)
  //  strcat(buf2," ");
  //strcat(buf,buf2);

  //sprintf(buf2,"%s\r\n",cstar);
  //strcat(buf,buf2);
  send_to_char(buf,ch);

/* Sixth Line - Race, Sex, STR */
  strcpy(buf,"");
  sprinttype(GET_RACE(ch), pc_race_types, buf3);
  sprintf(buf2,"%s &1Race&n         : %s%s&n", cstar, CCTEXT(ch,C_NRM), buf3);
  for (i=strlen(buf3);i<18;i++)
    strcat(buf2," ");
  strcat(buf,buf2);
  sprintf(buf2,"%s &1Sex&n   : ", cstar);
  strcat(buf,buf2);

  switch (ch->player.sex)
  {
    case SEX_NEUTRAL:
      strcpy(buf2, "NEUTRAL");
      break;
    case SEX_MALE:
      strcpy(buf2, "MALE");
      break;
    case SEX_FEMALE:
      strcpy(buf2, "FEMALE");
      break;
    default:
      strcpy(buf2, "ILLEGAL");
      break;
  }  
  sprintf(buf3,"%s%s%s&n",CCTEXT(ch,C_NRM),buf2,CCTEXT(ch,C_NRM));
  strcat(buf,buf3);
  for (i=strlen(buf2); i<15; i++)
    strcat(buf," ");
  char tmp[80];
  /*
  if (GET_REAL_STR(ch)==18)
  {
     sprintf(buf3,"%s/%s%d",CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_REAL_ADD(ch));
     sprintf(tmp, "%d", GET_REAL_ADD(ch));
     j=1+(strlen(tmp));
  } else {
    strcpy(buf3,""); 
    j=0;
  }
  */
  sprintf(buf2,"%s &1STR&n: %s%-2d  %-2d  %-2d &n%s&n\r\n", cstar,
          CCSTAT(ch,C_NRM), GET_REAL_STR(ch), GET_AFF_STR(ch), 
	  max_stat_value(ch, STAT_STR), cstar);
  strcat(buf,buf2);
  /*
  sprintf(tmp, "%d", GET_REAL_STR(ch));
  j=j+strlen(tmp);

  if (GET_REAL_STR(ch)!=GET_AFF_STR(ch))
  {
    if (GET_AFF_STR(ch)==18) {
      sprintf(tmp, "%d", GET_REAL_ADD(ch));
      j=j+1+strlen(tmp);
      sprintf(buf3,"%s/%s%d&n",
		      CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_AFF_ADD(ch));
    } else 
      strcpy(buf3,""); 
    sprintf(buf2,"%s(%s%d%s%s)&n",
	CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_AFF_STR(ch),buf3,CCSEP(ch,C_NRM));
    strcat(buf,buf2);
    sprintf(tmp, "%d", GET_AFF_STR(ch));
    j=j+2+strlen(tmp);
  }
  sprintf(buf2,"%s",CCNRM(ch,C_NRM));
  strcat(buf,buf2);
  for (i=j; i<11; i++)
    strcat(buf," ");
  sprintf(buf2,"%s\r\n",cstar);
  strcat(buf,buf2);
  */
  send_to_char(buf,ch);

/* Seventh Line - HPS, Age, Con */
// Choose the hp color .. Artus> Isn't their a function for this?
  if(GET_HIT(ch) < GET_MAX_HIT(ch) / 4)
    sprintf(buf2,"%s",CCRED(ch,C_NRM));
  else if(GET_HIT(ch) < GET_MAX_HIT(ch) / 2)
    sprintf(buf2,"%s",CCBRED(ch,C_NRM));
  else if(GET_HIT(ch) < GET_MAX_HIT(ch))
    sprintf(buf2,"%s",CCBYEL(ch,C_NRM));
  else sprintf(buf2,"%s",CCBGRN(ch,C_NRM));
  strcpy(buf,"");
  sprintf(buf, "%s &1Hit points&n   : %s%d%s/%s%d%s+&n%s%d&n", 
	cstar, buf2, GET_HIT(ch), CCSEP(ch,C_NRM), CCBGRN(ch,C_NRM),
	GET_MAX_HIT(ch), CCSEP(ch,C_NRM), CCGAIN(ch,C_NRM), hit_gain(ch));
  char tmp1[80], tmp2[80], tmp3[80];
  int tmpl1, tmpl2, tmpl3;
  sprintf(tmp1, "%d", GET_HIT(ch));
  sprintf(tmp2, "%d", GET_MAX_HIT(ch));
  sprintf(tmp3, "%d", hit_gain(ch));
  tmpl1 = strlen(tmp1);
  tmpl2 = strlen(tmp2);
  tmpl3 = strlen(tmp3);
  j = tmpl1 + tmpl2 + tmpl3 + 2;
  for (i=j; i<18; i++)
    strcat(buf," ");
  sprintf(buf2,"%s &1Age&n   : %s%d&n",
	cstar, CCNUMB(ch,C_NRM), age(ch)->year);
  strcat(buf,buf2);
  sprintf(tmp, "%d", age(ch)->year);
  for (i=strlen(tmp); i<15; i++)
    strcat(buf," ");
  sprintf(buf2,"%s &1CON&n: %s%-2d  %-2d  %-2d &n%s&n\r\n",
	cstar, CCSTAT(ch,C_NRM), GET_REAL_CON(ch), GET_AFF_CON(ch), 
	max_stat_value(ch, STAT_CON), cstar);
  strcat(buf,buf2);
  send_to_char(buf,ch);

/* Eighth line - Mana, Height/Weight, Dex */
  /* Choose the mana color */
  if(GET_MANA(ch) < GET_MAX_MANA(ch) / 4)
    sprintf(buf2,"%s",CCRED(ch,C_NRM));
  else if(GET_MANA(ch) < GET_MAX_MANA(ch) / 2)
    sprintf(buf2,"%s",CCBRED(ch,C_NRM));
  else if(GET_MANA(ch) < GET_MAX_MANA(ch))
    sprintf(buf2,"%s",CCBYEL(ch,C_NRM));
  else
    sprintf(buf2,"%s",CCBGRN(ch,C_NRM));  

  sprintf(buf, "%s &1Mana Points&n  : %s%d%s/%s%d%s+&n%s%d&n",
	  cstar, buf2, GET_MANA(ch), CCSEP(ch,C_NRM), CCBGRN(ch,C_NRM),
	  GET_MAX_MANA(ch), CCSEP(ch,C_NRM), CCGAIN(ch,C_NRM), mana_gain(ch));
  sprintf(tmp1, "%d", GET_MANA(ch));
  sprintf(tmp2, "%d", GET_MAX_MANA(ch));
  sprintf(tmp3, "%d", mana_gain(ch));
  tmpl1 = strlen(tmp1);
  tmpl2 = strlen(tmp2);
  tmpl3 = strlen(tmp3);
  j = tmpl1 + tmpl2 + tmpl3 + 2;
  for (i=j; i<18; i++)
    strcat(buf," ");
  sprintf(buf2,"%s &1Height%s/&1Weight&n: %s%d%s,&n%s%d&n", cstar,
          CCSEP(ch,C_NRM), CCNUMB(ch,C_NRM), GET_HEIGHT(ch), CCSEP(ch,C_NRM),
	  CCNUMB(ch,C_NRM), GET_WEIGHT(ch));
  strcat(buf,buf2);
  sprintf(tmp1, "%d", GET_HEIGHT(ch));
  sprintf(tmp2, "%d", GET_WEIGHT(ch));
  for (i=(strlen(tmp1) + strlen(tmp2)); i<7; i++)
    strcat(buf," ");
  sprintf(buf2,"%s &1DEX&n: %s%-2d  %-2d  %-2d &n%s&n\r\n", cstar,
	  CCSTAT(ch,C_NRM), GET_REAL_DEX(ch), GET_AFF_DEX(ch), 
	  max_stat_value(ch, STAT_DEX), cstar);
  strcat(buf,buf2);
  send_to_char(buf,ch);

  /* Ninth Line - Movement, Level, Int */
  // Choose the movement color -- Artus> Function?
  if(GET_MOVE(ch) < GET_MAX_MOVE(ch) / 4)
    sprintf(buf2,"%s",CCRED(ch,C_NRM));
  else if(GET_MOVE(ch) < GET_MAX_MOVE(ch) / 2)
    sprintf(buf2,"%s",CCBRED(ch,C_NRM));
  else if(GET_MOVE(ch) < GET_MAX_MOVE(ch))
    sprintf(buf2,"%s",CCBYEL(ch,C_NRM));
  else sprintf(buf2,"%s",CCBGRN(ch,C_NRM));
  sprintf(buf, "%s &1Movement&n     : %s%d%s/%s%d%s+&n%s%d&n", cstar, buf2,
          GET_MOVE(ch), CCSEP(ch,C_NRM), CCBGRN(ch,C_NRM), GET_MAX_MOVE(ch),
	  CCSEP(ch,C_NRM), CCGAIN(ch,C_NRM), move_gain(ch));
  sprintf(tmp1, "%d", GET_MOVE(ch));
  sprintf(tmp2, "%d", GET_MAX_MOVE(ch));
  sprintf(tmp3, "%d", move_gain(ch));
  tmpl1 = strlen(tmp1);
  tmpl2 = strlen(tmp2);
  tmpl3 = strlen(tmp3);
  j = tmpl1 + tmpl2 + tmpl3 + 2;
  for (i=j; i<18; i++)
    strcat(buf," ");
  j=GET_LEVEL(ch);
  if (j >= LVL_GOD) // Artus> Function?
    sprintf(buf3,"%s",CCBYEL(ch,C_SPR));
  else if (j >= LVL_ANGEL)
    sprintf(buf3,"%s",CCCYN(ch,C_SPR));
  else if (j >= LVL_ISNOT_GOD)
    sprintf(buf3,"%s",CCRED(ch,C_SPR));
  else if (j >= LVL_CHAMP)
    sprintf(buf3,"%s",CCBLU(ch,C_SPR));
  else
    sprintf(buf3,"%s",CCNRM(ch,C_SPR));
  sprintf(buf2,"%s &1Level&n : %s%d&n",
	cstar, buf3, GET_LEVEL(ch));
  strcat(buf,buf2);
  sprintf(tmp, "%d", j);
  for (i=strlen(tmp); i<15; i++)
    strcat(buf," ");
  sprintf(buf2,"%s &1INT&n: %s%-2d  %-2d  %-2d &n%s&n\r\n",
	cstar, CCSTAT(ch,C_NRM), GET_REAL_INT(ch), GET_AFF_INT(ch), 
	max_stat_value(ch, STAT_INT), cstar);
  strcat(buf,buf2);
  send_to_char(buf,ch);

/* Tenth line - Hitroll, Align, Wisdom */
  sprintf(buf, "%s &1Hitroll&n      : %s%d&n", cstar, 
          CCDH(ch,C_NRM), ch->points.hitroll);
  sprintf(tmp, "%d", ch->points.hitroll);
  for (i=strlen(tmp); i<18; i++)
    strcat(buf," ");
  strcpy(alignbuf,"");
  // Artus> Function?
  if ((GET_ALIGNMENT(ch)>-101)&&(GET_ALIGNMENT(ch)<101))
    strcpy(alignbuf,"Neutral");
  if ((GET_ALIGNMENT(ch)>100)&&(GET_ALIGNMENT(ch)<301))
    strcpy(alignbuf,"NeutralG");
  /* Good alignment messages */
  if ((GET_ALIGNMENT(ch)>300)&&(GET_ALIGNMENT(ch)<401))
   strcpy(alignbuf,"Fair");
  if ((GET_ALIGNMENT(ch)>400)&&(GET_ALIGNMENT(ch)<501))
   strcpy(alignbuf,"Kind");
  if ((GET_ALIGNMENT(ch)>500)&&(GET_ALIGNMENT(ch)<601))
   strcpy(alignbuf,"Friendly");
  if ((GET_ALIGNMENT(ch)>600)&&(GET_ALIGNMENT(ch)<701))
   strcpy(alignbuf,"Honest");
  if ((GET_ALIGNMENT(ch)>700)&&(GET_ALIGNMENT(ch)<801))
   strcpy(alignbuf,"Humane");
  if ((GET_ALIGNMENT(ch)>800)&&(GET_ALIGNMENT(ch)<901))
   strcpy(alignbuf,"Virtuous");
  if ((GET_ALIGNMENT(ch)>901))
   strcpy(alignbuf,"Angelic");
  /* Evil Ratings */
  if ((GET_ALIGNMENT(ch)<-100)&&(GET_ALIGNMENT(ch)>-300))
   strcpy(alignbuf,"NeutralE");
  if ((GET_ALIGNMENT(ch)<-300)&&(GET_ALIGNMENT(ch)>-401))
   strcpy(alignbuf,"Unfair");
  if ((GET_ALIGNMENT(ch)<-400)&&(GET_ALIGNMENT(ch)>-501))
   strcpy(alignbuf,"Mean");
  if ((GET_ALIGNMENT(ch)<-500)&&(GET_ALIGNMENT(ch)>-601))
   strcpy(alignbuf,"Wicked");
  if ((GET_ALIGNMENT(ch)<-600)&&(GET_ALIGNMENT(ch)>-701))
   strcpy(alignbuf,"Sinful");
  if ((GET_ALIGNMENT(ch)<-700)&&(GET_ALIGNMENT(ch)>-801))
   strcpy(alignbuf,"Villanous");
  if ((GET_ALIGNMENT(ch)<-800)&&(GET_ALIGNMENT(ch)>-901))
   strcpy(alignbuf,"Demonic");
  if ((GET_ALIGNMENT(ch)<-901))
   strcpy(alignbuf,"Satanic");
  // Artus> Function?
  if (GET_ALIGNMENT(ch) > 350)
    sprintf(buf3,"%s",CCCYN(ch,C_NRM));
  else if (GET_ALIGNMENT(ch) < -350)
    sprintf(buf3,"%s",CCRED(ch,C_NRM));
  else
    sprintf(buf3,"%s",CCBWHT(ch,C_NRM));
  sprintf(buf2,"%s &1Align&n : %s%s%s(%s%d%s)&n",
	cstar, buf3, alignbuf, CCSEP(ch,C_NRM), buf3,
	GET_ALIGNMENT(ch), CCSEP(ch,C_NRM));
  strcat(buf,buf2);
  sprintf(tmp, "%d", GET_ALIGNMENT(ch));
  j=2+strlen(alignbuf)+strlen(tmp);
  for (i=j; i<15; i++)
    strcat(buf," ");
  sprintf(buf2,"%s &1WIS&n: %s%-2d  %-2d  %-2d &n%s&n\r\n",
	  cstar, CCSTAT(ch,C_NRM), GET_REAL_WIS(ch), GET_AFF_WIS(ch), 
	  max_stat_value(ch, STAT_WIS), cstar);
  strcat(buf,buf2);
  send_to_char(buf,ch);

  /* Eleventh line - Damroll, gold, CHA */
  sprintf(buf, "%s &1Damroll&n      : %s%d", cstar, CCDH(ch,C_NRM),
          ch->points.damroll);
  // MINOTAUR and SUPERMAN bonus display
  int ctmp = 0;
  if (IS_SET(GET_SPECIALS(ch), SPECIAL_MINOTAUR))
  {
    sprintf(buf, "%s+%d", buf, MAX(5, (int)(GET_DAMROLL(ch) * 0.1)));
    ctmp += MAX(5, digits((long)(GET_DAMROLL(ch) * 0.1)));
  }
  if (IS_SET(GET_SPECIALS(ch), SPECIAL_SUPERMAN))
  {
    sprintf(buf, "%s+%d", buf, (int)(GET_DAMROLL(ch) * 0.02));
    ctmp += 1 + digits((long)(GET_DAMROLL(ch) * 0.02));
  }
  sprintf(tmp, "%d", ch->points.damroll);
  for (i=(strlen(tmp)+ctmp); i<18;i++)
    strcat(buf," ");
  sprintf(buf2,"&n%s &1Gold&n  : &Y%d&n", cstar, GET_GOLD(ch));
  strcat(buf,buf2);
  sprintf(tmp, "%d", GET_GOLD(ch));
  for (i=strlen(tmp); i<15; i++)
    strcat(buf," ");
  sprintf(buf2,"%s &1CHA&n: %s%-2d  %-2d  %-2d &n%s&n\r\n",
	  cstar, CCSTAT(ch,C_NRM), GET_REAL_CHA(ch), GET_AFF_CHA(ch), 
	  max_stat_value(ch, STAT_CHA), cstar);
  strcat(buf,buf2);
  send_to_char(buf,ch);

/* Twelth line - Armor Class, Bank */
  // TODO: fix armour class
  sprintf(buf, "%s &1Armour Class&n : %s%d%s/&n%s10 %s(&n%s%d%s)&n", cstar,
          CCACT(ch,C_NRM), compute_armor_class(ch, 0), CCSEP(ch,C_NRM),
	  CCACT(ch,C_NRM), CCSEP(ch,C_NRM), CCACT(ch,C_NRM),
	  compute_armor_class(ch, 1), CCSEP(ch, C_NRM));
  for(i=strdisplen(buf); i<35; i++)
    strcat(buf, " ");
  sprintf(buf2,"%s &1Bank&n  : &Y%d&n", cstar, GET_BANK_GOLD(ch));
  strcat(buf,buf2);
  sprintf(tmp, "%d", GET_BANK_GOLD(ch));
  for (i=strlen(tmp); i<15; i++)
    strcat(buf," ");
  sprintf(buf2,"%s",cstar);
  strcat(buf,buf2);
  for (i=1; i<18; i++)
    strcat(buf," ");
  sprintf(buf2,"%s\r\n",cstar);
  strcat(buf,buf2);
  send_to_char(buf,ch);

/* Thirteenth line - Thac0, Time */
  sprintf(buf, "%s &1Thac&n%s0&n        : %s%d&n", cstar, CCACT(ch,C_NRM),
          CCACT(ch,C_NRM), thaco(ch, NULL)); 
  sprintf(tmp, "%d", thaco(ch, NULL));
  for (i=strlen(tmp); i<18; i++)
    strcat(buf," ");
  playing_time = *real_time_passed((time(0) - ch->player.time.logon) + ch->player.time.played, 0);
  sprintf(buf2,"%s &1Time&n  : %s%d&n%sd&n%s%d%sh&n", cstar, CCNUMB(ch,C_NRM),
          playing_time.day, CCSEP(ch,C_NRM), CCNUMB(ch,C_NRM),
	  playing_time.hours, CCSEP(ch,C_NRM));
  strcat(buf,buf2);
  for (i=(digits(playing_time.hours)+digits(playing_time.day)+2); i<15; i++)
    strcat(buf," ");
  sprintf(buf2,"%s",cstar);
  strcat(buf,buf2);
  for (i=1; i<18; i++)
    strcat(buf," ");
  sprintf(buf2,"%s\r\n",cstar);
  strcat(buf,buf2);
  send_to_char(buf,ch);

/* Fourteenth line - ***** */
  send_to_char(cline, ch);  
  
/* Fifteenth line - Carrying Weight, Carrying Items, Can Carry Weight, Can Carry Items */
  sprintf(buf,"%s              &0Inventory                                     %s                 &n%s&n\r\n", cstar,CCHEAD(ch,C_NRM),cstar);
  send_to_char(buf,ch);
  send_to_char(cline,ch);
  sprintf(buf,"%s &1Carrying weight &n: %s%d&n", cstar, CCNUMB(ch,C_NRM),
          IS_CARRYING_W(ch));
  for (i=digits(IS_CARRYING_W(ch)); i<11; i++)
    strcat(buf," ");
  sprintf(buf2,"%s &1Carrying Items &n: %s%d&n",
                cstar, CCNUMB(ch,C_NRM), IS_CARRYING_N(ch));
  for (i=digits(IS_CARRYING_N(ch)); i < 10; i++)
    strcat(buf2," ");
  strcat(buf2,cstar);
  for (i=0; i < 17; i++)
    strcat(buf2, " ");
  strcat(buf2,cstar);
  strcat(buf2,"\r\n");
  strcat(buf,buf2);
  send_to_char(buf,ch);
  sprintf(buf,"%s &1Can Carry Weight&n: %s%d&n", cstar, CCNUMB(ch,C_NRM),
          CAN_CARRY_W(ch));
  for (i=digits(CAN_CARRY_W(ch)); i<11; i++)
    strcat(buf," ");
  sprintf(buf2,"%s &1Can Carry Items&n: %s%d&n",
                cstar, CCNUMB(ch,C_NRM), CAN_CARRY_N(ch));
  for (i=digits(CAN_CARRY_N(ch)); i < 10; i++)
    strcat(buf2," ");
  strcat(buf2,cstar);
  for (i=0; i < 17; i++)
    strcat(buf2, " ");
  strcat(buf2,cstar);
  sprintf(buf3,"%s\r\n",CCNRM(ch,C_NRM));
  strcat(buf2,buf3);
  strcat(buf,buf2);
  send_to_char(buf,ch);
  send_to_char(cline, ch);
  
  // DM - new score information
  /*
  struct affected_type *aff;
  // Routine to show what spells a char is affected by *
  if (ch->affected)
  {
    for (aff = ch->affected; aff; aff = aff->next)
    {
      *buf2 = '\0';
      if( aff->duration == -1 )
      {
        sprintf(buf, "ABL: (Unlim) &c%-21s &n ", skill_name(aff->type));
        if (aff->modifier)
	{
          sprintf(buf2, "%+d to %s", aff->modifier, apply_types[(int) aff->location]);
          strcat(buf, buf2);
        }
      } else {
        // ROD - here make Unlim for perm spells from eq
        // It appears the affect is removed when time is 1,
        // spell affects from magic eq are given with time 0
        // for abilities they are given time -1
	//
        // I hate this dodgy code of vaders ....
        // ok go through the eq list and find if the affect is given by eq
	//
        // This code is DUPLICATED in act.informative.c for affects
        bool found = FALSE;
        for (int i = 0; i < NUM_WEARS; i++)
	{
          if (GET_EQ(ch, i) && GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_MAGIC_EQ)
	  {
            for (int j = 0; j < 3; j++)
	    {
              if (GET_OBJ_VAL(GET_EQ(ch, i), j) == aff->type)
	      {
                found = TRUE;
                break;
              }
            }
          }
        }         
        if (found)
          sprintf(buf, "SPL: (Unlim) %s%-21s%s ", CCCYN(ch, C_NRM),
		  skill_name(aff->type), CCNRM(ch, C_NRM));
        else
          sprintf(buf, "SPL: (%3dhr) %s%-21s%s ", aff->duration + 1,
		  CCCYN(ch, C_NRM), skill_name(aff->type), CCNRM(ch, C_NRM));
        if (aff->modifier)
          sprintf(buf+strlen(buf), "%+d to %s", aff->modifier,
	          apply_types[(int) aff->location]);
      }      
      if (aff->bitvector)
      {
	if (*buf2)
	  strcat(buf, ", sets ");
	else
	  strcat(buf, "sets ");
	sprintbit(aff->bitvector, affected_bits, buf2);
	strcat(buf, buf2);
      }
      send_to_char(strcat(buf, "\r\n"), ch);
    }
  }
  struct timer_type *timer;
  // Routine to show what timers a char is affected by 
  if (ch->timers)
  {
    for (timer = ch->timers; timer; timer = timer->next)
    {
      sprintf(buf, "TIM: (%3dhr) %s%-22s%s", timer->duration, CCCYN(ch, C_NRM),
              timer_types[timer->type], CCNRM(ch, C_NRM));
      sprintf(buf+strlen(buf), "Uses: (%2d) of max: (%2d)\r\n",timer->uses,
              timer->max_uses);
      send_to_char(buf,ch);
    } 
  }
  */

/* Sixteenth line - ***** */
 /* 
  if ( !GET_CLAN_NUM (ch) < 1 ) 
	sprintf(buf, "You are part of the %s and your rank is %s.\r\n",
         get_clan_disp(ch), get_clan_rank(ch));
  else
	sprintf(buf, "You are clanless.\r\n" );
*/
  //send_to_char(cline, ch);
  // EXP TNL
  if (CAN_LEVEL(ch))
    sprintf(buf3, "You have earned &c%d&n exp, and need &c%d&n to reach level &c%d&n.\r\n", GET_EXP(ch), level_exp(ch, GET_LEVEL(ch) + 1) - GET_EXP(ch),
	    GET_LEVEL(ch)+1);
//  sprintf(buf, "Social Points: %d, Social Rank: %s\r\n", GET_SOCIAL_POINTS(ch),
//	social_ranks[GET_SOCIAL_STATUS(ch)]);
//  send_to_char(buf, ch);

  /* Punishment Bits - ARTUS */
  unsigned int i2 = 0, i3 = 0;
  bool bad = FALSE;
  sprintf(buf2, "%s &rPunishments&n:", cstar);
  for (i = 0; i < NUM_PUNISHES; i++)
    if (PUN_FLAGGED(ch, i)) 
    {
      sprintf(buf2, "%s &g%s&n[&c%d&n]", 
		      buf2, punish_types[i], PUN_HOURS(ch, i));
      i2 = 1;
      i3++;
    }
  if (i2 != 0) 
  {           // colour code chars (8 per punishment)
    strcpy(buf, buf2);
    if (strlen(buf2) < (92 + 8*i3))
      for (i=1; i < (92 + 8*i3 - strlen(buf2)); i++)
        strcat(buf, " ");
    strcat(buf, cstar);
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
    bad = TRUE;
  }
  /* Offence Counts - ARTUS */
  i2 = 0;
  i3 = 0;
  sprintf(buf2, "%s &rOffences&n:", cstar);
  for (i = 0; i < NUM_OFFENCES; i++)
    if (HAS_OFFENDED(ch,i) > 0)
    {
      sprintf(buf2, "%s &g%s&n[&c%d&n]", buf2, offence_types[i], HAS_OFFENDED(ch,i));
      i2 = 1;
      i3++;
    }
  if (i2 != 0) 
  {           // colour code chars (8 per offence)
    strcpy(buf, buf2);
    if (strlen(buf2) < (95 + 8*i3)) 
      for (i=1; i < (95 + 8*i3 - strlen(buf2)); i++)
        strcat(buf, " ");
    strcat(buf, cstar);
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
    bad = TRUE;
  }
  if (bad)
    send_to_char(cline, ch);
  strcpy(buf,"");  
  if (GET_LEVEL(ch))
  {
    sprintf(buf, "You need &c%d&n exp to reach your next level.\r\n", 
	(level_exp(ch, (int)GET_LEVEL(ch))) - GET_EXP(ch));
      send_to_char(buf, ch);  
  }

  strcpy(buf,"");
  switch (GET_POS(ch))
  {
    case POS_DEAD:
      strcat(buf, "You are DEAD!\r\n");
      break;
    case POS_MORTALLYW:
      strcat(buf, "You are mortally wounded!  You should seek help!\r\n");
      break;
    case POS_INCAP:
      strcat(buf, "You are incapacitated, slowly fading away...\r\n");
      break;
    case POS_STUNNED:
      strcat(buf, "You are stunned!  You can't move!\r\n");
      break;
    case POS_SLEEPING:
      strcat(buf, "You are sleeping.\r\n");
      break;
    case POS_RESTING:
      strcat(buf, "You are resting.\r\n");
      break;
    case POS_SITTING:
      strcat(buf, "You are sitting.\r\n");
      break;
    case POS_FIGHTING:
      if (FIGHTING(ch))
	sprintf(buf, "%sYou are fighting %s.\r\n", buf, PERS(FIGHTING(ch), ch));
      else
	strcat(buf, "You are fighting thin air.\r\n");
      break;
    case POS_STANDING:
      strcat(buf, "You are standing.\r\n");
      break;
    default:
      strcat(buf, "You are floating.\r\n");
      break;
  }
  if (EXT_FLAGGED(ch, EXT_AUTOLOOT))
    strcat(buf, "You are autolooting corpses.\r\n");
  if (EXT_FLAGGED(ch, EXT_AUTOGOLD)) 
  {
    strcat(buf, "You are autolooting gold from corpses.\r\n");
    if (EXT_FLAGGED(ch, EXT_AUTOSPLIT))
      strcat(buf, "You are autospliting gold between group members.\r\n");
  }
  if (EXT_FLAGGED(ch, EXT_AUTOEAT))
    strcat(buf, "You will automatically eat when you're hungry.\r\n");
  if (AUTOASSIST(ch))
    sprintf(buf+strlen(buf), "You are autoassisting &7%s&n.\r\n",
	    GET_NAME(AUTOASSIST(ch)));
  if (GET_COND(ch, DRUNK) > 10)
    strcat(buf, "You are intoxicated.\r\n");
  if (GET_COND(ch, FULL) == 0)
    strcat(buf, "You are hungry.\r\n");
  if (GET_COND(ch, THIRST) == 0)
    strcat(buf, "You are thirsty.\r\n");
  if (IS_AFFECTED(ch, AFF_BLIND))
    strcat(buf, "You have been blinded!\r\n");
  if (IS_AFFECTED(ch, AFF_INVISIBLE))
    strcat(buf, "You are invisible.\r\n");
  if (IS_AFFECTED(ch, AFF_DETECT_INVIS))
    strcat(buf, "You are sensitive to the presence of invisible things.\r\n");
  if (IS_AFFECTED(ch, AFF_SANCTUARY))
    strcat(buf, "You are protected by Sanctuary.\r\n");
  if (IS_AFFECTED(ch, AFF_POISON))
    strcat(buf, "You are poisoned!\r\n");
  if (IS_AFFECTED(ch, AFF_CHARM))
    strcat(buf, "You have been charmed!\r\n");
  if (affected_by_spell(ch, SPELL_ARMOR))
    strcat(buf, "You feel protected.\r\n");
  if (IS_AFFECTED(ch, AFF_INFRAVISION))
    strcat(buf, "Your eyes are glowing &rred&n.\r\n");
  if (IS_AFFECTED(ch, AFF_WATERWALK))
    strcat(buf, "You have magically webbed feet.\r\n");
  if (IS_AFFECTED(ch, AFF_WATERBREATHE))
    strcat(buf, "You can breathe underwater.\r\n");
  if (IS_AFFECTED(ch, AFF_REFLECT))
    strcat(buf, "You have shiny scales on your skin.\r\n");
  if (IS_AFFECTED(ch, AFF_FLY))
    strcat(buf, "You are flying.\r\n");
  if (PRF_FLAGGED(ch, PRF_SUMMONABLE))
    strcat(buf, "You are summonable by other players.\r\n");
  if (MOUNTING(ch))
    sprintf(buf+strlen(buf), "You are mounted on &6%s&n.\r\n",
	    GET_NAME(MOUNTING(ch)));
  if (affected_by_spell(ch,SPELL_CHANGED))
    if(PRF_FLAGGED(ch,PRF_WOLF))
      strcat(buf, "You're a Werewolf!\r\n");
    else if(PRF_FLAGGED(ch,PRF_VAMPIRE))
      strcat(buf, "You're a Vampire!\r\n");
  send_to_char(buf, ch);  
}

ACMD(do_score)
{
  if (IS_NPC(ch))
  {
    send_to_char("You are     : Inflatable\r\n"
		 "Occupation  : Goat\r\n"
		 "Inclination : Left 10 degrees\r\n", ch);
    return;
  }
  primal_score(ch, argument);

#if 0 // Artus> Unused.
  // Show old score if no settings defined
  //if (SCORE_SETTINGS(ch) || *argument)
  //{
  //	return;
  //}


  /** Ignore this crap
  sprintf(buf, "You are %d years old.", GET_AGE(ch));

  if (age(ch)->month == 0 && age(ch)->day == 0)
    strcat(buf, "  It's your birthday today.\r\n");
  else
    strcat(buf, "\r\n");

  sprintf(buf + strlen(buf),
       "You have %d(%d) hit, %d(%d) mana and %d(%d) movement points.\r\n",
	  GET_HIT(ch), GET_MAX_HIT(ch), GET_MANA(ch), GET_MAX_MANA(ch),
	  GET_MOVE(ch), GET_MAX_MOVE(ch));



  sprintf(buf + strlen(buf), "Your armor class is %d/10, and your alignment is %d.\r\n",
	  compute_armor_class(ch, 0), GET_ALIGNMENT(ch));


  sprintf(buf + strlen(buf), "You have scored %d exp, and have %d gold coins.\r\n",
	  GET_EXP(ch), GET_GOLD(ch));

  if (GET_LEVEL(ch) < LVL_IMMORT)
    sprintf(buf + strlen(buf), "You need %d exp to reach your next level.\r\n",
	level_exp(ch, GET_LEVEL(ch)) - GET_EXP(ch));

  playing_time = *real_time_passed((time(0) - ch->player.time.logon) +
				  ch->player.time.played, 0);
  sprintf(buf + strlen(buf), "You have been playing for %d day%s and %d hour%s.\r\n",
     playing_time.day, playing_time.day == 1 ? "" : "s",
     playing_time.hours, playing_time.hours == 1 ? "" : "s");

  sprintf(buf + strlen(buf), "This ranks you as %s %s (level %d).\r\n",
	  GET_NAME(ch), GET_TITLE(ch), GET_LEVEL(ch));

  switch (GET_POS(ch)) {
  case POS_DEAD:
    strcat(buf, "You are DEAD!\r\n");
    break;
  case POS_MORTALLYW:
    strcat(buf, "You are mortally wounded!  You should seek help!\r\n");
    break;
  case POS_INCAP:
    strcat(buf, "You are incapacitated, slowly fading away...\r\n");
    break;
  case POS_STUNNED:
    strcat(buf, "You are stunned!  You can't move!\r\n");
    break;
  case POS_SLEEPING:
    strcat(buf, "You are sleeping.\r\n");
    break;
  case POS_RESTING:
    strcat(buf, "You are resting.\r\n");
    break;
  case POS_SITTING:
    strcat(buf, "You are sitting.\r\n");
    break;
  case POS_FIGHTING:
    if (FIGHTING(ch))
      sprintf(buf + strlen(buf), "You are fighting %s.\r\n",
		PERS(FIGHTING(ch), ch));
    else
      strcat(buf, "You are fighting thin air.\r\n");
    break;
  case POS_STANDING:
    strcat(buf, "You are standing.\r\n");
    break;
  default:
    strcat(buf, "You are floating.\r\n");
    break;
  }

  if (EXT_FLAGGED(ch, EXT_AUTOLOOT))
    strcat(buf, "You are autolooting corpses.\r\n");
 
  if (EXT_FLAGGED(ch, EXT_AUTOGOLD)) {
    strcat(buf, "You are autolooting gold from corpses.\r\n");
    if (EXT_FLAGGED(ch, EXT_AUTOSPLIT))
      strcat(buf, "You are autospliting gold between group members.\r\n");
  }
 
  if (AUTOASSIST(ch)) {
    sprintf(buf2, "You are autoassisting %s.\r\n",GET_NAME(AUTOASSIST(ch)));
    strcat(buf,buf2);
  } 

  if (GET_COND(ch, DRUNK) > 10)
    strcat(buf, "You are intoxicated.\r\n");

  if (GET_COND(ch, FULL) == 0)
    strcat(buf, "You are hungry.\r\n");

  if (GET_COND(ch, THIRST) == 0)
    strcat(buf, "You are thirsty.\r\n");

  if (AFF_FLAGGED(ch, AFF_BLIND))
    strcat(buf, "You have been blinded!\r\n");

  if (AFF_FLAGGED(ch, AFF_INVISIBLE))
    strcat(buf, "You are invisible.\r\n");

  if (AFF_FLAGGED(ch, AFF_DETECT_INVIS))
    strcat(buf, "You are sensitive to the presence of invisible things.\r\n");

  if (AFF_FLAGGED(ch, AFF_SANCTUARY))
    strcat(buf, "You are protected by Sanctuary.\r\n");

  if (AFF_FLAGGED(ch, AFF_POISON))
    strcat(buf, "You are poisoned!\r\n");

  if (AFF_FLAGGED(ch, AFF_CHARM))
    strcat(buf, "You have been charmed!\r\n");

  if (affected_by_spell(ch, SPELL_ARMOR))
    strcat(buf, "You feel protected.\r\n");

  if (AFF_FLAGGED(ch, AFF_INFRAVISION))
    strcat(buf, "Your eyes are glowing red.\r\n");

  if (PRF_FLAGGED(ch, PRF_SUMMONABLE))
    strcat(buf, "You are summonable by other players.\r\n");

  send_to_char(buf, ch);

  // Show them their abilities
  show_ability_messages_to_char(ch);
  */
#endif
}

ACMD(do_timers)
{
  struct timer_type *timer;
  /* Routine to show what timers a char is affected by */
  if (ch->timers) 
  {
    send_to_char("Timers currently running:\r\n", ch);
    for (timer = ch->timers; timer; timer = timer->next) 
    {

      sprintf(buf,"TIM: (%3dhr) %s%-22s%s", timer->duration, CCCYN(ch, C_NRM), timer_types[timer->type], CCNRM(ch, C_NRM));
      sprintf(buf2,"Uses: (%2d) of max: (%2d)\r\n",timer->uses, timer->max_uses);

      strcat(buf, buf2);

      send_to_char(buf,ch);
    } 
  } else
    send_to_char("You are currently not affected by any timers.\r\n", ch);
}

ACMD(do_affects)
{
  struct affected_type *aff;
 
  if (IS_NPC(ch))
    return;
    
  strcpy(buf,"");
// DM - TODO - check what we want to be given in text
  /*
  if (PRF_FLAGGED(ch, PRF_SUMMONABLE))
    strcat(buf, "You are summonable by other players.\r\n");
  if (IS_AFFECTED(ch, AFF_INFRAVISION))
    strcat(buf, "Your eyes are glowing red.\r\n");
  if (IS_AFFECTED(ch, AFF_WATERWALK))
    strcat(buf, "You have magically webbed feet.\r\n");
  if (IS_AFFECTED(ch, AFF_WATERBREATHE))
    strcat(buf, "You can breathe underwater.\r\n");
  if (affected_by_spell(ch, SPELL_ARMOR))
    strcat(buf, "You feel protected.\r\n");
  if (affected_by_spell(ch, SPELL_STRENGTH))
    strcat(buf, "You feel stronger.\r\n");
  if (affected_by_spell(ch, SPELL_CHILL_TOUCH))
    strcat(buf, "You feel weakened.\r\n");
  if (IS_AFFECTED(ch, AFF_CHARM))
    strcat(buf, "You have been charmed!\r\n");
  if (IS_AFFECTED(ch, AFF_DETECT_INVIS))
    strcat(buf, "You are sensitive to the presence of invisible things.\r\n");
  if (IS_AFFECTED(ch, AFF_INVISIBLE))
    strcat(buf, "You are invisible.\r\n");
  if (IS_AFFECTED(ch, AFF_SANCTUARY))
    strcat(buf, "You are protected by Sanctuary.\r\n");
  if (IS_AFFECTED(ch, AFF_POISON))
    strcat(buf, "You are poisoned!\r\n");
  if (IS_AFFECTED(ch, AFF_BLIND))
    strcat(buf, "You have been blinded!\r\n");
  if (affected_by_spell(ch, SPELL_BLESS))
    strcat(buf, "You feel righteous.\r\n");
  if (IS_AFFECTED(ch, AFF_CURSE))
    strcat(buf, "You are cursed.\r\n");
  if (IS_AFFECTED(ch, AFF_SENSE_LIFE))
    strcat(buf, "You feel more aware.\r\n");
  if (IS_AFFECTED(ch, AFF_SNEAK))
    strcat(buf, "You feel more sneaky.\r\n");
  if (IS_AFFECTED(ch, AFF_DETECT_ALIGN))
    strcat(buf, "You have the ability to see auras.\r\n");
  if (IS_AFFECTED(ch, AFF_DETECT_MAGIC))
    strcat(buf, "You are more sensitive to magic.\r\n");
  if (IS_AFFECTED(ch, AFF_PROTECT_EVIL))
    strcat(buf, "You feel protected from Evil.\r\n");
  if (IS_AFFECTED(ch, AFF_PROTECT_GOOD))
    strcat(buf, "You feel protected from Good.\r\n");
  if (IS_AFFECTED(ch, AFF_SLEEP))
    strcat(buf, "You are asleep.\r\n");
  if (IS_AFFECTED(ch, AFF_REFLECT))
    strcat(buf, "You have shiny scales on your skin.\r\n");
  if (IS_AFFECTED(ch, AFF_FLY))
    strcat(buf, "You are flying.\r\n");
  if (affected_by_spell(ch,SPELL_DRAGON))
    strcat(buf, "You feel like a dragon!\r\n");
  if (affected_by_spell(ch,SPELL_CHANGED))
    if(PRF_FLAGGED(ch,PRF_WOLF))
      strcat(buf, "You're a Werewolf!\r\n");
    else if(PRF_FLAGGED(ch,PRF_VAMPIRE))
      strcat(buf, "You're a Vampire!\r\n");
  if (IS_AFFECTED(ch, AFF_PARALYZED))
     strcat(buf, "You are paralyzed.\r\n");
*/
  if (MOUNTING(ch))
    sprintf(buf+strlen(buf), "You are mounted on %s.\r\n",
	    GET_NAME(MOUNTING(ch)));
  if (MOUNTING_OBJ(ch))
    sprintf(buf+strlen(buf), "You are mounted on %s.\r\n",
	    MOUNTING_OBJ(ch)->short_description);
  send_to_char(buf, ch);
  /*
   * Rod - now level 5 restricted only
   *
        if ((GET_LEVEL(ch) < 20) && (GET_CLASS(ch) <= CLASS_WARRIOR))
                return; // Artus - Let them see the lot after remort too.
  */
  if (!ch->affected) 
  {
    send_to_char("You are currently not affected by any spells or abilities.\r\n", ch);
    return;
  }
  if (ch->affected) 
  {
    int noAffects = 0, i = 0;
    struct affected_type *affect_array[MAX_AFFECT];
    /* Artus> Couldn't see any reason not to move this to the next loop..
     * for (aff = ch->affected; aff; aff = aff->next) 
     *   noAffects++;
    */

    // Artus> Send some sort of header.
    send_to_char("You are affected by the following spells and/or skills:\r\n",
	         ch);
    for (aff = ch->affected; aff; aff = aff->next) 
    {
      noAffects++;
      *buf2 = '\0';
      affect_array[i++] = aff;
    }
    // sort array
    qsort(affect_array, noAffects, sizeof(struct affected_type *), compareAffectDuration);
    /*
    // debug:
    //basic_mud_loglog("i = %d, noAffects = %d", i, noAffects);
    for (aff = affect_array[0]; (aff) && i < noAffects; aff = affect_array[i++])
      basic_mud_log("Affect (%d) = %d %s", i, aff->type, skill_name(aff->type));
    */
    // Reset counter to 0 ...
    // now step through the sorted array ...
    for (aff = affect_array[0], i = 0; (aff) && i < noAffects;
	 aff = affect_array[++i])
    {
      if ((aff->type <= 0) || (aff->type > TOP_SPELL_DEFINE))
        continue;
      *buf2 = '\0';
      if (aff->duration == CLASS_ABILITY) 
        sprintf(buf, "ABL: (Unlim) &c%-21s&n ", skill_name(aff->type));
      else if (aff->duration == CLASS_ITEM)
	sprintf(buf, "OBJ: (Unlim) &c%-21s&n ", skill_name(aff->type));
      else
      {
        // ROD - here make Unlim for perm spells from eq
	// It appears the affect is removed when time is 1,
	// spell affects from magic eq are given with time 0
	// for abilities they are given time -1
	// I hate this dodgy code of vaders ....
	// ok go through the eq list and find if the affect is given by eq

	// This code is DUPLICATED in act.wizard.c for stat
	/* Artus> This is no longer necessary.
	bool found = FALSE;
        for (int i = 0; i < NUM_WEARS; i++)
          if (GET_EQ(ch, i) && GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_MAGIC_EQ)
            for (int j = 0; j < 3; j++)
              if (GET_OBJ_VAL(GET_EQ(ch, i), j) == aff->type)
	      {
                found = TRUE;
                break;  
              }
        
        if (found) 
          sprintf(buf, "SPL: (Unlim) %s%-21s%s ", CCCYN(ch, C_NRM), 
              skill_name(aff->type), CCNRM(ch, C_NRM));
        else */
	sprintf(buf, "SPL: (%3dhr) %s%-21s%s ", aff->duration + 1, 
		CCCYN(ch, C_NRM), skill_name(aff->type), CCNRM(ch, C_NRM));
      } 
      strcpy(buf2, "");
      if (aff->modifier)
        sprintf(buf+strlen(buf), "%+d to %s", aff->modifier,
	        apply_types[(int) aff->location]);
      if (aff->bitvector)
      {
        if (*buf2)
          strcat(buf, ", sets ");
        else
          strcat(buf, "sets ");
        sprintbit(aff->bitvector, affected_bits, buf2);
        strcat(buf, buf2);
      }
      send_to_char(strcat(buf, "\r\n"), ch);
    }
  }
}

ACMD(do_exp)
{
  if (IS_NPC(ch))
    return;
  // Separate message for immorts.
  if (!LR_FAIL(ch, LVL_ISNOT_GOD))
  {
    send_to_char("You have no need for experience, you are immortal!\r\n", ch);
    return;
  }
  // No room to level, but remort is an option..
  if (!(CAN_LEVEL(ch)))
  {
    if (GET_CLASS(ch) < CLASS_MASTER)
      send_to_char("You have reached your classes maximum level. You might consider remorting.\r\n", ch);
    else
      send_to_char("You cannot gain further experience without great unholiness.\r\n", ch);
    return;
  }
  sprintf(buf, "With &c%d&n exp, you need &c%d&n exp to reach your next level.\r\n", GET_EXP(ch), level_exp(ch,GET_LEVEL(ch)) - GET_EXP(ch));
  send_to_char(buf, ch);
  return;
} 

ACMD(do_inventory)
{
  send_to_char("You are carrying:\r\n", ch);
  list_obj_to_char(ch->carrying, ch, 1, TRUE);
}


ACMD(do_equipment)
{
  int i, j, found = 0, okpos = 0;
  int find_eq_pos(struct char_data * ch, struct obj_data * obj, char *arg);

  one_argument(argument, arg);
  if (*arg)
  {
    if (is_abbrev(arg, "wield"))
      i = WEAR_WIELD;
    else if (is_abbrev(arg, "hold") || is_abbrev(arg, "held"))
      i = WEAR_HOLD;
    else if (is_abbrev(arg, "light"))
      i = WEAR_LIGHT;
    else if (is_abbrev(arg, "empty"))
    { // List all the empty bits.
      for (i = 0; i < NUM_WEARS; i++)
      {
	if (GET_EQ(ch, i))
	  continue;
	if (!eq_pos_ok(ch, i))
	  continue;
	if ((i == WEAR_SHIELD) && IS_DUAL_WIELDING(ch))
	  continue;
	send_to_char(where[i], ch);
	send_to_char("Nothing.\r\n", ch);
	found++;
      }
      if (found < 1)
	send_to_char("You don't have any empty wear positions!\r\n", ch);
      return;
    } else 
      i = find_eq_pos(ch, NULL, arg);
    if (i < 0) 
      return;
    switch (i)
    {
      case WEAR_LIGHT:
      case WEAR_BODY:
      case WEAR_HEAD:
      case WEAR_LEGS:
      case WEAR_FEET:
      case WEAR_HANDS:
      case WEAR_ARMS:
      case WEAR_SHIELD:
      case WEAR_ABOUT:
      case WEAR_WAIST:
      case WEAR_EYES: // The easy bits.
	if (!GET_EQ(ch, i))
	{
	  if (!eq_pos_ok(ch, i))
	    send_to_char("You can't wear anything there!\r\n", ch);
	  else
	    send_to_char("You're not using anything there!\r\n", ch);
	  return;
	}
        send_to_char(where[i], ch);
        if (CAN_SEE_OBJ(ch, GET_EQ(ch, i)))
	  show_obj_to_char(GET_EQ(ch, i), ch, 1);
	else
  	  send_to_char("Something.\r\n", ch);
        return;
      case WEAR_FINGER_1:
	for (i = 1; i < 6; i++)
	{
	  j = wear_positions[i];
	  if (GET_EQ(ch, j))
	  {
	    okpos++;
	    found++;
	    send_to_char(where[j], ch);
	    if (CAN_SEE_OBJ(ch, GET_EQ(ch, j)))
	      show_obj_to_char(GET_EQ(ch, j), ch, 1);
	    else
	      send_to_char("Something.\r\n", ch);
	  } else if (eq_pos_ok(ch, j))
	    okpos++;
	}
	if (okpos < 1) 
	  send_to_char("You can't wear anything there!\r\n", ch);
	if (found < okpos)
	{
	  sprintf(buf, "You have%s %d finger%s available.\r\n",
	          (found < 1) ? ((okpos > 1) ? " all" : " your") : "", 
		  okpos - found, (okpos - found == 1) ? "" : "s");
	  send_to_char(buf, ch);
	}
	return;
      case WEAR_NECK_1:
      case WEAR_WRIST_R:
      case WEAR_EAR_1:
      case WEAR_ANKLE_1:
	for (j = i; j <= i+1; j++)
	  if (GET_EQ(ch, j))
	  {
	    okpos++;
	    found++;
	    send_to_char(where[j], ch);
	    if (CAN_SEE_OBJ(ch, GET_EQ(ch, j)))
	      show_obj_to_char(GET_EQ(ch, j), ch, 1);
	    else
	      send_to_char("Something.\r\n", ch);
	  } else if (eq_pos_ok(ch, j))
	    okpos++;
	if (okpos < 1)
	  send_to_char("You can't wear anything there!\r\n", ch);
	else if (found < okpos)
	{
	  sprintf(buf, "You can wear %d %sthing%s there!\r\n",
	          okpos - found, (found > 0) ? "more " : "", 
		  (okpos - found) == 1 ? "" : "s");
	  send_to_char(buf, ch);
	}
	return;
      case WEAR_HOLD:
	if (!IS_DUAL_WIELDING(ch))
	{
	  if (GET_EQ(ch, WEAR_HOLD))
	  {
	    okpos++;
	    found++;
	    send_to_char(where[WEAR_HOLD], ch);
	    if (CAN_SEE_OBJ(ch, GET_EQ(ch, WEAR_HOLD)))
	      show_obj_to_char(GET_EQ(ch, WEAR_HOLD), ch, 1);
	    else
	      send_to_char("Something.\r\n", ch);
	  } else if (eq_pos_ok(ch, WEAR_HOLD))
	    okpos++;
	}
	if (GET_EQ(ch, WEAR_LIGHT))
	{
	  okpos++;
	  found++;
	  send_to_char(where[WEAR_LIGHT], ch);
	  if (CAN_SEE_OBJ(ch, GET_EQ(ch, WEAR_LIGHT)))
	    show_obj_to_char(GET_EQ(ch, WEAR_LIGHT), ch, 1);
	  else
	    send_to_char("Something.\r\n", ch);
	} else if (eq_pos_ok(ch, WEAR_LIGHT))
	  okpos++;
	if (okpos < 1)
	{
	  if (IS_DUAL_WIELDING(ch))
	    send_to_char("You are dual wielding, you can't hold anything!\r\n", ch);
	  else
	    send_to_char("You can't hold anything!\r\n", ch);
	}
	if (found < 1)
	  send_to_char("You're not holding anything.\r\n", ch);
	return;
      case WEAR_WIELD:
	if (!GET_EQ(ch, i))
	{
	  if (!eq_pos_ok(ch, i))
	    send_to_char("You can't weild anything!\r\n", ch);
	  else
	    send_to_char("You're not wielding anything!\r\n", ch);
	  return;
	}
        send_to_char(where[i], ch);
        if (CAN_SEE_OBJ(ch, GET_EQ(ch, i)))
	  show_obj_to_char(GET_EQ(ch, i), ch, 1);
	else
  	  send_to_char("Something.\r\n", ch);
	if (IS_DUAL_WIELDING(ch))
	{
	  send_to_char("<wielded (2nd)>      ", ch);
	  if (CAN_SEE_OBJ(ch, GET_EQ(ch, WEAR_HOLD)))
	    show_obj_to_char(GET_EQ(ch, WEAR_HOLD), ch, 1);
	  else
	    send_to_char("Something.\r\n", ch);
	}
	return;
    }
  }
  send_to_char("You are using:\r\n", ch);
  for (i = 0; i < NUM_WEARS; i++)
  {
    // Hide unavailable positions, unless the char happens to be wearing
    // something on that position
    if (eq_pos_ok(ch, wear_positions[i]) || GET_EQ(ch, wear_positions[i]))
    {
      // Wielding weapon in hold position - display "<wielded>"
//      if (i == WEAR_HOLD && 
//	  (GET_EQ(ch, i) && CAN_WEAR(GET_EQ(ch, i), WEAR_WIELD) && 
//	   !CAN_WEAR(GET_EQ(ch, i), WEAR_HOLD))) { 
      if ((wear_positions[i] == WEAR_HOLD) && IS_DUAL_WIELDING(ch))
        send_to_char("<wielded (2nd)>      ", ch);
      else
        send_to_char(where[wear_positions[i]], ch);

      if (GET_EQ(ch, wear_positions[i]))
      {
        if (CAN_SEE_OBJ(ch, GET_EQ(ch, wear_positions[i])))
	{
	  show_obj_to_char(GET_EQ(ch, wear_positions[i]), ch, 1);
	  found = TRUE;
        } else {
  	  send_to_char("Something.\r\n", ch);
	  found = TRUE;
        }
      } else {
        send_to_char("Nothing.\r\n", ch);
      }
    }
  }
}


ACMD(do_time)
{
  const char *suf;
  int weekday, day;

  sprintf(buf, "It is %d o'clock %s, on ",
	  ((time_info.hours % 12 == 0) ? 12 : ((time_info.hours) % 12)),
	  ((time_info.hours >= 12) ? "pm" : "am"));
  /* 35 days in a month */
  weekday = ((35 * time_info.month) + time_info.day + 1) % 7;
  strcat(buf, weekdays[weekday]);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
  day = time_info.day + 1;	/* day in [1..35] */
  if ((day % 10) == 1)
    suf = "st";
  else if ((day % 10) == 2)
    suf = "nd";
  else if ((day % 10) == 3)
    suf = "rd";
  else
    suf = "th";
  sprintf(buf, "The %d%s Day of the %s, Year %d.\r\n",
	  day, suf, month_name[(int) time_info.month], time_info.year);
  send_to_char(buf, ch);
}

ACMD(do_weather)
{
  const char *sky_look[] =
  {
    "cloudless",
    "cloudy",
    "rainy",
    "lit by flashes of lightning"
  };
  if (OUTSIDE(ch))
  {
    sprintf(buf, "The sky is %s and %s.\r\n", sky_look[weather_info.sky],
	    (weather_info.change >= 0 ? "you feel a warm wind from south" :
	     "your foot tells you bad weather is due"));
    send_to_char(buf, ch);
  } else
    send_to_char("You have no feeling about the weather at all.\r\n", ch);
}

/* command to tell ya what the moon is - Vader */
ACMD(do_moon)
{
  extern struct time_info_data time_info;
  byte day = time_info.day % 3;
 
  if(weather_info.moon == MOON_NONE)
  {
    send_to_char("It is a moonless night.\r\n",ch);
    return;
  }
  if(!(time_info.hours > 12)) 
  {
    day--;
    if(day < 0)
      day = 2;
  }
  switch(day) 
  {
    case 0:
      sprintf(buf, "It is the 1st night of the %s moon.\r\n",
	      moon_mesg[weather_info.moon]);
      break;
    case 1:
      sprintf(buf, "It is the 2nd night of the %s moon.\r\n",
	      moon_mesg[weather_info.moon]);
      break;
    case 2:
      sprintf(buf, "It is the 3rd night of the %s moon.\r\n",
	      moon_mesg[weather_info.moon]);
      break;
  }
  send_to_char(buf,ch);
} 

ACMD(do_help)
{
  int chk, bot, top, mid, minlen, count = 0;
  char *helpstring;

  if (!ch->desc)
    return;
  skip_spaces(&argument);
  if (!*argument)
  {
    page_string(ch->desc, help, 0);
    return;
  }
  if (!help_table)
  {
    send_to_char("No help available.\r\n", ch);
    return;
  }
  bot = 0;
  top = top_of_helpt;
  minlen = strlen(argument);
  for (;;)
  {
    mid = (bot + top) / 2;
    if (bot > top)
    {
      send_to_char("There is no help on that word.\r\n", ch);
      return;
    } 
    if (!(chk = strn_cmp(argument, help_table[mid].keyword, minlen)))
    {
      /* trace backwards to find first matching entry. Thanks Jeff Fink! */
      while ((mid > 0) &&
	     (!(chk = strn_cmp(argument, help_table[mid - 1].keyword, minlen))))
	mid--;
      // DM - check the help level restriction 
      // TODO - if restricted try and find an unrestricted match before failing 
      if (LR_FAIL_MAX(ch, help_table[mid].level_restriction))
      {
        send_to_char("Sorry, you don't have access to that help.\r\n",ch);
        return;
      }
      /* Bypass the keywords */
      helpstring = help_table[mid].entry;      
      while(helpstring[count] != '\n')
        count++;
      page_string(ch->desc, &helpstring[count+1], 0);
      return;
    }
    if (chk > 0)
      bot = mid + 1;
    else
      top = mid - 1;
  }
}

struct char_data *theWhoList[500];
#define WHO_FORMAT \
"&1usage: &4who [minlev[-maxlev]] [-i [clan num]] [-n name] [-c classlist]\r\n           [-a] [-b] [-t] [-s] [-o] [-q] [-r] [-z] [-1] [-2] [-3]\r\n"
ACMD(do_who)
{
  struct descriptor_data *d;
  struct char_data *tch;
  char name_search[MAX_INPUT_LENGTH];
  char clan_search[MAX_INPUT_LENGTH];
  char mode;
  size_t i;
  int low = 0, high = LVL_OWNER, localwho = 0, questwho = 0;
  int showclass = 0, short_list = 0, outlaws = 0, num_can_see = 0;
  int who_room = 0;
  int orderCharName = 0, orderCharLevelA = 0, orderCharTime = 0;
  int showClanOnly = 0, clanNumber = 0;
  int noElements = 0;

  skip_spaces(&argument);
  strcpy(buf, argument);
  name_search[0] = '\0';
  while (*buf)
  {
    half_chop(buf, arg, buf1);
    if (*arg == '-')
    {
      mode = *(arg + 1);       // just in case; we destroy arg in the switch 
      switch (mode)
      {
	case 'a':
	  orderCharName = 1;
	  strcpy(buf,buf1);
	  break;
	case 'b':
	  orderCharLevelA = 1;
	  strcpy(buf,buf1);
	  break;
	case 't':
	  orderCharTime = 1;
	  strcpy(buf,buf1);
	  break;
	case 'i':
	  showClanOnly = 1;
	  half_chop(buf1, clan_search, buf);
	  break;
	case 'o':
	  outlaws = 1;
	  strcpy(buf, buf1);
	  break;
	case 'z':
	  localwho = 1;
	  strcpy(buf, buf1);
	  break;
	case 's':
	  short_list = 1;
	  strcpy(buf, buf1);
	  break;
	case 'q':
	  questwho = 1;
	  strcpy(buf, buf1);
	  break;
	case 'l':
	  half_chop(buf1, arg, buf);
	  sscanf(arg, "%d-%d", &low, &high);
	  break;
	case 'n':
	  half_chop(buf1, name_search, buf);
	  break;
	case 'r':
	  who_room = 1;
	  strcpy(buf, buf1);
	  break;
	case 'c':
	  half_chop(buf1, arg, buf);
	  for (i = 0; i < strlen(arg); i++)
	    showclass |= find_class_bitvector(arg[i]);
	  break;
	default:
	  send_to_char(WHO_FORMAT, ch);
	  return;
      }				// end of switch 
    } else if (isdigit(*arg)) {
      sscanf(arg, "%d-%d", &low, &high);
      strcpy(buf, buf1);
    } else {			// endif
      send_to_char(WHO_FORMAT, ch);
      return;
    }
  }				// end while (parser) 
  // Clan processing
  if (showClanOnly)
  {
    if (*clan_search)
    {
      clanNumber = find_clan_by_sid(clan_search);
      if ((clanNumber = find_clan_by_sid(clan_search)) < 0)
      {
        send_to_char(WHO_FORMAT,ch);
        send_to_char("That is not a clan, type 'clan info' to see the list.\r\n",ch);
        return;
      }
    } else {
      if (GET_CLAN(ch) < 1)
      {
        send_to_char(WHO_FORMAT, ch);
        send_to_char("You don't belong to a clan.\r\n",ch);
        return;
      } else {
        clanNumber = GET_CLAN(ch);
      }
    }
  }

  for (d = descriptor_list; d; d = d->next)
  {
    //if (STATE(d) != CON_PLAYING)
    if (!IS_PLAYING(d))
      continue;
    if (d->original)
      tch = d->original;
    else if (!(tch = d->character))
      continue;
    if (*name_search && str_cmp(GET_NAME(tch), name_search) &&
	!strstr(GET_TITLE(tch), name_search))
      continue;
    if ((showClanOnly && GET_CLAN(tch) != clanNumber))
      continue;
    if (!CAN_SEE(ch, tch) || GET_LEVEL(tch) < low || GET_LEVEL(tch) > high)
      continue;
    if (outlaws && !PLR_FLAGGED(tch, PLR_KILLER) &&
	!PLR_FLAGGED(tch, PLR_THIEF))
      continue;
    if (questwho && !PRF_FLAGGED(tch, PRF_QUEST))
      continue;
    if (localwho && world[ch->in_room].zone != world[tch->in_room].zone)
      continue;
    if (who_room && (tch->in_room != ch->in_room))
      continue;
    if (showclass && !(showclass & (1 << GET_CLASS(tch))))
      continue;
    if (short_list)
    {
      // BUG FIX TODO - too few substitutes in string, who added socials?
      sprintf(buf, "%s[%3d %s] %s%-12.12s%s%s",
              // Added colour for social status
              //(GET_SOCIAL_STATUS(ch) <= SOCIAL_UNDESIRABLE  ? CCRED(ch, C_SPR) :
               //GET_SOCIAL_STATUS(ch) <= SOCIAL_LANDOWNER ? CCBLU(ch, C_SPR) : CCGRN(ch, C_SPR)),
	       // DM - ok removed social colours now based on remort
	      (GET_REM_TWO(tch) > 0) ? CCCYN(ch, C_SPR) : 
	       GET_REM_ONE(tch) > 0  ? CCGRN(ch, C_SPR) : CCWHT(ch, C_SPR),
              GET_LEVEL(tch), CLASS_ABBR(tch), 
      	      (GET_LEVEL(tch) >= LVL_GOD       ? CCBYEL(ch,C_SPR)  :
              (GET_LEVEL(tch) >= LVL_ANGEL     ? CCCYN(ch,C_SPR)   :
              (GET_LEVEL(tch) >= LVL_LEGEND    ? CCMAG(ch,C_SPR)   : 
              (GET_LEVEL(tch) >= LVL_ISNOT_GOD ? CCRED(ch,C_SPR)   :
	      (GET_LEVEL(tch) >= LVL_CHAMP     ? CCBLU(ch, C_SPR)  :
              (GET_LEVEL(tch) >= LVL_ETRNL1    ? CCBBLU(ch, C_SPR) :
	       CCWHT(ch, C_SPR))))))),
	      GET_NAME(tch),
              (GET_LEVEL(tch) >= LVL_ETRNL1 ? CCNRM(ch, C_SPR) : ""),
              ((!(++num_can_see % 4)) ? "\r\n" : ""));
      send_to_char(buf,ch);
    } else {
      theWhoList[noElements++] = tch;
      num_can_see++;
    }				// endif shortlist 
  }				// end of for 
  // Ordered by char name (alpha ascending) 
  if (orderCharName)
    qsort(theWhoList, noElements, sizeof(struct char_data *), compareCharName);
  else if (orderCharLevelA) // Ordered by Level Ascending
    qsort(theWhoList, noElements, sizeof(struct char_data *),
	  compareCharLevelA);
  else if (orderCharTime); // Unsorted (by time)
  else // Default ordering is Level Descending
    qsort(theWhoList, noElements, sizeof(struct char_data *),
	  compareCharLevelD);
  if (!short_list)
    print_who_info(theWhoList,num_can_see,ch);
  if (short_list && (num_can_see % 4))
    send_to_char("\r\n", ch);
  if (num_can_see == 0)
    sprintf(buf, "\r\n&nNo-one at all!\r\n");
  else if (num_can_see == 1)
    sprintf(buf, "\r\n&nOne lonely character displayed.\r\n");
  else
    sprintf(buf, "\r\n&c%d&n characters displayed.\r\n", num_can_see);
  send_to_char(buf, ch);
}

int compareAffectDuration(const void *l, const void *r)
{
  struct affected_type **left;
  struct affected_type **right;
  left = (struct affected_type **)l;
  right = (struct affected_type **)r;
  // sort -1 (unlimited durations) to head of list
  if ((*left)->duration == CLASS_ABILITY)
    return -1;
  if ((*right)->duration == CLASS_ABILITY)
    return 1;
  if ((*left)->duration == CLASS_ITEM)
    return -1;
  if ((*right)->duration == CLASS_ITEM)
    return 1;
  return ((*left)->duration < (*right)->duration);
}

// Compares chars names, returns normal strcmp result
int compareCharName(const void *l, const void *r)
{
  struct char_data **left;
  struct char_data **right;
  left = (struct char_data **)l;
  right = (struct char_data **)r;
  return strcmp(GET_NAME(*left),GET_NAME(*right));
}

// Compares chars levels for descending, if l < r, return 1 
int compareCharLevelD(const void *l, const void *r)
{
  struct char_data **left;
  struct char_data **right;
  left = (struct char_data **)l;
  right = (struct char_data **)r;
  if (GET_LEVEL(*left) < GET_LEVEL(*right))
    return 1;
  else if (GET_LEVEL(*left) == GET_LEVEL(*right))
    return 0;
  else
    return -1;
}

// Compares chars levels for ascending, l < r, return -1
int compareCharLevelA(const void *l, const void *r)
{
  struct char_data **left;
  struct char_data **right;
  left = (struct char_data **)l;
  right = (struct char_data **)r;
  if (GET_LEVEL(*left) < GET_LEVEL(*right))
    return -1;
  else if (GET_LEVEL(*left) == GET_LEVEL(*right))
    return 0;
  else
    return 1;
}

// Level Rank Abbreviations: PLR, CMP, GOD, etc.
char *levelrank_abbrev(int level)
{
  static char s[5];
  if (level <  LVL_ETRNL1) return("PLR");
  if (level <  LVL_CHAMP)  
  {
    sprintf(s, "ET%d", level-LVL_ETRNL1+1);
    return (s);
  }
  if (level <  LVL_IMMORT) return("CMP");
  if (level <  LVL_ANGEL)  return("IMM");
  if (level <  LVL_LEGEND) return("ANG");
  if (level <  LVL_GOD)    return("LEG");
  if (level <  LVL_GRGOD)  return("DEI");
  if (level <  LVL_IMPL)   return("GOD");
  if (level <  LVL_GRIMPL) return("IMP");
  if (level <  LVL_OWNER)  return("BCH");
  if (level == LVL_OWNER)  return("ONR");
  return("WTF");
}

// Level Rank Colours.
char *levelrank_colour(struct char_data *ch, int targlevel, int colourlevel)
{
  if ((!clr(ch, colourlevel)) || (targlevel < LVL_ETRNL1)) return "";
  if (targlevel < LVL_CHAMP)  return "&B";
  if (targlevel < LVL_IMMORT) return "&r";
  if (targlevel < LVL_ANGEL)  return "&R";
  if (targlevel < LVL_LEGEND) return "&c";
  if (targlevel < LVL_GOD)    return "&C";
  if (targlevel < LVL_IMPL)   return "&y";
  return "&Y";
}

/** 
 * Prints out the characters referenced by an array of struct char_data * 
 */ 
void print_who_info(struct char_data *array[], int length, 
                    struct char_data *ch)
{
  int i,j,k,l;
  struct char_data *tch;
  char sr[5], sc[4];
  buf2[0]='\0';
  send_to_char("&y---------\r\n &rP&Rl&Ya&Wy&Ye&Rr&rs&n\r\n&y---------&n\r\n", ch);
  for (i = 0; i < length; i++)
  {
    tch = array[i];
    strcpy(sc, levelrank_colour(ch, GET_LEVEL(tch), C_SPR));
    if (strlen(GET_WHO_STR(tch)) > 0)
    {
      j = 10; k = 20; l=0;
      //sprintf(buf, "%s[", (GET_SOCIAL_STATUS(tch) <= SOCIAL_UNDESIRABLE ? 
      //      CCRED(ch, C_SPR) : GET_SOCIAL_STATUS(tch) <= SOCIAL_LANDOWNER ? 
      //      CCBLU(ch, C_SPR) : CCGRN(ch, C_SPR)));
      // DM    - removed social status, now based on remort levels
      // Artus - fuck it. lets go back to the old level way.
      sprintf(buf, "%s[", (*sc ? sc : "&n"));
      j -= (int)(strdisplen(GET_WHO_STR(tch)) / 2);
      k -= (j+strdisplen(GET_WHO_STR(tch)));
      for (l=0; l < j; l++)
	strcat(buf, " ");
      strcat(buf, GET_WHO_STR(tch));
      for (l=0; l < k; l++)
	strcat(buf, " ");
      sprintf(buf+strlen(buf), "%s] %s %s&n", (*sc ? sc : "&n"), 
	      GET_NAME(tch), GET_TITLE(tch));
    } else {
      strcpy(sr, levelrank_abbrev(GET_LEVEL(tch)));
      sprintf(buf, "%s[ %02d/%02d/%-3d %c %s %s ] %s %s",
	      (*sc ? sc : "&n"), GET_REM_ONE(tch), GET_REM_TWO(tch),
	      GET_LEVEL(tch),
	       (GET_SEX(tch)==SEX_MALE   ? 'M' :
		GET_SEX(tch)==SEX_FEMALE ? 'F' : '-'),
	       CLASS_ABBR(tch), RACE_ABBR(tch), GET_NAME(tch),
	       GET_TITLE(tch));
    }
    if (GET_INVIS_LEV(tch))
    {
      if (GET_INVIS_TYPE(tch) == INVIS_NORMAL) // Standard invis?
	sprintf(buf+strlen(buf), " (i%d)", GET_INVIS_LEV(tch));
      else if (GET_INVIS_TYPE(tch) == INVIS_SINGLE) // Level invis?
	sprintf(buf+strlen(buf), " (i%ds)", GET_INVIS_LEV(tch));
      else if (GET_INVIS_TYPE(tch) == INVIS_SPECIFIC) // Player invis?
	strcpy(buf, " (i-char)");
      else // Ranged invis!
	sprintf(buf+strlen(buf), " (i%d - %d)", GET_INVIS_LEV(tch),
	        GET_INVIS_TYPE(tch));
    }
    if (IS_AFFECTED(tch, AFF_INVISIBLE))
      strcat(buf, " (invis)"); 
    if (IS_BUILDING(tch))
      strcat(buf, " (building)");
    else if (PLR_FLAGGED(tch, PLR_MAILING))
      strcat(buf, " (mailing)");
    else if (PLR_FLAGGED(tch, PLR_WRITING | PLR_ODDWRITE))
      strcat(buf, " (writing)");
    else if (PLR_FLAGGED(tch, PLR_REPORTING))
      strcat(buf, " (reporting)");
    for (j = 0; j < MAX_IGNORE; j++)
      if (GET_IGNORE(tch, j) > 0 || GET_IGN_LVL(tch) > 0)
      {
	strcat(buf, " (snob)");
	break;
      }
    if (PRF_FLAGGED(tch, PRF_AFK))
      strcat(buf, " (AFK)");
    if (PRF_FLAGGED(tch, PRF_DEAF))
      strcat(buf, " (deaf)");
    if (EXT_FLAGGED(tch, EXT_PKILL)) /* PK flag showing. - ARTUS */
      strcat(buf, " (PK)");
    if (PRF_FLAGGED(tch, PRF_NOTELL))
      strcat(buf, " (notell)");
    if (PRF_FLAGGED(tch, PRF_QUEST))
      strcat(buf, " (quest)");
    if (PLR_FLAGGED(tch, PLR_THIEF))
      strcat(buf, " (THIEF)");
    if (PLR_FLAGGED(tch, PLR_KILLER))
      strcat(buf, " (KILLER)");
    if (PRF_FLAGGED(tch, PRF_TAG))
      strcat(buf, " (tag)");
    if (world[IN_ROOM(tch)].number == IDLE_ROOM_VNUM)
      strcat(buf, " (limbo)");
    if (IS_GHOST(tch))
      strcat(buf, " (ghost)");
    if (GET_UNHOLINESS(tch) > 0)
      sprintf(buf+strlen(buf), " (UV: %d)", GET_UNHOLINESS(tch));
    if (GET_LEVEL(tch) >= LVL_ETRNL1)
      strcat(buf, CCNRM(ch, C_SPR));
    if (GET_CLAN(tch) > 0) // Show Clan.
    {
      int c;
      c = find_clan_by_id(GET_CLAN(tch));
      if (GET_CLAN_RANK(tch) == clan[c].ranks)
	strcat(buf, CCBLU(ch, C_SPR));
      sprintf(buf, "%s [%s - %s]&n", buf, clan[c].name, 
	      ((GET_CLAN_RANK(tch) < 1) ? "Applying" : 
	       clan[c].rank_name[(GET_CLAN_RANK(tch) - 1)]));
    }
    strcat(buf, "\r\n");
    strncat(buf2,buf,strlen(buf));
  }				/* end of for */
  page_string(ch->desc, buf2, 0);
}

#define USERS_FORMAT \
"&1format: &4users [-a name ] [-l minlevel[-maxlevel]] [-n name] [-h host] [-c classlist] [-o] [-p]&n\r\n"
ACMD(do_users)
{
  const char *format = "%3d %-7s %-12s %-14s %-3s %-8s ";
  char line[200], line2[220], idletime[10], classname[20];
  char state[30], *timeptr, *timeptr2, mode;
  char name_search[MAX_INPUT_LENGTH], host_search[MAX_INPUT_LENGTH];
  struct char_data *tch;
  struct descriptor_data *d;
  struct user_data *users;
#ifdef NO_LOCALTIME
  struct tm lt;
#endif
  size_t i;
  int low = 0, high = LVL_OWNER-1, num_can_see = 0;
  int showclass = 0, outlaws = 0, playing = 0, deadweight = 0;
  int h, m, s;
  time_t mytime, tally = 0;
  char temp1[11], temp2[11], *name;
  int singleuser = FALSE;

  host_search[0] = name_search[0] = '\0';

  strcpy(buf, argument);
  while (*buf)
  {
    half_chop(buf, arg, buf1);
    if (*arg == '-')
    {
      mode = *(arg + 1);  /* just in case; we destroy arg in the switch */
      switch (mode)
      {
	case 'a':
	  // name specified - tally times and only display that person
	  if (*buf1)
	  {
	    name = buf1;
	    skip_spaces(&name);
	    if (get_id_by_name(name) > 0)
	      singleuser = TRUE;
	  }
	  strcpy(buf, "Num Lvl   Name         Site                     Login@@   Logout@@  Session\r\n");
	  strcat(buf, "--- ----- ------------ ------------------------ -------- -------- --------\r\n");
	  for (users = user_list; users; users=users->next)
	  {
	    if (singleuser && str_cmp(name, users->name))
	      continue;
#ifndef NO_LOCALTIME
	    timeptr = asctime(localtime(&users->login));
#else
	    if (jk_localtime(&lt, users->login))
	    {
	      basic_mud_log("Error in jk_localtime (users->login: %ld) [%s:%d]", users->login, __FILE__, __LINE__);
	      continue;
	    }
	    timeptr = asctime(&lt);
#endif
	    timeptr += 11;
	    *(timeptr + 8) = '\0';
	    strcpy(temp1, timeptr);

	    if (users->logout)
	    {
#ifndef NO_LOCALTIME
	      timeptr2 = asctime(localtime(&users->logout));
#else
	      if (jk_localtime(&lt, users->logout))
	      {
		basic_mud_log("Error in jk_localtime(users->logout: %ld) [%s:%d]", users->logout, __FILE__, __LINE__);
		continue;
	      }
	      timeptr2 = asctime(&lt);
#endif
	      timeptr2 += 11;
	      *(timeptr2 + 8) = '\0'; 
	      strcpy(state, timeptr2);
	      strcpy(temp2, timeptr2);
	      
	      mytime = users->logout - users->login;
	    } else {
	      strcpy(temp2, "-active-");
	      mytime = time(0) - users->login;
	    }
	    if (singleuser)
	      tally = tally + mytime;
	    h = (mytime / 3600);
	    m = (mytime / 60) % 60;
	    s = mytime % 60;
	    sprintf(buf2, "%3d [%-3d] %-12s %-24s %-8s %-8s %dh%dm%ds\r\n",
		    users->number, users->level, users->name, users->host,
		    temp1, temp2, h, m, s);
	    strcat(buf, buf2);
	  }
	  if (singleuser)
	  {
	    h = (tally / 3600);
	    m = (tally / 60) % 60;
	    s = tally % 60;
	    sprintf(buf2,"Total time for %s: %dh%dm%ds\r\n", name, h, m, s);
	    strcat(buf, buf2);
	  }
	  page_string(ch->desc, buf, TRUE);
	  return;
	case 'o':
	case 'k':
	  outlaws = 1;
	  playing = 1;
	  strcpy(buf, buf1);
	  break;
	case 'p':
	  playing = 1;
	  strcpy(buf, buf1);
	  break;
	case 'd':
	  deadweight = 1;
	  strcpy(buf, buf1);
	  break;
	case 'l':
	  playing = 1;
	  half_chop(buf1, arg, buf);
	  sscanf(arg, "%d-%d", &low, &high);
	  break;
	case 'n':
	  playing = 1;
	  half_chop(buf1, name_search, buf);
	  break;
	case 'h':
	  playing = 1;
	  half_chop(buf1, host_search, buf);
	  break;
	case 'c':
	  playing = 1;
	  half_chop(buf1, arg, buf);
	  for (i = 0; i < strlen(arg); i++)
	    showclass |= find_class_bitvector(arg[i]);
	  break;
	default:
	  send_to_char(USERS_FORMAT, ch);
	  return;
      }				/* end of switch */
    } else {			/* endif */
      send_to_char(USERS_FORMAT, ch);
      return;
    }
  }				/* end while (parser) */
  strcpy(line,
	 "Num Class    Name         State          Idl Login@@   Site\r\n");
  strcat(line, "--- -------- ------------ -------------- --- -------- ------------------------\r\n");
  send_to_char(line, ch);
  one_argument(argument, arg);
  for (d = descriptor_list; d; d = d->next)
  {
    if (STATE(d) != CON_PLAYING && playing)
      continue;
    if (STATE(d) == CON_PLAYING && deadweight)
      continue;
    if (IS_PLAYING(d))
    { 
      if (d->original)
	tch = d->original;
      else if (!(tch = d->character))
	continue;
      if (*host_search && !strstr(d->host, host_search))
	continue;
      if (*name_search && str_cmp(GET_NAME(tch), name_search))
	continue;
      if (!CAN_SEE(ch, tch) || GET_LEVEL(tch) < low)// || GET_LEVEL(tch)>high)
	continue;
      if (outlaws && !PLR_FLAGGED(tch, PLR_KILLER) &&
	  !PLR_FLAGGED(tch, PLR_THIEF))
	continue;
      if (showclass && !(showclass & (1 << GET_CLASS(tch))))
	continue;
      if (GET_INVIS_LEV(ch) > GET_LEVEL(ch))
	continue;
      if (d->original)
	sprintf(classname, "[%3d %s]", GET_LEVEL(d->original),
		CLASS_ABBR(d->original));
      else
	sprintf(classname, "[%3d %s]", GET_LEVEL(d->character),
		CLASS_ABBR(d->character));
    } else
      strcpy(classname, "   -   ");
#ifndef NO_LOCALTIME
    timeptr = asctime(localtime(&d->login_time));
#else
    if (jk_localtime(&lt, d->login_time))
    {
      basic_mud_log("Error in jk_localtime (d->login_time: %ld) [%s:%d]", d->login_time, __FILE__, __LINE__);
      return;
    }
    timeptr = asctime(&lt);
#endif
    timeptr += 11;
    *(timeptr + 8) = '\0';
    if (STATE(d) == CON_PLAYING && d->original)
      strcpy(state, "Switched");
    else
      strcpy(state, connected_types[STATE(d)]);
    //if (d->character && STATE(d) == CON_PLAYING && (GET_LEVEL(d->character) < LVL_GOD)
    if ((d->character && STATE(d) == CON_PLAYING) && (GET_LEVEL(d->character) <= GET_LEVEL(ch)))
      sprintf(idletime, "%3d", d->character->char_specials.timer *
	      SECS_PER_MUD_HOUR / SECS_PER_REAL_MIN);
    else
      strcpy(idletime, "");

    if (d->character && d->character->player.name)
    {
      if (d->original)
	sprintf(line, format, d->desc_num, classname,
		d->original->player.name, state, idletime, timeptr);
      else
	sprintf(line, format, d->desc_num, classname,
		d->character->player.name, state, idletime, timeptr);
    } else
      sprintf(line, format, d->desc_num, "   -   ", "UNDEFINED",
	      state, idletime, timeptr);
    if (d->host && *d->host)
      sprintf(line + strlen(line), "[%s]\r\n", d->host);
    else
      strcat(line, "[Hostname unknown]\r\n");
    if (STATE(d) != CON_PLAYING)
    {
      sprintf(line2, "%s%s%s", CCGRN(ch, C_SPR), line, CCNRM(ch, C_SPR));
      strcpy(line, line2);
    }
    if (((STATE(d) != CON_PLAYING) || (STATE(d) == CON_PLAYING)) &&
	(CAN_SEE(ch, d->character)))
    {
      send_to_char(line, ch);
      num_can_see++;
    }
  }
  sprintf(line, "\r\n%d visible sockets connected.\r\n", num_can_see);
  send_to_char(line, ch);
}


/* Generic page_string function for displaying text */
ACMD(do_gen_ps)
{
  switch (subcmd)
  {
    case SCMD_CREDITS:
      page_string(ch->desc, credits, 0);
      break;
    case SCMD_NEWS:
      page_string(ch->desc, news, 0);
      break;
    case SCMD_INFO:
      page_string(ch->desc, info, 0);
      break;
    case SCMD_WIZLIST:
      page_string(ch->desc, wizlist, 0);
      break;
    case SCMD_IMMLIST:
      page_string(ch->desc, immlist, 0);
      break;
    case SCMD_HANDBOOK:
      page_string(ch->desc, handbook, 0);
      break;
    case SCMD_POLICIES:
      page_string(ch->desc, policies, 0);
      break;
    case SCMD_MOTD:
      page_string(ch->desc, motd, 0);
      break;
    case SCMD_IMOTD:
      page_string(ch->desc, imotd, 0);
      break;
    case SCMD_CLEAR:
      send_to_char("\033[H\033[J", ch);
      break;
    case SCMD_VERSION:
      sprintf(buf, "PrimalMUD version: &c%d.%d.%d&n Copyright (C) 1994-2004\r\n"
		   "  Built on: %s\r\n\r\n"
		   "Based on CircleMUD version 3bpl17 and" 
		   " PrimalMUD version 2.00\r\n", 
	      release.getMajor(), release.getBranch(), release.getMinor(),
	      release.getDate());
      send_to_char(buf, ch);
      send_to_char(strcat(strcpy(buf, DG_SCRIPT_VERSION), "\r\n"), ch);
      //send_to_char(strcat(strcpy(buf, circlemud_version), "\r\n"), ch);
      break;
    case SCMD_WHOAMI:
      send_to_char(strcat(strcpy(buf, GET_NAME(ch)), "\r\n"), ch);
      break;
    case SCMD_AREAS:
      page_string(ch->desc, areas, 0);
      break;
    default:
      basic_mud_log("SYSERR: Unhandled case in do_gen_ps. (%d)", subcmd);
      return;
  }
}


void perform_mortal_where(struct char_data * ch, char *arg)
{
  int zone_name_len, j;  
  register struct char_data *i;
  register struct descriptor_data *d;
  extern struct zone_data *zone_table; 

  if (!*arg)
  {
    int k;
    zone_name_len = strlen(zone_table[world[ch->in_room].zone].name);
    sprintf(buf, "Players in &R%s&n\r\n",
	    zone_table[world[ch->in_room].zone].name);
    k = strlen(buf);
    for (j=0; j < (11+zone_name_len); j++)
      buf[k++] = '-';
    buf[k] = '\0';
    strcat(buf, "\r\n");
    send_to_char(buf,ch);
    for (d = descriptor_list; d; d = d->next)
    {
      if (STATE(d) != CON_PLAYING || d->character == ch)
	continue;
      if ((i = (d->original ? d->original : d->character)) == NULL)
	continue;
      if (i->in_room == NOWHERE || !CAN_SEE(ch, i))
	continue;
      if (world[ch->in_room].zone != world[i->in_room].zone)
	continue;
      sprintf(buf, "%-20s - %s\r\n", GET_NAME(i), world[i->in_room].name);
      send_to_char(buf, ch);
    }
  } else {			/* print only FIRST char, not all. */
    for (i = character_list; i; i = i->next)
    {
      if (i->in_room == NOWHERE || i == ch)
	continue;
      if (!CAN_SEE(ch, i) || world[i->in_room].zone != world[ch->in_room].zone)
	continue;
      if (!isname(arg, i->player.name))
	continue;
      sprintf(buf, "%-25s - %s\r\n", GET_NAME(i), world[i->in_room].name);
      send_to_char(buf, ch);
      return;
    }
    send_to_char("No-one around by that name.\r\n", ch);
  }
}

void print_object_location(int num, struct obj_data * obj, struct char_data *ch,
			   int recur, char *writeto)
{
  if (num > 0)
    sprintf(writeto, "&bO&n%3d. %-25s - ", num, obj->short_description);
  else
    sprintf(writeto, "%33s", " - ");
  if (obj->in_room > NOWHERE)
  {
    sprintf(writeto + strlen(writeto), "&c[%5d]&n %s\r\n",
	    GET_ROOM_VNUM(IN_ROOM(obj)), world[obj->in_room].name);
    //send_to_char(buf, ch);
  } else if (obj->carried_by) {
    sprintf(writeto + strlen(writeto), "carried by %s\r\n",
	    PERS(obj->carried_by, ch));
    //send_to_char(buf, ch);
  } else if (obj->worn_by) {
    sprintf(writeto + strlen(writeto), "worn by %s\r\n",
	    PERS(obj->worn_by, ch));
    //send_to_char(buf, ch);
  } else if (obj->in_obj) {
    sprintf(writeto + strlen(writeto), "inside %s%s\r\n",
	    obj->in_obj->short_description, (recur ? ", which is" : " "));
    //send_to_char(buf, ch);
    if (recur)
    {
      buf2[0] = '\0';
      print_object_location(0, obj->in_obj, ch, recur, buf2);
      sprintf(writeto, "%s%s", writeto, buf2);
    }
  } else {
    sprintf(writeto + strlen(writeto), "in an unknown location\r\n");
    //send_to_char(buf, ch);
  }
}



void perform_immort_where(struct char_data * ch, char *arg)
{
  register struct char_data *i;
  register struct obj_data *k;
  struct descriptor_data *d;
  int num = 0, found = 0;
  buf[0] = '\0';
  buf1[0] = '\0';
  if (!*arg)
  {
    sprintf(buf, "&gPlayers&n\r\n-------\r\n");
    for (d = descriptor_list; d; d = d->next)
      if (STATE(d) == CON_PLAYING)
      {
	i = (d->original ? d->original : d->character);
	if (i && CAN_SEE(ch, i) && (i->in_room != NOWHERE))
	{
	  if (d->original)
	    sprintf(buf+strlen(buf), "%-20s - &c[%5d]&n %s (%s) (in %s)\r\n",
		    GET_NAME(i), GET_ROOM_VNUM(IN_ROOM(d->character)),
		    world[i->in_room].name,
		    zone_table[world[i->in_room].zone].name, 
		    GET_NAME(d->character));
	  else
	    sprintf(buf+strlen(buf), "%-20s - &c[%5d]&n %s (%s)\r\n",
		    GET_NAME(i), GET_ROOM_VNUM(IN_ROOM(i)),
		    world[i->in_room].name,
		    zone_table[world[i->in_room].zone].name);
	}
      }
    page_string(ch->desc, buf, TRUE);
  } else {
    for (i = character_list; i; i = i->next)
      if (CAN_SEE(ch, i) && i->in_room != NOWHERE 
                      && isname(arg, i->player.name))
      {
	found = 1;
	sprintf(buf+strlen(buf), "&rM&n%3d. %-25s - &c[%5d]&n %s\r\n", ++num,
	        GET_NAME(i), GET_ROOM_VNUM(IN_ROOM(i)), world[IN_ROOM(i)].name);
	//send_to_char(buf, ch);
      }
    for (num = 0, k = object_list; k; k = k->next)
      if (CAN_SEE_OBJ(ch, k) && isname(arg, k->name))
      {
	found = 1;
	print_object_location(++num, k, ch, TRUE, buf+strlen(buf));
      }
    if (!found)
      send_to_char("Couldn't find any such thing.\r\n", ch);
    else
      page_string(ch->desc, buf, TRUE);
  }
}



ACMD(do_where)
{
  one_argument(argument, arg);
  if (LR_FAIL(ch, LVL_ISNOT_GOD))
    perform_mortal_where(ch, arg);
  else
    perform_immort_where(ch, arg);
}

// DM - TODO - decide on levels format
ACMD(do_levels)
{
  int i;

  if (IS_NPC(ch))
  {
    send_to_char("You ain't nothin' but a hound-dog.\r\n", ch);
    return;
  }
  *buf = '\0';

  for (i = 1; i < LVL_IMMORT-1; i++)
  {
    if (i >= LVL_ETRNL1-1)
      sprintf(buf+strlen(buf), "&g[&m%3d - %2d&g]&n &c%9d&n\r\n", i, i+1,
	      level_exp(ch, i));
    else
      sprintf(buf+strlen(buf), "&g[&n%3d - %2d&g]&n &c%9d&n\r\n", i, i+1,
	      level_exp(ch, i));
  }
  sprintf(buf+strlen(buf), "&g[   &b%3d&g  ]&n &c%9d&n : &bImmortality&n\r\n",
	  LVL_IMMORT, level_exp(ch, LVL_IMMORT-1));
  page_string(ch->desc, buf, 1);
}

ACMD(do_consider)
{
  struct char_data *victim;
  int diff;

  one_argument(argument, buf);

  if (!(victim = generic_find_char(ch, buf, FIND_CHAR_ROOM)))
  {
    send_to_char("Consider killing who?\r\n", ch);
    return;
  }
  if (victim == ch)
  {
    send_to_char("Easy!  Very easy indeed!\r\n", ch);
    return;
  }
  if (!IS_NPC(victim))
  {
    send_to_char("Would you like to borrow a cross and a shovel?\r\n", ch);
    return;
  }
  diff = (GET_LEVEL(victim) - GET_LEVEL(ch));

  if (diff <= -10)
    send_to_char("Now where did that chicken go?\r\n", ch);
  else if (diff <= -5)
    send_to_char("You could do it with a needle!\r\n", ch);
  else if (diff <= -2)
    send_to_char("Easy.\r\n", ch);
  else if (diff <= -1)
    send_to_char("Fairly easy.\r\n", ch);
  else if (diff == 0)
    send_to_char("The perfect match!\r\n", ch);
  else if (diff <= 1)
    send_to_char("You would need some luck!\r\n", ch);
  else if (diff <= 2)
    send_to_char("You would need a lot of luck!\r\n", ch);
  else if (diff <= 3)
    send_to_char("You would need a lot of luck and great equipment!\r\n", ch);
  else if (diff <= 5)
    send_to_char("Do you feel lucky, punk?\r\n", ch);
  else if (diff <= 10)
    send_to_char("Are you mad!?\r\n", ch);
  else if (diff <= 100)
    send_to_char("You ARE mad!\r\n", ch);
}

ACMD(do_diagnose)
{
  struct char_data *vict;

  one_argument(argument, buf);

  if (*buf)
  {
    if (!(vict = generic_find_char(ch, buf, FIND_CHAR_ROOM)))
      send_to_char(NOPERSON, ch);
    else
      diag_char_to_char(vict, ch);
  } else {
    if (FIGHTING(ch))
      diag_char_to_char(FIGHTING(ch), ch);
    else
      send_to_char("Diagnose who?\r\n", ch);
  }
}


const char *ctypes[] = { "off", "sparse", "normal", "complete", "\n" };
ACMD(do_color)
{
  int tp;
  if (IS_NPC(ch))
    return;
  one_argument(argument, arg);
  if (!*arg)
  {
    sprintf(buf, "Your current colour level is %s.\r\n", ctypes[COLOR_LEV(ch)]);
    send_to_char(buf, ch);
    return;
  }
  if (((tp = search_block(arg, ctypes, FALSE)) == -1))
  {
    send_to_char("Usage: colour { Off | Sparse | Normal | Complete }\r\n", ch);
    return;
  }
  REMOVE_BIT(PRF_FLAGS(ch), PRF_COLOR_1 | PRF_COLOR_2);
  SET_BIT(PRF_FLAGS(ch), (PRF_COLOR_1 * (tp & 1)) | 
                         (PRF_COLOR_2 * (tp & 2) >> 1));
  sprintf(buf, "Your %scolour%s is now %s.\r\n", CCRED(ch, C_SPR),
	  CCNRM(ch, C_OFF), ctypes[tp]);
  send_to_char(buf, ch);
}

/* DM - modified for new toggles and to toggle others and from file */
ACMD(do_toggle)
{
  struct char_data *victim;
  struct char_file_u tmp_store;
 
  if (IS_NPC(ch))
    return;
  half_chop(argument, buf1, buf2);
  if ((!*buf1) || LR_FAIL(ch, LVL_IMMORT))
  {
    toggle_display(ch,ch);
    return;
  }
  if (is_abbrev(buf1, "file"))
  {
    if ((!*buf2) || LR_FAIL(ch, LVL_IS_GOD))
      send_to_char("Toggle's for who?\r\n", ch);
    else
    {
      CREATE(victim, struct char_data, 1);
      clear_char(victim);
      if (load_char(buf2, &tmp_store) > -1)
      {
        store_to_char(&tmp_store, victim);
	if (GET_LEVEL(victim) > GET_LEVEL(ch))
	  send_to_char("Sorry, you can't do that.\r\n", ch);
	else
          toggle_display(ch, victim);
        free_char(victim);
      } else {
        send_to_char("There is no such player.\r\n", ch);
        free(victim);
      }
    }
  } else {
    if ((victim = generic_find_char(ch, buf1, FIND_CHAR_WORLD)))
      toggle_display(ch,victim);
    else
      send_to_char("Toggle's for who?\r\n", ch);
  }
}
 
/* DM - Toggle display on vict */
void toggle_display(struct char_data *ch, struct char_data *vict)
{ 
  char prompt_string[25 + 1 + 2];

  if (IS_NPC(ch) || IS_NPC(vict))
    return;
  if (GET_WIMP_LEV(ch) == 0)
    strcpy(buf2, "OFF");
  else
    sprintf(buf2, "%-3d", GET_WIMP_LEV(ch));
  prompt_string[0] = '\0';
  if (GET_PROMPT(vict))
  {
    strcat(prompt_string, "'");
    strcat(prompt_string, GET_PROMPT(vict));
    strcat(prompt_string, "&n'");
  } else {
    if (PRF_FLAGGED(vict, PRF_DISPHP))
      strcat(prompt_string, "H");
    if (PRF_FLAGGED(vict, PRF_DISPMANA))
      strcat(prompt_string, "M");
    if (PRF_FLAGGED(vict, PRF_DISPMOVE))
      strcat(prompt_string, "V");
    if (PRF_FLAGGED(vict, PRF_DISPEXP))
      strcat(prompt_string, "X");
    if (PRF_FLAGGED(vict, PRF_DISPALIGN))
      strcat(prompt_string, "L");
  }
  sprintf(buf, " Character Name: %s\r\n\r\n"
	       "Hit Pnt Display: %-3s    " "     Brief Mode: %-3s    "
	       " Summon Protect: %-3s\r\n"
	       "   Move Display: %-3s    " "   Compact Mode: %-3s    "
	       "       On Quest: %-3s\r\n"
	       "   Mana Display: %-3s    " " Auto Show Exit: %-3s    "
	       " Gossip Channel: %-3s\r\n"
	       "    Exp Display: %-3s    " "   Repeat Comm.: %-3s    "
	       "Auction Channel: %-3s\r\n"
	       "  Align Display: %-3s    " "           Deaf: %-3s    "
	       "  Grats Channel: %-3s\r\n"
	       "       Autoloot: %-3s    " "         NoTell: %-3s    "
	       " Newbie Channel: %-3s\r\n"
	       "       Autogold: %-3s    " "     Marked AFK: %-3s    "
	       "   Clan Channel: %-3s\r\n"
	       "      Autosplit: %-3s    " " Clan Available: %-3s    "
	       "   Info Channel: %-3s\r\n"
	       "        Autoeat: %-3s    " "    Color Level: %-10s"
	       "Hint Channel: %-3s\r\n"
	       "    Page Length: %-3d    " "     Page Width: %-3d   "
	       "Corpse Retrieval: %-3s\r\n"
	       "     Wimp Level: %-4s   "  "  Prompt String: %s\r\n",
          GET_NAME(vict), ONOFF(PRF_FLAGGED(vict, PRF_DISPHP)),
          ONOFF(PRF_FLAGGED(vict, PRF_BRIEF)),
          ONOFF(!PRF_FLAGGED(vict, PRF_SUMMONABLE)),
 
          ONOFF(PRF_FLAGGED(vict, PRF_DISPMOVE)),
          ONOFF(PRF_FLAGGED(vict, PRF_COMPACT)),
          YESNO(PRF_FLAGGED(vict, PRF_QUEST)), 

          ONOFF(PRF_FLAGGED(vict, PRF_DISPMANA)),
          ONOFF(PRF_FLAGGED(vict, PRF_AUTOEXIT)),
          ONOFF(!PRF_FLAGGED(vict, PRF_NOGOSS)),
 
          ONOFF(PRF_FLAGGED(vict, PRF_DISPEXP)),
          YESNO(!PRF_FLAGGED(vict, PRF_NOREPEAT)),
          ONOFF(!PRF_FLAGGED(vict, PRF_NOAUCT)),
 
          ONOFF(PRF_FLAGGED(vict, PRF_DISPALIGN)),
          YESNO(PRF_FLAGGED(vict, PRF_DEAF)),
          ONOFF(!PRF_FLAGGED(vict, PRF_NOGRATZ)),
 
          ONOFF(EXT_FLAGGED(vict, EXT_AUTOLOOT)),
          ONOFF(PRF_FLAGGED(vict, PRF_NOTELL)),
          ONOFF(!EXT_FLAGGED(vict, EXT_NONEWBIE)),
 
          ONOFF(EXT_FLAGGED(vict, EXT_AUTOGOLD)),
          YESNO(PRF_FLAGGED(vict, PRF_AFK)),
          ONOFF(!EXT_FLAGGED(vict, EXT_NOCT)),
 
          ONOFF(EXT_FLAGGED(vict, EXT_AUTOSPLIT)),
          YESNO(EXT_FLAGGED(vict, EXT_PKILL)),
          ONOFF(!PRF_FLAGGED(vict, PRF_NOINFO)),

	  ONOFF(EXT_FLAGGED(vict, EXT_AUTOEAT)),
          ctypes[COLOR_LEV(vict)],
          ONOFF(!EXT_FLAGGED(vict, EXT_NOHINTS)),
 
          GET_PAGE_LENGTH(vict), 
	  GET_PAGE_WIDTH(vict),
	  ONOFF(EXT_FLAGGED(vict, EXT_AUTOCORPSE)),

	  buf2,
          prompt_string);
 
  send_to_char(buf, ch);
  if (GET_MAX_LVL(vict) >= LVL_ETRNL1)
  {
    sprintf(buf, "\r\n     Room Flags: %-3s    " " Wiznet Channel: %-3s\r\n"
		 "      No Hassle: %-3s    " " Immnet Channel: %-3s\r\n"
		 "     Holy Light: %-3s\r\n",
          ONOFF(PRF_FLAGGED(vict, PRF_ROOMFLAGS)),
          ONOFF(!PRF_FLAGGED(vict, PRF_NOWIZ)),
          ONOFF(PRF_FLAGGED(vict, PRF_NOHASSLE)),
          ONOFF(!PRF_FLAGGED(vict, PRF_NOIMMNET)),
          ONOFF(PRF_FLAGGED(vict, PRF_HOLYLIGHT)));
    send_to_char(buf,ch);
  } 
}

struct sort_struct {
  int sort_pos;
  byte is_social;
} *cmd_sort_info = NULL;
int num_of_cmds;

void sort_commands(void)
{
  int a, b, tmp;
  num_of_cmds = 0;
  /*
   * first, count commands (num_of_commands is actually one greater than the
   * number of commands; it inclues the '\n'.
   */
  while (*cmd_info[num_of_cmds].command != '\n')
    num_of_cmds++;
  /* create data array */
  CREATE(cmd_sort_info, struct sort_struct, num_of_cmds);
  /* initialize it */
  for (a = 1; a < num_of_cmds; a++)
  {
    cmd_sort_info[a].sort_pos = a;
    cmd_sort_info[a].is_social = (cmd_info[a].command_pointer == do_action);
  }
  /* the infernal special case */
  cmd_sort_info[find_command("insult")].is_social = TRUE;
  /* Sort.  'a' starts at 1, not 0, to remove 'RESERVED' */
  for (a = 1; a < num_of_cmds - 1; a++)
    for (b = a + 1; b < num_of_cmds; b++)
      if (strcmp(cmd_info[cmd_sort_info[a].sort_pos].command,
		 cmd_info[cmd_sort_info[b].sort_pos].command) > 0)
      {
	tmp = cmd_sort_info[a].sort_pos;
	cmd_sort_info[a].sort_pos = cmd_sort_info[b].sort_pos;
	cmd_sort_info[b].sort_pos = tmp;
      }
}

#define CPASS_NONE      -1
#define CPASS_ALL       1
#define CPASS_SUBCMD    2
#define CPASS_VICT      3

/*
 * Searches in order of the above defines for a matching argument used parsing
 * the "commands" command.
 *
 * Returns CPASS_NONE if no rule is matched for the given argument, otherwise
 * set the various variables as defined below and returns the corresponding 
 * matched rule define.
 *
 * CMD_SUBCMD:  sets the value of cmd_num
 * CMD_VICT:    sets *vict, applies level checks and sets *vict to ch if level 
 *              checks do not pass 
 */
int parse_command_arg(struct char_data *ch, struct char_data **vict, 
                char *arg, int *cmd_num)
{
  int cmd = -1;
  struct char_data *find;

  if (!*arg)
    return CPASS_NONE;
  // "all"
  if (!str_cmp(arg, "all"))
    return CPASS_ALL;
  // "subcmd"
  if ((cmd = search_block_case_insens(arg, cmd_types, FALSE)) != -1)
  {
    *cmd_num = cmd; 
    return CPASS_SUBCMD;
  }
  if (LR_FAIL(ch, LVL_IS_GOD))
    return CPASS_NONE;
  // "playername"
  if ((find = generic_find_char(ch, arg, FIND_CHAR_WORLD)))
  {
    *vict = find;
    // apply restrictions
    if (IS_NPC(find) && GET_LEVEL(ch) < LVL_GOD)
      *vict = ch; 
    if (!IS_NPC(find) && GET_LEVEL(ch) < GET_LEVEL(find))
      *vict = ch;
    return CPASS_VICT;
  }
  return CPASS_NONE;
}

void display_commands(struct char_data *ch, struct char_data *vict, 
                int subcmd, int cmdtype)
{
  int cmd_num, no, i;
  bool wizhelp = FALSE, socials = FALSE;
  char command_type[MAX_INPUT_LENGTH];

  if (cmdtype > -1)
    sprintf(command_type, "&1%s ", cmd_types[cmdtype]);
  if (subcmd == SCMD_WIZHELP)
    wizhelp = TRUE;
  if (subcmd == SCMD_SOCIALS)
    socials = TRUE;
  sprintf(buf, "The following %s&4%s%s&n are available to &7%s&n:\r\n",
          (cmdtype > -1) ? command_type : "", wizhelp ? "privileged " : "",
	  socials ? "socials" : "commands",
	  vict == ch ? "you" : GET_NAME(vict));
  // cmd_num starts at 1, not 0, to remove 'RESERVED' 
  for (no = 1, cmd_num = 1; cmd_num < num_of_cmds; cmd_num++)
  {
    i = cmd_sort_info[cmd_num].sort_pos;
    if (cmd_info[i].minimum_level >= 0 &&
        !LR_FAIL_MAX(vict, cmd_info[i].minimum_level) &&
        ((cmd_info[i].minimum_level >= LVL_ETRNL1) == wizhelp 
         || cmdtype == CMD_WIZ) &&
        ((wizhelp || cmdtype == CMD_WIZ) || 
         (socials == cmd_sort_info[i].is_social) || cmdtype == CMD_SOCIAL))
    {
      if (cmdtype < 0 || cmd_info[i].type == cmdtype)
      {
        sprintf(buf + strlen(buf), "%-11s", cmd_info[i].command);
        if (!(no % 7))
          strcat(buf, "\r\n");
        no++;
      }
    }
  }

  strcat(buf, "\r\n");
  page_string(ch->desc, buf, TRUE);
}

ACMD(do_commands)
{
  int cmd_num = -1;
  struct char_data *vict = ch;
  char rest[MAX_INPUT_LENGTH];
  int cmd_pass = CPASS_NONE;
  char usage[MAX_STRING_LENGTH];

  arg[0] = '\0';
  rest[0] = '\0';

  if (subcmd == SCMD_COMMANDS)
  {
    sprintf(usage, "&1Usage: &4%s&n [ all | &1cmd-type&n ] [ player ]\r\n\r\n", cmd_info[cmd].command);
    sprintf(usage + strlen(usage), "&0Command Types:&n\r\n");
    // start at 1 ignoring None ... (still leave it there, just dont display it)
    for (int i = 1; i < NUM_CMD_TYPES; i++)
      sprintf(usage + strlen(usage), "&1%-15s&n %s\r\n", cmd_types[i], cmd_bhelp[i]);
  } else if (subcmd == SCMD_WIZHELP)
    sprintf(usage, "&1Usage: &4%s&n [ player ]\r\n", cmd_info[cmd].command);
  else
    sprintf(usage, "&1Usage: &4%s&n\r\n", cmd_info[cmd].command);
  half_chop(argument, arg, rest);
  if (subcmd != SCMD_SOCIALS && *arg)
  {
    // arg 1: [ all | cmd_type | player_name ]
    cmd_pass = parse_command_arg(ch, &vict, arg, &cmd_num);
    if ((subcmd == SCMD_COMMANDS) && 
	(cmd_pass == CPASS_NONE || cmd_pass == CPASS_VICT))
    {
      send_to_char(usage, ch);
      return;
    }
    // commands "all" | "subcmd"
    if ((subcmd == SCMD_COMMANDS) && 
	(cmd_pass == CPASS_ALL || cmd_pass == CPASS_SUBCMD))
    {
      // search arg2 for commands { all | sbcmd } "player_name"
      half_chop(rest, arg, rest);
      if (*arg) // only need to set vict ...
        parse_command_arg(ch, &vict, arg, &cmd_num);
    }
  } else if (!*arg && subcmd == SCMD_COMMANDS) {
    send_to_char(usage, ch);      
    return;
  }
  display_commands(ch, vict, subcmd, cmd_num); 
}

ACMD(do_classes)
{
  int index;
  sprintf(buf,"Classes:\r\n");
  for (index=0; index < NUM_CLASSES; index++)
  {
    sprintf(buf2,"&B%s\r\n",CLASS_NAME(index));
    strcat(buf,buf2);
  }
  page_string(ch->desc, buf, TRUE);
}

// DM - set your sexy colours
ACMD(do_setcolour)
{
  int colour_code, colour_num, no_args = TRUE, i;
  char *usage = "&1Usage:&n &4colourset&n [-<0..9> { <colourcode> | Default }]\r\n";
  int colour_codes[10];
  char mode;
  if (IS_NPC(ch))
    return;
  skip_spaces(&argument);
  strcpy(buf, argument);
  for (i=0;i<10;i++)
    colour_codes[i] = -1;
  while (*buf)
  {
    half_chop_case_sens(buf, arg, buf1);
    if (*arg == '-')
    {
      mode = *(arg + 1);       /* just in case; we destroy arg in the switch */
      if (isnum(mode))
      {
        colour_num = mode - '0';
	half_chop_case_sens(buf1, arg, buf);
        if (!strn_cmp(arg,"default",3))
	{
          // The magic default number
          colour_codes[colour_num] = 69; 
          no_args = FALSE;
        } else if ((colour_code = is_colour(NULL,*arg,TRUE)) >= 0) {
          colour_codes[colour_num] = colour_code;
          no_args = FALSE;
        } else {
          send_to_char("Invalid colour code.\r\n",ch);
          send_to_char(usage,ch);
          return;
        }
      } else {			/* endif isnum */
        send_to_char(usage, ch);
        return;
      }
    } else {			/* endif arg == '-' */
      send_to_char(usage, ch);
      return;
    }
  }
  if (no_args)
  {
    sprintf(buf,"&1Personal colour settings:&n\r\n"
		"&&0. &0%s&n\r\n" "&&1. &1%s&n\r\n" "&&2. &2%s&n\r\n"
		"&&3. &3%s&n\r\n" "&&4. &4%s&n\r\n" "&&5. &5%s&n\r\n"
		"&&6. &6%s&n\r\n" "&&7. &7%s&n\r\n" "&&8. &8%s&n\r\n"
		"&&9. &9%s&n\r\n",
	    colour_headings[0], colour_headings[1], colour_headings[2],
	    colour_headings[3], colour_headings[4], colour_headings[5],
	    colour_headings[6], colour_headings[7], colour_headings[8],
	    colour_headings[9]);
    send_to_char(buf,ch);
  } else {
    for (i=0;i<10;i++)
    {
      // The magic default number
      if (colour_codes[i] == 69)
        set_default_colour(ch,i);
      else if (colour_codes[i] >= 0)
        set_colour(ch,i,colour_codes[i]);
    }
    send_to_char("Colour changed.\r\n",ch);
  }
}

extern int vote_level;
int check_for_event(int event, zone_rnum zone) 
{
  struct event_data *ev;
  for (ev = events.list; ev; ev = ev->next) 
    if (zone != -1) 
    {
      if ((ev->type == event) && (ev->room->zone == zone))
	return 1;
    } else if (ev->type == event)
      return 1;
  return 0;
}

void handle_burglary(struct event_data *ev) 
{
  // check if burglar has evacuated rooms, and act accordingly

  // Also, check if an excessive number of rooms have been burgled,
  // and initiate a curfew in a zone that's been burgled (and is a town)
}

// Artus> Happy Hour.
void handle_happy(struct event_data *ev)
{
  void destroy_event_happy(struct char_data *ch, struct event_data *ev);
  ev->info1 -= 10;
  if (ev->info1 > 0)
    return;
  destroy_event_happy(NULL, ev);
}

// Artus> Have changed this a bit... Should be better now.
void handle_gold_rush(struct event_data *ev)
{
  void send_to_not_zone_world(const char *msg, zone_rnum zone);
  void destroy_event_goldrush(struct char_data *ch, struct event_data *ev);
  extern zone_rnum top_of_zone_table;
  struct obj_data *gold;
  int i, j, k;
  room_rnum curroom;
  obj_rnum currobj;

  if (ev->type != EVENT_GOLD_RUSH)
    return;
  ev->info1 += 10;
  if (!ev->room)
  {
    mudlog("SYSERR: Gold rush has no room attached!", BRF, LVL_IMPL, TRUE);
    return;
  }
  if (((ev->info1 >= 300) || (ev->info2 >= 30)) && (number(1, 30) == 1))
  {
    destroy_event_goldrush(NULL, ev);
    return;
  }
  if ((ev->room->zone < 0) || (ev->room->zone > top_of_zone_table))
  {
    sprintf(buf, "SYSERR: Invalid zone (%d) attached to gold rush.", 
	    ev->room->zone);
    mudlog(buf, BRF, LVL_IMPL, TRUE);
    return;
  }
  if ((currobj = real_object(GOLD_OBJ_VNUM)) < 0)
  {
    sprintf(buf, "SYSERR: Could not load gold object (%d).", GOLD_OBJ_VNUM);
    mudlog(buf, BRF, LVL_IMPL, TRUE);
    return;
  }
  // Anywhere from 1 to 5 gold objs *may* be loaded.
  j = number(1, 5);
  // Since it's not ended, spread a bit more gold around the zone
  for (i = 0; i <= j; i++)
  {
    k = number(zone_table[ev->room->zone].number * 100,
	       zone_table[ev->room->zone].top);
    curroom = real_room(k);
    if (curroom == NOWHERE)
      continue; 
    // Artus> Sector Check...
    if ((BASE_SECT(SECT(curroom)) < SECT_FIELD) || 
	(BASE_SECT(SECT(curroom)) > SECT_MOUNTAIN))
      continue;
    // Load the obj, and give it a random value.
    gold = read_object(currobj, REAL);
    GET_OBJ_VAL(gold, 1) = number(1000, 30000);
    // Artus> Change value based on zone level.
    if (zone_table[ev->room->zone].zflag > 3)
    {
      int lvbit = zone_table[ev->room->zone].zflag;
      REMOVE_BIT(lvbit, ZN_NO_STEAL | ZN_NO_TELE | ZN_NO_GOLDRUSH | 
		 (1 << 27) | (1 << 28) | (1 << 29) | (1 << 30) | (1 << 31));
      if (lvbit > ZN_LR_40) // Double for Level >= 40
	GET_OBJ_VAL(gold, 1) <<= 1;
      if (lvbit > ZN_LR_70) // Quadruple for Lvl >= 70
	GET_OBJ_VAL(gold, 1) <<= 1;
    }
    // Artus> Copy the value to the cost.
    GET_OBJ_COST(gold) = GET_OBJ_VAL(gold, 1);
    ev->info2++;
    obj_to_room(gold, curroom);
  }
}

// Artus> Called by handle_fire.
void incinerate(room_rnum room)
{
  struct obj_data *burning, *next_burn;
  struct char_data *cburning, *next_cburn;
  send_to_room("The room is on fire!\r\n", room);
  if (world[room].contents)
    for (burning = world[room].contents; burning; burning = next_burn)
    {
      next_burn = burning->next_content;
      extract_obj(burning);
    }
  if (world[room].people)
    for (cburning = world[room].people; cburning; cburning = next_cburn)
    {
      next_cburn = cburning->next_in_room;
      if (LR_FAIL(cburning, LVL_GOD))
      {
	if (IS_GHOST(cburning))
	  send_to_char("The flames pass right through you!\r\n", cburning);
	else
	{
	  send_to_char("You burn to a crisp!\r\n", cburning);
	  die(cburning, NULL, "FIRE!");
	}
      } else {
	send_to_char("Fortunately, you are immortal!\r\n", cburning);
	char_from_room(cburning);
	char_to_room(cburning, real_room(1200));
      }
    }
  SET_BIT(RMSM_FLAGS(room), RMSM_BURNED);
}

// Artus> I told you I'd get around to it, Sandii :o)
void handle_fire(struct event_data *ev)
{
  room_rnum burnrnum;
  int burncount = 0, i;
  void destroy_event_fire(struct char_data *ch, struct event_data *ev);
  
  burnrnum = real_room(ev->room->number);
  if (!RMSM_FLAGGED(burnrnum, RMSM_BURNED))
  {
    incinerate(burnrnum);
    return;
  }
  for (burnrnum = 0; burnrnum <= top_of_world; burnrnum++)
  {
    if ((world[burnrnum].zone != ev->room->zone) ||
        RMSM_FLAGGED(burnrnum, RMSM_BURNED) ||
	world[burnrnum].number == 1200)
      continue;
    for (i = 0; i < NUM_OF_DIRS; i++)
      if ((W_EXIT(burnrnum, i)) && 
	  (W_EXIT(burnrnum,i)->to_room != NOWHERE) &&
	  (SECT(W_EXIT(burnrnum,i)->to_room) < SECT_WATER_SWIM) &&
	  (RMSM_FLAGGED(W_EXIT(burnrnum,i)->to_room, RMSM_BURNED)))
	{
	  burncount++;
	  incinerate(burnrnum);
	  break;
	}
    if (burncount > 3)
      break;
  }
  if (burncount < 1)
    destroy_event_fire(NULL, ev);
}

// Artus> Mortal version of events list.
ACMD(do_events)
{
  struct event_data *ev;
  int counter = 0;

  if (IS_NPC(ch))
    return;
  sprintf(buf2, "The following events are running:\r\n\r\n");
  for (ev = events.list; ev; ev = ev->next)
  {
    *buf = '\0';
    if (counter == 1)
      *buf2 = '\0';
    switch (ev->type)
    {
      case EVENT_QUEST:
	sprintf(buf, "%sA '%s' quest is running in %s!\r\n", buf2,
		quest_names[ev->info1], zone_table[ev->room->zone].name);
	counter++;
	break;
      case EVENT_GOLD_RUSH:
	sprintf(buf, "%s%d chunks of gold have been sighted in %s!\r\n", buf2,
	        ev->info2, zone_table[ev->room->zone].name);
	counter++;
	break;
      case EVENT_HAPPY_HR:
	if (ev->info1 <= 60) 
	  sprintf(buf, "%sHappy hour will be over in approximately %d seconds.\r\n", buf2, ev->info1);
	else
	  sprintf(buf, "%sHappy hour will be over in approximately %d minutes and %d seconds.\r\n", buf2, (int)(ev->info1 / 60), ev->info1 % 60);
	counter++;
	break;
      case EVENT_FIRE:
	sprintf(buf, "%s%s is on fire!\r\n", buf2, 
	        zone_table[ev->room->zone].name);
	counter++;
	break;
/*    case EVENT_ELECTION:
      case EVENT_CURFEW:
      case EVENT_BOUNTY_HUNT:
      case EVENT_BURGLARY:
      case EVENT_OVER: */
      default: break;
    }
    if (*buf)
      send_to_char(buf, ch);
  }

  if (counter < 1) 
  {
    send_to_char("There are currently no events running.\r\n", ch);
    return;
  }

  sprintf(buf, "\r\n%d event%s listed.\r\n", counter, (counter==1) ? "s" : "");
  send_to_char(buf, ch);
}

/* Artus - Hear Noises => Listen 
 * 
 * Would like to improve it at some stage, to factor in weights or perhaps
 * levels of mobs to give players more idea..                              */
ACMD(do_listen)
{
  struct char_data *i;
  struct room_data *target;
  int direction;
  int count = 0;
  room_rnum targnum;
  
  if (IS_NPC(ch) || ch->in_room == NOWHERE)
    return;
  
  one_argument(argument, arg);

  if (!(*arg)) {
    send_to_char("Listen in which direction?\r\n", ch);
    return;
  }
  if ((direction = search_block(arg, dirs, FALSE)) < 0) {
    send_to_char("What direction is that??\r\n", ch);
    return;
  }
  if (!world[ch->in_room].dir_option[direction])
  {
    sprintf(buf, "You stick your head against the %s and all you get is a sore ear.\r\n", ((direction < UP) ? "wall" : (direction == UP) ? "ceiling" : "floor"));
    send_to_char(buf, ch);
    return;
  }
  if ((targnum = world[ch->in_room].dir_option[direction]->to_room) == NOWHERE) 
  {
    send_to_char("There doesn't seem to be an exit there.\r\n", ch);
    return;
  }
  target = &world[targnum];
  if (!(target))
  {
    send_to_char("You can't seem to listen in that direction.\r\n", ch);
    return;
  }
  if (basic_skill_test(ch, SKILL_LISTEN, 1) == 0) 
    return;
  if (!target->people)
  {
    send_to_char("That room sounds void of life.\r\n", ch);
    return;
  }
  
  for (i = target->people; i; i = i->next_in_room)
    count++;
  if (count == 1)
    send_to_char("You can make out one lonesome creature.\r\n", ch);
  else if (count < 5)
  {
    sprintf(buf, "You can make out %d creatures", count);
    switch (direction)
    {
      case NORTH:
      case EAST:
      case SOUTH:
      case WEST:
	sprintf(buf, "%s to the %s.\r\n", buf, dirs[direction]);
	break;
      case UP:
	strcat(buf, " up above.\r\n");
	break;
      case DOWN:
	strcat(buf, " down below.\r\n");
	break;
      default:
	strcat(buf, " in an unknown direction.\r\n");
        break;
    }
    send_to_char(buf, ch);
  } else
    send_to_char("There is a lot of activity happening there!\r\n", ch);
  return;
}

void handle_curfew(struct event_data *ev)
{
// TODO - Artus, I guess Tali's never going to get around to it :p~
}

bool is_player_bountied(struct char_data *ch)
{
  struct event_data *ev;
  long lTargetId = GET_IDNUM(ch);

  for (ev = events.list; ev; ev = ev->next)
    if ((ev->type == EVENT_BOUNTY_HUNT) && (ev->chID == lTargetId))
      return TRUE;
  return FALSE;
}

/* Starts a bounty hunt event */
void init_bounty_hunt()
{
  struct descriptor_data *d;
  struct event_data *ev;
  int found = FALSE;

  // Go through every player
  for (d = descriptor_list; d; d = d->next)
  {
    if (STATE(d) != CON_PLAYING || IS_NPC(d->character))
      continue;
    if(!LR_FAIL(d->character, LVL_IS_GOD))
      continue;

    // See if they're criminals
    if (GET_SOCIAL_STATUS(d->character) == SOCIAL_CRIMINAL)
    {
      // See if they're already bountied up
      for (ev = events.list; ev; ev = ev->next)
	if ((ev->type == EVENT_BOUNTY_HUNT) &&
	    (ev->chID == GET_IDNUM(d->character)))
	{
	  found = TRUE;
	  break;
	}
      // If they're not already bountied, chance of doing so
      if (!found)
      {
	// 10% Random chance of the law putting up a bounty
	if (number(1, 10) != 1)
	  continue;
	sprintf(buf, "%s bountied by the law.",GET_NAME(d->character));
	mudlog(buf, BRF, LVL_GOD, FALSE);
	CREATE(ev, struct event_data, 1);
	ev->chID = GET_IDNUM(d->character);
	ev->info1 = GET_LEVEL(d->character) * 20000 * number(1, 3);
	ev->info3 = THE_LAW; 
	ev->type = EVENT_BOUNTY_HUNT;
	ev->room = &world[real_room(BOUNTY_RETURN_ROOM)];
	add_mud_event(ev);
      }
      // Reset search sentinel
      found = FALSE;
    }	
  }
}

#if 0 
// Artus> I think i'll re-write this, too :o)
void init_gold_rush() 
{
  struct event_data *ev;
  int counter = 0, sector = 0;
  room_rnum rnum_room;
  CREATE(ev, struct event_data, 1);
  ev->chID = -1;
  ev->type = -1;
  ev->info1 = 0;
  ev->info2 = 0;
  // Get a room, checking it for a nice sector type, and a non-gold rush already zone
  for (int i = 0; i < 10; i++)
  {
    rnum_room = number(1, top_of_world);
    ev->room = &world[rnum_room];
    // Ignore !GOLDRUSH zones  (Moved from before the counter check)
    if (IS_SET(zone_table[ev->room->zone].zflag, ZN_NO_GOLDRUSH))
      continue;
    // basic_mud_log("init_gold_rush: attempting to use room rnum (%d) vnum (%d)", rnum_room, ev->room->number);
    // if room_rnum happens to be NOWHERE, set to one of the sector
    // types define at the bottom of the do while loop so we try
    // again and dont go outside the world[] array limits
    if (rnum_room == NOWHERE)
      continue;
    sector = BASE_SECT(SECT(rnum_room));
    if ((sector < SECT_FIELD) || (sector > SECT_MOUNTAIN))
      continue;
    if (check_for_event(EVENT_GOLD_RUSH, ev->room->zone))
      continue;
    ev->type = EVENT_GOLD_RUSH;
    break;
  }
  if(ev->type != EVENT_GOLD_RUSH)
  {
    free(ev);	
//    basic_mud_log("GoldRush: Unable to create event, counter limit reached.");
    return;
  }	
  add_mud_event(ev);
  // Notify the zone
  sprintf(buf, "&YA GOLD RUSH is on at %s!&n\r\n", zone_table[ev->room->zone].name);
  send_to_zone(buf, ev->room->zone);
  sprintf(buf, "&WYou hear rumours of a gold rush at %s!&n\r\n",zone_table[ev->room->zone].name);
  send_to_not_zone_world(buf, ev->room->zone);
}
#endif

// Artus> My way..
void init_gold_rush()
{
  struct event_data *ev = NULL;
  int sector = 0;
  room_rnum rnum_room;
  // Get a room, checking it for a nice sector type, and a non-gold rush already zone
  for (int i = 0; i < 10; i++)
  {
    rnum_room = number(1, top_of_world);
    if (IS_SET(zone_table[world[rnum_room].zone].zflag, ZN_NO_GOLDRUSH))
      continue;
    sector = BASE_SECT(SECT(rnum_room));
    if ((sector < SECT_FIELD) || (sector > SECT_MOUNTAIN))
      continue;
    if (check_for_event(EVENT_GOLD_RUSH, world[rnum_room].zone))
      continue;
    CREATE(ev, struct event_data, 1);
    ev->chID = 0;
    ev->type = EVENT_GOLD_RUSH;
    ev->room = &world[rnum_room];
    ev->info1 = 0;
    ev->info2 = 0;
    ev->info3 = 0;
    strcpy(ev->desc, "Random gold rush.\r\n");
    break;
  }
  if (!ev)
    return;
  add_mud_event(ev);
  // Notify the zone
  sprintf(buf, "&YA GOLD RUSH is on at %s!&n\r\n", zone_table[ev->room->zone].name);
  send_to_zone(buf, ev->room->zone);
  sprintf(buf, "&WYou hear rumours of a gold rush at %s!&n\r\n",zone_table[ev->room->zone].name);
  send_to_not_zone_world(buf, ev->room->zone);
}

// TODO: Finish with quest system
void init_event()
{
  // About a 0.1% chance of an event
  switch(number(1, 1000))
  {
    case 1: init_bounty_hunt(); break;
    case 2: init_gold_rush(); break;
    default: break;
  }
}

bool burglar_left_scene(Burglary *burglary)
{
  struct char_data *burglar = get_player_by_id(burglary->chID); 
  if (burglar == NULL)
    return TRUE; 
  int nBurglarRoom = IN_ROOM(burglar);
  int nCount = burglary->CountBurgledRooms();
  
  if (nCount == 0)
    return TRUE;	// Could have cleared burglary out
  for (int i = 0; i < nCount; i++)
    if (nBurglarRoom == burglary->burgledRooms[i].rNum)
      return FALSE;
  return TRUE;	// Not found in burgling rooms
}

/* Strength = percentage, ie 1.3 = 30%, 0.9 = -10% */
void apply_burglar_stats_to_mob(struct char_data *mob, long lID, float fStrength)
{
  struct char_data *ch = get_player_by_id(lID);
  if (ch == NULL)
    return;
  if (fStrength <= 0.0)
    return;
  int nLevel = int((number(GET_LEVEL(ch) -3, GET_LEVEL(ch) + 3) +
	           int(GET_MODIFIER(ch))) * fStrength);
  if (nLevel > 250)
    nLevel = 250;
  if (nLevel <= 0)
    nLevel = 1 + number(0,2);
  GET_LEVEL(mob) = nLevel;
  GET_AC(mob) = int(GET_AC(ch) * fStrength);
  GET_MAX_HIT(mob) = int(number(int(GET_MAX_HIT(ch) * 0.9),
	                        int(GET_MAX_HIT(ch) * 1.1)) * fStrength);
  GET_HITROLL(mob) = int(GET_HITROLL(ch) * fStrength);
  GET_DAMROLL(mob) = int((GET_DAMROLL(ch) + GET_LEVEL(ch)) * fStrength);
  mob->mob_specials.damnodice = int((5 + int(GET_MODIFIER(ch))) * fStrength);
  int nDamSizeDice = int(GET_LEVEL(ch) * fStrength);
  mob->mob_specials.damsizedice = nDamSizeDice > 120 ? 120 : nDamSizeDice;
  GET_GOLD(mob) = int((100 * GET_LEVEL(ch) * (int(GET_MODIFIER(ch))+ 1)) *
                      fStrength);
  GET_EXP(mob) = int((number(int(level_exp(ch, GET_LEVEL(ch)) * 0.02), 
		             int(level_exp(ch, GET_LEVEL(ch)) * 0.05))) *
                     fStrength);
  GET_HIT(mob) = GET_MAX_HIT(mob);
}

// The random burglar's generic mob vnum
#define RANDOM_BURGLAR		30900

void create_burgle_encounter(struct char_data *ch)
{
  struct char_data *burglar = read_mobile(RANDOM_BURGLAR, VIRTUAL);
  
  if (burglar == NULL)
  {
    mudlog("Random Burgle Encounter - cannot read mobile.", NRM, LVL_GOD, TRUE);
    return;
  }
  // Beef the burglar up
  apply_burglar_stats_to_mob(burglar, ch->in_room, 1.0);
  GET_HIT(burglar) = GET_MAX_HIT(burglar);
  char_to_room(burglar, ch->in_room);
  hit(burglar, ch, TYPE_UNDEFINED);
}

void handle_burglaries()
{
  int nDiscoveryChance;
  Burglary *current;
  
  if (burglaries == NULL)
    return;	// Nada
  // If it's daytime, chance of discovery is greater
  if (time_info.hours >= 0 && time_info.hours < 6)
    nDiscoveryChance = 2;
  else
    nDiscoveryChance = 5;
  current = burglaries;
  while (current)
  {
    struct char_data *burglar = get_player_by_id(current->chID);
    // Firstly, see if player has exited burglary rooms, and end it if so
    if (burglar_left_scene(current))
    {
      current->Clear();
      Burglary *tmp = current->next;	// Back up the next burglary
      remove_burglary(current);	// Remove this one, which clears 'next'
      current = tmp;			// Restore next (if any)
      continue;	// Done with this burglary, its history
    }
    // They're still around, see if the cops are now onto them
    if (number(1, 100 + GET_SKILL(burglar, SKILL_BURGLE)) <= nDiscoveryChance && !is_player_bountied(burglar))
    {
      // Set up a bounty on them
      struct event_data *ev;
      CREATE(ev, struct event_data, 1);
      // Set it up
      ev->chID = current->chID; 			// Target
      ev->info1 = GET_LEVEL(burglar) * 5000 * (int(GET_MODIFIER(burglar)) +1);// Bounty 
      ev->info3 = THE_LAW; 				// Bounty initiator ID	
      ev->type = EVENT_BOUNTY_HUNT;			// Ahuh
      ev->room = &world[real_room(BOUNTY_RETURN_ROOM)];// &world[burglar->in_room];
      // Add it to the list
      add_mud_event(ev);
      // Reduce the players social status severely
      GET_SOCIAL_POINTS(burglar) -= 10;
      send_to_char("&rYour actions have been noticed!&n\r\n", burglar);
      send_to_char("... a bounty has been set on you.\r\n", burglar);
      current = current->next;
      continue;
    }
    // Some chance that they're going to be cutting into someone's territory
    if (number(1,100) == 1)
    {
      send_to_char("&bYou hear a familiar rustle....&n\r\n", burglar);
      send_to_char("... you have cut in on someone else's burglary!\r\n",
	           burglar);	
      create_burgle_encounter(burglar);
      int nExpGain = number(int(level_exp(burglar, GET_LEVEL(burglar)) * 0.01),
			    int(level_exp(burglar, GET_LEVEL(burglar)) * 0.03));
      if (nExpGain > 0)
      {
	sprintf(buf, "You learn from the experience! (%d exp)\r\n", nExpGain);
	send_to_char(buf, burglar);
	GET_EXP(burglar) += nExpGain;
      }
    }  
    current = current->next;
  }
}

/* Function to go through all events and take appropriate action on them */
void handle_events() 
{

  struct event_data *ev, *nextev;
	
  init_event();		// Random chance of beginning a new event
  // For every event
  for(ev = events.list; ev; ev = nextev)
  {
    nextev = ev->next;
    switch(ev->type)
    {
      case EVENT_BURGLARY:  handle_burglary(ev);    break;
      case EVENT_GOLD_RUSH: handle_gold_rush(ev);   break;
      case EVENT_CURFEW:    handle_curfew(ev);      break;
      case EVENT_QUEST:     handle_quest_event(ev); break;
      case EVENT_FIRE:      handle_fire(ev);        break;
      case EVENT_HAPPY_HR:  handle_happy(ev);       break;
      default: break;
    }
  }
  ev=events.list;
  // Clean up any events that have ended
  while(ev)
  {
    nextev = ev->next;		
    if (ev->type == EVENT_OVER)
      remove_mud_event(ev);
    ev = nextev;
  }	
  // Separate handler for burglaries now that they have their own class
  handle_burglaries();	
}


void show_election_status(struct char_data *ch)
{
  struct event_data *ev;
  // Get the event
  for (ev = events.list; ev; ev = ev->next) 
    if (ev->type == EVENT_ELECTION)
      break;
  // A double check, just in case
  if (ev == NULL)
  {
    send_to_char("No election is being held at this time.\r\n", ch);
    return;
  }
  sprintf(buf, "Current election status is #1: %d, #2: %d, #3: %d.\r\n", 
	  ev->info1, ev->info2, ev->info3);
  send_to_char(buf, ch);
}

ACMD(do_vote)
{
  struct event_data *ev;
  if (IS_NPC(ch))
  {
    send_to_char("Hate to say it, but some votes just don't count!\r\n", ch);
    return;
  }
  one_argument(argument, arg);
  if (*arg && strcmp(arg, "status") == 0 && check_for_event(EVENT_ELECTION, -1))
  {
    show_election_status(ch);
    return;
  }
  // Check if player can vote
  if ((GET_VOTED(ch) == TRUE) || LR_FAIL(ch, vote_level) ||
      !check_for_event(EVENT_ELECTION, -1))
  {
    send_to_char("You cannot place a vote at this time.\r\n", ch);
    return;
  }
  one_argument(argument, arg);
  if (!*arg)
  {
    send_to_char("You are eligible to vote.\r\n", ch);
    return;
  }
  if (!isdigit(arg[0]))
  {
    send_to_char("Your vote must be a digit or 'status'.\r\n", ch);
    return;
  }
  // Get the event
  for (ev = events.list; ev; ev = ev->next) 
    if (ev->type == EVENT_ELECTION)
      break;
  switch(atoi(arg))
  {
    case 1:
      ev->info1 = ev->info1 + 1;
      break;
    case 2:
      ev->info2 = ev->info2 + 1;
      break;
    case 3:
      ev->info3 = ev->info3 + 1;
      break;
    default:
      send_to_char("Your vote must be either '1', '2' or '3'.\r\n", ch);
      return;
  }
  send_to_char("Your vote has been registered. Thank you for your participation.\r\n",ch);
  GET_VOTED(ch) = TRUE;
}

/* NOTE: Requires a pre-made character named ' Adjudicator' */	
ACMD(do_worship)
{
  struct char_data *divinity;
  one_argument(argument, arg);
  if (!*arg)
  {
    send_to_char("You fall to your knees and beg for forgiveness.\r\n",ch);
    act("$n falls to $s knees and grovels to the mighty.\r\n", FALSE,
	ch, 0, 0, TO_ROOM);
    return;
  }
  if ((divinity = generic_find_char(ch, arg, FIND_CHAR_ROOM)) != NULL)
  {
    act("You fall to your knees before $N and beg for forgiveness.\r\n", false,
	ch, 0, divinity, TO_CHAR);
    act("$n falls to $s knees before you, begging for forgiveness.\r\n", true, 
	ch, 0, divinity, TO_VICT);
    act("$n gets down on $s knees before $N.\r\n", true, ch, 0, divinity, 
	TO_NOTVICT);
    return;
  }
  send_to_char("You wish there was noone worthy of your worshipping.\r\n", ch);
  return;
  
#if 0 // Artus> This is not implemented.
  // Maintain a social for it
  if (!*arg)
  {
    send_to_char("You fall to your knees and beg for forgiveness.\r\n",ch);
    act("$n falls to $s knees and grovels to the mighty.\r\n", FALSE,
	ch, 0, 0, TO_ROOM);
    return;
  }
  basic_mud_log("Worshipping");
  // Check that the player has some points to give away,
  // before bothering to check anything
  if (GET_WORSHIP_POINTS(ch) <= 0)
  {
    send_to_char("You pray to the divine, in hope.\r\n", ch);
    // Notify the target anyway, if they're online.
    if ((divinity = get_player_online(ch, arg, FIND_CHAR_WORLD) ) !=NULL) 
      act("You were worshipped by $n, but they had no power left to give you.",
	  FALSE, ch, 0, divinity, TO_VICT);
    else
    { // Check if they exist
      CREATE(divinity, struct char_data, 1);
      clear_char(divinity);
      if (load_char(arg, &tmp) < 0)
      {
	send_to_char("No such divinity exists!\r\n", ch);
	free(divinity);
	return;
      }	
      // they exist, send them a mail
      store_to_char(&tmp, divinity);
      sprintf(buf, "You were worshipped by %s, but they had no power to give you.\r\n", GET_NAME(ch));	
      store_mail(get_id_by_name(GET_NAME(divinity)),
		 get_id_by_name("Adjudicator"), buf);
      char_to_room(divinity, 0);
      extract_char(divinity);
      return;
    }
    return; 
  }
  send_to_char("Worship function not completed yet. See your nearest implementor.\r\n",ch);
#endif
}

/* Command to display the current bounties available */
ACMD(do_bounties)
{
  int bounty_count = 0, amount = 0;
  struct event_data *ev = NULL;
  struct char_data *vict = NULL;
  struct obj_data *obj = NULL;

  // NPC's are alloted bounty hunting differently
  if (IS_NPC(ch))
    return;

  // Check that there is some kind of valid item in the room
  /* Do this whenever */

  // Check that the player's class is an appropriate class
/*	if( class != CLASS_WARRIOR && class != CLASS_BATTLEMAGE &&
      class != CLASS_PALADIN && class != CLASS_NIGHTBLADE) {
	  send_to_char("Better leave the hunting to the pro's.\r\n",ch);
	  return;
  }
*/
  /* Check for skill instead of class here */
  // If there are no arguments, just list the bounties
  if (!*argument)
  {
    // Go through the events, and list the details
    for (ev = events.list; ev; ev = ev->next)
    {
      // Sift out the inappropriate events
      if (ev->type != EVENT_BOUNTY_HUNT)
	continue;
      // Get the bounty victim's name
      sprintf(buf, "(%2d) Bounty open for: &r%s&n.", bounty_count + 1,
	      get_name_by_id(ev->chID));
      // The reward
      sprintf(buf + strlen(buf), "\r\n     Reward: &Y%d&n", ev->info1);
      // Who started it
      sprintf(buf + strlen(buf), " coins on behalf of %s.", 
	      (ev->info3 != THE_LAW ? get_name_by_id(ev->info3): "the law")); 
      // The room to return to
      sprintf(buf + strlen(buf), "\r\n     Collect at: %s\r\n", ev->room->name);
      send_to_char(buf, ch);
      bounty_count++;
    }
    if (bounty_count == 0)
      send_to_char("No bounties available at this time.\r\n",ch);
    return;
  } // No arguments

  /* Check here, if they're bountying an item?! -- easily done
   * but have to break up the function into multiple parts
   * so I'll do it later.
   */
  // Grab the arguments
  two_arguments(argument, arg, buf1);
  /* Check the first argument for what type of bounty they're after*/
  if (strcmp(arg, "item") == 0)
    return;
  /* If there is no second argument, attempt to remove the bounty
   * on the player indicated, assuming they set up the bounty in 
   * the first place, otherwise, they're trying to collect.
   */
  if (!*buf1)
  {
    // Are they trying to cancel or collect the bounty?
    for(ev = events.list; ev; ev = ev->next)
    {
      // Valid bounty event?
      if (ev->type != EVENT_BOUNTY_HUNT)
	continue;
      // Is the event target the argument?
      if (get_id_by_name(arg) == ev->chID)
      {
	// Did they set it up? If so, cancel.
	if (GET_IDNUM(ch) == ev->info3)
	{
	  act("$n removes a bounty.", FALSE, ch, 0, 0,TO_ROOM);
	  int nGoldBack = int(ev->info1 - (0.10*ev->info1));
	  send_to_char("You cancel the bounty, forfeitting your cancellation fee.\r\n", ch);
	  sprintf(buf, "&Y%d&n coins are returned.\r\n", nGoldBack);
	  send_to_char(buf, ch);
	  // Money back, less 10%
	  GET_GOLD(ch) += nGoldBack;
	  ev->type = EVENT_OVER;
	  return;
	} // If they set it up	
	one_argument(argument, arg); // Dunno why I need this.
	// If they didn't set it up, they're trying to collect
	if ((obj = generic_find_obj(ch, "corpse", FIND_OBJ_INV)) == NULL)
	{
	  send_to_char("You hopelessly try to collect the bounty.\r\n", ch);
	  return;
	} // Do they have the appropriate item?
	arg[0] = UPPER(arg[0]);
	sprintf(buf, "the corpse of %s", arg);
	if (strcmp(obj->short_description, buf) != 0)
	{
	  send_to_char("Hmm, that doesn't look like the right corpse.\r\n",
		       ch);
	  return;
	} 
	// Successful bounty collection!
	amount = (int)(ev->info1 * 0.95);
	act("$n hands over a bounty, collecting %s reward!\r\n",
	    FALSE, ch, 0, 0, TO_ROOM);
	sprintf(buf, "You hand over your bounty, collecting &Y%d&n coins!\r\n",
		amount);	
	send_to_char(buf, ch);
	// Extract the item
	extract_obj(obj);
	GET_GOLD(ch) += amount;
	// Notify initiator
	if (ev->info3 != THE_LAW)
	{
	  sprintf(buf, "Your bounty on %s for %d was collected!\r\n",
		  get_name_by_id(ev->chID), ev->info1);
	  send_to_char(buf, generic_find_char(ch, get_name_by_id(ev->info3),
					      FIND_CHAR_WORLD)); 
	} else {
	  // Else - Run a  message on the board, declaring capture
	  /*TODO: Message on bounty board */
	  // DM - hmm removing quest points for the mean time
	  // (commented out quest points)
	  send_to_char("The lawful authorities thank you and reward you with an additional Quest Point!\r\n", ch);
	  //GET_QUEST_POINTS(ch) += 1;
	}
	// Finally, delete the event
	ev->type = EVENT_OVER;
	return; 
      } // If this event is the one with the player
    }  // For every event
    return;
  }
  /* New Bounty!  */
  // character visible?
  if (!(vict = generic_find_char(ch, arg, FIND_CHAR_WORLD)))
  {
    send_to_char("Put a bounty up on who!?\r\n", ch);
    return;
  }
  if (!isdigit(buf1[0]))
  {
    send_to_char("You have to put up a cash amount.\r\n", ch);
    return;
  }
  amount = atoi(buf1);
  // Check their balance
  if ((GET_GOLD(ch) < amount) && (GET_BANK_GOLD(ch) < amount))
  { 
    send_to_char("You don't have the cash resources for that right now.\r\n",
	         ch);
    return;
  }
  // Validate the amount is a logical one
  if ((amount < (GET_LEVEL(vict) * 10000)) || (!LR_FAIL(vict, LVL_GOD)))
  {
    send_to_char("Get real, noone would risk that bounty for that piddling cash reward!\r\n", ch);
    return;
  }
  // Get the cash
  if (GET_GOLD(ch) >= amount)
    GET_GOLD(ch) -= amount;
  else
    GET_BANK_GOLD(ch) -= amount;
  // Create the event
  CREATE(ev, struct event_data, 1);
  // Set it up
  ev->chID = GET_IDNUM(vict); 		// Target
  ev->info1 = amount;	// Bounty offered
  ev->info3 = get_id_by_name(GET_NAME(ch)); // Bounty initiator ID	
  ev->type = EVENT_BOUNTY_HUNT;	// Ahuh.
  ev->room = &world[real_room(BOUNTY_RETURN_ROOM)]; //&world[ch->in_room];
  // Add it to the list
  add_mud_event(ev);
  // Notify the room
  act("$n puts up a new bounty.", FALSE, ch, 0, 0, TO_ROOM);
  sprintf(buf, "You put up a bounty on &B%s&n for &Y%d&n coins.\r\n", 	
	  GET_NAME(vict), amount);
  send_to_char(buf, ch);

}
@


1.126
log
@Artus> Fixed bug in whostring titles.
@
text
@d1343 7
d1362 1
@


1.125
log
@Artus> Finished off movement changes.
@
text
@d4427 1
a4427 1
	      GET_NAME(tch), GET_TITLE(ch));
@


1.124
log
@Artus> Mostly looks like indent changes.. And a modification to determine
       whether we're moving, or fleeing.
@
text
@d2341 1
a2341 1
   byte crap=0;
d5471 1
a5471 1
		"&&9. &9%s&n\r\n"
@


1.123
log
@Artus> Colour of player on who list determined by level, once more.
@
text
@d170 4
a173 6
	char out[MAX_STRING_LENGTH];
	
	sprintf(out, "   %s is burgling %d rooms.\r\n",
		get_name_by_id(chID), CountBurgledRooms());
	send_to_char(out, ch);

a178 1
  
a179 1
  {
d181 1
a181 3
	nCount++;
  }
  
d520 1
a520 1
void do_zone_hint()
d526 12
a537 9
  for (d = descriptor_list; d; d = d->next) {
    if ((STATE(d) == CON_PLAYING) && d->character) { 
      if (!EXT_FLAGGED(d->character, EXT_NOHINTS)) {
        zrnum = world[d->character->in_room].zone;
	if (zone_table[zrnum].nohnts > 0) {
          rnumb = number(0, zone_table[zrnum].nohnts-1);
          sprintf(buf, "&W[ &bZone: &B%s &W]&n\r\n", zone_table[zrnum].hints[rnumb]);
          send_to_char(buf,d->character); 
	}
d544 1
a544 1
void do_hint()
a549 1

d551 5
a555 7

  for (d = descriptor_list; d; d = d->next) {
    if ((STATE(d) == CON_PLAYING) && d->character) { 
      if (!EXT_FLAGGED(d->character, EXT_NOHINTS)) {
        send_to_char(buf,d->character); 
      }
    }
d566 4
a569 2
  if (*arg) {
    if (!str_cmp(arg, "ON")) {
a580 1

a581 1

d599 4
a602 2
      for (struct obj_data *inner = obj->contains; inner; inner = inner->next_content)
	if (IS_OBJ_STAT(inner, ITEM_NODROP) && (number (1, 101) < GET_SKILL(ch, SKILL_SENSE_CURSE)))
a608 1

a610 1

a622 1

a700 1

d1109 2
a1110 1
  if ((mode == 0) && object->description) {
d1113 3
a1115 3
  }
  else if (object->short_description && ((mode == 1) ||
				 (mode == 2) || (mode == 3) || (mode == 4))) {
d1117 1
a1117 1
    if (invalid_level(ch, object, FALSE)) {
d1120 1
a1120 1
    } else if (OBJ_FLAGGED(object, ITEM_QEQ)) {
d1123 1
a1123 1
    } else {
a1124 2
    }
    
d1126 5
a1130 4
  }
  else if (mode == 5) {
    if (GET_OBJ_TYPE(object) == ITEM_NOTE) {
      if (object->action_description) {
d1148 2
a1149 1
  if (mode != 3) {
d1187 3
a1189 1
                      int show){
d1206 2
a1207 1
  if (unique == NULL) {
d1215 2
a1216 1
  if (u_item_ptrs == NULL) {
d1225 2
a1226 1
  for (i = list; i; i = i->next_content) {
d1228 4
a1231 2
    if (item_num < 0) {
      if (CAN_SEE_OBJ(ch, i)) {
d1239 4
a1242 2
      while (num && !exists) {
        if (unique[(num-1)*2] == item_num) {
d1248 2
a1249 1
      if (!exists) {
d1258 4
a1261 2
    if (CAN_SEE_OBJ(ch,u_item_ptrs[num])) {
      if (unique[num*2+1]>1) {
d1270 1
a1270 1
  if (unique != NULL) {
d1272 1
a1272 2
  }
  if (u_item_ptrs != NULL) {
d1274 1
a1274 2
  }
}  
a1372 1
//    found = FALSE;
a1374 9
//  for (tmp_obj = i->carrying; tmp_obj; tmp_obj = tmp_obj->next_content)
//    if (CAN_SEE_OBJ(ch, tmp_obj) && (number(0, 20) < GET_LEVEL(ch)))
//    {
//      show_obj_to_char(tmp_obj, ch, 1);
//	found = TRUE;
//      }
//    }
//  if (!found)
//    send_to_char("You can't see anything.\r\n", ch);
d1395 1
a1395 1
      act( " (mounted)", FALSE, i, 0, ch, TO_VICT);
d1401 2
a1402 1
  const char *positions[] = {
d1545 2
a1546 1
	send_to_char("You see a pair of glowing red eyes looking your way.\r\n", ch);
a1549 1

a1554 1

a1556 1

a1560 1

a1561 1

d1661 2
a1662 1
  if (IS_DARK(ch->in_room) && !CAN_SEE_IN_DARK(ch)) {
a1670 1
  
d1678 2
a1679 2

  if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_ROOMFLAGS)) {
a1738 2


d1741 2
a1742 1
  if (EXIT(ch, dir)) {
d1751 3
a1753 1
    } else if (EXIT_FLAGGED(EXIT(ch, dir), EX_ISDOOR) && EXIT(ch, dir)->keyword) {
a1760 2


a1777 1

a1848 1

a2018 2


a2046 2


d2089 1
d2093 2
a2094 2
	long lVector=0;
	int nLevel;
d2096 8
a2103 8
	if (!strcmp(argument, "brief"))
		nLevel = 1;
	else if (!strcmp(argument, "long"))
		nLevel = 3;
	else if (!strcmp(argument, "regular"))
		nLevel = 2;
        else
                return -1;
d2105 31
a2135 33
	if (nLevel >= 1) 		// Bare
	{	
		SET_BIT(lVector, SCORE_DAMROLL);
		SET_BIT(lVector, SCORE_HITROLL);
		SET_BIT(lVector, SCORE_NAME);
		SET_BIT(lVector, SCORE_AC);
		SET_BIT(lVector, SCORE_HMV);
	}
	if (nLevel >= 2)		// Other stuff
	{
		SET_BIT(lVector, SCORE_ALIGN);
		SET_BIT(lVector, SCORE_THACO);
		SET_BIT(lVector, SCORE_LEVEL);
		SET_BIT(lVector, SCORE_RACE);
		SET_BIT(lVector, SCORE_CLASS);
		SET_BIT(lVector, SCORE_STATS);
	}
	if (nLevel >= 3)		// The whole deal
	{
		SET_BIT(lVector, SCORE_AFFECTS);
		SET_BIT(lVector, SCORE_ABILITIES);
		SET_BIT(lVector, SCORE_INVENTORY);
		SET_BIT(lVector, SCORE_AGE);
		SET_BIT(lVector, SCORE_HEIGHTWEIGHT);
		SET_BIT(lVector, SCORE_SEX);
		SET_BIT(lVector, SCORE_GOLD);
		SET_BIT(lVector, SCORE_TIME);
                SET_BIT(lVector, SCORE_CARRYING);
	}

        SCORE_SETTINGS(ch) = lVector;

	return lVector;
d2140 7
a2146 7
	send_to_char("The valid score settings are:\r\n"
			"  damroll  hitroll    age        level    affects\r\n"
			"  name     abilities  inventory  height   hmv\r\n"
			"  sex      gold       stats      class    ac\r\n"
			"  align    thaco      carrying   none\r\n"
                        "In addition, the following sets are available:\r\n"
                        "  brief    regular    long\r\n", ch);
d2151 56
a2206 55
        if (getScoreDetail(argument, ch) != -1)
                return;
        else if (strcmp(argument, "damroll") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_DAMROLL);
	else if (strcmp(argument, "hitroll") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_HITROLL);
	else if (strcmp(argument, "age") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_AGE);
	else if (strcmp(argument, "level") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_LEVEL);
	else if (strcmp(argument, "affects") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_AFFECTS);
	else if (strcmp(argument, "name") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_NAME);
	else if (strcmp(argument, "abilities") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_ABILITIES);
	else if (strcmp(argument, "inventory") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_INVENTORY);
	else if (strcmp(argument, "height") == 0 || strcmp(argument, "weight") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_HEIGHTWEIGHT);
	else if (strcmp(argument, "race") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_RACE);
	else if (strcmp(argument, "sex") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_SEX);
	else if (strcmp(argument, "gold") == 0 || strcmp(argument, "bank") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_GOLD);
	else if (strcmp(argument, "stats") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_STATS);
	else if (strcmp(argument, "class") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_CLASS);
	else if (strcmp(argument, "ac") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_AC);
	else if (strcmp(argument, "align") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_ALIGN);
	else if (strcmp(argument, "thac0") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_THACO);
	else if (strcmp(argument, "hmv") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_HMV);
	else if (strcmp(argument, "quest") == 0 || strcmp(argument, "questpoints") == 0)
		SETREMOVE(SCORE_SETTINGS(ch), SCORE_QUESTPOINTS);
        else if (strcmp(argument, "carrying") == 0)
                SETREMOVE(SCORE_SETTINGS(ch), SCORE_CARRYING);
	else if (strcmp(argument, "list") == 0)
	{
		score_help_to_char(ch);
		return;
	}
	else if (strcmp(argument, "none") == 0)
	{
		send_to_char("All score settings removed.\r\n", ch);
		SCORE_SETTINGS(ch) = 0;
		return;
	}
	else
		strcpy(argument, "unknown");
d2208 8
a2215 8
	// Inform player
	if (strcmp(argument, "unknown") == 0)
		send_to_char("Unknown score setting...Try '&yscore set list&n'...\r\n", ch);
	else
	{
		sprintf(buf2, "Score setting for &B%s&n updated...\r\n", argument);
		send_to_char(buf2, ch);
	}
d2220 1
a2220 1
	basic_mud_log("%d, %d", current, max);
d2222 8
a2229 8
	if (current < (max / 4))
		return "&r";
	if (current < (max / 2))
		return "&R";
	if ( current < max)
		return "&Y";
	
	return "&G";
d2234 1
a2234 1
	bool bFound = TRUE;
d2236 95
a2330 93
	if (!show) 
		return;

	switch(item)
	{
		case 0:	//  Damroll
			sprintf(buf, "Damroll: %d\r\n", GET_DAMROLL(ch));
			break;
		case 1:	// Hitroll
			sprintf(buf, "Hitroll: %d\r\n", GET_HITROLL(ch));
			break;
		case 2: // Age
			sprintf(buf, "Age: %d\r\n", GET_AGE(ch));
			break;
		case 3: // Name
			sprintf(buf, "Character Name: %s\r\n", GET_NAME(ch));
			break;
		case 4: // Level
			sprintf(buf, "Level: %d\r\n", GET_LEVEL(ch));
			break;
		case 5: // Stats
			sprintf(buf, 	"Strength    :  %2d (%2d)\r\n"
					"Intelligence:  %2d (%2d)\r\n"
					"Wisdom      :  %2d (%2d)\r\n"
					"Dexterity   :  %2d (%2d)\r\n"
					"Constitution:  %2d (%2d)\r\n"
					"Charisma    :  %2d (%2d)\r\n",
				GET_REAL_STR(ch), GET_AFF_STR(ch), 
				GET_REAL_INT(ch), GET_AFF_INT(ch),
				GET_REAL_WIS(ch), GET_AFF_WIS(ch),
				GET_REAL_DEX(ch), GET_AFF_DEX(ch),
				GET_REAL_CON(ch), GET_AFF_CON(ch),
				GET_REAL_CHA(ch), GET_AFF_CHA(ch));
			break;
		case 6: // Race
			sprinttype(GET_RACE(ch), pc_race_types, buf2);
			sprintf(buf, "Race: %s\r\n", buf2);
			break;
		case 7: // Class
			sprinttype(GET_CLASS(ch), pc_class_types, buf2);
			sprintf(buf, "Class: %s\r\n", buf2);
			break;
		case 8: // HMV
			sprintf(buf, 	"Hit Points: %s%5d&n / %-5d\r\n"
					"Mana      : %s%5d&n / %-5d\r\n"
					"Movement  : %s%5d&n / %-5d\r\n",
					getColorType(GET_HIT(ch), GET_MAX_HIT(ch)), GET_HIT(ch), GET_MAX_HIT(ch),
					getColorType(GET_MANA(ch), GET_MAX_MANA(ch)), GET_MANA(ch), GET_MAX_MANA(ch),
					getColorType(GET_MOVE(ch), GET_MAX_MOVE(ch)), GET_MOVE(ch), GET_MAX_MOVE(ch));
			break;
		case 9: // AC
//			sprintf(buf, "Armour Class: %d\r\n", GET_AC(ch));
			sprintf(buf, "Armour Class: %d\r\n", compute_armor_class(ch, 0));
			break;
		case 10: // THAC0
			sprintf(buf, "THAC0: %d\r\n", thaco(ch, NULL));
			break;
		case 11: // Height & Weight
			sprintf(buf, "Height: %d, Weight: %d\r\n", GET_HEIGHT(ch), GET_WEIGHT(ch));
			break;
		case 12: // Align
			sprintf(buf, "Alignment: %d\r\n", GET_ALIGNMENT(ch));
			break;
		case 13: // Gold & Bank
			sprintf(buf, "Gold: %d, Bank: %d\r\n", GET_GOLD(ch), GET_BANK_GOLD(ch));
			break;
		case 14: // Time
			sprintf(buf, "Time played: %s\r\n", "TODO!");
			break;
		case 15: // Inv
			sprintf(buf, "Inventory stats: %s\r\n", "TODO!");
			break;
		case 16: // Affects
			sprintf(buf, "Affected by: %s\r\n", "TODO!");
			break;
		case 17: // Abilities
			sprintf(buf, "Abilities: %s\r\n", "TODO!");
			break;
		case 18: // Sex
			sprintf(buf, "Sex: %s\r\n", 
				ch->player.sex == SEX_NEUTRAL ? "Neutered" : 
				ch->player.sex == SEX_MALE ? "Male" : "Female");
			break; 
		case 19: // Quest points
			sprintf(buf, "Stat points: %d\r\n", GET_STAT_POINTS(ch));
			break;
		default: 
			bFound = FALSE;
			break;
	}

	if (bFound)
		send_to_char(buf, ch);
d2332 1
d2348 1
a2355 1

d2556 1
d2559 1
d2573 1
d2608 3
a2610 2
  if (IS_NPC(ch)) {
    send_to_char("Umm, I don't think so.",ch);
d2646 4
a2649 4
  if (GET_CLAN(ch) > 0) {
    sprintf(buf2, "%s &0Clan&n: &g%s&n", 
		    cstar, clan[find_clan_by_id(GET_CLAN(ch))].name);

d2653 3
a2655 4
	    
    sprintf(buf2, "%s &0Rank&n: &g%s&n", 
	   cstar, (GET_CLAN_RANK(ch) < 1) ? "Applying" : clan[find_clan_by_id(GET_CLAN(ch))].rank_name[GET_CLAN_RANK(ch)-1]);

a2662 1

a2663 1

a2664 1

d2668 1
a2668 1
    if (CHAR_MEMORISED(ch) > 0) {
d2670 2
a2671 2
	      mob_proto[real_mobile(CHAR_MEMORISED(ch))].player.short_descr);
    } else {
d2673 1
a2673 4
    }
    sprintf(buf, "%s &0Mob memorised&n: &6%s&n", 
	    cstar, mobname); 
	    
d2676 4
a2679 3
    sprintf(buf2, "%s &0Disguised&n: %s&n", 
		    cstar, CHAR_DISGUISED(ch) == 0 ? "No" : "Yes");
    if (CHAR_DISGUISED(ch)) {
d2692 1
a2692 3
  /* Kill Counts - Artus */ // ... You want to get stats off the target, Artus
                            // Oh man, i assure you, i am not high ;o) -- Artus

d2695 3
a2697 5
		"&1By PC&n[&c%ld&n]",
		cstar, GET_IMMKILLS(ch), GET_KILLSBYIMM(ch), 
		GET_MOBKILLS(ch), GET_KILLSBYMOB(ch), GET_PCKILLS(ch), 
		GET_KILLSBYPC(ch));

a2698 1

a2703 1

d2706 1
a2706 1
		  "&1Max&n[&c%3d&n] &1Total&n[&c%3d&n]", 
a2708 2
      

a2709 1

a2713 1

a2715 1

a2730 1

a2732 1

d2734 3
a2736 3

  if (GET_INVIS_LEV(ch) > 0) {
    if (GET_INVIS_TYPE(ch) == INVIS_SPECIFIC) {
d2738 1
a2738 1
    } else if( GET_INVIS_TYPE(ch) == INVIS_SINGLE) {
d2740 1
a2740 1
    } else if (GET_INVIS_TYPE(ch) == INVIS_NORMAL) {
d2742 1
a2742 1
    } else { 
d2744 1
a2744 3
		      GET_INVIS_TYPE(ch)); 
    }

a2746 1

a2748 1

a2755 1

a2757 2


a2771 1

d2774 2
a2775 2
		  cstar, CCTEXT(ch,C_NRM), buf3, cstar,
		  GET_STAT_POINTS(ch), cstar, cstar);
a2787 1

a2788 1

a2791 1

d2795 14
a2808 13
  switch (ch->player.sex) {
  case SEX_NEUTRAL:
    strcpy(buf2, "NEUTRAL");
    break;
  case SEX_MALE:
    strcpy(buf2, "MALE");
    break;
  case SEX_FEMALE:
    strcpy(buf2, "FEMALE");
    break;
  default:
    strcpy(buf2, "ILLEGAL");
    break;
a2809 1
  
a2811 1

a2813 1

a2814 1

d2816 2
a2817 1
  if (GET_REAL_STR(ch)==18) {
d2826 3
a2828 4

  sprintf(buf2,"%s &1STR&n: %s%-2d  %-2d  %-2d &n%s&n\r\n",
	cstar, CCSTAT(ch,C_NRM), GET_REAL_STR(ch), GET_AFF_STR(ch), 
	max_stat_value(ch, STAT_STR), cstar);
a2829 1

a2850 1

a2852 1

d2859 1
a2859 2
  
/* Choose the hp color */
d2863 1
a2863 1
     sprintf(buf2,"%s",CCBRED(ch,C_NRM));
d2865 1
a2865 1
     sprintf(buf2,"%s",CCBYEL(ch,C_NRM));
a2866 1

a2870 1

a2872 1
  
a2875 1

a2878 1

a2879 1

a2881 1

a2884 1
  
a2887 1

a2891 1

a2894 1

d2902 2
a2903 1
  else sprintf(buf2,"%s",CCBGRN(ch,C_NRM));  
d2906 2
a2907 3
	cstar, buf2, GET_MANA(ch), CCSEP(ch,C_NRM), CCBGRN(ch,C_NRM),
	GET_MAX_MANA(ch), CCSEP(ch,C_NRM), CCGAIN(ch,C_NRM), mana_gain(ch));

a2910 1
  
a2913 1

a2914 1

d2917 3
a2919 5

  sprintf(buf2,"%s &1Height%s/&1Weight&n: %s%d%s,&n%s%d&n",
		cstar, CCSEP(ch,C_NRM), CCNUMB(ch,C_NRM), 
		GET_HEIGHT(ch), CCSEP(ch,C_NRM), CCNUMB(ch,C_NRM), 
		GET_WEIGHT(ch));
a2920 1

a2922 1

d2925 3
a2927 4

  sprintf(buf2,"%s &1DEX&n: %s%-2d  %-2d  %-2d &n%s&n\r\n",
	cstar, CCSTAT(ch,C_NRM), GET_REAL_DEX(ch), GET_AFF_DEX(ch), 
	max_stat_value(ch, STAT_DEX), cstar);
a2928 1

d2931 2
a2932 3
/* Ninth Line - Movement, Level, Int */

  /* Choose the movement color */
d2940 3
a2942 5

  sprintf(buf, "%s &1Movement&n     : %s%d%s/%s%d%s+&n%s%d&n",
	cstar, buf2, GET_MOVE(ch), CCSEP(ch,C_NRM), CCBGRN(ch,C_NRM),
	GET_MAX_MOVE(ch), CCSEP(ch,C_NRM), CCGAIN(ch,C_NRM), move_gain(ch));

a2945 1
  
a2948 1

a2949 1

a2951 1

d2953 1
a2953 1
  if (j >= LVL_GOD)
a2962 1

a2965 1

a2966 1

a2968 1

a2972 1

d2976 2
a2977 4

  sprintf(buf, "%s &1Hitroll&n      : %s%d&n", 
		  cstar, CCDH(ch,C_NRM), ch->points.hitroll);

a2978 1

a2980 1

d2982 1
a2982 1

d3019 1
a3019 1

d3022 2
d3025 1
a3025 5
    if (GET_ALIGNMENT(ch) < -350)
      sprintf(buf3,"%s",CCRED(ch,C_NRM));
    else
      sprintf(buf3,"%s",CCBWHT(ch,C_NRM));

a3029 1

a3030 1

a3031 1

a3033 1

d3035 2
a3036 2
	cstar, CCSTAT(ch,C_NRM), GET_REAL_WIS(ch), GET_AFF_WIS(ch), 
	max_stat_value(ch, STAT_WIS), cstar);
a3037 1

d3041 2
a3042 3
  sprintf(buf, "%s &1Damroll&n      : %s%d",
	cstar, CCDH(ch,C_NRM), ch->points.damroll);

a3044 1

a3049 1

a3054 1

a3055 1

a3057 1

a3059 1

a3060 1

a3062 1

d3064 2
a3065 2
	cstar, CCSTAT(ch,C_NRM), GET_REAL_CHA(ch), GET_AFF_CHA(ch), 
	max_stat_value(ch, STAT_CHA), cstar);
a3066 1

a3069 1

d3071 4
a3074 4
  sprintf(buf, "%s &1Armour Class&n : %s%d%s/&n%s10 %s(&n%s%d%s)&n",
	cstar, CCACT(ch,C_NRM), compute_armor_class(ch, 0), CCSEP(ch,C_NRM), CCACT(ch,C_NRM),
	CCSEP(ch,C_NRM), CCACT(ch,C_NRM), compute_armor_class(ch, 1), CCSEP(ch, C_NRM));

d3077 1
a3077 3

  sprintf(buf2,"%s &1Bank&n  : &Y%d&n", 
		  cstar, GET_BANK_GOLD(ch));
a3078 1

a3079 1

a3081 1

a3083 1

a3085 1

d3091 2
a3092 4

  sprintf(buf, "%s &1Thac&n%s0&n        : %s%d&n",
	cstar, CCACT(ch,C_NRM), CCACT(ch,C_NRM), thaco(ch, NULL)); 

a3093 1

a3095 1

d3097 3
a3099 4
				  
  sprintf(buf2,"%s &1Time&n  : %s%d&n%sd&n%s%d%sh&n", 
	cstar, CCNUMB(ch,C_NRM), playing_time.day, CCSEP(ch,C_NRM),
	CCNUMB(ch,C_NRM), playing_time.hours, CCSEP(ch,C_NRM));
a3100 1

a3102 1

a3104 1

a3106 1

a3112 1

d3115 1
a3115 3

  sprintf(buf,"%s              &0Inventory                                     %s                 &n%s&n\r\n",
		cstar,CCHEAD(ch,C_NRM),cstar);
d3118 2
a3119 4

  sprintf(buf,"%s &1Carrying weight &n: %s%d&n",
                cstar, CCNUMB(ch,C_NRM), IS_CARRYING_W(ch));

a3121 1

a3123 1

a3125 1

a3128 1

d3133 2
a3134 5

  sprintf(buf,"%s &1Can Carry Weight&n: %s%d&n",
		cstar, CCNUMB(ch,C_NRM), CAN_CARRY_W(ch));

  
a3136 1

a3138 1

a3140 1

a3143 1

a3148 1

a3151 1

a3153 1

d3155 4
a3158 2
  if (ch->affected) {
    for (aff = ch->affected; aff; aff = aff->next) {
d3160 2
a3161 1
      if( aff->duration == -1 ) {
d3163 2
a3164 1
        if (aff->modifier) {
d3168 1
a3168 2
      }
      else {
d3173 1
a3173 1
 
d3176 1
a3176 1

a3177 1
 
d3179 8
a3186 4
        for (int i = 0; i < NUM_WEARS; i++) {
          if (GET_EQ(ch, i) && GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_MAGIC_EQ) {
            for (int j = 0; j < 3; j++) {
              if (GET_OBJ_VAL(GET_EQ(ch, i), j) == aff->type) {
d3193 1
a3193 2

        if (found) {
d3195 2
a3196 2
              skill_name(aff->type), CCNRM(ch, C_NRM));
        } else {
d3198 4
a3201 7
              CCCYN(ch, C_NRM), skill_name(aff->type), CCNRM(ch, C_NRM));
        }    

        if (aff->modifier) {
          sprintf(buf2, "%+d to %s", aff->modifier, apply_types[(int) aff->location]);
          strcat(buf, buf2);
        }
d3203 2
a3204 1
      if (aff->bitvector) {
a3214 1

a3215 1

d3217 8
a3224 8
  if (ch->timers) {
    for (timer = ch->timers; timer; timer = timer->next) {

      sprintf(buf,"TIM: (%3dhr) %s%-22s%s", timer->duration, CCCYN(ch, C_NRM), timer_types[timer->type], CCNRM(ch, C_NRM));
      sprintf(buf2,"Uses: (%2d) of max: (%2d)\r\n",timer->uses, timer->max_uses);

      strcat(buf, buf2);

a3227 1

a3237 1

a3238 2

  
a3242 2


a3249 1

a3258 2


a3269 1

d3275 2
a3276 1
    if (HAS_OFFENDED(ch,i) > 0) {
a3280 2


a3291 1

a3293 1

a3294 1

d3303 35
a3337 34
  switch (GET_POS(ch)) {
  case POS_DEAD:
    strcat(buf, "You are DEAD!\r\n");
    break;
  case POS_MORTALLYW:
    strcat(buf, "You are mortally wounded!  You should seek help!\r\n");
    break;
  case POS_INCAP:
    strcat(buf, "You are incapacitated, slowly fading away...\r\n");
    break;
  case POS_STUNNED:
    strcat(buf, "You are stunned!  You can't move!\r\n");
    break;
  case POS_SLEEPING:
    strcat(buf, "You are sleeping.\r\n");
    break;
  case POS_RESTING:
    strcat(buf, "You are resting.\r\n");
    break;
  case POS_SITTING:
    strcat(buf, "You are sitting.\r\n");
    break;
  case POS_FIGHTING:
    if (FIGHTING(ch))
      sprintf(buf, "%sYou are fighting %s.\r\n", buf, PERS(FIGHTING(ch), ch));
    else
      strcat(buf, "You are fighting thin air.\r\n");
    break;
  case POS_STANDING:
    strcat(buf, "You are standing.\r\n");
    break;
  default:
    strcat(buf, "You are floating.\r\n");
    break;
a3338 1

a3340 1

a3346 1

d3349 3
a3351 6

  if (AUTOASSIST(ch)) {
    sprintf(buf2, "You are autoassisting &7%s&n.\r\n",GET_NAME(AUTOASSIST(ch)));
    strcat(buf,buf2); 
  }

a3353 1

a3355 1

a3357 1

a3359 1

a3361 1

a3363 1

a3365 1

a3367 1

a3369 1

a3371 1

a3373 1

a3375 1

a3377 1

a3379 1

a3381 1

d3384 3
a3386 5

  if (MOUNTING(ch)) {
    sprintf(buf2, "You are mounted on &6%s&n.\r\n", GET_NAME(MOUNTING(ch)));
    strcat(buf, buf2);
  }
a3396 1

d3403 1
a3403 2
   }

d3406 1
d3541 1
a3546 1

a3572 1
 
a3573 1

a3576 1

a3578 1

a3580 1

a3582 1

a3584 1

a3586 1

a3588 1

a3590 1

a3592 1

a3594 1

a3596 1

a3598 1

a3600 1

a3602 1

a3604 1

a3606 1

a3608 1

a3610 1

a3612 1

a3614 1

d3616 1
a3616 2
     strcat(buf, "You feel protected from Good.\r\n");

d3618 1
a3618 2
     strcat(buf, "You are asleep.\r\n");

d3620 1
a3620 2
     strcat(buf, "You have shiny scales on your skin.\r\n");

d3622 1
a3622 2
     strcat(buf, "You are flying.\r\n");

d3624 1
a3624 2
     strcat(buf, "You feel like a dragon!\r\n");

a3629 1

d3634 2
a3635 4
  {
	sprintf(buf2, "You are mounted on %s.\r\n", GET_NAME(MOUNTING(ch)));
	strcat(buf, buf2);
  }
d3637 2
a3638 5
  {
	sprintf(buf2, "You are mounted on %s.\r\n", MOUNTING_OBJ(ch)->short_description);
	strcat(buf, buf2);
  }
 
a3645 1
 
a3650 1

a3654 1

d3661 2
a3662 2
    send_to_char("You are affected by the following spells and/or skills:\r\n", ch);

a3668 1

a3670 1

d3674 1
a3674 2

    for (aff = affect_array[0]; (aff) && i < noAffects; aff = affect_array[i++]) {
a3675 1
    }
a3676 1

a3677 1
    i = 0;
d3679 2
a3680 1
    for (aff = affect_array[0]; (aff) && i < noAffects; aff = affect_array[++i])
d3682 1
a3682 1
      if (aff->type <= 0 || aff->type > TOP_SPELL_DEFINE)
a3683 1

a3685 1
      {
d3687 1
a3687 1
      } else if (aff->duration == CLASS_ITEM) {
d3689 2
a3690 1
      } else {
d3714 2
a3715 2
          sprintf(buf, "SPL: (%3dhr) %s%-21s%s ", aff->duration + 1, 
              CCCYN(ch, C_NRM), skill_name(aff->type), CCNRM(ch, C_NRM));
d3719 2
a3720 4
      {
        sprintf(buf2, "%+d to %s", aff->modifier, apply_types[(int) aff->location]);
        strcat(buf, buf2); 
      }
d3957 4
a3960 2
      if (GET_EQ(ch, wear_positions[i])) {
        if (CAN_SEE_OBJ(ch, GET_EQ(ch, wear_positions[i]))) {
a3982 1

a3984 1

a3987 1

a3988 1

a3996 1

a3998 1

a4001 1

d4004 2
a4005 1
  const char *sky_look[] = {
d4011 2
a4012 2

  if (OUTSIDE(ch)) {
d4027 2
a4028 1
  if(weather_info.moon == MOON_NONE) {
d4031 1
a4031 2
    }
 
a4037 1
 
d4041 2
a4042 1
      sprintf(buf,"It is the 1st night of the %s moon.\r\n",moon_mesg[weather_info.moon]);
d4045 2
a4046 1
      sprintf(buf,"It is the 2nd night of the %s moon.\r\n",moon_mesg[weather_info.moon]);
d4049 2
a4050 1
      sprintf(buf,"It is the 3rd night of the %s moon.\r\n",moon_mesg[weather_info.moon]);
a4052 1
 
a4062 1

a4063 1

a4073 1

a4076 1

a4079 1

d4089 1
a4089 1
	 (!(chk = strn_cmp(argument, help_table[mid - 1].keyword, minlen))))
a4090 1
      
a4097 1
      
a4101 1
      
a4112 1

a4114 1

a4132 1

a4200 1

d4323 5
a4327 5
    struct char_data **left;
    struct char_data **right;
    left = (struct char_data **)l;
    right = (struct char_data **)r;
    return strcmp(GET_NAME(*left),GET_NAME(*right));
a4403 1

a4404 1

a4405 1

a4507 1

d4531 2
a4532 1
  while (*buf) {
d4539 15
a4553 17
      case 'a':
        // name specified - tally times and only display that person
        if (*buf1)
	{
          name = buf1;
          skip_spaces(&name);
          if (get_id_by_name(name) > 0)
            singleuser = TRUE;
        }
  strcpy(buf,
"Num Lvl   Name         Site                     Login@@   Logout@@  Session\r\n");
  strcat(buf,
"--- ----- ------------ ------------------------ -------- -------- --------\r\n");
        for (users = user_list; users; users=users->next)
	{
          if (singleuser && str_cmp(name, users->name))
            continue;
d4555 1
a4555 1
          timeptr = asctime(localtime(&users->login));
d4557 6
a4562 6
	  if (jk_localtime(&lt, users->login))
	  {
	    basic_mud_log("Error in jk_localtime (users->login: %ld) [%s:%d]", users->login, __FILE__, __LINE__);
	    continue;
	  }
	  timeptr = asctime(&lt);
d4564 3
a4566 3
          timeptr += 11;
          *(timeptr + 8) = '\0';
          strcpy(temp1, timeptr);
d4568 2
a4569 2
          if (users->logout)
	  {
d4571 1
a4571 1
            timeptr2 = asctime(localtime(&users->logout));
d4573 16
a4588 4
	    if (jk_localtime(&lt, users->logout))
	    {
	      basic_mud_log("Error in jk_localtime(users->logout: %ld) [%s:%d]", users->logout, __FILE__, __LINE__);
	      continue;
d4590 56
a4645 70
	    timeptr2 = asctime(&lt);
#endif
            timeptr2 += 11;
            *(timeptr2 + 8) = '\0'; 
            strcpy(state, timeptr2);
            strcpy(temp2, timeptr2);
            
            mytime = users->logout - users->login;
          } else {
            strcpy(temp2, "-active-");
            mytime = time(0) - users->login;
          }
          if (singleuser)
            tally = tally + mytime;

          h = (mytime / 3600);
          m = (mytime / 60) % 60;
          s = mytime % 60;
            
          sprintf(buf2, "%3d [%-3d] %-12s %-24s %-8s %-8s %dh%dm%ds\r\n",
                          users->number, users->level, users->name, users->host,
                          temp1, temp2, h, m, s);
          strcat(buf, buf2);
        }
        if (singleuser)
	{
          h = (tally / 3600);
          m = (tally / 60) % 60;
          s = tally % 60;
          sprintf(buf2,"Total time for %s: %dh%dm%ds\r\n", name, h, m, s);
          strcat(buf, buf2);
        }
        page_string(ch->desc, buf, TRUE);
        return;
      case 'o':
      case 'k':
	outlaws = 1;
	playing = 1;
	strcpy(buf, buf1);
	break;
      case 'p':
	playing = 1;
	strcpy(buf, buf1);
	break;
      case 'd':
	deadweight = 1;
	strcpy(buf, buf1);
	break;
      case 'l':
	playing = 1;
	half_chop(buf1, arg, buf);
	sscanf(arg, "%d-%d", &low, &high);
	break;
      case 'n':
	playing = 1;
	half_chop(buf1, name_search, buf);
	break;
      case 'h':
	playing = 1;
	half_chop(buf1, host_search, buf);
	break;
      case 'c':
	playing = 1;
	half_chop(buf1, arg, buf);
	for (i = 0; i < strlen(arg); i++)
	  showclass |= find_class_bitvector(arg[i]);
	break;
      default:
	send_to_char(USERS_FORMAT, ch);
	return;
d4654 1
a4654 2
  strcat(line,
	 "--- -------- ------------ -------------- --- -------- ------------------------\r\n");
a4655 1

a4656 1

a4689 1

a4701 1

a4705 1

d4733 2
a4734 2
    if (STATE(d) != CON_PLAYING ||
		(STATE(d) == CON_PLAYING && CAN_SEE(ch, d->character)))
a4739 1

d4748 52
a4799 50
  switch (subcmd) {
  case SCMD_CREDITS:
    page_string(ch->desc, credits, 0);
    break;
  case SCMD_NEWS:
    page_string(ch->desc, news, 0);
    break;
  case SCMD_INFO:
    page_string(ch->desc, info, 0);
    break;
  case SCMD_WIZLIST:
    page_string(ch->desc, wizlist, 0);
    break;
  case SCMD_IMMLIST:
    page_string(ch->desc, immlist, 0);
    break;
  case SCMD_HANDBOOK:
    page_string(ch->desc, handbook, 0);
    break;
  case SCMD_POLICIES:
    page_string(ch->desc, policies, 0);
    break;
  case SCMD_MOTD:
    page_string(ch->desc, motd, 0);
    break;
  case SCMD_IMOTD:
    page_string(ch->desc, imotd, 0);
    break;
  case SCMD_CLEAR:
    send_to_char("\033[H\033[J", ch);
    break;
  case SCMD_VERSION:
    sprintf(buf, "PrimalMUD version: &c%d.%d.%d&n Copyright (C) 1994-2004\r\n"
		 "  Built on: %s\r\n\r\n"
                 "Based on CircleMUD version 3bpl17 and" 
                 " PrimalMUD version 2.00\r\n", 
            release.getMajor(), release.getBranch(), release.getMinor(), release.getDate());
    send_to_char(buf, ch);
    send_to_char(strcat(strcpy(buf, DG_SCRIPT_VERSION), "\r\n"), ch);
    //send_to_char(strcat(strcpy(buf, circlemud_version), "\r\n"), ch);
    break;
  case SCMD_WHOAMI:
    send_to_char(strcat(strcpy(buf, GET_NAME(ch)), "\r\n"), ch);
    break;
  case SCMD_AREAS:
    page_string(ch->desc, areas, 0);
    break;
  default:
    basic_mud_log("SYSERR: Unhandled case in do_gen_ps. (%d)", subcmd);
    return;
d4811 11
a4821 5
  if (!*arg) {
//    send_to_char("Players in your Zone\r\n--------------------\r\n", ch);

    zone_name_len=strlen(zone_table[world[ch->in_room].zone].name);
    sprintf(buf,"Players in &R%s&n\r\n", zone_table[world[ch->in_room].zone].name);
d4823 2
a4824 5
    for (j=0; j < (11+zone_name_len); j++)
      send_to_char("-",ch);
    send_to_char("\r\n",ch); 

    for (d = descriptor_list; d; d = d->next) {
d4837 2
a4838 1
    for (i = character_list; i; i = i->next) {
a4852 1

d4854 1
a4854 1
			        int recur, char *writeto)
d4860 2
a4861 2

  if (obj->in_room > NOWHERE) {
d4877 2
a4878 1
    if (recur) {
a4896 1

d4899 2
a4900 2

  if (!*arg) {
d4903 2
a4904 1
      if (STATE(d) == CON_PLAYING) {
d4906 2
a4907 1
	if (i && CAN_SEE(ch, i) && (i->in_room != NOWHERE)) {
d4909 1
a4909 1
	    sprintf(buf1, "%-20s - &c[%5d]&n %s (%s) (in %s)\r\n",
d4911 3
a4913 3
		 world[i->in_room].name,
		zone_table[world[i->in_room].zone].name, 
                GET_NAME(d->character));
d4915 3
a4917 2
	    sprintf(buf1, "%-20s - &c[%5d]&n %s (%s)\r\n", GET_NAME(i),
		    GET_ROOM_VNUM(IN_ROOM(i)), world[i->in_room].name,
a4918 2
          sprintf(buf, "%s%s", buf, buf1);
	  //send_to_char(buf, ch);
d4925 2
a4926 1
                      && isname(arg, i->player.name)) {
d4928 2
a4929 3
	sprintf(buf1, "&rM&n%3d. %-25s - &c[%5d]&n %s\r\n", ++num, GET_NAME(i),
		GET_ROOM_VNUM(IN_ROOM(i)), world[IN_ROOM(i)].name);
        sprintf(buf, "%s%s", buf, buf1);
d4933 2
a4934 1
      if (CAN_SEE_OBJ(ch, k) && isname(arg, k->name)) {
d4936 1
a4936 2
	print_object_location(++num, k, ch, TRUE, buf1);
        sprintf(buf, "%s%s", buf, buf1);
d4940 1
a4940 1
    else {
a4941 1
    }
a4956 1

d4971 2
a4972 2
      sprintf(buf + strlen(buf), "&g[&m%3d - %2d&g]&n &c%9d&n", 
              i, i+1, level_exp(ch, i));
d4974 2
a4975 3
      sprintf(buf + strlen(buf), "&g[&n%3d - %2d&g]&n &c%9d&n", 
          i, i+1, level_exp(ch, i));
    strcat(buf, "\r\n");
d4977 1
a4977 1
  sprintf(buf + strlen(buf), "&g[   &b%3d&g  ]&n &c%9d&n : &bImmortality&n\r\n",
a4981 2


a5029 2


d5036 2
a5037 1
  if (*buf) {
d5051 1
a5051 4
const char *ctypes[] = {
  "off", "sparse", "normal", "complete", "\n"
};

a5054 1

a5056 1

d5058 2
a5059 2

  if (!*arg) {
d5064 2
a5065 1
  if (((tp = search_block(arg, ctypes, FALSE)) == -1)) {
d5070 2
a5071 2
  SET_BIT(PRF_FLAGS(ch), (PRF_COLOR_1 * (tp & 1)) | (PRF_COLOR_2 * (tp & 2) >> 1));

a5076 1

a5084 1
 
a5085 1
 
a5090 1
 
a5130 1

d5132 2
a5133 2
  
  if (GET_PROMPT(vict)) {
d5138 1
a5138 1
    if (PRF_FLAGGED(vict, PRF_DISPHP)) {
d5140 1
a5140 2
    }
    if (PRF_FLAGGED(vict, PRF_DISPMANA)) {
d5142 1
a5142 2
    }
    if (PRF_FLAGGED(vict, PRF_DISPMOVE)) {
d5144 1
a5144 2
    }
    if (PRF_FLAGGED(vict, PRF_DISPEXP)) {
d5146 1
a5146 2
    }
    if (PRF_FLAGGED(vict, PRF_DISPALIGN)) {
a5147 1
    }
d5149 23
a5171 19

  sprintf(buf,
          " Character Name: %s\r\n\r\n"
 
          "Hit Pnt Display: %-3s    " "     Brief Mode: %-3s    " " Summon Protect: %-3s\r\n"
          "   Move Display: %-3s    " "   Compact Mode: %-3s    " "       On Quest: %-3s\r\n"
          "   Mana Display: %-3s    " " Auto Show Exit: %-3s    " " Gossip Channel: %-3s\r\n"
          "    Exp Display: %-3s    " "   Repeat Comm.: %-3s    " "Auction Channel: %-3s\r\n"
          "  Align Display: %-3s    " "           Deaf: %-3s    " "  Grats Channel: %-3s\r\n"
          "       Autoloot: %-3s    " "         NoTell: %-3s    " " Newbie Channel: %-3s\r\n"
          "       Autogold: %-3s    " "     Marked AFK: %-3s    " "   Clan Channel: %-3s\r\n"
          "      Autosplit: %-3s    " " Clan Available: %-3s    " "   Info Channel: %-3s\r\n"
	  "        Autoeat: %-3s    " "    Color Level: %-10s"       "Hint Channel: %-3s\r\n"
          "    Page Length: %-3d    " "     Page Width: %-3d   " "Corpse Retrieval: %-3s\r\n"
          "     Wimp Level: %-4s   "  "  Prompt String: %s\r\n",

          GET_NAME(vict),
 
          ONOFF(PRF_FLAGGED(vict, PRF_DISPHP)),
d5215 5
a5219 7

  if (GET_MAX_LVL(vict) >= LVL_ETRNL1) {
    sprintf(buf,
          "\r\n     Room Flags: %-3s    " " Wiznet Channel: %-3s\r\n"
          "      No Hassle: %-3s    " " Immnet Channel: %-3s\r\n"
          "     Holy Light: %-3s\r\n",
 
a5224 1
 
a5228 1

a5232 1

a5234 1

a5237 1

a5238 1

a5244 1

a5246 1

d5248 2
a5249 1
  for (a = 1; a < num_of_cmds; a++) {
a5252 1

a5254 1

d5259 2
a5260 1
		 cmd_info[cmd_sort_info[b].sort_pos].command) > 0) {
d5285 2
a5286 2
                char *arg, int *cmd_num) {

a5291 1

a5294 1

d5296 2
a5297 1
  if ((cmd = search_block_case_insens(arg, cmd_types, FALSE)) != -1) {
a5300 1

a5302 1
  
d5304 2
a5305 1
  if ((find = generic_find_char(ch, arg, FIND_CHAR_WORLD))) {
d5308 1
a5308 1
    if (IS_NPC(find) && GET_LEVEL(ch) < LVL_GOD) {
d5310 1
a5310 2
    }
    if (!IS_NPC(find) && GET_LEVEL(ch) < GET_LEVEL(find)) {
a5311 1
    }
d5318 2
a5319 2
                int subcmd, int cmdtype) {

d5324 1
a5324 1
  if (cmdtype > -1) {
d5326 1
a5326 3
  }

  if (subcmd == SCMD_WIZHELP) {
d5328 1
a5328 2
  }
  if (subcmd == SCMD_SOCIALS) {
a5329 2
  }

d5331 1
a5331 2
          (cmdtype > -1) ? command_type : "",
	  wizhelp ? "privileged " : "",
a5333 1
  
d5335 2
a5336 1
  for (no = 1, cmd_num = 1; cmd_num < num_of_cmds; cmd_num++) {
a5337 1

d5343 4
a5346 3
         (socials == cmd_sort_info[i].is_social) || cmdtype == CMD_SOCIAL)) {

      if (cmdtype < 0 || cmd_info[i].type == cmdtype) {
d5370 2
a5371 1
  if (subcmd == SCMD_COMMANDS) {
a5373 1

d5375 1
a5375 1
    for (int i = 1; i < NUM_CMD_TYPES; i++) {
d5377 1
a5377 2
    }
  } else if (subcmd == SCMD_WIZHELP) {
d5379 1
a5379 1
  } else {
a5380 2
  } 

d5382 2
a5383 3

  if (subcmd != SCMD_SOCIALS && *arg) {

d5386 3
a5388 3

    if (subcmd == SCMD_COMMANDS && 
                    (cmd_pass == CPASS_NONE || cmd_pass == CPASS_VICT)) {
a5391 1

d5393 3
a5395 2
    if (subcmd == SCMD_COMMANDS && 
                    (cmd_pass == CPASS_ALL || cmd_pass == CPASS_SUBCMD)) {
d5398 1
a5398 2
      if (*arg) {
        // only need to set vict ...
a5399 1
      }
a5404 1
  
a5407 82
/* 
#undef CLAN_TABLE_ALL
#define CLAN_TABLE_LEADER
 -- ARTUS: Old clan stuff.
*/
/* DM - display the clan tables */
/* -- ARTUS: Old clan stuff.
ACMD(do_clan_table)
{
  struct clan_data *clan;
 
  one_argument(argument,arg);
 
  if (IS_NPC(ch))
    return;
 
  if (GET_LEVEL(ch) >= LVL_ANGEL)
    if (!*arg) {
      send_to_char("Which clan?\r\n",ch);
      return;
    } else {
      if (!(clan=get_clan_by_name(arg))) {
        send_to_char("That is not a clan, type 'clans' to see the list.\r\n",ch);
        return;
      } else {
        display_clan_table(ch,clan);
        return;
      }
    }
 
  #ifdef CLAN_TABLE_ALL
    if (!(clan=get_clan_by_num(GET_CLAN_NUM(ch)))) {
      send_to_char("You are not a clan member.\r\n",ch);
      return;
    } else {
      display_clan_table(ch,clan);
      return;
    }
  #endif
 
  #ifdef CLAN_TABLE_LEADER
    if ((GET_CLAN_NUM(ch) != 0) && (EXT_FLAGGED(ch, EXT_LEADER))) {
      if (!(clan=get_clan_by_num(GET_CLAN_NUM(ch)))) { 
        sprintf(buf,"Clan Error: Clan Numb %d, char %s",
                GET_CLAN_NUM(ch),GET_NAME(ch));
        return;
      } else {
        display_clan_table(ch,clan);
        return;
      }
    } else {
      send_to_char("Sorry you cannot do that.\r\n",ch);
      return;
    }
  #endif
 
  send_to_char("Sorry you cannot do that.\r\n",ch);
  return;
} 
*/

/* DM - display the clans */
/* -- ARTUS: Old clan stuff.
ACMD(do_clans)
{
  int i,j;
 
  sprintf(buf,"Current clans:\r\n");
  strcat (buf,"--------------\r\n");
 
  for (i=0; i < NUM_CLANS; i++) {
    sprintf(buf2,"&B%s&n", clan_info[i].disp_name);
    strcat(buf,buf2);
    for (j=0; j < (MAX_LEN-strlen(clan_info[i].disp_name)); j++)
      strcat(buf," ");
    sprintf(buf2,"(&B%s&n)\r\n",clan_info[i].name);
    strcat(buf,buf2);
  }
  page_string(ch->desc, buf, TRUE);
}
*/

a5410 1

d5412 2
a5413 2

  for (index=0; index < NUM_CLASSES; index++) {
a5419 23
/* -- ARTUS: Old clan stuff.
void display_clan_table(struct char_data *ch, struct clan_data *clan)
{
  int i;
 
  if (!clan)
    return;
 
  sprintf(buf,"Members of the &B%s&n:\r\n",clan->disp_name);
  sprintf(buf2,"----------------");
  for (i=0; i < strlen(clan->disp_name); i++)
    strcat(buf2,"-");
 
  strcat(buf2,"\r\n");
  strcat(buf,buf2);
 
  sprintf(buf2,"%s",clan->table);
  strcat(buf,buf2);
 
  page_string(ch->desc,buf,TRUE);
}
*/

d5424 1
a5424 1
  char *usage="&1Usage:&n &4colourset&n [-<0..9> { <colourcode> | Default }]\r\n";
a5426 1

a5428 1

a5430 1

d5433 2
a5434 2

  while (*buf) {
d5436 2
a5437 1
    if (*arg == '-') {
d5439 2
a5440 1
      if (isnum(mode)) {
a5441 1
        
d5443 2
a5444 1
        if (!strn_cmp(arg,"default",3)) {
d5465 11
a5475 25
          
         
  if (no_args) {

    sprintf(buf,"&1Personal colour settings:&n\r\n");
    sprintf(buf2,"&&0. &0%s&n\r\n",colour_headings[0]);
    strcat(buf,buf2);
    sprintf(buf2,"&&1. &1%s&n\r\n",colour_headings[1]);
    strcat(buf,buf2);
    sprintf(buf2,"&&2. &2%s&n\r\n",colour_headings[2]);
    strcat(buf,buf2);
    sprintf(buf2,"&&3. &3%s&n\r\n",colour_headings[3]);
    strcat(buf,buf2);
    sprintf(buf2,"&&4. &4%s&n\r\n",colour_headings[4]);
    strcat(buf,buf2);
    sprintf(buf2,"&&5. &5%s&n\r\n",colour_headings[5]);
    strcat(buf,buf2);
    sprintf(buf2,"&&6. &6%s&n\r\n",colour_headings[6]);
    strcat(buf,buf2);
    sprintf(buf2,"&&7. &7%s&n\r\n",colour_headings[7]);
    strcat(buf,buf2);
    sprintf(buf2,"&&8. &8%s&n\r\n",colour_headings[8]);
    strcat(buf,buf2);
    sprintf(buf2,"&&9. &9%s&n\r\n",colour_headings[9]);
    strcat(buf,buf2);
d5478 2
a5479 1
    for (i=0;i<10;i++) {
d5481 1
a5481 1
      if (colour_codes[i] == 69) {
d5483 1
a5483 1
      } else if (colour_codes[i] >= 0) {
a5484 1
      }
a5490 1

a5534 1

a5535 1

a5540 1

a5545 1

a5552 1

a5558 1

a5560 1

d5564 2
a5565 1
    k = number(zone_table[ev->room->zone].number * 100, zone_table[ev->room->zone].top);
a5568 1

a5572 5

    /* Artus> 1% chance of gold being deposited...
    if (number(1, 100) != 1)
      continue; Removed */

a5575 1

d5612 7
a5618 2
	send_to_char("You burn to a crisp!\r\n", cburning);
	die(cburning, NULL, "FIRE!");
a5671 1
  
d5760 2
a5761 1
  if (!(target)) {
a5764 1

d5767 2
a5768 2

  if (!target->people) {
d5775 1
a5775 2

  if (count == 1) {
d5777 2
a5778 1
  } else if (count < 5) {
d5780 2
a5781 1
    switch (direction) {
d5799 1
a5799 1
  } else {
a5800 1
  }
a5816 1

a5845 1

a5968 1
   
d5970 1
a5970 2
	return TRUE; 
 
d5975 1
a5975 2
	return TRUE;	// Could have cleared burglary out

a5976 1
  {
d5978 1
a5978 3
	return FALSE;
   }

a5985 1

d5987 1
a5987 2
	return;

d5989 3
a5991 4
	return;

  int nLevel =int((number(GET_LEVEL(ch) -3, GET_LEVEL(ch) + 3) 
			+ int(GET_MODIFIER(ch))) * fStrength);
d5993 1
a5993 1
	nLevel = 250;
d5995 1
a5995 1
        nLevel = 1 + number(0,2);
a5996 1

d5998 2
a5999 1
  GET_MAX_HIT(mob) = int(number(int(GET_MAX_HIT(ch) * 0.9), int(GET_MAX_HIT(ch) * 1.1)) * fStrength);
d6005 2
a6006 1
  GET_GOLD(mob) = int((100 * GET_LEVEL(ch) * (int(GET_MODIFIER(ch))+ 1)) * fStrength);
d6008 2
a6009 2
		            int(level_exp(ch, GET_LEVEL(ch)) * 0.05))) * fStrength);

d6022 2
a6023 2
	mudlog("Random Burgle Encounter - cannot read mobile.", NRM, LVL_GOD, TRUE);
	return;
a6024 1

a6038 1

a6043 1

a6070 1
 
a6072 1

d6082 2
a6083 1
      send_to_char("... you have cut in on someone else's burglary!\r\n", burglar);	
a6104 1

a6119 1

a6120 1

a6128 1

d6136 14
a6149 17
	struct event_data *ev;

	// Get the event
	for( ev = events.list; ev; ev = ev->next ) 
		if( ev->type == EVENT_ELECTION )
			break;

	// A double check, just in case
	if (ev == NULL)
	{
	   send_to_char("No election is being held at this time.\r\n", ch);
	   return;
	}

	sprintf(buf, "Current election status is #1: %d, #2: %d, #3: %d.\r\n", 
		ev->info1, ev->info2, ev->info3);
	send_to_char(buf, ch);
d6152 53
a6204 52
ACMD(do_vote) {

	struct event_data *ev;
	
	if( IS_NPC(ch) ) {
		send_to_char("Hate to say it, but some votes just don't count!\r\n", ch);
		return;
	}

	one_argument(argument, arg);
	if (*arg && strcmp(arg, "status") == 0 && check_for_event(EVENT_ELECTION, -1))
	{
	   show_election_status(ch);
	   return;
	}

	// Check if player can vote
	if ((GET_VOTED(ch) == TRUE) || LR_FAIL(ch, vote_level) ||
	    !check_for_event(EVENT_ELECTION, -1)) {
		send_to_char("You cannot place a vote at this time.\r\n", ch);
		return;
	}

	one_argument(argument, arg);
	
	if( !*arg ) {
		send_to_char("You are eligible to vote.\r\n", ch);
		return;
	}

	if( !isdigit(arg[0]) ) {
		send_to_char("Your vote must be a digit or 'status'.\r\n", ch);
		return;
	}

	// Get the event
	for( ev = events.list; ev; ev = ev->next ) 
		if( ev->type == EVENT_ELECTION )
			break;

	switch(atoi(arg)) {
		case 1: ev->info1 = ev->info1 + 1; break;
		case 2: ev->info2 = ev->info2 + 1; break;
		case 3: ev->info3 = ev->info3 + 1; break;
		default:
			send_to_char("Your vote must be either '1', '2' or '3'.\r\n", ch);
			return;
	}

	send_to_char("Your vote has been registered. Thank you for your participation.\r\n",ch);
	GET_VOTED(ch) = TRUE;
	
a6210 1

a6211 1

a6240 1

a6241 1

d6279 4
a6282 4
	int bounty_count = 0, amount = 0;
	struct event_data *ev = NULL;
	struct char_data *vict = NULL;
	struct obj_data *obj = NULL;
d6284 3
a6286 3
	// NPC's are alloted bounty hunting differently
	if( IS_NPC(ch) )
		return;
d6288 2
a6289 2
	// Check that there is some kind of valid item in the room
	/* Do this whenever */
d6291 1
a6291 2

	// Check that the player's class is an appropriate class
d6293 32
a6324 34
	    class != CLASS_PALADIN && class != CLASS_NIGHTBLADE) {
		send_to_char("Better leave the hunting to the pro's.\r\n",ch);
		return;
	}
 */
	/* Check for skill instead of class here */


  	// If there are no arguments, just list the bounties
	if( !*argument ) {
	  // Go through the events, and list the details
	  for(ev = events.list; ev; ev = ev->next) {
		// Sift out the inappropriate events
		if( ev->type != EVENT_BOUNTY_HUNT )
			continue;
		// Get the bounty victim's name
		sprintf(buf, "(%2d) Bounty open for: &r%s&n.",
			bounty_count + 1, get_name_by_id(ev->chID));
		// The reward
		sprintf(buf + strlen(buf),
			"\r\n     Reward: &Y%d&n", ev->info1);
		// Who started it
		sprintf(buf + strlen(buf), 
			" coins on behalf of %s.", 
		 (ev->info3 != THE_LAW ? get_name_by_id(ev->info3): "the law")); 
		// The room to return to
		sprintf(buf + strlen(buf), "\r\n     Collect at: %s\r\n",
			ev->room->name);
		send_to_char(buf, ch);
		bounty_count++;
	  }

	  if( bounty_count == 0 )
		send_to_char("No bounties available at this time.\r\n",ch);
d6326 42
d6369 4
a6372 99

	} // No arguments


	/* Check here, if they're bountying an item?! -- easily done
	 * but have to break up the function into multiple parts
	 * so I'll do it later.
	 */
	
	// Grab the arguments
	two_arguments(argument, arg, buf1);

	/* Check the first argument for what type of bounty they're after*/
	if( strcmp(arg, "item") == 0 ) {
		/* HAndle Item bounty here */
		return;
	}

	/* If there is no second argument, attempt to remove the bounty
	 * on the player indicated, assuming they set up the bounty in 
	 * the first place, otherwise, they're trying to collect.
	 */
	if( !*buf1 ) {
		// Are they trying to cancel or collect the bounty?
		for(ev = events.list; ev; ev = ev->next) {
		  // Valid bounty event?
		  if( ev->type != EVENT_BOUNTY_HUNT ) 
		    continue;
		  // Is the event target the argument?
		  if( get_id_by_name(arg) == ev->chID ) {

 		     // Did they set it up? If so, cancel.
		     if( GET_IDNUM(ch) == ev->info3 ) {
		       act("$n removes a bounty.", FALSE, ch, 0, 0,TO_ROOM);
 		       int nGoldBack = int(ev->info1 - (0.10*ev->info1));
		       send_to_char("You cancel the bounty, forfeitting your cancellation fee.\r\n", ch);
		       sprintf(buf, "&Y%d&n coins are returned.\r\n", nGoldBack);
		       send_to_char(buf, ch);
		       // Money back, less 10%
		       GET_GOLD(ch) += nGoldBack;

		       ev->type = EVENT_OVER;
		       return;
		     } // If they set it up	

		     one_argument(argument, arg); // Dunno why I need this.

		     // If they didn't set it up, they're trying to collect
		     if((obj = generic_find_obj(ch, "corpse", FIND_OBJ_INV)) == NULL)
		     {
			send_to_char("You hopelessly try to collect the bounty.\r\n", ch);			
		        return;
		     } // Do they have the appropriate item?
		     arg[0] = UPPER(arg[0]);
	             sprintf(buf, "the corpse of %s", arg);
		     if( strcmp(obj->short_description, buf) != 0 )
		     {
			send_to_char("Hmm, that doesn't look like the right corpse.\r\n", ch);
		        return;
	 	     } 

		     // Successful bounty collection!
		     amount = (int)(ev->info1 * 0.95);
		     act("$n hands over a bounty, collecting %s reward!\r\n", FALSE, ch, 0, 0, TO_ROOM);
		     sprintf(buf, "You hand over your bounty, collecting &Y%d&n coins!\r\n", amount);	
		     send_to_char(buf, ch);
		     // Extract the item
		     extract_obj(obj);
		     GET_GOLD(ch) += amount;
		     // Notify initiator
		     if( ev->info3 != THE_LAW )
		     {
		        sprintf(buf, "Your bounty on %s for %d was collected!\r\n",
			   get_name_by_id(ev->chID), ev->info1);
		        send_to_char(buf, generic_find_char(ch,
			   get_name_by_id(ev->info3), FIND_CHAR_WORLD)); 
		     }
		     // Else - Run a  message on the board, declaring capture
		     else
                     {
			/*TODO: Message on bounty board */
			// DM - hmm removing quest points for the mean time
			// (commented out quest points)
			send_to_char("The lawful authorities thank you and reward you with an additional Quest Point!\r\n", ch);
			//GET_QUEST_POINTS(ch) += 1;
                     }
		     // Finally, delete the event
		     ev->type = EVENT_OVER;
		     return; 
		 } // If this event is the one with the player

		}  // For every event

		return;
        }

	/* New Bounty!  */
	// character visible?
	if (!(vict = generic_find_char(ch, arg, FIND_CHAR_WORLD)))
d6374 16
a6389 5
		send_to_char("Put a bounty up on who!?\r\n", ch);
		return;
	}

	if( !isdigit(buf1[0]) )
d6391 11
a6401 10
		send_to_char("You have to put up a cash amount.\r\n", ch);
		return;
  	}

	amount = atoi(buf1);
	
	// Check their balance
	if( GET_GOLD(ch) < amount  && GET_BANK_GOLD(ch) < amount ) { 
		send_to_char("You don't have the cash resources for that right now.\r\n", ch);
		return;
d6403 53
a6455 31

	// Validate the amount is a logical one
	if( amount < ( GET_LEVEL(vict) * 10000 ) 
	 || (!LR_FAIL(vict, LVL_GOD)) ) {
		send_to_char("Get real, noone would risk that bounty for that piddling cash reward!\r\n", ch);
		return;
	}
	
	// Get the cash
	if( GET_GOLD(ch) >= amount )
		GET_GOLD(ch) -= amount;
	else
		GET_BANK_GOLD(ch) -= amount;

	// Create the event
	CREATE(ev, struct event_data, 1);
	// Set it up
	ev->chID = GET_IDNUM(vict); 		// Target
	ev->info1 = amount;	// Bounty offered
	ev->info3 = get_id_by_name(GET_NAME(ch)); // Bounty initiator ID	
	ev->type = EVENT_BOUNTY_HUNT;	// Ahuh.
	ev->room = &world[real_room(BOUNTY_RETURN_ROOM)]; //&world[ch->in_room];

	// Add it to the list
	add_mud_event(ev);

	// Notify the room
	act("$n puts up a new bounty.", FALSE, ch, 0, 0, TO_ROOM);
	sprintf(buf, "You put up a bounty on &B%s&n for &Y%d&n coins.\r\n", 	
	     	GET_NAME(vict), amount);
	send_to_char(buf, ch);
a6457 1

@


1.122
log
@Artus> Slight modification to do_users();
@
text
@a77 2
char *title_male(int chclass, int level);
char *title_female(int chclass, int level);
d161 2
a162 1
void print_who_info(struct char_data *array[], int length, struct char_data *ch);
d621 2
a622 2
	struct char_data *victim;
	int diff = 0;
d624 5
a628 5
	if (!*arg)
	{
	  send_to_char("Sense whose stats?\r\n", ch);
	  return;
	}
d630 45
a674 49
	// Find the target
        if (!(victim = generic_find_char(ch, arg, FIND_CHAR_ROOM))) 
	{
	   send_to_char("You sense a big empty spot where you think they should be!\r\n", ch);
	   return;
	}
  
	// If it's an npc, the amount of info they get varies according to relative power
	if (IS_NPC(victim))
	{
	  diff = GET_LEVEL(victim) - GET_LEVEL(ch);	
  
	  // Give some basic info
          sprinttype(GET_CLASS(victim), npc_class_types, buf2);
	  sprintf(buf, "%-20s %s\r\n%-20s %s \r\n%-20s %d\r\n", 
		"Name:", GET_NAME(victim), "Type:", buf2, "Level:", GET_LEVEL(victim));

	  if (diff < 5 )// Npc is possibly much more powerful
	  {
		sprintf(buf + strlen(buf), "%-20s %s\r\n%-20s %d\r\n", "Special Powers:",
			GET_MOB_SPEC(victim) ? "Yes" : "No", "Gold:", GET_GOLD(victim));
  	  }

	  if (diff <= 0 )	// PC is somewhat more powerful
	  {
	    sprintf(buf + strlen(buf), "%-20s %d/%d \r\n%-20s %d\r\n", "Life Force:", 
	       	GET_HIT(victim), GET_MAX_HIT(victim), "Combat Skill Rating:", thaco(victim, NULL));
	  }
	  if ( diff < -5 ) // Player is way more powerful, give some good info
	  {
	     sprintf(buf + strlen(buf), "%-20s %d \r\n%-20s %d\r\n%-20s %d\r\n",
 	  	"Damage Bonus:", GET_DAMROLL(victim), 
		"Hitroll Bonus:", GET_HITROLL(victim), "Armour Class:", compute_armor_class(victim, 0));
	  }
	
	  send_to_char(buf, ch);
	  return;
	}

	// Okay they're sensing a player
	if (GET_LEVEL(victim) >= LVL_IMMORT && LR_FAIL(ch, LVL_IMMORT))
	{
	  send_to_char("You sense a mighty being, able to crush you with a snap of their fingers!\r\n",ch);
	  act("$n just tried to sense your abilities, but failed, as mortals are wont to do.",
		FALSE, ch, 0, victim, TO_VICT);
	  return;
	}

	
d679 27
a705 31
	two_arguments(argument, buf, buf1);

	if (!GET_SKILL(ch, SKILL_SENSE_CURSE) && !GET_SKILL(ch, SKILL_SENSE_STATS))
	{
		send_to_char("You have no idea how to.\r\n", ch);
		return;
	}

	if( !*buf )
	{
           strcpy(buf, "You are able to sense");
	   if (GET_SKILL(ch, SKILL_SENSE_CURSE))
	   	strcat(buf, " &Bcurses&n");
	   if (GET_SKILL(ch, SKILL_SENSE_CURSE) && GET_SKILL(ch, SKILL_SENSE_STATS))
		strcat(buf, " and");
	   if (GET_SKILL(ch, SKILL_SENSE_STATS))
	   	strcat(buf, " &Bstats&n");
	   strcat(buf, ".\r\n");
	   send_to_char(buf, ch);
	   return;
	}	

	toUpper((char *)buf);
	if (strcmp(buf, "STATS") == 0)
		mortal_stat(ch, buf1);
	else if (strcmp(buf, "CURSES") == 0)
		mortal_detectcurses(ch);
	else
	 	send_to_char("You have no idea how to sense for that.\r\n", ch);
		
	return;
d715 1
a715 1
  if( GET_OBJ_VAL(obj, 0) == 0 )
a726 1

a728 1

d730 1
a730 2

  if( GET_OBJ_VAL(obj, 0) == 1 ) 
d736 10
a745 10
  }	else {   // Room affect
     send_to_char("The trap goes off, damaging everyone nearby.\r\n", ch);
     act("The trap goes off, damaging everyone in the vicinity!", 
	  FALSE, ch, 0, 0, TO_ROOM);	
     for( d = descriptor_list; d; d = d->next ) {
	  if(d->character && ((d->character)->in_room == ch->in_room) &&
	     (d->character != ch))
	    damage(NULL, d->character, dam, TYPE_UNDEFINED, FALSE);
	    // GET_HIT(d->character) -= damage; // Do damage
     } // Every descriptor
a746 1

d748 1
a748 1
  if( GET_OBJ_VAL(obj, 3) >= 1 )
d750 4
a753 4
      temp = read_object(GET_OBJ_VAL(obj, 3), VIRTUAL);
      act("You find $p in the aftermath.", FALSE, ch, temp,0,TO_CHAR);
      act("You spot $p in the aftermath.", FALSE, ch, temp,0,TO_ROOM);
      obj_to_room(temp, ch->in_room);
a754 1

d759 5
a763 1
ACMD(do_search) {
d765 92
a856 10
	int chance = 0, i, counter = 0, baseChance = 0;
	struct room_data *r;
	struct obj_data *o;

	if( IS_NPC(ch))
		return;

	if( AFF_FLAGGED(ch, AFF_PARALYZED) ) {
	  send_to_char("Your limbs won't respond. You're paralysed!\r\n",ch);
	  return;
d858 4
a861 74
	
 	if( !GET_SKILL(ch, SKILL_SEARCH)) {
	   send_to_char("You stumble around, but achieve nothing.\r\n",ch);
	   return;
	}
	
	if( IS_THIEF(ch) )	// Favour thief for multi-classed
		baseChance = 15;	// 15%
	else if( IS_MAGIC_USER(ch) )
		baseChance = 5;	// 5%
	else
		baseChance = 2;	// 2%

        if (IS_SET(GET_SPECIALS(ch), SPECIAL_THIEF))
		baseChance += 40;	// +40% for enhanced thieves

	r = &world[ch->in_room];

	// first, check for exits
	for(i = 0; i < NUM_OF_DIRS; i++ ) {
		if( r->dir_option[i] == NULL )
			continue;

		if( EXIT_FLAGGED(EXIT(ch, i), EX_ISDOOR) &&
		    EXIT_FLAGGED(EXIT(ch, i), EX_CLOSED) ) {
		   sprintf(buf, "You find an exit leading %s.\r\n", dirs[i]);
		   send_to_char(buf, ch);
		   counter++;
		} 
	}

        // Change the basechance according to player level and class and modifier
        chance = baseChance  
	    +	(GET_LEVEL(ch) > 90 ? 10 : GET_LEVEL(ch) > 50 ? 7 : GET_LEVEL(ch) > 25 ? 4 : 2)
	    +   (GET_CLASS(ch) == CLASS_MASTER ? 10 : GET_CLASS(ch) == CLASS_NIGHTBLADE ? 9 :
		GET_CLASS(ch) == CLASS_SPELLSWORD ? 9 : GET_CLASS(ch) > CLASS_WARRIOR ? 5 : 2)
	    +   int(GET_MODIFIER(ch));

        if (chance > 90)
	   chance = 90;

	// Now do the real looking
	for( o = r->contents; o; o = o->next_content) {
	  if( OBJ_FLAGGED(o, ITEM_HIDDEN))
	     if( number(1, 100) > 100-chance ) {
		act("You find $p, hidden nearby!", FALSE, ch, o, 0, TO_CHAR);
	        act("$n finds $p, hidden nearby!", FALSE, ch, o, 0, TO_ROOM);
	        counter++;
		REMOVE_BIT(o->obj_flags.extra_flags, ITEM_HIDDEN);
		// Check if it's a trap!
		if( GET_OBJ_TYPE(o) == ITEM_TRAP ) {
                   send_to_char("&RIt's a trap! ", ch);
		   if( number(1, baseChance) == baseChance) {  // favour thieves
		      ch_trigger_trap(ch, o);
		   }
		   else
                   {
			send_to_char("&g .. but you manage not to trigger it.&n\r\n",ch);
			// Check if it was hiding an item
			if(GET_OBJ_VAL(o, 3) != 0)
			{
                           extract_obj(o);
			   o = read_object(GET_OBJ_VAL(o, 3), VIRTUAL);
			   act("... The trap was protecting $p!", FALSE, ch, o, 0, TO_CHAR);
			   act("$n found $p under a trap!", FALSE, ch, o, 0, TO_ROOM);
			   obj_to_room(o, ch->in_room);
			}
                   }
		}
	     }
	}

	if( !counter )
		send_to_char("You find nothing unusual.\r\n", ch);
d864 2
a865 4


void sort(long list[], long owners[], int num) {

a867 1
  
d870 2
a871 1
      if (list[j] > list[j + 1]) {	    
a874 1

d1368 2
a1369 1
  if (ch != i && (IS_THIEF(ch) || !LR_FAIL(ch, LVL_IMMORT))) {
d1372 5
a1376 5

	list_obj_to_char(i->carrying, ch, 1, FALSE);
   // for (tmp_obj = i->carrying; tmp_obj; tmp_obj = tmp_obj->next_content) {
//      if (CAN_SEE_OBJ(ch, tmp_obj) && (number(0, 20) < GET_LEVEL(ch))) {
	//show_obj_to_char(tmp_obj, ch, 1);
d1380 2
a1381 3

//    if (!found)
//      send_to_char("You can't see anything.\r\n", ch);
d1385 19
a1403 21
void list_rider(struct char_data *i, struct char_data *ch, int mode) {

	if (CAN_SEE(ch, i)) {
	   if (MOUNTING(i)) {
	      if (IS_NPC(i)) {
		sprintf(buf2, "...ridden by %s.", (MOUNTING(i) == ch ? "you" : (CAN_SEE(ch,MOUNTING(i))
			 ? GET_NAME(MOUNTING(i)) : "someone")) );
		if (mode == 1)
		    strcat(buf, buf2);
		if (mode == 0)
		    act(buf2, FALSE, i, 0, ch, TO_VICT);
	      }
	      else {
		if (mode == 1)
		   strcat(buf2, " (mounted)");
		if (mode == 0)
		   act( " (mounted)", FALSE, i, 0, ch, TO_VICT);
	      }
	   }
	}

a1405 1

d1420 3
a1422 2
  if (IS_NPC(i) && i->player.long_descr && GET_POS(i) == GET_DEFAULT_POS(i)) {
    if (AFF_FLAGGED(i, AFF_INVISIBLE)) {
d1424 1
a1424 1
    } else {
d1426 3
a1428 5
    }
      //*buf = '\0';

    if (AFF_FLAGGED(ch, AFF_DETECT_ALIGN)) {
      if (IS_EVIL(i)) {
d1430 1
a1430 1
      } else if (IS_GOOD(i)) {
a1431 1
      }
a1434 1

a1437 1

d1445 1
a1445 1
	list_rider(i, ch, 0);
d1448 2
a1449 1
  if (IS_NPC(i)) {
d1453 1
a1453 1
  } else
d1469 1
a1469 1

a1481 1

d1483 1
d1488 3
a1490 2
  else {
    if (FIGHTING(i)) {
d1494 2
a1495 1
      else {
d1505 2
a1506 2

  if (AFF_FLAGGED(ch, AFF_DETECT_ALIGN)) {
d1513 1
a1513 1
	list_rider(i, ch, 1);
d1525 1
a1525 1
	list_rider(i, ch, 0);
a1527 2


d1533 2
a1534 1
    if (ch != i) {
d1582 2
a1583 1
  if (AFF_FLAGGED(ch, AFF_BLIND)) {
d1589 2
a1590 1
	!EXIT_FLAGGED(EXIT(ch, door), EX_CLOSED)) {
d1595 2
a1596 1
      else {
d1600 2
a1601 1
	else {
a1608 1

d1915 1
a1915 1
      if (GET_LEVEL(found_char) > LVL_IMMORT)
d1926 2
a1927 1
  if (!(fnum = get_number(&arg))) {
d1933 2
a1934 1
  if ((desc = find_exdesc(arg, world[ch->in_room].ex_description)) != NULL && ++i == fnum)
d1941 1
a1941 1
  for (j = 0; j < NUM_WEARS && !found; j++)
a1951 1

d1953 2
a1954 1
  for (obj = ch->carrying; obj && !found; obj = obj->next_content) {
d1956 2
a1957 1
      if ((desc = find_exdesc(arg, obj->ex_description)) != NULL && ++i == fnum)
a1965 1

d1967 1
a1967 1
  for (obj = world[ch->in_room].contents; obj && !found; obj = obj->next_content)
d1969 3
a1971 1
      if ((desc = find_exdesc(arg, obj->ex_description)) != NULL && ++i == fnum) {
a1977 1

a1988 1

d2680 2
a2681 1
  if (!IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_DISGUISE)) {
d3031 1
a3031 1
  else if (j >= LVL_IMMORT)
d3033 1
a3033 1
  else if (j >= LVL_IMMORT)
d3130 1
a3130 2
/* Eleventh line - Damroll, gold, CHA */

d3956 1
a3956 1
  if (!LR_FAIL(ch, LVL_IMMORT))
d3964 4
a3967 1
    send_to_char("You have reached your classes maximum level. You might consider remorting.\r\n", ch);
d3996 18
a4013 1
    else
d4342 1
a4342 1
"&1usage: &4who [minlev[-maxlev]] [-i [clan num]] [-n name] [-c classlist]\r\n[-a] [-b] [-t] [-s] [-o] [-q] [-r] [-z]\r\n"
d4363 2
a4364 1
  while (*buf) {
d4366 58
a4423 1
    if (isdigit(*arg)) {
a4425 56
    } else if (*arg == '-') {
      mode = *(arg + 1);       // just in case; we destroy arg in the switch 
      switch (mode) {
      case 'a':
        orderCharName = 1;
        strcpy(buf,buf1);
        break;
      case 'b':
        orderCharLevelA = 1;
        strcpy(buf,buf1);
        break;
      case 't':
        orderCharTime = 1;
        strcpy(buf,buf1);
        break;
      case 'i':
        showClanOnly = 1;
	half_chop(buf1, clan_search, buf);
        break;
      case 'o':
	outlaws = 1;
	strcpy(buf, buf1);
	break;
      case 'z':
	localwho = 1;
	strcpy(buf, buf1);
	break;
      case 's':
	short_list = 1;
	strcpy(buf, buf1);
	break;
      case 'q':
	questwho = 1;
	strcpy(buf, buf1);
	break;
      case 'l':
	half_chop(buf1, arg, buf);
	sscanf(arg, "%d-%d", &low, &high);
	break;
      case 'n':
	half_chop(buf1, name_search, buf);
	break;
      case 'r':
	who_room = 1;
	strcpy(buf, buf1);
	break;
      case 'c':
	half_chop(buf1, arg, buf);
	for (i = 0; i < strlen(arg); i++)
	  showclass |= find_class_bitvector(arg[i]);
	break;
      default:
	send_to_char(WHO_FORMAT, ch);
	return;
      }				// end of switch 

d4433 4
a4436 2
  if (showClanOnly) {
    if (*clan_search) {
d4438 2
a4439 1
      if ((clanNumber = find_clan_by_sid(clan_search)) < 0) {
d4445 2
a4446 1
      if (GET_CLAN(ch) < 1) {
d4456 2
a4457 1
  for (d = descriptor_list; d; d = d->next) {
a4460 1

a4464 1

d4483 2
a4484 1
    if (short_list) {
a4485 1
      
d4492 1
a4492 1
	       GET_REM_ONE(tch) > 0 ? CCGRN(ch, C_SPR) : CCWHT(ch, C_SPR),
d4494 7
a4500 5
      	      (GET_LEVEL(tch) >= LVL_GOD ? CCBYEL(ch,C_SPR) :
              (GET_LEVEL(tch) >= LVL_ANGEL ? CCCYN(ch,C_SPR) :
              (GET_LEVEL(tch) >= LVL_LEGEND ? CCMAG(ch,C_SPR) : 
              (GET_LEVEL(tch) >= LVL_IMMORT ? CCRED(ch,C_SPR) :
              (GET_LEVEL(tch) >= LVL_ETRNL1 ? CCBBLU(ch, C_SPR) : CCWHT(ch, C_SPR)))))),
d4502 1
a4502 1
              (GET_LEVEL(tch) >= LVL_IS_GOD || GET_LEVEL(tch) >= LVL_ETRNL1 ? CCNRM(ch, C_SPR) : ""),
a4509 2
  

d4511 1
a4511 1
  if (orderCharName) {
d4513 7
a4519 13

  // Ordered by Level Ascending
  } else if (orderCharLevelA) {
    qsort(theWhoList, noElements, sizeof(struct char_data *), compareCharLevelA);

  // Unsorted (by time)
  } else if (orderCharTime) {

  // Default ordering is Level Descending
  } else {
    qsort(theWhoList, noElements, sizeof(struct char_data *), compareCharLevelD);
  }
          
a4521 1
  
d4533 16
a4548 19
int compareAffectDuration(const void *l, const void *r) {

    struct affected_type **left;
    struct affected_type **right;

    left = (struct affected_type **)l;
    right = (struct affected_type **)r;

    // sort -1 (unlimited durations) to head of list
    if ((*left)->duration == CLASS_ABILITY)
      return -1;
    if ((*right)->duration == CLASS_ABILITY)
      return 1;
    if ((*left)->duration == CLASS_ITEM)
      return -1;
    if ((*right)->duration == CLASS_ITEM)
      return 1;
    
    return ((*left)->duration < (*right)->duration);
d4552 2
a4553 2
int compareCharName(const void *l, const void *r) {

a4555 1

a4557 1

d4562 2
a4563 1
int compareCharLevelD(const void *l, const void *r) {
a4565 1

a4567 1

d4577 2
a4578 1
int compareCharLevelA(const void *l, const void *r) {
a4580 1

a4582 1

d4591 35
d4629 4
a4632 3
void print_who_info(struct char_data *array[], int length, struct char_data *ch) {

  int i,j;
d4634 1
a4634 1
  char s[5];
d4640 56
a4695 24
  for (i = 0; i < length; i++) {

      tch = array[i];

      sprintf(s,"%s",
              (GET_LEVEL(tch) == LVL_OWNER ? "ONR" :
               (GET_LEVEL(tch) >= LVL_GRIMPL ? "BCH" :
               (GET_LEVEL(tch) >= LVL_IMPL ? "IMP" :
               (GET_LEVEL(tch) >= LVL_GRGOD ? "GOD" :
               (GET_LEVEL(tch) >= LVL_GOD ? "DEI" :
               (GET_LEVEL(tch) >= LVL_LEGEND ? "LEG" :
               (GET_LEVEL(tch) >= LVL_ANGEL ? "ANG" :
               (GET_LEVEL(tch) >= LVL_IMMORT ? "IMM" : 
               (GET_LEVEL(tch) == LVL_ETRNL9 ? "ET9" : 
               (GET_LEVEL(tch) == LVL_ETRNL8 ? "ET8" : 
               (GET_LEVEL(tch) == LVL_ETRNL7 ? "ET7" : 
               (GET_LEVEL(tch) == LVL_ETRNL6 ? "ET6" : 
               (GET_LEVEL(tch) == LVL_ETRNL5 ? "ET5" : 
               (GET_LEVEL(tch) == LVL_ETRNL4 ? "ET4" : 
               (GET_LEVEL(tch) == LVL_ETRNL3 ? "ET3" : 
               (GET_LEVEL(tch) == LVL_ETRNL2 ? "ET2" : 
               (GET_LEVEL(tch) == LVL_ETRNL1 ? "ET1" : "PLR")))))))))))))))))); 

      if (strlen(GET_WHO_STR(tch)) > 0)
d4697 2
a4698 46
	int j = 10, k = 20;
	//sprintf(buf, "%s[", (GET_SOCIAL_STATUS(tch) <= SOCIAL_UNDESIRABLE ? 
	//      CCRED(ch, C_SPR) : GET_SOCIAL_STATUS(tch) <= SOCIAL_LANDOWNER ? 
	//      CCBLU(ch, C_SPR) : CCGRN(ch, C_SPR)));
	// DM - removed social status, now based on remort levels
	sprintf(buf, "%s&[[", 
	    (GET_REM_TWO(tch) > 0) ? CCCYN(ch, C_SPR) :
	    GET_REM_ONE(tch) > 0 ? CCGRN(ch, C_SPR) : CCWHT(ch, C_SPR));
	j -= (int)(strdisplen(GET_WHO_STR(tch)) / 2);
	k -= (j+strdisplen(GET_WHO_STR(tch)));
	for (int l = 0; l < j; l++)
	  strcat(buf, " ");
	strcat(buf, GET_WHO_STR(tch));
	for (int l = 0; l < k; l++)
	  strcat(buf, " ");
	sprintf(buf, "%s&]] %s%s %s&n", buf,
	  (GET_LEVEL(tch) >= LVL_GOD ? CCBYEL(ch, C_SPR) :
	   (GET_LEVEL(tch) >= LVL_ANGEL ? CCCYN(ch, C_SPR) :
	    (GET_LEVEL(tch) >= LVL_IMMORT ? CCBBLU(ch,C_SPR) : CCNRM(ch, C_SPR)))),
	  GET_NAME(tch), GET_TITLE(tch));
      } else {
	sprintf(buf, "%s&[[ %02d/%02d/%-3d %c %s %s &]] %s%s %s%s&n",
	        (GET_REM_TWO(tch) > 0) ? CCCYN(ch, C_SPR) :
	         GET_REM_ONE(tch) > 0 ? CCGRN(ch, C_SPR) : CCWHT(ch, C_SPR),
		GET_REM_ONE(tch), GET_REM_TWO(tch), GET_LEVEL(tch),
		(GET_SEX(tch)==SEX_MALE ? 'M' :
		 GET_SEX(tch)==SEX_FEMALE ? 'F' : '-'),
		CLASS_ABBR(tch),
		RACE_ABBR(tch),
		(GET_LEVEL(tch) >= LVL_GOD ? CCBYEL(ch, C_SPR) :
		 (GET_LEVEL(tch) >= LVL_ANGEL ? CCCYN(ch,C_SPR) :
		  (GET_LEVEL(tch) >= LVL_IMMORT ? CCBBLU(ch,C_SPR) : CCNRM(ch, C_SPR)))),
		GET_NAME(tch),
		GET_TITLE(tch),
		(GET_LEVEL(tch) >= LVL_GOD ? CCBYEL(ch, C_SPR) :
		 (GET_LEVEL(tch) >= LVL_ANGEL ? CCCYN(ch,C_SPR) :
		  (GET_LEVEL(tch) >= LVL_IMMORT ? CCBBLU(ch,C_SPR) : ""))));
      }

      if (GET_CLAN(tch) > 0) {
	int c;
	c = find_clan_by_id(GET_CLAN(tch));
        if (GET_CLAN_RANK(tch) == clan[c].ranks)
          strcat(buf, CCBLU(ch, C_SPR));
      
        sprintf(buf, "%s [%s - %s]&n", buf, clan[c].name, ((GET_CLAN_RANK(tch) < 1) ? "Applying" : clan[c].rank_name[(GET_CLAN_RANK(tch) - 1)]));
d4700 36
a4735 61
 
      if (GET_INVIS_LEV(tch)) {
        // Standard invis?
        if (GET_INVIS_TYPE(tch) == INVIS_NORMAL)
          sprintf(buf, "%s (i%d)", buf, GET_INVIS_LEV(tch));
        // Level invis?
        else if (GET_INVIS_TYPE(tch) == INVIS_SINGLE)
          sprintf(buf, "%s (i%ds)", buf, GET_INVIS_LEV(tch));
        // Player invis?
        else if (GET_INVIS_TYPE(tch) == INVIS_SPECIFIC)
          sprintf(buf, "%s (i-char)", buf);
        else
        // Ranged invis!
          sprintf(buf, "%s (i%d - %d)", buf, GET_INVIS_LEV(tch), GET_INVIS_TYPE(tch)); 
      } else if (IS_AFFECTED(tch, AFF_INVISIBLE))
        strcat(buf, " (invis)"); 

      if (IS_BUILDING(tch))
        strcat(buf, " (building)");
      else if (PLR_FLAGGED(tch, PLR_MAILING))
	strcat(buf, " (mailing)");
      else if (PLR_FLAGGED(tch, PLR_WRITING | PLR_ODDWRITE))
	strcat(buf, " (writing)");
      else if (PLR_FLAGGED(tch, PLR_REPORTING))
        strcat(buf, " (reporting)");

      for (j = 0; j < MAX_IGNORE; j++)
        if (GET_IGNORE(tch, j) > 0 || GET_IGN_LVL(tch) > 0) {
          strcat(buf, " (snob)");
          break;
        }
      if (PRF_FLAGGED(tch, PRF_AFK))
        strcat(buf, " (AFK)");
      if (PRF_FLAGGED(tch, PRF_DEAF))
	strcat(buf, " (deaf)");
      if (EXT_FLAGGED(tch, EXT_PKILL)) /* PK flag showing. - ARTUS */
        strcat(buf, " (PK)");
      if (PRF_FLAGGED(tch, PRF_NOTELL))
	strcat(buf, " (notell)");
      if (PRF_FLAGGED(tch, PRF_QUEST))
	strcat(buf, " (quest)");
      if (PLR_FLAGGED(tch, PLR_THIEF))
	strcat(buf, " (THIEF)");
      if (PLR_FLAGGED(tch, PLR_KILLER))
	strcat(buf, " (KILLER)");
      if (PRF_FLAGGED(tch, PRF_TAG))
        strcat(buf, " (tag)");
      if (world[IN_ROOM(tch)].number == IDLE_ROOM_VNUM)
	strcat(buf, " (limbo)");
      if (IS_GHOST(tch))
	strcat(buf, " (ghost)");
      if (GET_UNHOLINESS(tch) > 0)
      {
	char bufuv[9] = "";
	sprintf(bufuv, " (UV: %d)", GET_UNHOLINESS(tch));
	strcat(buf, bufuv);
      }
      if (GET_LEVEL(tch) >= LVL_ETRNL1)
        strcat(buf, CCNRM(ch, C_SPR));
      strcat(buf, "\r\n");
      strncat(buf2,buf,strlen(buf));
a4736 1

a4737 1

d5190 1
a5190 2

  if (LR_FAIL(ch, LVL_IMMORT))
d5202 2
a5203 1
  if (IS_NPC(ch)) {
d5209 2
a5210 1
  for (i = 1; i < LVL_IMMORT-1; i++) {
d5213 1
a5213 1
          i, i+1, level_exp(ch, i));
d5338 2
a5339 1
  if ((!*buf1) || LR_FAIL(ch, LVL_IMMORT)) {
d5344 3
a5346 2
  if (is_abbrev(buf1, "file")) {
    if ((!*buf2) || LR_FAIL(ch, LVL_IS_GOD)) {
d5348 2
a5349 1
    } else {
d5352 2
a5353 1
      if (load_char(buf2, &tmp_store) > -1) {
d5355 3
a5357 3
        if (GET_LEVEL(victim) > GET_LEVEL(ch))
          send_to_char("Sorry, you can't do that.\r\n", ch);
        else
d5366 1
a5366 1
    if ((victim = generic_find_char(ch, buf1, FIND_CHAR_WORLD))) {
d5368 1
a5368 1
    } else {
a5369 1
    }  
@


1.121
log
@Artus> Changed immlist to keep a list in memory instead of reading from disk.
@
text
@d4761 2
a4762 1
    if (*arg == '-') {
d4764 2
a4765 1
      switch (mode) {
d4768 2
a4769 1
        if (*buf1) {
d4772 1
a4772 1
          if (get_id_by_name(name) > 0) {
a4773 1
          }
d4779 2
a4780 2
        for (users = user_list; users; users=users->next) {

a4782 1
          
d4797 2
a4798 1
          if (users->logout) {
a4818 1

d4831 2
a4832 2

        if (singleuser) {
a4838 1

a4840 1

a4877 1

d4891 2
a4892 1
  for (d = descriptor_list; d; d = d->next) {
d4897 2
a4898 1
    if (IS_PLAYING(d)) { 
a4902 1

a4915 1

d4944 1
a4944 1
    if (d->character && STATE(d) == CON_PLAYING/* && (GET_LEVEL(d->character) <= GET_LEVEL(ch))*/)
d4950 2
a4951 1
    if (d->character && d->character->player.name) {
a4960 1

d4965 2
a4966 2

    if (STATE(d) != CON_PLAYING) {
d4971 2
a4972 1
		(STATE(d) == CON_PLAYING && CAN_SEE(ch, d->character))) {
@


1.120
log
@Artus> Champs stay on immlist after unholy vengeance.
       Angels are no longer shown on immlist.
       Minotaur/Superman Bonus changed to MAX(5, DAMROLL/10)
       Copyright changed to 2004.
@
text
@d885 3
a887 6
  long counter, found = 0;
  struct char_data *tch;
  struct char_file_u tmp;
  long immpts[NUM_PLAYERS], // kills vs imms
       immid[NUM_PLAYERS];  // Id's of imms found
  int nLevel = 0, chlev = 0;
d889 2
a890 5
  skip_spaces(&argument);
  one_argument(argument, arg);

  // See if they're after a specific type of imm
  if (*arg)
d892 2
a893 6
    if (!isdigit(arg[0]))
    {
      send_to_char("That's not a level!\r\nUsage: immlist [<level>]\r\n", ch);
      return;
    }
    nLevel = atoi(arg);
a895 35
  for (counter = 1; counter <= top_idnum; counter++)
  {
    if ((get_name_by_id(counter)))
    {
      if (load_char(get_name_by_id(counter), &tmp) < 0)
        continue;
    } else {
      continue; 
    }

    // Player exists 
    CREATE(tch, struct char_data, 1);
    clear_char(tch);
    store_to_char(&tmp, tch);
    char_to_room(tch, 0);
    chlev = GET_LEVEL(tch);
    if ((GET_UNHOLINESS(tch) > 0) && (GET_CLASS(tch) == CLASS_MASTER) &&
	(GET_LEVEL(tch) >= 95))
      chlev = MAX(100, GET_LEVEL(tch));

    if (chlev >= LVL_IMMORT && chlev < LVL_ANGEL)
    {
      if (nLevel == 0 || (nLevel != 0 && nLevel == chlev))
      {
        immid[found] = counter;
        immpts[found] = GET_IMMKILLS(ch);
        found++;
      }
    }		  				
    extract_char(tch);
  }	

  // sort in ascending order
  sort(immpts, immid, found);

d897 8
a904 12
  sprintf(buf, "\r\n   &r.-&R'-.&y_.&Y-'&w-&W Primal Immortals &w-&Y'-&y._.&R-'&r-.&n\r\n");
  sprintf(buf + strlen(buf), "\r\n\r\n       &BName                  Rank     Kills   Unholiness\r\n");
  for (counter = 0; counter < found; counter++)
  {
    load_char(get_name_by_id(immid[counter]), &tmp); 
    CREATE(tch, struct char_data, 1);
    clear_char(tch);
    store_to_char(&tmp, tch);
    char_to_room(tch, 0);
           
    sprintf(buf + strlen(buf), "&y       %-20s  %2ld         %ld        %3d&n\r\n", GET_NAME(tch), (counter + 1),GET_IMMKILLS(tch),GET_UNHOLINESS(tch)); 
	   extract_char(tch);
d906 2
a907 2
  sprintf(buf + strlen(buf), "\r\n       &B%ld &bImmortal%s listed.\r\n&n",
          found, found == 1 ? "" : "s"); 	
@


1.119
log
@Artus> Indenting, is all.
@
text
@d890 1
a890 1
  int nLevel = 0;
d898 6
a903 7
	if (!isdigit(arg[0]))
	{
		send_to_char("That's not a level!\r\nUsage: immlist [<level>]\r\n", ch);
		return;
	}

	nLevel = atoi(arg);
d906 5
a910 3
  for (counter = 1; counter <= top_idnum; counter++) {
    if ((get_name_by_id(counter))) {
      if (load_char(get_name_by_id(counter), &tmp) < 0) { 
a911 1
      }
d921 4
d926 3
a928 2
    if (GET_LEVEL(tch) >= LVL_IMMORT && GET_LEVEL(tch) < LVL_GOD) {
      if (nLevel == 0 || (nLevel != 0 && nLevel == GET_LEVEL(tch)))
d943 3
a945 2
  sprintf(buf + strlen(buf), "\r\n\r\n       &BName          Rank     Kills\r\n");
  for (counter = 0; counter < found; counter++) {
d952 1
a952 2
    sprintf(buf + strlen(buf), "&y       %-12s  %2ld         %ld&n\r\n", 
                 GET_NAME(tch), (counter + 1),GET_IMMKILLS(tch)); 
d2624 5
a2628 5
	int nRaw = GET_DAMROLL(ch);
	double dbTmp = 0.0;
	
	if (IS_SET(GET_SPECIALS(ch), SPECIAL_MINOTAUR))
		dbTmp += (GET_DAMROLL(ch) * 0.05);
d2630 2
a2631 2
	if (IS_SET(GET_SPECIALS(ch), SPECIAL_SUPERMAN))
		dbTmp += (GET_DAMROLL(ch) * 0.02);
d2633 1
a2633 1
	return (int)(dbTmp + nRaw);
d2636 2
a2637 2
int digits(long number) {
  
d3187 4
a3190 3
  if (IS_SET(GET_SPECIALS(ch), SPECIAL_MINOTAUR)) {
    sprintf(buf, "%s+%d", buf, (int)(GET_DAMROLL(ch) * 0.05));
    ctmp += 1 + digits((long)(GET_DAMROLL(ch) * 0.05));
d3193 2
a3194 1
  if (IS_SET(GET_SPECIALS(ch), SPECIAL_SUPERMAN)) {
d5068 1
a5068 1
    sprintf(buf, "PrimalMUD version: &c%d.%d.%d&n Copyright (C) 1994-2003\r\n"
@


1.118
log
@Artus> Gloves don't show up as dual wield now.
       Backstab with no target, when fighting and have combat backstab, targets
       person fighting.
@
text
@d718 5
a722 1
void ch_trigger_trap(struct char_data *ch, struct obj_data *obj) {
d724 12
a735 17
	struct obj_data *temp;
        struct descriptor_data *d;
	int dam;

	if( GET_OBJ_VAL(obj, 0) == 0 ) {
	  send_to_char("&bPhew, it wasn't loaded.&n\r\n", ch);
	  if( GET_OBJ_VAL(obj, 3) == 0 )
		return;	// Nothing more to do

	  temp = read_object(GET_OBJ_VAL(obj, 3), VIRTUAL);
 	  extract_obj(obj);
	  obj_to_room(temp, ch->in_room);
	  act("The trap was protecting $p!", FALSE, ch, temp, 0, TO_CHAR);
	  act("$n triggered a trap, which was fortunately unloaded, finding $p.", FALSE, ch, temp, 0, TO_ROOM);
	  
	  return;
	}
d737 31
a767 30
	send_to_char("You trigger it!&n\r\n", ch);
	act("...$n triggers a trap!", FALSE, ch, 0, 0, TO_ROOM);

	dam = dice(GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 2));

	if( GET_OBJ_VAL(obj, 0) == 1 ) 
	{
	   send_to_char("You take the brunt of the damage.\r\n", ch);
	   // GET_HIT(ch) -= damage;
	   damage(NULL, ch, dam, TYPE_UNDEFINED, FALSE);
	   update_pos(ch);
	}	else {   // Room affect
	   send_to_char("The trap goes off, damaging everyone nearby.\r\n", ch);
	   act("The trap goes off, damaging everyone in the vicinity!", 
		FALSE, ch, 0, 0, TO_ROOM);	
	   for( d = descriptor_list; d; d = d->next ) {
		if(d->character && ((d->character)->in_room == ch->in_room) &&
		   (d->character != ch))
		  damage(NULL, d->character, dam, TYPE_UNDEFINED, FALSE);
		  // GET_HIT(d->character) -= damage; // Do damage
	   } // Every descriptor
	} // Room affect

	// Check if we replace the obj
	if( GET_OBJ_VAL(obj, 3) >= 1 ) {
	    temp = read_object(GET_OBJ_VAL(obj, 3), VIRTUAL);
            act("You find $p in the aftermath.", FALSE, ch, temp,0,TO_CHAR);
	    act("You spot $p in the aftermath.", FALSE, ch, temp,0,TO_ROOM);
	    obj_to_room(temp, ch->in_room);
	}
d769 2
a770 2
	// Get rid of the trap
        extract_obj(obj);
@


1.117
log
@Artus> Fixed info command, you can now use spaces.
@
text
@d1397 2
a1398 1
  if (found) {
d1403 2
a1404 6
                      CAN_SEE_OBJ(ch, GET_EQ(i, wear_positions[j]))) {

	// Wielding weapon in hold spot - display "<wielded>"
//        if ((j == WEAR_HOLD) && CAN_WEAR(GET_EQ(ch, j), WEAR_WIELD) && 
//	      !CAN_WEAR(GET_EQ(ch, j), WEAR_HOLD)) { 

d1406 1
a1406 1
        if ((j == WEAR_HOLD) && IS_DUAL_WIELDING(i))
@


1.116
log
@Artus> Cleanup only.
@
text
@d961 1
d963 2
a964 1
  if (IS_NPC(ch)) {
d969 2
a970 1
  two_arguments(argument, arg, buf1);
d1004 2
d1007 1
a1007 1
  if (!*buf1) 
d1057 2
a1058 1
  if (is_abbrev(arg, "email")) {
d1061 2
a1062 2

    if (str_cmp(buf1, "clear") == 0 ) {
d1064 1
a1064 1
      *buf1 = '\0';
d1067 1
a1067 2
      GET_EMAIL(ch) = str_dup(buf1);
      *buf1 = '\0';
d1073 2
a1074 1
  if (is_abbrev(arg, "webpage")) {
d1077 2
a1078 2

    if (!str_cmp(buf1, "clear")) {
d1082 1
a1082 1
      GET_WEBPAGE(ch) = str_dup(buf1);
d1088 2
a1089 1
  if (is_abbrev(arg, "personal")) {
d1092 2
a1093 2

    if (!str_cmp(buf1, "clear")) {
d1097 1
a1097 1
      GET_PERSONAL(ch) = str_dup(buf1);
@


1.115
log
@Artus> Required changes for new find_xxx functions.
       Also, changed worship to be just a social.
@
text
@d1936 2
a1937 1
  if (!*arg) {
@


1.114
log
@Artus> Fixed object damage display issues.
@
text
@d632 1
a632 1
        if (!(victim = get_char_vis(ch, arg, FIND_CHAR_ROOM))) 
d5263 2
a5264 1
  if (!(victim = get_char_vis(ch, buf, FIND_CHAR_ROOM))) {
d5268 2
a5269 1
  if (victim == ch) {
d5273 2
a5274 1
  if (!IS_NPC(victim)) {
a5301 1

d5313 1
a5313 1
    if (!(vict = get_char_vis(ch, buf, FIND_CHAR_ROOM)))
d5392 1
a5392 1
    if ((victim = get_char_vis(ch, buf1, FIND_CHAR_WORLD))) {
d5599 1
a5599 1
  if ((find = get_char_vis(ch, arg, FIND_CHAR_WORLD))) {
d6668 3
a6670 1
ACMD(do_worship) {
d6672 1
a6672 2
	struct char_data *divinity;
	struct char_file_u tmp;
d6674 29
a6702 1
	one_argument(argument, arg);
d6704 1
a6704 39
	// Maintain a social for it
	if( !*arg ) {
		send_to_char("You fall to your knees and beg for forgiveness.\r\n",ch);
		act("$n falls to $s knees and grovels to the mighty.\r\n", FALSE,
			ch, 0, 0, TO_ROOM);
		return;
	}

	basic_mud_log("Worshipping");

	// Check that the player has some points to give away,
	// before bothering to check anything
	if( GET_WORSHIP_POINTS(ch) <= 0 ) {
	  send_to_char("You pray to the divine, in hope.\r\n", ch);
	  // Notify the target anyway, if they're online.
	  if( (divinity = get_char_online(ch, arg, FIND_CHAR_WORLD) ) !=NULL ) 
		act("You were worshipped by $n, but they had no power left to give you.",
			FALSE, ch, 0, divinity, TO_VICT);
	  else { // Check if they exist
		CREATE(divinity, struct char_data, 1);
		clear_char(divinity);
		if( load_char(arg, &tmp) < 0 ) {
			send_to_char("No such divinity exists!\r\n", ch);
			free(divinity);
			return;
		}	
		// they exist, send them a mail
		store_to_char(&tmp, divinity);
		sprintf(buf, "You were worshipped by %s, but they had no power to give you.\r\n", GET_NAME(ch));	
                store_mail(get_id_by_name(GET_NAME(divinity)),
			 get_id_by_name("Adjudicator"), buf);
		char_to_room(divinity, 0);
		extract_char(divinity);
		return;
	  }
	  return; 
	}
	
	send_to_char("Worship function not completed yet. See your nearest implementor.\r\n",ch);
d6706 32
d6842 2
a6843 2
		     if( (obj = get_obj_in_list_vis(ch, "corpse",
			ch->carrying)) == NULL) {
d6849 2
a6850 1
		     if( strcmp(obj->short_description, buf) != 0 ) {
d6864 2
a6865 1
		     if( ev->info3 != THE_LAW ) {
d6868 1
a6868 1
		        send_to_char(buf, get_char_vis(ch,
d6892 2
a6893 1
	if( !(vict =get_char_vis(ch, arg, FIND_CHAR_WORLD)) ) {
d6898 2
a6899 1
	if( !isdigit(buf1[0]) ) {
@


1.113
log
@Artus> Fixed all those Showing object damage on null object's I must have
       introduced somewhere along the line.
@
text
@d1103 8
a1110 8
    "It is in &gperfect&n condition.",
    "It is &Bslightly damaged&n.",
    "It is &Ysomewhat damaged&n.",
    "It is &ymoderately damaged&n.",
    "It is &rquite damaged&n.",
    "It is &Rseverely damaged&n.",
    "It is &mbroken&n.",
    "It is &Gindestructable!&n"
d1182 3
a1184 2
      sprintf(buf, "%s\r\n", show_object_damage(object));
      send_to_char(buf, ch);
d1192 2
a1193 1
  show_object_damage(object);
d1987 1
a1987 2
	sprintf(buf, "%s\r\n", show_object_damage(GET_EQ(ch, j)));
	send_to_char(buf, ch);
d1999 1
a1999 2
	sprintf(buf, "%s\r\n", show_object_damage(obj));
	send_to_char(buf, ch);
d2011 1
a2011 2
	sprintf(buf, "%s\r\n", show_object_damage(obj));
	send_to_char(buf, ch);
@


1.112
log
@Artus> Moved all the quest event stuff to quest.[ch].
       Added trivia quest type.
@
text
@d1099 15
a1113 42
const char *show_object_damage(struct obj_data *obj) {

	const char *damage_msgs[] = {
		"It is in &gperfect&n condition.",
		"It is &Bslightly damaged&n.",
		"It is &Ysomewhat damaged&n.",
		"It is &ymoderately damaged&n.",
		"It is &rquite damaged&n.",
		"It is &Rseverely damaged&n.",
		"It is &mbroken&n.",
		"It is &Gindestructable!&n"
        };
	int dmgno = 0;
	float damage;

	if (obj == NULL) {
	  mudlog("SYSERR: Showing object damage on null object.", BRF, LVL_GRGOD, TRUE);
	  return "-"; 
	}

	if (GET_OBJ_MAX_DAMAGE(obj) == 0)
	    dmgno = 6;
	else if (GET_OBJ_MAX_DAMAGE(obj) <= -1)
	    dmgno = 7;
	else
	    damage = (GET_OBJ_DAMAGE(obj) *100) / GET_OBJ_MAX_DAMAGE(obj);

        if (dmgno != 0)
		dmgno = dmgno;	// Pre - allocated ( Broken or Indes )
	else if (damage == 0)   // Busted
	   dmgno = 6;
        else if (damage <= 20)	// Severely damaged   (01 - 20%)
	   dmgno = 5;
	else if (damage <= 50)  // Quite damaged      (21 - 50%)
	   dmgno = 4;
        else if (damage <= 70)  // Moderately damaged (51 - 70%)
 	   dmgno = 3;
	else if (damage <= 85)  // Somewhat damaged   (71 - 85%)
	   dmgno = 2;
	else if (damage <= 99)  // Slightly damaged   (86 - 99%) 
	   dmgno = 1;
	else dmgno = 0;		// Perfect condition  (  100%  )
d1115 27
d1144 1
a1144 2

	return damage_msgs[dmgno];
d1981 3
a1983 1
      if ((desc = find_exdesc(arg, GET_EQ(ch, j)->ex_description)) != NULL && ++i == fnum) {
d1995 2
a1996 1
      if ((desc = find_exdesc(arg, obj->ex_description)) != NULL && ++i == fnum) {
d1998 1
a1998 1
	sprintf(buf, "%s\r\n", show_object_damage(GET_EQ(ch, j)));
d2011 1
a2011 1
	sprintf(buf, "%s\r\n", show_object_damage(GET_EQ(ch, j)));
@


1.111
log
@Artus> Few minor changes to item damage display. (Adding in \r\ns)
@
text
@d26 1
d67 1
d92 2
d6118 2
a6119 6
	if (ev->info1 == QUEST_ITEM_HUNT)
	  sprintf(buf, "%sAn 'item hunt' quest is running in %s!\r\n", buf2,
	          zone_table[ev->room->zone].name);
	else
	  sprintf(buf, "%sAn unknown quest is running in %s!\r\n", buf2,
	          zone_table[ev->room->zone].name);
a6240 82
void handle_quest_item_hunt(struct event_data *ev)
{
  extern struct obj_data *obj_proto;
  extern mob_rnum top_of_mobt;
  struct itemhunt_data *qev;
  struct char_data *qmob;
  struct obj_data *qobj;
  struct quest_score_data *player;
  int total = 0, pcount = 0;

  // Sanity.
  qev = (struct itemhunt_data *)ev->info2;
  if ((qev->ev != ev) || (number(1, 3) != 1))
    return;
  // Calc total found..
  for (player = qev->players; player; player = player->next)
  {
    pcount++;
    total += player->score;
  }
  // Make sure we don't flood the mud.
  if (total + pcount <= qev->itemsmade)
    return;
  // If we get here, we want to randomly load a mob.
  for (pcount = 0; pcount < 10; pcount++)
  {
    total = number(0, top_of_mobt-1);
    if ((GET_LEVEL(&mob_proto[total]) <= qev->lowlevel+10) &&
	(!MOB_FLAGGED(&mob_proto[total], MOB_NOKILL)))
      break;
    total = NOBODY;
  }
  // Artus> Didn't find a mob to use.
  if (total == NOBODY)
    return;
  qmob = read_mobile(total, REAL);
  if (!(qmob))
    return;
  for (pcount = 0; pcount < top_of_world; pcount++)
  {
    if (world[pcount].zone != ev->room->zone)
      continue;
    total = pcount + number(1, 300);
    if ((total > top_of_world) || (world[total].zone != ev->room->zone) ||
        (ROOM_FLAGGED(total, ROOM_DEATH | ROOM_PEACEFUL)))
      continue;
    break;
  }
  if ((total > top_of_world) || (world[total].zone != ev->room->zone))
  {
    free_char(qmob);
    return;
  }
  char_to_room(qmob, total);
  SET_BIT(MOB_FLAGS(qmob), MOB_STAY_ZONE | MOB_QUEST | MOB_NOSUMMON);
  REMOVE_BIT(MOB_FLAGS(qmob), MOB_AGGRESSIVE | MOB_SENTINEL | MOB_AGGR_GOOD |
	                      MOB_AGGR_EVIL | MOB_AGGR_NEUTRAL);
  SET_BIT(AFF_FLAGS(qmob), AFF_NOTRACK);
  // Artus> Sanity.
  if (obj_proto[qev->itemrnum].item_number != qev->itemvnum)
    qev->itemrnum = real_object(qev->itemvnum);
  qobj = read_object(qev->itemrnum, REAL);
  if (!(qobj))
    return;
  qev->itemsmade++;
  GET_OBJ_TYPE(qobj) = ITEM_QUEST;
  obj_to_char(qobj, qmob, __FILE__, __LINE__);
}

void handle_quest(struct event_data *ev)
{
  switch(ev->info1)
  {
    case QUEST_ITEM_HUNT:    handle_quest_item_hunt(ev);    break;
    default:
      sprintf(buf, "Unhandled quest type: %d found.", ev->info1);
      mudlog(buf, BRF, LVL_IMPL, TRUE);
      break;
  }
}


d6563 6
a6568 6
      case EVENT_BURGLARY:  handle_burglary(ev);  break;
      case EVENT_GOLD_RUSH: handle_gold_rush(ev); break;
      case EVENT_CURFEW:    handle_curfew(ev);    break;
      case EVENT_QUEST:     handle_quest(ev);     break;
      case EVENT_FIRE:      handle_fire(ev);      break;
      case EVENT_HAPPY_HR:  handle_happy(ev);     break;
@


1.110
log
@Artus> Random mobs are up to minlevel + 10.
@
text
@d1179 2
a1180 1
      show_object_damage(object);
d1980 2
a1981 1
	send_to_char(show_object_damage(GET_EQ(ch, j)), ch);
d1992 2
a1993 1
	send_to_char(show_object_damage(obj), ch);
d2005 2
a2006 1
	send_to_char(show_object_damage(obj), ch);
@


1.109
log
@Artus> Implemented QUEST_ITEM_HUNT
       Removed QUEST_PANDORAS_BOX
@
text
@d6264 1
a6264 1
    if ((GET_LEVEL(&mob_proto[total]) <= qev->lowlevel) &&
@


1.108
log
@Artus> Unholy Vengeance.
@
text
@a6112 3
	else if (ev->info1 == QUEST_PANDORAS_BOX)
	  sprintf(buf, "%sA 'pandoras box' quest is running in %s!\r\n", buf2,
	          zone_table[ev->room->zone].name);
d6239 65
a6303 11
  /* TODO - Artus - Helper Function for:
   * handle_gold_rush(ev, ev->info2); */
}

void handle_quest_pandoras_box(struct event_data *ev)
{
  // TODO: Need the vnums of some objects to spec_proc for trade ins
  /* TODO - Artus - Helper Function for:
   * handle_gold_rush(ev, BLUEGEM);
   * handle_gold_rush(ev, REDGEM);
   * handle_gold_rush(ev, GREENGEM); */
a6310 1
    case QUEST_PANDORAS_BOX: handle_quest_pandoras_box(ev); break;
@


1.107
log
@Artus> Minor cleanup.
@
text
@d4745 6
d4752 1
a4752 1
        strcat(buf, CCNRM(ch, C_SPR));             
@


1.106
log
@Artus> Initialised pointer.
@
text
@d1362 2
a1363 2
  if (!IS_NPC(i) && IS_SET(GET_SPECIALS(i), SPECIAL_DISGUISE) && CHAR_DISGUISED(i) &&
    !IS_SET(PRF_FLAGS(i), PRF_HOLYLIGHT))
d1365 5
a1369 5
	tch = read_mobile(CHAR_DISGUISED(i), VIRTUAL);
	char_to_room(tch, i->in_room);
	look_at_char(tch, ch);
	extract_char(tch);
	return;       	
@


1.105
log
@Artus> Changes for object spells.
@
text
@d1235 1
a1235 1
  struct obj_data **u_item_ptrs;
@


1.104
log
@Artus> Now warning free :o)
@
text
@d3862 2
a3863 1
  if (MOUNTING(ch)) {
d3867 2
a3868 1
  if (MOUNTING_OBJ(ch)) {
d3922 2
a3923 2
    for (aff = affect_array[0]; (aff) && i < noAffects; aff = affect_array[++i]) {
      
d3928 1
a3928 1
      if (aff->duration == -1) 
d3931 2
d3942 1
d3956 1
a3956 1
        else
d3961 2
a3962 1
      if (aff->modifier) {
d3966 2
a3967 1
      if (aff->bitvector) {
d4553 5
a4557 1
    if ((*left)->duration == -1)
d4559 1
a4559 1
    if ((*right)->duration == -1)
@


1.103
log
@Artus> ASSERT on NOWHERE in look_at_room().
@
text
@d271 3
a273 3
  long lMob1,	// Boss
       lMob2,   // Sub
       lMob3;   // Underling
d324 1
a324 1
	  basic_mud_log("Boss Mobile #%d cannot be burgle loaded.", lMob1);
d339 1
a339 1
	  basic_mud_log("Sub Mobile #%d cannot be burgle loaded.", lMob2);
d355 1
a355 1
	  basic_mud_log("Underling Mobile #%d cannot be burgle loaded.", lMob3);
d942 1
a942 1
    sprintf(buf + strlen(buf), "&y       %-12s  %2d         %ld&n\r\n", 
d946 1
a946 1
  sprintf(buf + strlen(buf), "\r\n       &B%d &bImmortal%s listed.\r\n&n",
d955 1
a955 1
  struct char_data *tch;
d1033 1
a1033 1
	GET_NAME(tch), GET_LEVEL(tch), pc_class_types[GET_CLASS(tch)],
a1355 1
  struct obj_data *tmp_obj;
a2068 1
  char *tmp_arg;
d2117 1
a2117 1
    sprintf(buf, "You have &Y%ld&n gold coins all on hand.\r\n", GET_GOLD(ch));
d2131 1
a2131 1
  sprintf(buf, "You have &Y%d&n gold coin%s, and &Y%d&n in the bank, totalling &Y%d&n.\r\n", GET_GOLD(ch), (GET_GOLD(ch) > 1 ? "s" : ""), GET_BANK_GOLD(ch), total);
a2385 1
   long lScoreDetail;
d2473 1
a2473 1
     sprintf(buf, "%s&0Class:&n %s", buf, pc_class_types[GET_CLASS(ch)]);
d2648 1
a2648 1
  int i,j;
a2774 1
  struct tm lt;
d2781 1
d3264 1
a3264 1
		cstar,CCHEAD(ch,C_NRM),cstar,cstar);
d3409 2
a3410 1
    sprintf(buf3, "You have earned &c%d&n exp, and need &c%d&n to reach level &c%d&n.\r\n", level_exp(ch, GET_LEVEL(ch) + 1) - GET_EXP(ch));
d3418 1
a3418 2
  int i2 = 0;
  int i3 = 0;
a3596 3
  struct time_info_data playing_time;
  bool foundDamBonus = FALSE;
  float nTmp = 0;
d4352 1
a4352 1
  char mode, s[5];
a4359 1
  struct char_data *sortArray[500];
d4605 1
a4605 1
  char mode, s[5];
d5635 1
a5635 2
  int no, i, cmd_num = -1;
  int wizhelp = 0, socials = 0;
a5636 1
  bool all=FALSE;
a5929 1
  extern struct index_data *obj_index;
a6043 2
  struct obj_data *oburning, *next_burn;
  struct char_data *cburning, *next_cburn;
d6371 1
a6371 1
  int counter = 0, sector = 0;
d6726 3
a6728 3
ACMD(do_bounties) {

	int nClass = GET_CLASS(ch), bounty_count = 0, amount = 0;
@


1.102
log
@Artus> (limbo) on who list, for players in limbo.
@
text
@d1698 11
@


1.101
log
@Artus> Changes for Detect Deathtrap skill.
       Changes to init_gold_rush.
@
text
@d4726 2
@


1.100
log
@Artus> Gold rush's can now end after 30 bars.
       Made sense wounds a little more useful.
@
text
@d1693 2
d1705 1
d1736 19
d6317 2
d6364 1
d6366 36
@


1.99
log
@Artus> Added mortal events command.
       Gold rush now tracks number of bars generated and seconds running, and
       won't end before 300 seconds, or 50 bars.
@
text
@d1653 37
a1689 1

d1744 1
a1744 10
  {
    struct char_data *pers;
    for (pers = world[ch->in_room].people; pers; pers = pers->next_in_room)
    {
      if (IS_NPC(pers) || (pers == ch) || !CAN_SEE(ch, pers) ||
	  (GET_HIT(pers) > (int)(GET_MAX_HIT(pers)/3)))
	continue;
      act("$N&r could use a little healing!&n", TRUE, ch, NULL, pers, TO_CHAR);
    }
  }
d5922 1
a5922 1
  if (((ev->info1 >= 300) || (ev->info2 >= 50)) && (number(1, 30) == 1))
@


1.98
log
@Artus> Massive changes to events :o)
@
text
@d27 3
a29 1
#define SETREMOVE(flag, bit) if (IS_SET((flag), (bit))) REMOVE_BIT((flag), (bit)); else SET_BIT((flag),(bit))
d142 1
d5887 2
d5895 1
a5895 1
  if (number(1, 30) == 1)
d5953 1
d6025 67
d6276 2
@


1.97
log
@Artus> Happy Hour!
@
text
@d81 1
a81 1
void remove_event(struct event_data *ev);
d5862 1
a5862 2
  void destroy_event_happy(struct char_data *ch);

d5866 1
a5866 2
  send_to_all("&yAwwwwwwww, happy hour has ended :o(&n\r\n");
  destroy_event_happy(NULL);
d5869 2
a5870 1
void handle_gold_rush(struct event_data *ev, obj_vnum objv = 0)
d5872 2
a5873 5
  zone_rnum zone = ev->room->zone;	
  room_vnum zoneup = zone_table[zone].top;
  int counter = 0;
  struct obj_data *gold = NULL;
  struct obj_data *trash = NULL;
d5875 28
a5902 1
  void send_to_not_zone_world(const char *msg, zone_rnum zone);
d5904 1
a5904 2
  // 4% random chance of ending event, if a normal gold hunt
  if( number(1, 25) == 1 && objv == 0 )
d5906 2
a5907 35
    sprintf(buf, "&yThe gold rush in %s has ended!",
	    zone_table[zone].name); 
    mudlog(buf, CMP, LVL_ANGEL, FALSE); // (msg, type, level, to_file)
    sprintf(buf, "&WYou stop hearing reports of gold findings in %s.&n\r\n", 
	    zone_table[zone].name);
    send_to_not_zone_world(buf, zone);
    send_to_zone("&YThe gold rush has ended!&n\r\n", zone);
    ev->type = EVENT_OVER;
    
    /* ARTUS - Clean up afterwards.. */
    for (counter = zoneup; counter; counter--)
    {
      if (real_room(counter) == NOWHERE)
	continue;
      if (world[real_room(counter)].name == NULL)
	continue;
      if( world[real_room(counter)].zone != zone ) 
	return;
      for (gold = world[real_room(counter)].contents; gold; 
	   gold = gold->next_content) 
      {
	if (trash != NULL) 
	{
	  extract_obj(trash);
	  trash = NULL;
	}
	if (GET_OBJ_VNUM(gold) == GOLD_OBJ_VNUM)
	  trash = gold;
      }
      if (trash != NULL)
      { /* Without this we would miss the last one */
	extract_obj(trash);
	trash = NULL;
      }
    }
d5911 3
d5915 1
a5915 1
  for(counter = zoneup; counter; counter = counter - 1) 
d5917 4
a5920 6
    // unless the top of zone is set to the actual top of zone,
    // we're never gonna get anywhere, should exit correctly
    // with next 2 checks, although not sure if check on name ==
    // NULL is actually needed - DM.
    if (real_room(counter) == NOWHERE)
      continue;
d5922 3
a5924 2
    // Check it's a valid room?
    if (world[real_room(counter)].name == NULL)
d5927 7
a5933 4
    // FIX: failing here ... 
    // Check that we're still in the same zone.
    if (world[real_room(counter)].zone != zone) 
      return;		// our work is done
d5935 2
a5936 5
    // Do a sector check here, no use having gold appearing in the middle
    // of a city, really

    // 1% chance of some gold (or, 1 every 100 rooms, really)
    if(number(1, 100) == 1) 
d5938 7
a5944 19
      // This object must exist or mud will crash
      if (objv == 0) 
      {
	gold = read_object(real_object(GOLD_OBJ_VNUM), REAL);
	GET_OBJ_VAL(gold, 1) = number(1000, 30000);
	// Artus> Change value based on zone level.
	if (zone_table[zone].zflag > 3)
	{
	  int lvbit = zone_table[zone].zflag;
	  REMOVE_BIT(lvbit, ZN_NO_STEAL | ZN_NO_TELE | ZN_NO_GOLDRUSH | 
	             (1 << 27) | (1 << 28) | (1 << 29) | (1 << 30) | (1 << 31));
	  if (lvbit > ZN_LR_40) // Double for Level >= 40
	    GET_OBJ_VAL(gold, 1) <<= 1;
	  if (lvbit > ZN_LR_70) // Quadruple for Lvl >= 70
	    GET_OBJ_VAL(gold, 1) <<= 1;
	}
      } else	// Use specified object 
	gold = read_object(real_object(objv), REAL);
      obj_to_room(gold, real_room(counter));
d5946 3
d5952 1
a5952 1
// Called by handle_event_zone -- Artus.
d5988 1
a5988 1
  void destroy_event_fire(struct char_data *ch, zone_rnum zone);
d6016 1
a6016 1
    destroy_event_fire(NULL, ev->room->zone);
a6024 1

d6100 1
a6100 1
void handle_quest_item_hunt(struct event_data  *ev)
d6102 2
a6103 1
	handle_gold_rush(ev, ev->info2);	
d6108 5
a6112 4
	// TODO: Need the vnums of some objects to spec_proc for trade ins
	handle_gold_rush(ev, BLUEGEM);
	handle_gold_rush(ev, REDGEM);
	handle_gold_rush(ev, GREENGEM);
d6117 9
a6125 13

	switch(ev->info1)
	{
		case QUEST_ITEM_HUNT:
			handle_quest_item_hunt(ev);
			break;
		case QUEST_PANDORAS_BOX:
			handle_quest_pandoras_box(ev);
			break;
		default:
			basic_mud_log("Unhandled quest type found.");
			break;
	}
d6129 3
a6131 2
void handle_curfew(struct event_data *ev) {

d6139 3
a6141 6
  for ( ev = events.list; ev; ev = ev->next )
  {
     if (ev->type == EVENT_BOUNTY_HUNT)
	if (ev->chID == lTargetId)
		return TRUE;
  }  
d6147 5
a6151 1
void init_bounty_hunt() {
d6153 7
a6159 3
	struct descriptor_data *d;
	struct event_data *ev;
	int found = FALSE;
d6161 11
a6171 6
	// Go through every player
	for(d = descriptor_list; d; d = d->next) {
		if( STATE(d) != CON_PLAYING || IS_NPC(d->character) )
			continue;
		if(!LR_FAIL(d->character, LVL_GOD))
			continue;
d6173 20
a6192 28
		// See if they're criminals
		if(GET_SOCIAL_STATUS(d->character) == SOCIAL_CRIMINAL ) {
			// See if they're already bountied up
			for(ev = events.list; ev; ev = ev->next) {
				if( ev->type == EVENT_BOUNTY_HUNT ) {
					if( ev->chID == GET_IDNUM(d->character) )
						found = TRUE;
				}
			}
			// If they're not already bountied, chance of doing so
			if( !found ) {
				// 10% Random chance of the law putting up a bounty
				if( number(1, 10) != 1)
					continue;
				sprintf(buf, "%s bountied by the law.",GET_NAME(d->character));
				mudlog(buf, BRF, LVL_GOD, FALSE);
				CREATE(ev, struct event_data, 1);
				ev->chID = GET_IDNUM(d->character);
				ev->info1 = GET_LEVEL(d->character) * 20000 * number(1, 3);
				ev->info3 = THE_LAW; 
				ev->type = EVENT_BOUNTY_HUNT;
				ev->room = &world[real_room(BOUNTY_RETURN_ROOM)];
				add_mud_event(ev);
			}
			// Reset search sentinel
			found = FALSE;
		}	
	}
a6199 1
  // Create the new event
a6200 1
  // Populate the details
d6205 3
a6207 2
  {    
    ev->room = &world[number(1, top_of_world)];
d6211 1
a6211 2
    rnum_room = real_room(ev->room->number);
    basic_mud_log("init_gold_rush: attempting to use room rnum (%d) vnum (%d)", rnum_room, ev->room->number);
d6217 1
a6217 1
    sector = SECT(rnum_room);
d6220 1
a6220 1
    if (check_for_event(EVENT_GOLD_RUSH, world[real_room(ev->room->number)].zone))
d6228 1
a6228 1
    basic_mud_log("GoldRush: Unable to create event, counter limit reached.");
a6230 4
  /* Leave the time details out for now */
//ev->time_taken = time(0);
  // Log the room type
  //basic_mud_log("Room sector type is: %d.", sector);	
d6241 9
a6249 9
void init_event() {

	// About a 0.1% chance of an event
	switch(number(1, 1000)) {
		case 1: init_bounty_hunt(); break;
		case 2: init_gold_rush(); break;
		default: // Bugger all for now
			break; 
	}
d6329 3
a6334 1
  int nDiscoveryChance;
d6341 53
a6393 55
  Burglary *current = burglaries;
  do {
	struct char_data *burglar = get_player_by_id(current->chID);

	// Firstly, see if player has exited burglary rooms, and end it if so
	if (burglar_left_scene(current))
	{
		current->Clear();
		Burglary *tmp = current->next;	// Back up the next burglary
		remove_burglary(current);	// Remove this one, which clears 'next'
		current = tmp;			// Restore next (if any)
		continue;	// Done with this burglary, its history
	}
	else   // They're still around, see if the cops are now onto them
	if (number(1, 100 + GET_SKILL(burglar, SKILL_BURGLE)) <= nDiscoveryChance &&
	    !is_player_bountied(burglar))
	{
          // Set up a bounty on them
          struct event_data *ev;
     	  CREATE(ev, struct event_data, 1);
	  // Set it up
	  ev->chID = current->chID; 			// Target
	  ev->info1 = GET_LEVEL(burglar) * 5000 * (int(GET_MODIFIER(burglar)) +1);// Bounty 
	  ev->info3 = THE_LAW; 				// Bounty initiator ID	
	  ev->type = EVENT_BOUNTY_HUNT;			// Ahuh
	  ev->room = &world[real_room(BOUNTY_RETURN_ROOM)];// &world[burglar->in_room];
   	  // Add it to the list
	  add_mud_event(ev);
     
          // Reduce the players social status severely
          GET_SOCIAL_POINTS(burglar) -= 10;

	  send_to_char("&rYour actions have been noticed!&n\r\n", burglar);
	  send_to_char("... a bounty has been set on you.\r\n", burglar);
	} 
	else   // Some chance that they're going to be cutting into someone's territory
	if (number(1,100) == 1 )
	{
	  send_to_char("&bYou hear a familiar rustle....&n\r\n", burglar);
	  send_to_char("... you have cut in on someone else's burglary!\r\n", burglar);	
	  create_burgle_encounter(burglar);
	  int nExpGain = number(int(level_exp(burglar, GET_LEVEL(burglar)) * 0.01),
				int(level_exp(burglar, GET_LEVEL(burglar)) * 0.03));
          if (nExpGain > 0)
          {
	    sprintf(buf, "You learn from the experience! (%d exp)\r\n", nExpGain);
	    send_to_char(buf, burglar);
   	    GET_EXP(burglar) += nExpGain;
          }
	}  

	current = current->next;

  } while(current != NULL);
	
d6405 3
a6407 1
  for(ev = events.list; ev; ev = ev->next)
d6410 1
a6410 1
      case EVENT_BURGLARY: handle_burglary(ev); break;
d6412 4
a6415 4
      case EVENT_CURFEW: handle_curfew(ev); break;
      case EVENT_QUEST: handle_quest(ev);break;
      case EVENT_FIRE: handle_fire(ev);break;
      case EVENT_HAPPY_HR: handle_happy(ev);
d6417 2
a6418 1
    }		
d6420 1
a6420 1
  ev = events.list;
d6427 1
a6427 1
      remove_event(ev);
@


1.96
log
@Artus> Fixed minor display bug in do_gold().
       Equipment command now takes a position argument.
@
text
@d80 1
a80 1
void add_event(struct event_data *ev);
d5859 12
d6205 1
a6205 1
				add_event(ev);
d6255 1
a6255 1
  add_event(ev);
d6390 1
a6390 1
	  add_event(ev);
d6424 1
a6424 1
	struct event_data *ev, *nextev;
d6426 1
a6426 1
	init_event();		// Random chance of beginning a new event
d6428 23
a6450 21
	// For every event
	for(ev = events.list; ev; ev = ev->next) {
		switch(ev->type) {
			case EVENT_BURGLARY: handle_burglary(ev); break;
			case EVENT_GOLD_RUSH: handle_gold_rush(ev); break;
			case EVENT_CURFEW: handle_curfew(ev); break;
			case EVENT_QUEST: handle_quest(ev);break;
			case EVENT_FIRE: handle_fire(ev);break;
			default: break;
		}		
	}

	ev = events.list;

	// Clean up any events that have ended
	while(ev) {
		nextev = ev->next;		
		if( ev->type == EVENT_OVER )
			remove_event(ev);
		ev = nextev;
	}	
d6452 2
a6453 2
	// Separate handler for burglaries now that they have their own class
	handle_burglaries();	
d6773 1
a6773 1
	add_event(ev);
@


1.95
log
@Artus> Minor fix to do_gold()
@
text
@d1499 4
a1502 1
    else {
d2048 2
a2050 2
    else
      send_to_char("You have one miserable little gold coin, banked away.\r\n", ch);
d2056 1
a2056 1
    sprintf(buf, "You have &Y%ld&n gold coins all on hand.\r\n");
d3946 2
a3947 1
  int i, found = 0;
d3949 153
d4103 2
a4104 2
  for (i = 0; i < NUM_WEARS; i++) {
    
d4107 2
a4108 2
    if (eq_pos_ok(ch, wear_positions[i]) || GET_EQ(ch, wear_positions[i])) {

a4113 1
      {
d4115 1
a4115 1
      } else {
a4116 1
      }
d4230 2
a4231 1
  if (!*argument) {
d4235 2
a4236 1
  if (!help_table) {
d4245 2
a4246 1
  for (;;) {
d4249 2
a4250 1
    if (bot > top) {
d4253 3
a4255 1
    } else if (!(chk = strn_cmp(argument, help_table[mid].keyword, minlen))) {
a4275 5
    } else {
      if (chk > 0)
        bot = mid + 1;
      else
        top = mid - 1;
d4277 4
@


1.94
log
@Artus> Improved gold command.
@
text
@d2054 1
a2054 1
    if (GET_GOLD(ch) / 250000 >= 1)
@


1.93
log
@Artus> Colourised werewolf listing to room.
@
text
@d2033 23
a2055 7
  if (GET_GOLD(ch) == 0)
    send_to_char("You're broke!\r\n", ch);
  else if (GET_GOLD(ch) == 1)
    send_to_char("You have one miserable little gold coin.\r\n", ch);
  else {
    sprintf(buf, "You have &Y%d&n coins on hand and &Y%d&n coins banked, totalling &Y%d&n coins.\r\n", 
		    GET_GOLD(ch), GET_BANK_GOLD(ch), GET_GOLD(ch) + GET_BANK_GOLD(ch));
d2057 1
d2059 12
@


1.92
log
@Artus> Cleaned up.
@
text
@d1495 1
a1495 1
      sprintf(buf,"%s the Werewolf",i->player.name);
@


1.91
log
@Artus> Info is now tested against LVL_MAX.
@
text
@d4013 2
a4014 1
  if(!(time_info.hours > 12)) {
d4018 1
a4018 1
    }
d4020 2
a4021 1
  switch(day) {
d4031 1
a4031 1
    }
@


1.90
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d969 1
a969 1
  if (LR_FAIL(ch, 10))
@


1.89
log
@Artus>
act.informative.c: Fixed bug where examining a container was always listng the
                   objects in the first container matched.
                   Gold rush finishing is now only displayed within the same
		   world.
act.movement.c   : Environmental damage is now passed through damage().
act.offensive.c  : Throw() now calls damage().
act.other.c      : When you fail to create a torch, it hurts.
dg_mobcmd.c      : mdamage() now calls damage().
dg_objcmd.c      : odamage() now calls damage().
dg_wldcmd.c      : wdamage() now calls damage().
fight.c          : Changed damage() to allow a NULL ch.
interpreter.c    : Falling because fly has worn off now calls damage().
limits.c         : No waterbreathe underwater now calls damage().
magic.c          : Added handle_fireball() for fire breathing, fireball, type
                   stuff..
                   Random chance of objs in inventory/open containers burning
                   up :o)
spec_assign.c    : Removed some unused/wasted assigns: corridor_guard,
                   receiptionist, virus, bacteria.
spec_procs.c     : Removed some unused/wasted procs. Changed lots of tali's
                   indenting.
                   Fixed gaping hole in deadlyblade proc.
                   Replaced GET_HIT(vict) -= with damage(ch, vict...
spell_parser.c   : Added awake and can_see checks to magic fail = mob attacks.
@
text
@d664 1
a664 1
	if (GET_LEVEL(victim) >= LVL_IMMORT && GET_LEVEL(ch) < LVL_IMMORT)
d969 1
a969 1
  if (GET_LEVEL(ch) < 10)
d971 1
a971 1
    send_to_char(HUH, ch);
d975 1
a975 1
  if (PLR_FLAGGED(ch, PLR_NOINFO) && (GET_LEVEL(ch) < LVL_GRGOD)) 
d1401 1
a1401 1
  if (ch != i && (IS_THIEF(ch) || GET_LEVEL(ch) >= LVL_IMMORT)) {
d1605 1
a1605 1
  sprintf(buf2, "&8[ Exits: %s]\r\n", *buf ? buf : "None! ");
d1624 1
a1624 1
      if (GET_LEVEL(ch) >= LVL_IS_GOD)
d1691 3
d3316 1
a3316 1
  if (GET_LEVEL(ch) < LVL_IMMORT) {
a3317 1
  }
d3381 1
a3381 1
  if (GET_LEVEL(ch) < LVL_ISNOT_GOD)
d3888 2
a3889 2

  if ((GET_CLASS(ch) <= CLASS_WARRIOR) && GET_LEVEL(ch) >= RONE_MAX_LVL)
d3891 1
a3891 1
    send_to_char("You have reached your classes maximum level. You might consider remorting.\r\n", ch);
d3894 2
a3895 1
  if ((GET_CLASS(ch) < CLASS_MASTER) && GET_LEVEL(ch) >= RTWO_MAX_LVL)
d3900 2
a3901 6
  if (GET_LEVEL(ch) < LVL_ISNOT_GOD){
    sprintf(buf, "With &c%d&n exp, you need &c%d&n exp to reach your next level.\r\n", GET_EXP(ch), level_exp(ch,GET_LEVEL(ch)) - GET_EXP(ch));
    send_to_char(buf, ch);
    return;
  }
  send_to_char("You are beyond the need to level.\r\n", ch);
d4071 2
a4072 1
      if (GET_LEVEL(ch) < help_table[mid].level_restriction) {
d4947 3
a4949 1
  if (GET_LEVEL(ch) >= LVL_IMMORT)
a4950 2
  else
    perform_mortal_where(ch, arg);
d5091 1
a5091 1
  if ((!*buf1) || (GET_LEVEL(ch) < LVL_IMMORT)) {
d5097 1
a5097 1
    if (!*buf2) {
d5221 1
a5221 1
  if (GET_LEVEL(vict) >= LVL_ETRNL1) {
d5305 1
a5305 1
  if (!*arg) {
a5306 1
  }
d5309 1
a5309 1
  if (!str_cmp(arg, "all")) {
a5310 1
  }
d5317 3
d5365 1
a5365 1
        GET_LEVEL(vict) >= cmd_info[i].minimum_level &&
d5767 67
d5977 1
a5977 1
		if( GET_LEVEL(d->character) >= LVL_GOD ) 
d6218 2
a6219 1
void handle_events() {
d6232 1
d6290 2
a6291 2
	if( GET_VOTED(ch) == TRUE  ||  GET_LEVEL(ch) < vote_level 
	  || !check_for_event(EVENT_ELECTION, -1) ) {
d6547 1
a6547 1
	 ||( GET_LEVEL(vict) >= LVL_GOD) ) {
@


1.88
log
@Artus> Intermittent build.
act.informative.c: Affect/Timers now display something when no affects/timers
                   are present.
                   Sense curse now senses objects inside containers.
act.movement.c   : Optimised the aggravate stuff a little.
act.offensive.c  : Logging death by pit trap.
act.other.c      : Logging death by suicide.
                   Superman now sets affects rather than actual stats, for STR
                   and CON (CON bonus is +1, STR is 21 - GET_REAL_STR
                   Logging death by arrow.
clan.c           : Removed aggravate_check() function, no longer used.
db.c             : Now initialising character specials.
dg_mobcmd.c      : Logging death by mdamage.
dg_objcmd.c      : Logging death by odamage.
dg_wldcmd.c      : Logging death by wdamage.
fight.c          : New optional msg paramater to die(), for if the death was
                   not caused by a character.
                   Deaths are now logged to info channel.
handler.c        : Modified ability affect function to permit more than one
                   affect modifier per special. (Required for superman)
spec_procs.c     : Logging death by pit trap, archers and room blast.
spells.h         : Added SPELL_SUPERMAN for special affect modifiers.
utils.h          : Updated die() prototype to match changes in fight.c.
@
text
@d143 1
d145 2
a146 2
void look_at_target(struct char_data * ch, char *arg);

d715 1
a715 1
	int damage;
d734 1
a734 1
	damage = dice(GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 2));
d739 2
a740 1
	   GET_HIT(ch) -= damage;
d748 3
a750 2
		   (d->character != ch)) 
		   GET_HIT(d->character) -= damage; // Do damage
a1744 1
  int amt, bits;
d1747 1
d1749 5
a1753 2
  else if (!(bits = generic_find(arg, FIND_OBJ_INV | FIND_OBJ_ROOM |
				 FIND_OBJ_EQUIP, ch, &dummy, &obj))) {
d1756 10
a1765 21
  } else if ((GET_OBJ_TYPE(obj) != ITEM_DRINKCON) &&
	     (GET_OBJ_TYPE(obj) != ITEM_FOUNTAIN) &&
	     (GET_OBJ_TYPE(obj) != ITEM_CONTAINER))
    send_to_char("There's nothing inside that!\r\n", ch);
  else {
    if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER) {
      if (OBJVAL_FLAGGED(obj, CONT_CLOSED))
	send_to_char("It is closed.\r\n", ch);
      else {
	send_to_char(fname(obj->name), ch);
	switch (bits) {
	case FIND_OBJ_INV:
	  send_to_char(" (carried): \r\n", ch);
	  break;
	case FIND_OBJ_ROOM:
	  send_to_char(" (here): \r\n", ch);
	  break;
	case FIND_OBJ_EQUIP:
	  send_to_char(" (used): \r\n", ch);
	  break;
	}
d1767 26
a1792 15
	list_obj_to_char(obj->contains, ch, 2, TRUE);
      }
    } else {		/* item must be a fountain or drink container */
      if (GET_OBJ_VAL(obj, 1) <= 0)
	send_to_char("It is empty.\r\n", ch);
      else {
	if (GET_OBJ_VAL(obj,0) <= 0 || GET_OBJ_VAL(obj,1)>GET_OBJ_VAL(obj,0)) {
	  sprintf(buf, "Its contents seem somewhat murky.\r\n"); /* BUG */
	} else {
	  amt = (GET_OBJ_VAL(obj, 1) * 3) / GET_OBJ_VAL(obj, 0);
	  sprinttype(GET_OBJ_VAL(obj, 2), color_liquid, buf2);
	  sprintf(buf, "It's %sfull of a %s liquid.\r\n", fullness[amt], buf2);
	}
	send_to_char(buf, ch);
      }
d1794 15
d1810 9
d1842 2
d1845 2
a1846 1
void look_at_target(struct char_data * ch, char *arg)
d1854 5
d1873 2
d1900 2
a1901 1
  if ((desc = find_exdesc(arg, world[ch->in_room].ex_description)) != NULL && ++i == fnum) {
d1913 2
d1924 2
d1936 2
d1941 2
a1942 1
  if (bits) {
d1947 2
d2001 1
d2009 1
a2009 1
  look_at_target(ch, arg);
d2011 2
a2012 2
  generic_find(arg, FIND_OBJ_INV | FIND_OBJ_ROOM | FIND_CHAR_ROOM |
		      FIND_OBJ_EQUIP, ch, &tmp_char, &tmp_object);
d2014 2
a2015 1
  if (tmp_object) {
d2018 2
a2019 1
	(GET_OBJ_TYPE(tmp_object) == ITEM_CONTAINER)) {
d2021 1
a2021 1
      look_in_obj(ch, arg);
a2023 1

d5659 3
a5661 1
void handle_burglary(struct event_data *ev) {
d5663 3
a5665 1
	// check if burglar has evacuated rooms, and act accordingly
d5667 9
a5675 3
	// Also, check if an excessive number of rooms have been burgled,
	// and initiate a curfew in a zone that's been burgled (and is a town)
}
d5677 28
a5704 39
void handle_gold_rush(struct event_data *ev, obj_vnum objv = 0) {
	zone_rnum zone = ev->room->zone;	
	room_vnum zoneup = zone_table[zone].top;
	int counter = 0;
	struct obj_data *gold = NULL;
        struct obj_data *trash = NULL;
        extern struct index_data *obj_index;

	// 4% random chance of ending event, if a normal gold hunt
	if( number(1, 25) == 1 && objv == 0 ) {
	  sprintf(buf, "&yThe gold rush in %s has ended!",
		  zone_table[zone].name); 
	  mudlog(buf, BRF, 1, FALSE); // (msg, type, level, to_file)
	  ev->type = EVENT_OVER;
          
          /* ARTUS - Clean up afterwards.. */
          for (counter = zoneup; counter; counter--) {
            if (real_room(counter) == NOWHERE)
              continue;
            if (world[real_room(counter)].name == NULL)
              continue;
	    if( world[real_room(counter)].zone != zone ) 
	      return;
            for (gold = world[real_room(counter)].contents; gold; 
                 gold = gold->next_content) {
              if (trash != NULL) {
                extract_obj(trash);
                trash = NULL;
              }
              if (GET_OBJ_VNUM(gold) == GOLD_OBJ_VNUM)
                trash = gold;
            }
            if (trash != NULL) { /* Without this we would miss the last one */
              extract_obj(trash);
              trash = NULL;
            }
          }
          
	  return;
d5706 11
d5718 9
a5726 2
	// Since it's not ended, spread a bit more gold around the zone
	for( counter = zoneup; counter; counter = counter - 1) {
d5728 3
a5730 6
                // unless the top of zone is set to the actual top of zone,
                // we're never gonna get anywhere, should exit correctly
                // with next 2 checks, although not sure if check on name ==
                // NULL is actually needed - DM.
                if (real_room(counter) == NOWHERE)
                        continue;
d5732 7
a5738 3
		// Check it's a valid room?
		if( world[real_room(counter)].name == NULL )
			continue;
d5740 24
a5763 33
                // FIX: failing here ... 
		// Check that we're still in the same zone.
		if( world[real_room(counter)].zone != zone ) 
			return;		// our work is done

		// Do a sector check here, no use having gold appearing in the middle
		// of a city, really

		// 1% chance of some gold (or, 1 every 100 rooms, really)
		if( number(1, 100) == 1) {
			// This object must exist or mud will crash
			if (objv == 0) {
			  gold = read_object(real_object(GOLD_OBJ_VNUM), REAL);
			  GET_OBJ_VAL(gold, 1) = number(1000, 30000);
			  // Artus> Change value based on zone level.
			  if (zone_table[zone].zflag > 3)
			  {
			    int lvbit = zone_table[zone].zflag;
			    REMOVE_BIT(lvbit, ZN_NO_STEAL | ZN_NO_TELE |
					      ZN_NO_GOLDRUSH | (1 << 27) |
					      (1 << 28) | (1 << 29) | 
					      (1 << 30) | (1 << 31));
			    if (lvbit > ZN_LR_40) // Double for Level >= 40
			      GET_OBJ_VAL(gold, 1) <<= 1;
			    if (lvbit > ZN_LR_70) // Quadruple for Lvl >= 70
			      GET_OBJ_VAL(gold, 1) <<= 1;
			  }
			}
			else	// Use specified object 
				gold = read_object(real_object(objv), REAL);
			obj_to_room(gold, real_room(counter));
		}		
	}		
a5769 1

@


1.87
log
@Artus> Fixed: Crash in listen, Missing CRLF on gsay, Scan fail message.
@
text
@d587 2
a588 2
	struct obj_data *obj;
	int curseCounter = 0;
d590 10
a599 1
	for (obj = world[ch->in_room].contents; obj; obj = obj->next_content)
d601 5
a605 6
	  if (IS_OBJ_STAT(obj, ITEM_NODROP) && (number(1, 101) < GET_SKILL(ch, SKILL_SENSE_CURSE)))
	  {
	    curseCounter++;
	    act("You sense that $p is cursed.", FALSE, ch, obj, 0, TO_CHAR);
	  }
	}	
d607 2
a608 2
	if (!curseCounter)
		send_to_char("You sense nothing out of the ordinary.\r\n", ch);
d3606 5
a3610 2
  if (ch->timers) {
    for (timer = ch->timers; timer; timer = timer->next) {
d3619 2
a3620 1
  }
d3736 8
a3743 1
  if (ch->affected) {
d3747 10
a3756 1
    for (aff = ch->affected; aff; aff = aff->next) {
a3757 3
    }

    for (aff = ch->affected; aff; aff = aff->next) {
d3779 1
a3779 1
      if (aff->type <= 0 || aff->type > MAX_SKILLS)
d3783 3
a3785 2
      if (aff->duration == -1) {
        sprintf(buf, "ABL: (Unlim) &c%-21s&n ", skill_name(aff->type) );
d3796 5
a3800 4
        for (int i = 0; i < NUM_WEARS; i++) {
          if (GET_EQ(ch, i) && GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_MAGIC_EQ) {
            for (int j = 0; j < 3; j++) {
              if (GET_OBJ_VAL(GET_EQ(ch, i), j) == aff->type) {
a3803 3
            } 
          } 
        }
d3805 1
a3805 1
        if (found) {
d3808 1
a3808 1
        } else {
a3810 1
        }
@


1.86
log
@Artus> Moving stuff across to live.

act.informative.c:
  Info on it's own will now display the info file. Use me or self to see your
own info.
  Score and Exp now both show gained and remaining exp.
  Gold value is now to a max of 30000. (60000 in lvl 40+ zones, 120 in 70+)
  Gold rushes no longer occur in !GOLDRUSH zones, city sectors, etc.

act.other.c:
  Mana retained on remort is now floored at 100 instead of 50.
  Added elitist bonus for chars who play past the earliest remort point(s).

act.wizard.c:
  Gold rush events are now only advertised within the world they occur.

genolc.h:
  Added special #defines for different OLC levels whether running live or test.
  (Noted by compiling with -DPRIMAL_LIVE)

interpreter.c:
  Aliases will now be saved automatically, when added or remoed.
  Added elitist_modifier() to modifier calculation.
  Replaced Huh?!? with HUH.

limits.c:
  NPC corpses are no longer emptied before they are purged. Too much clutter.

spells.c:
  Reduced the amount of weight applied by create water to 1/3 of what it was.

comm.c:       Added send_to_not_zone_world()
db.c:         Added elitist_modifier() to modifier calculation.
dg_mobcmd.c:  Replaced Huh?!? with the define, HUH.
dg_scripts.h: Changed version string so it will fit on one line :o)
fight.c:      Eq should no longer be damaged when a hit fails.
handler.c:    Now, when the sleep spell wears of an NPC, it will wake up.
structs.h:    Added HUH define.
utils.c:      Added elitist_modifier() calculation.
utils.h:      Added elitist_modifier() prototype.
@
text
@d5709 8
a5716 1
  if ((targnum = world[ch->in_room].dir_option[direction]->to_room) == NOWHERE) {
@


1.85
log
@Artus>
\r\n appended to gold rush message: act.informative.c

Imms no longer affected by underwater: act.movement.c, limits.c

Changed remort some more.. New special, tracker (SPECIAL_TRACKER):
act.other.c, act.wizard.c, constants.c, graph.c, structs.h, utils.c

Object and Room triggers can now %send% <room vnum> <message>:
dg_objcmd.c, dg_wldcmd.c

%self.direction% now has a vnum subfield to return the exit room's vnum.
(Eg: %self.north(vnum)%): dg_scripts.c

%actor.hisher%, %actor.himher%, %actor.heshe% implemented: dg_scripts.c

vnum, name, can_see, can_see_me added to %actor.next_in_room%, returning char
vnum, char name, if actor can see char, and if char can see actor respectively:
dg_scripts.c

Changed "do not know that spell" to "do not know of that spell": spell_parser.c

Changed "do not of know that skill/spell" to "do not know of..": utils.c

SECT_UNDERWATER and SECT_INSIDE now checked in OUTSIDE() macro: utils.h
@
text
@d83 1
a83 1
void send_to_not_zone(const char *, zone_rnum);
d938 2
a939 2
ACMD(do_info){

d948 18
a965 2
	
  if (PLR_FLAGGED(ch, PLR_NOINFO) && (GET_LEVEL(ch) < LVL_GRGOD)) {
a970 1
  two_arguments(argument, arg, buf1);
d972 1
d981 1
a981 1
  }
d984 33
a1016 4
  if (!*buf1) {
    if ((tchid = get_id_by_name(arg)) < 1) {
      send_to_char("No such player!\r\n", ch);
      return;
a1017 6
    // Load the character up
    CREATE(tch, struct char_data, 1);
    clear_char(tch);
    load_char(arg, &tmp);
    store_to_char(&tmp, tch);
    char_to_room(tch, 0);
d1023 3
a1025 3
            GET_EMAIL(tch) == NULL ? "None" : GET_EMAIL(tch), 
            GET_WEBPAGE(tch) == NULL ? "None" : GET_WEBPAGE(tch),
            GET_PERSONAL(tch) == NULL ? "None" : GET_PERSONAL(tch));
d1027 2
a1028 1
    extract_char(tch);
d3254 1
a3254 1
    sprintf(buf3, "Experience tnl: %d\r\n", level_exp(ch, GET_LEVEL(ch) + 1) - GET_EXP(ch));
d3823 1
a3823 2
    sprintf(buf, "You need &c%d&n exp to reach your next level.\r\n",
      level_exp(ch,GET_LEVEL(ch)) - GET_EXP(ch));
d5571 11
a5581 14
int check_for_event(int event, zone_rnum zone) {

	struct event_data *ev;

	for( ev = events.list; ev; ev = ev->next ) 
		if( zone != -1 ) {
		   if( (ev->type == event) && (ev->room->zone == zone) )
			return 1;
		}
		else if( (ev->type == event) )
			return 1;

	return 0;

d5660 14
a5673 1
			  GET_OBJ_VAL(gold, 1) = number(1000, 1000000);
d5852 48
a5899 59
void init_gold_rush() {

	struct event_data *ev;
	int counter = 0, sector = 0;
        room_rnum rnum_room;

	// Create the new event
	CREATE(ev, struct event_data, 1);
	// Populate the details
	ev->chID = -1;
	// Get a room, checking it for a nice sector type, and a non-gold rush already zone
	do {    
     		ev->room = &world[number(1, top_of_world)];

		// Ignore !GOLDRUSH zones 
		if (IS_SET(zone_table[ev->room->zone].zflag, ZN_NO_GOLDRUSH))
		  continue;

		// Don't want an endless loop
		if( ++counter > 10 ) {	
			free(ev);	
			basic_mud_log("GoldRush: Unable to create event, counter limit reached.");
			return;
		}	

                //sprintf(buf, " Init gold rush: room %d", ev->room->number);
                //log(buf);
                // DM - was passing virtual room number, added real_room
                // doh, good one Tali ;p, sad thing is it took me a while
                // to realise ...
		// -- ner ner :P
                rnum_room = real_room(ev->room->number);

                basic_mud_log("init_gold_rush: attempting to use room rnum (%d) vnum (%d)", rnum_room, ev->room->number);

                // if room_rnum happens to be NOWHERE, set to one of the sector
                // types define at the bottom of the do while loop so we try
                // again and dont go outside the world[] array limits
                if (rnum_room == NOWHERE) {
                  sector = SECT_FIELD; 
                } else {
		  sector = SECT(rnum_room);
                }
		
	} while( (sector != SECT_FIELD) && (sector != SECT_FOREST) 
		&&(sector != SECT_HILLS) && (sector != SECT_MOUNTAIN)
		&& check_for_event(EVENT_GOLD_RUSH, world[real_room((ev)->room->number)].zone) );

	/* Leave the time details out for now */
//	ev->time_taken = time(0);
	ev->type = EVENT_GOLD_RUSH;
	// Log the room type
	//basic_mud_log("Room sector type is: %d.", sector);	
	add_event(ev);
	// Notify the zone
	sprintf(buf, "&YA GOLD RUSH is on at %s!&n\r\n", zone_table[ev->room->zone].name);
	send_to_zone(buf, ev->room->zone);
	sprintf(buf, "&WYou hear rumours of a gold rush at %s!&n\r\n",zone_table[ev->room->zone].name);
	send_to_not_zone(buf, ev->room->zone);
@


1.84
log
@Artus> Changed remort, in particular, list remort abilities to char.. Also,
       spellsword was incorrectly being listed as a possible path for a
       warrior.

       Replaced #ifdef USE_LOCALTIME with #ifndef NO_LOCALTIME..

       Added define NOTELL_SOUNDPROOF .. Define this to stop people telling
       to/from soundproof rooms.

       Removed extraneous level checking from do_wear.. This is handled
       better by perform_wear.
@
text
@d5858 1
a5858 1
	sprintf(buf, "&YA GOLD RUSH is on at %s!&n", zone_table[ev->room->zone].name);
@


1.83
log
@Artus> Couple of colour bleeds fixed up.. Nothing major.
@
text
@d2584 1
a2584 1
#ifdef USE_LOCALTIME
d4393 1
a4393 1
#ifndef USE_LOCALTIME
d4430 1
a4430 1
#ifdef USE_LOCALTIME
d4445 1
a4445 1
#ifdef USE_LOCALTIME
d4575 1
a4575 1
#ifdef USE_LOCALTIME
@


1.82
log
@Artus>
act.informative.c: Added Sense Wounds.
constants.c      : Added Sense Wounds.
db.c             : Fixed spell effectiveness.
dg_mobcmd.c      : mpurge will no longer purge player corpses.
dg_objcmd.c      : opurge will no longer purge player corpses.
dg_wldcmd.c      : wpurge will no longer purge player corpses.
fight.c          : Added Sense Wounds.
magic.c          : Added Sense Wounds.
spell_parser.c   : Added Sense Wounds.. Trialling changes do damage
                   done by headbutt, flytackle, piledrive.
spells.h         : Added Sense Wounds.
structs.h        : Added Sense Wounds.
@
text
@d1653 1
a1653 1
	  (GET_HIT(pers) > (int)(GET_MAX_HIT(pers) / 4)))
d1655 1
a1655 1
      act("$N&r could use a little healing!", TRUE, ch, NULL, pers, TO_CHAR);
@


1.81
log
@Artus> Implemented Autoeat.
       Putting objs in cursed containers now results in obj being cursed :o)
@
text
@d1645 16
a1660 1
  if(HUNTING(ch)) {
d1663 1
a1663 1
    }
@


1.80
log
@Artus> Added !KILL flag for mobs... Things like gamina, postmaster, etc, can
       have this set, which should make it pretty damn impossible for them to
       die..
       Modified more stuff for dark ritual and vampires.. Have added a switch
       statement to affect_remove, which should be a good central place to
       handle triggers on affect removal.. Mainly to reset mana/move/hit to
       make sure they're not higher than max values when removing werewolf/
       vampire.
@
text
@d3311 2
a3312 1
  if (EXT_FLAGGED(ch, EXT_AUTOGOLD)) {
d3318 3
d5041 1
a5041 1
          "     Wimp Level: %-4s   "  "    Color Level: %-10s"       "Hint Channel: %-3s\r\n"
d5043 1
a5043 1
          "  Prompt String: %s\r\n",
d5078 2
a5079 2
 
          buf2,
d5082 3
a5084 1
          GET_PAGE_LENGTH(vict), GET_PAGE_WIDTH(vict),
d5086 2
@


1.79
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@d727 2
a728 1
	if( GET_OBJ_VAL(obj, 0) == 1 ) {
d732 1
a732 2
	}	
	else {   // Room affect
@


1.78
log
@Artus> Sorry, Dish.. Another bastard change..

       has_stats_for_skill now takes an extra arg (bool) to determine whether
       or not to display messages.

       new routine: has_stats_for_prac.. Basically the same as
       has_stas_for_skill, without GET_SKILL(ch, i) == 0 check..

       Force is now restricted for <GRGOD.

       Score no longer displays punishment lines twice.

       New macro: IS_SKILL(skillnum) .. Used to determine whether skillnum is
                  a skill.
@
text
@d320 1
a320 1
	  log("Boss Mobile #%d cannot be burgle loaded.", lMob1);
d335 1
a335 1
	  log("Sub Mobile #%d cannot be burgle loaded.", lMob2);
d351 1
a351 1
	  log("Underling Mobile #%d cannot be burgle loaded.", lMob3);
d1084 1
a1084 1
//	log("Item %s, %d*100/%d = %lf", obj->short_description, GET_OBJ_DAMAGE(obj),
d2057 1
a2057 1
	log("%d, %d", current, max);
d3683 1
a3683 1
    //log("i = %d, noAffects = %d", i, noAffects);
d3686 1
a3686 1
      log("Affect (%d) = %d %s", i, aff->type, skill_name(aff->type));
d4416 1
a4416 1
	    log("Error in jk_localtime (users->login: %ld) [%s:%d]", users->login, __FILE__, __LINE__);
d4431 1
a4431 1
	      log("Error in jk_localtime(users->logout: %ld) [%s:%d]", users->logout, __FILE__, __LINE__);
d4561 1
a4561 1
      log("Error in jk_localtime (d->login_time: %ld) [%s:%d]", d->login_time, __FILE__, __LINE__);
d4664 1
a4664 1
    log("SYSERR: Unhandled case in do_gen_ps. (%d)", subcmd);
d5711 1
a5711 1
			log("Unhandled quest type found.");
d5801 1
a5801 1
			log("GoldRush: Unable to create event, counter limit reached.");
d5813 1
a5813 1
                log("init_gold_rush: attempting to use room rnum (%d) vnum (%d)", rnum_room, ev->room->number);
d5832 1
a5832 1
	//log("Room sector type is: %d.", sector);	
d6122 1
a6122 1
	log("Worshipping");
@


1.77
log
@Artus> As soon as i checked that in I knew I had to change ch => i.
@
text
@d3214 2
a3215 1
    if (PUN_FLAGGED(ch, i)) {
a3219 1
      bad = TRUE;
a3221 1
  strcpy(buf, buf2);
d3223 5
a3227 3
  if (i2 != 0) {           // colour code chars (8 per punishment)
    if (strlen(buf2) < (92 + 8*i3)) {
      for (i=1; i < (92 + 8*i3 - strlen(buf2)); i++) {
a3228 2
      }
    }
d3232 1
d3241 1
a3241 1
      sprintf(buf2, "%s &g%s&n[&c%d&n]", buf, offence_types[i], HAS_OFFENDED(ch,i));
a3243 1
      bad = TRUE;
a3245 1
  strcpy(buf, buf2);
d3247 5
a3251 3
  if (i2 != 0) {           // colour code chars (8 per offence)
    if (strlen(buf2) < (95 + 8*i3)) {
      for (i=1; i < (95 + 8*i3 - strlen(buf2)); i++) {
a3252 2
      }
    }
d3256 1
d3259 1
a3259 1
  if (bad) {
a3260 1
  }
d3264 2
a3265 1
  if (GET_LEVEL(ch) < LVL_ISNOT_GOD){
@


1.76
log
@Artus> Slight change to look_at_char. Now uses IS_DUAL_WIELDING(ch).
@
text
@d1343 1
a1343 1
        if ((j == WEAR_HOLD) && IS_DUAL_WIELDING(ch))
@


1.75
log
@Artus> Dual Wielding Wear/Remove/Display/Fighting Fixes.
       Cursed items can no longer be sold.
       Bodyslam message now appears in the right spot (hopefully).

       NOTE: IS_DUAL_WIELDING(ch) and IS_DUAL_CAPABLE(ch) defines in utils.h
             have been modified... If you plan to use them, check out how they
	     have changed first :o)
@
text
@d1343 1
a1343 3
        if (!IS_NPC(i) && GET_SKILL(i, SKILL_AMBIDEXTERITY) && 
	    GET_EQ(i, wear_positions[j]) && (wear_positions[j] == WEAR_HOLD) &&
	    CAN_WEAR(GET_EQ(i, wear_positions[j]), ITEM_WEAR_WIELD)) {
d1345 1
a1345 1
	} else {
a1346 1
	}
@


1.74
log
@Artus>
Adrenaline : (Potion Quaffing): 6 per fight Round instead of 5.
             (Flying Tackle)  : 2 fight rounds vs 3.
Balance    : QEQ no longer gets written to the log file when unbalanced.
Colour     : &f is no longer flash, &@@ is. Keep it quiet(tm).
Corpse File: Flush()ing after write().
Double Kick: Now calls apply_spell_skill_abil()
Echo       : No longer sends text to mobs calling it.
Fighting   : Is only possible if STATE = CON_PLAYING
Glance     : Fixed erroneous dex check.
OLC        : No longer possible while fighting.
           : LVL_IMPL+ (150+) can now edit mob levels up to 120.
Pit Trap   : Now logs deaths.
             No longer says "theoretically" on creation.
Report File: Flush()ing after write().
Spell/Skill: Now allows up to NUM_CLASSES class lines in primal_spskls
             (Used to only allow up to 10)
@
text
@d3799 2
a3800 3
      if (!IS_NPC(ch) && GET_SKILL(ch, SKILL_AMBIDEXTERITY) && 
	  GET_EQ(ch, wear_positions[i]) && (wear_positions[i] == WEAR_HOLD) && 
	  CAN_WEAR(GET_EQ(ch, wear_positions[i]), ITEM_WEAR_WIELD)) {
@


1.73
log
@Latest Version
@
text
@d1773 2
a1774 1
  if (found_char != NULL) {
d1776 6
a1781 3
    if (!IS_NPC(ch) && GET_SKILL(ch, SKILL_GLANCE)) 
      glancing = (number(0, 101) > GET_SKILL(ch, SKILL_GLANCE));
    if (glancing) 
d1783 7
a1789 10

    if ((ch != found_char) && (!glancing)) {
      if (CAN_SEE(found_char, ch))
	act("$n looks at you.", TRUE, ch, 0, found_char, TO_VICT);
      act("$n looks at $N.", TRUE, ch, 0, found_char, TO_NOTVICT);
    } else if (GET_LEVEL(found_char) > LVL_IMMORT) {
      if (ch != found_char) {
        act("$n glances at you.", TRUE, ch, 0, found_char, TO_VICT);
      }
    }
d2532 1
d4653 1
a4653 1
    sprintf(buf, "PrimalMUD version: &c%d.%d.%d&n Copyright (C) 1994-2002\r\n"
@


1.72
log
@

Modified: DM

Changed:
- fixed up the sorted affects command
@
text
@d2692 1
a2692 1
	pc_max_race_stats[GET_RACE(ch)][STAT_STR], cstar);
d2767 1
a2767 1
	pc_max_race_stats[GET_RACE(ch)][STAT_CON], cstar);
d2814 1
a2814 1
	pc_max_race_stats[GET_RACE(ch)][STAT_DEX], cstar);
d2870 1
a2870 1
	pc_max_race_stats[GET_RACE(ch)][STAT_INT], cstar);
d2946 1
a2946 1
	pc_max_race_stats[GET_RACE(ch)][STAT_WIS], cstar);
d2984 1
a2984 1
	pc_max_race_stats[GET_RACE(ch)][STAT_CHA], cstar);
d4652 1
d4655 1
a4655 1
            release.getMajor(), release.getBranch(), release.getMinor());
@


1.71
log
@Artus> Localtime() Fix
@
text
@d3558 3
a3659 1

d3667 1
a3667 6
        /* Routine to show what spells a char is affected by */
  
  
  
  if (ch->affected)
  {
d3669 1
a3669 1
    struct affected_type *affect_array[noAffects];
d3684 2
a3685 2
    //debug:
    log("i = %d, noAffects = %d", i, noAffects);
d3695 2
a3696 2
    for (aff = affect_array[0]; (aff) && i < noAffects; aff = affect_array[++i]) { 

d3698 1
a3698 1
         continue;
d3700 1
d3702 1
a3702 1
        sprintf(buf, "ABL: (Unlim) &c%-21s&n ", skill_name(aff->type));
d3705 5
a3709 8
        // It appears the affect is removed when time is 1,
        // spell affects from magic eq are given with time 0
        // for abilities they are given time -1
        
        // I hate this dodgy code of vaders ....
        // ok go through the eq list and find if the affect is given by eq

        // This code is DUPLICATED in act.wizard.c for stat 
d3711 2
a3712 1
        bool found = FALSE;
@


1.70
log
@

Modified: DM

Changed:
- minor bug fixes, implementation of ideas on email from sandii on 5/4
@
text
@d2565 2
a2566 2
  
  time_t ct = time(0);
d2570 1
d2572 6
d4381 3
d4418 1
d4420 8
d4433 1
d4435 8
d4563 1
d4565 8
@


1.69
log
@

Modified: DM

Changed:
- sorted the affects command output (act.informative.c)
- made a define for ignoring timeouts on name prompt (comm.c)
@
text
@d5232 2
a5233 1
    for (int i = 0; i < NUM_CMD_TYPES; i++) {
@


1.68
log
@
: ----------------------------------------------------------------------
: Enter Log.  Lines beginning with `CVS:' are removed automatically
:
: Committing in .
:
: Modified Files:
: 	act.informative.c act.other.c act.wizard.c balance.c class.c
: 	constants.c db.c fight.c handler.c interpreter.c magic.c
: 	oedit.c redit.c spec_procs.c spell_parser.c spells.h
: 	update_revisions
: ----------------------------------------------------------------------

Modified: DM

Changed:
- heaps: mostly minor bug fixes.
@
text
@d3660 1
a3660 1
  /*
d3664 3
a3666 1
    int noAffects = 1;
a3670 2
    struct affected_type *affect_array[noAffects];
	  
d3673 1
a3673 1
      affect_array[noAffects++] = aff;
d3679 20
a3698 7
    int i = 0;
    // now step through ordered array ...
     for (aff = affect_array[0]; i < noAffects; aff = affect_array[i++]) { 
      if( aff->duration == -1 ) {
        sprintf(buf, "ABL: (Unlim) &c%-21s&n ", skill_name(aff->type) );
      }
      else {
a3720 3
	// need a 2d array here, first entry duration, the second a string with the entry
	// sort the array on row1 of the array...
	// 
d3729 2
a3730 2
      if (aff->modifier)
      {
d3734 1
a3734 2
      if (aff->bitvector)
      {
a3744 1
*/
d4165 7
a4171 1
    return ((*left)->duration > (*right)->duration);
@


1.67
log
@
Modified: DM

Changed:
- Don't ask (large group checkin) - lots of bug fixes mainly.
- Use cvs diff if you really wanna see the changes.
@
text
@d151 1
d3555 1
d3639 1
a3639 1

d3650 4
d3656 1
d3659 3
d3664 8
a3671 2
    for (aff = ch->affected; aff; aff = aff->next)
    {
d3673 9
d3708 3
d3736 1
d4147 11
@


1.66
log
@
Modified: DM

Added:
- autoretrieve corpse display in toggle
@
text
@d4065 1
d4068 5
a4072 2
              (GET_SOCIAL_STATUS(ch) <= SOCIAL_UNDESIRABLE  ? CCRED(ch, C_SPR) :
               GET_SOCIAL_STATUS(ch) <= SOCIAL_LANDOWNER ? CCBLU(ch, C_SPR) : CCGRN(ch, C_SPR)),
d4078 1
a4078 1
              (GET_LEVEL(tch) >= LVL_ETRNL1 ? CCBBLU(ch, C_SPR) : ""))))),
d4112 1
a4112 1
    sprintf(buf, "\r\nNo-one at all!\r\n");
d4114 1
a4114 1
    sprintf(buf, "\r\nOne lonely character displayed.\r\n");
d4116 1
a4116 1
    sprintf(buf, "\r\n%d characters displayed.\r\n", num_can_see);
d4202 8
a4209 4
	int j = 11, k = 22;
	sprintf(buf, "%s[", (GET_SOCIAL_STATUS(tch) <= SOCIAL_UNDESIRABLE ? CCRED(ch, C_SPR) :
	                     GET_SOCIAL_STATUS(tch) <= SOCIAL_LANDOWNER ? CCBLU(ch, C_SPR) : 
			      CCGRN(ch, C_SPR)));
d4217 1
a4217 4
	sprintf(buf, "%s&n%s] %s%s %s&n", buf,
	  (GET_SOCIAL_STATUS(tch) <= SOCIAL_UNDESIRABLE ? CCRED(ch, C_SPR) :
	   GET_SOCIAL_STATUS(tch) <= SOCIAL_LANDOWNER ? CCBLU(ch, C_SPR) :
	   CCGRN(ch, C_SPR)),
d4223 3
a4225 3
	sprintf(buf, "%s[%02d/%02d/%-3d %c %s %s %s] %s%s %s%s&n",
		(GET_SOCIAL_STATUS(tch) <= SOCIAL_UNDESIRABLE ? CCRED(ch, C_SPR) :
		  GET_SOCIAL_STATUS(tch) <= SOCIAL_LANDOWNER ? CCBLU(ch, C_SPR) : CCGRN(ch, C_SPR)  ),
a4230 1
		s,
d4564 1
a4564 1
    sprintf(buf, "PrimalMUD version: &c%d.%d.%d&n Copyright (C) 1994-2001\r\n"
@


1.65
log
@
Modifed: DM

Added:
- IS_NPC check before an IS_DISGUISED call
@
text
@d4948 2
a4949 2
          "     Wimp Level: %-4s   "  "    Color Level: %-10s"        "Hint Channel: %-3s\r\n"
          "    Page Length: %-3d    " "     Page Width: %-3d\r\n"
d4990 1
@


1.64
log
@
Modified: DM

Changed:
- kill data in score to %ld's ...
@
text
@d1526 1
a1526 1
        if (!CHAR_DISGUISED(i))
@


1.63
log
@Artus> Added ghosts.. Newbies no longer die, they become ghosts.
@
text
@d2531 3
a2533 3
  sprintf(buf2, "%s &0Kills&n        : &1Imm&n[&c%d&n] &1By Imm&n[&c%d&n] "
		"&1Mob&n[&c%d&n] &1By Mob&n[&c%d&n] &1PC&n[&c%d&n] "
		"&1By PC&n[&c%d&n]",
@


1.62
log
@
Modified: DM

Changed:
- colour touch ups
@
text
@d4291 3
a4293 1
        strcat(buf, " (tag)");     
@


1.61
log
@Artus> Just a couple of minor bugfixes... Accounted for colour in whostring..
@
text
@d594 1
a594 1
	    act("You sense that &R$p&n is cursed.", FALSE, ch, obj, 0, TO_CHAR);
@


1.60
log
@Jus> Fixed a bunch of badly written for loops.. Modified who list to show all
     three levels. Modified who list to allow a string to be placed instead of
     level/class/etc. This string can be set with the
     set <player> whostring [string] command (LR_GRGOD+).
     If [string] is blank, level/class/etc will be displayed.
@
text
@d4202 2
a4203 2
	j -= (int)(strlen(GET_WHO_STR(tch)) / 2);
	k -= (j+strlen(GET_WHO_STR(tch)));
d4209 4
a4212 1
	sprintf(buf, "%s] %s%s %s&n", buf,
@


1.59
log
@Jus> Changed score display again. Commiting to move to another machine.
     These changes are not final, this is an intermediate build.
@
text
@d2462 1
a2462 2
  if ((strlen(ch_name)) < 28)
  for (i=1;i<(28-strlen(ch_name));i++)
d2464 2
d2470 1
a2470 2
  if ((strdisplen(GET_TITLE(ch))) < 35)				
  for (i=1;i<(35-((strdisplen(GET_TITLE(ch))) ? strdisplen(GET_TITLE(ch))  : 0));i++)
d2483 2
a2484 5
    if (strlen(buf2) < 53) {
      for(i=1; i < (53 - strlen(buf2)); i++) {
        strcat(buf, " ");
      }
    }
d2490 2
a2491 5
    if (strlen(buf2) < 61) {
      for(i=1; i < (61 - strlen(buf2)); i++) {
        strcat(buf, " ");
      }
    }
d2512 2
a2513 5
    if (strlen(mobname) < 19) {
      for (i=1; i < (19-strlen(mobname)); i++) {
        strcat(buf, " ");
      }
    }
d2517 1
a2517 1
      for (i=1; i < 28; i++) {
a2518 1
      }
d2520 1
a2520 1
      for (i=1; i < 29; i++) {
a2521 1
      }
d2540 2
a2541 5
  if (strdisplen(buf2) < 79) {
    for (i=1; i < (79-strdisplen(buf2)); i++) {
      strcat(buf, " ");
    }
  }
d2555 2
a2556 5
  if (strlen(buf2) < 124) {
    for(i=1; i < (124-strlen(buf2)); i++) {
      strcat(buf, " ");
    }
  }
d2592 2
a2593 4
    if (strlen(buf2) < 55) 
      for (i=1; i < (55-strlen(buf2)); i++) {
        strcat(buf, " ");
      }
d2596 1
a2596 1
    for (i=1; i < 36; i++) {
a2597 1
    }
d2627 1
a2627 2
  //if ((strlen(buf3)) < 3)
  //for (i=1;i<(3-strlen(buf3));i++)
d2641 1
a2641 2
  if ((strlen(buf3)) < 19)
  for (i=1;i<(19-strlen(buf3));i++)
d2666 1
a2666 2
  if ((strlen(buf2)) < 16)
  for (i=1;i<(16-strlen(buf2));i++)
d2709 1
a2709 2
  if (j < 12)
  for (i=1;i<(12-j);i++)
d2746 1
a2746 2
  if (j < 19)
  for (i=1;i<(19-j);i++)
d2754 1
a2754 2
  if (strlen(tmp) < 16)
  for (i=1;i<(16-strlen(tmp));i++)
d2789 1
a2789 2
  if (j < 19)
  for (i=1;i<(19-j);i++)
d2801 1
a2801 2
  if ((strlen(tmp1) + strlen(tmp2) +8) < 16)
  for (i=1;i<(16-strlen(tmp1)-strlen(tmp2)-8);i++)
d2836 1
a2836 2
  if (j < 19)
  for (i=1;i<(19-j);i++)
d2857 1
a2857 2
  if (strlen(tmp) < 16)
  for (i=1;i<(16-strlen(tmp));i++)
d2874 1
a2874 2
  if (strlen(tmp) < 19)
  for (i=1;i<(19-strlen(tmp));i++)
d2933 1
a2933 2
  if (j < 16)
  for (i=1;i<(16-j);i++)
d2963 1
a2963 2
  if (strlen(tmp) + ctmp < 19)
  for (i = 1;i < (19 - strlen(tmp) - ctmp);i++)
d2970 2
a2971 2
  if (strlen(tmp) < 16)
  for (i=1;i<(16-strlen(tmp));i++)
d2984 3
a2986 4
  sprintf(buf, "%s &1Armour Class&n : %s%d%s/%s10",
	cstar, CCACT(ch,C_NRM), compute_armor_class(ch, 0), CCSEP(ch,C_NRM), CCACT(ch,C_NRM));

  sprintf(tmp, "%d", compute_armor_class(ch, 0));
d2988 2
a2989 3
  if (strlen(tmp)+3 < 19)
  for (i=1;i<(19-strlen(tmp)-3);i++)
    strcat(buf," "); 
d2997 1
a2997 2
  if (strlen(tmp) < 16)
  for (i=1;i<(16-strlen(tmp));i++)
d3003 1
a3003 1
  for (i=1;i<18;i++)
d3017 1
a3017 2
  if (strlen(tmp) < 19)
  for (i=1;i<(19-strlen(tmp));i++)
d3027 1
a3027 2
  if ((digits(playing_time.hours)+digits(playing_time.day)+2) < 16)
  for (i=1;i<(16-digits(playing_time.hours)-digits(playing_time.day)-2);i++)
d3033 1
a3033 1
  for (i=1;i<18;i++)
d3054 1
a3054 2
  if ((digits(IS_CARRYING_W(ch))) < 11)
  for (i=0; i < (11-digits(IS_CARRYING_W(ch))); i++)
d3060 1
a3060 2
  if ((digits(IS_CARRYING_N(ch))) < 10)
  for (i=0; i < (10-digits(IS_CARRYING_N(ch))); i++)
d3076 1
a3076 2
  if ((digits(CAN_CARRY_W(ch))) < 11)
  for (i=0; i < (11-digits(CAN_CARRY_W(ch))); i++)
d3082 1
a3082 2
  if ((digits(CAN_CARRY_N(ch))) < 10)
  for (i=0; i < (10-digits(CAN_CARRY_N(ch))); i++)
d4196 37
a4232 19
      sprintf(buf, "%s[%3d %c %s %s %s] %s%s %s%s&n",
              (GET_SOCIAL_STATUS(tch) <= SOCIAL_UNDESIRABLE ? CCRED(ch, C_SPR) :
		GET_SOCIAL_STATUS(tch) <= SOCIAL_LANDOWNER ? CCBLU(ch, C_SPR) : CCGRN(ch, C_SPR)  ),
              GET_LEVEL(tch),
              (GET_SEX(tch)==SEX_MALE ? 'M' :
               GET_SEX(tch)==SEX_FEMALE ? 'F' : '-'),
              CLASS_ABBR(tch),
              RACE_ABBR(tch),
              s,
              (GET_LEVEL(tch) >= LVL_GOD ? CCBYEL(ch, C_SPR) :
               (GET_LEVEL(tch) >= LVL_ANGEL ? CCCYN(ch,C_SPR) :
               (GET_LEVEL(tch) >= LVL_IMMORT ? CCBBLU(ch,C_SPR) : CCNRM(ch, C_SPR)))),
               // (GET_LEVEL(tch) >= LVL_CHAMP ? CCBLU(ch,C_SPR) : "")))),
              GET_NAME(tch),
              GET_TITLE(tch),
              (GET_LEVEL(tch) >= LVL_GOD ? CCBYEL(ch, C_SPR) :
               (GET_LEVEL(tch) >= LVL_ANGEL ? CCCYN(ch,C_SPR) :
               (GET_LEVEL(tch) >= LVL_IMMORT ? CCBBLU(ch,C_SPR) : ""))));
               // (GET_LEVEL(tch) >= LVL_CHAMP ? CCBLU(ch,C_SPR) : ""))))); 
@


1.58
log
@
Modified: DM

Changed:
- more informative gold information
@
text
@d77 1
a77 1
int compute_armor_class(struct char_data *ch);
d646 1
a646 1
		"Hitroll Bonus:", GET_HITROLL(victim), "Armour Class:", compute_armor_class(victim));
d2126 1
a2126 1
			sprintf(buf, "Armour Class: %d\r\n", compute_armor_class(ch));
d3017 2
a3018 2
  sprintf(buf, "%s &1Armour Class&n : %s%d   %s",
	cstar, CCACT(ch,C_NRM), compute_armor_class(ch), CCACT(ch,C_NRM));
d3020 1
a3020 1
  sprintf(tmp, "%d", compute_armor_class(ch));
d3457 1
a3457 1
	  compute_armor_class(ch), GET_ALIGNMENT(ch));
@


1.57
log
@
Modified: DM

Changed:
- stat point updates, connection (char creation) states
@
text
@d1921 2
a1922 1
    sprintf(buf, "You have &Y%d&n gold coins.\r\n", GET_GOLD(ch));
d2999 1
a2999 2
  sprintf(buf2,"&n%s &1Gold&n  : %s%d&n", 
		  cstar, CCGOLD(ch,C_NRM), GET_GOLD(ch));
d3026 2
a3027 2
  sprintf(buf2,"%s &1Bank&n  : %s%d", 
		  cstar, CCGOLD(ch,C_NRM), GET_BANK_GOLD(ch));
@


1.56
log
@Artus: There's the armor class stuff..
@
text
@d2641 4
a2644 2
  sprintf(buf,"%s &1Class&n        : %s%-47s &1Base App Max&n %s\r\n", 
		  cstar, CCTEXT(ch,C_NRM), buf3, cstar);
@


1.55
log
@
Modified: DM

Changed:
- Stats in score - Base App Max
@
text
@d646 1
a646 1
		"Hitroll Bonus:", GET_HITROLL(victim), "Armour Class:", GET_AC(victim));
d2124 2
a2125 1
			sprintf(buf, "Armour Class: %d\r\n", GET_AC(ch));
d2318 1
a2318 1
     sprintf(buf, "%s&9Ac:&n %4d&4/10&n  ", buf, GET_AC(ch));
d3015 2
a3016 2
  sprintf(buf, "%s &1Armour Class&n : %s%d%s/&n%s10&n",
	cstar, CCACT(ch,C_NRM), GET_AC(ch), CCSEP(ch,C_NRM), CCACT(ch,C_NRM));
d3018 1
a3018 1
  sprintf(tmp, "%d", GET_AC(ch));
@


1.54
log
@
Modified: DM

Changed:
- finished fixing up score?
- added strdisplen function (colour.c)
- paging fix up
@
text
@d2156 1
a2156 1
			sprintf(buf, "Quest points: %d\r\n", GET_QP(ch));
d2549 2
a2550 2
  if (strlen(buf2) < 140) {
    for (i=1; i < (140-strlen(buf2)); i++) {
d2640 2
a2641 1
  sprintf(buf2,"%s &1Class&n        : %s%s&n", cstar, CCTEXT(ch,C_NRM), buf3);
d2643 4
a2646 4
  if ((strlen(buf3)) < 62)
  for (i=1;i<(62-strlen(buf3));i++)
    strcat(buf2," ");
  strcat(buf,buf2);
d2648 2
a2649 2
  sprintf(buf2,"%s\r\n",cstar);
  strcat(buf,buf2);
d2690 1
d2699 1
d2701 3
a2703 2
  sprintf(buf2,"%s &1STR&n: %s%d&n", 
		  cstar, CCSTAT(ch,C_NRM), GET_REAL_STR(ch),buf3);
d2706 1
d2734 1
d2779 3
a2781 2
  sprintf(buf2,"%s &1CON&n: %s%d&n",
	cstar, CCSTAT(ch,C_NRM),GET_REAL_CON(ch));
a2783 17
  sprintf(tmp, "%d", GET_REAL_CON(ch));
  j=strlen(tmp);
  if (GET_REAL_CON(ch)!=GET_AFF_CON(ch))
  {
    sprintf(buf2,"%s(%s%d%s)&n",
	CCSEP(ch,C_NRM), CCSTAT(ch,C_NRM), GET_AFF_CON(ch), CCSEP(ch,C_NRM));
    strcat(buf,buf2);
    sprintf(tmp, "%d", GET_AFF_CON(ch));
    j=j+2+strlen(tmp);
  }

  if (j < 12)
  for (i=1;i<(12-j);i++)
    strcat(buf," ");

  sprintf(buf2,"%s\r\n",cstar);
  strcat(buf,buf2);
d2828 3
a2830 1
  sprintf(buf2,"%s &1DEX&n: %s%d&n", cstar, CCSTAT(ch,C_NRM),GET_REAL_DEX(ch));
a2832 17
  sprintf(tmp1, "%d", GET_REAL_DEX(ch));
  sprintf(tmp2, "%d", GET_AFF_DEX(ch));

  j=strlen(tmp1);
  if (GET_REAL_DEX(ch)!=GET_AFF_DEX(ch))
  {
    sprintf(buf2,"%s(%s%d%s)&n",CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_AFF_DEX(ch),CCSEP(ch,C_NRM));
    strcat(buf,buf2);
    j=j+2+strlen(tmp2);
  }

  if (j < 12)
  for (i=1;i<(12-j);i++)
    strcat(buf," ");

  sprintf(buf2,"%s\r\n",cstar);
  strcat(buf,buf2);
d2886 3
a2888 1
  sprintf(buf2,"%s &1INT&n: %s%d&n", cstar, CCSTAT(ch,C_NRM), GET_REAL_INT(ch));
a2890 18
  sprintf(tmp1, "%d", GET_REAL_INT(ch));
  sprintf(tmp2, "%d", GET_AFF_INT(ch));

  j = strlen(tmp1);

  if (GET_REAL_INT(ch)!=GET_AFF_INT(ch))
  {
    sprintf(buf2,"%s(%s%d%s)&n",CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_AFF_INT(ch),CCSEP(ch,C_NRM));
    strcat(buf,buf2);
    j=j+2+strlen(tmp2);
  }

  if (j < 12)
  for (i=1;i<(12-j);i++)
    strcat(buf," ");

  sprintf(buf2,"%s\r\n",cstar);
  strcat(buf,buf2);
d2964 3
a2966 1
  sprintf(buf2,"%s &1WIS&n: %s%d&n", cstar, CCSTAT(ch,C_NRM), GET_REAL_WIS(ch));
a2968 17
  sprintf(tmp1, "%d", GET_REAL_WIS(ch));
  sprintf(tmp2, "%d", GET_AFF_WIS(ch));

  j=strlen(tmp1);
  if (GET_REAL_WIS(ch)!=GET_AFF_WIS(ch))
  {
    sprintf(buf2,"%s(%s%d%s)&n",CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_AFF_WIS(ch),CCSEP(ch,C_NRM));
    strcat(buf,buf2);
    j=j+2+strlen(tmp2);
  }
  
  if (j < 12)
  for (i=1;i<(12-j);i++)
    strcat(buf," ");

  sprintf(buf2,"%s\r\n",cstar);
  strcat(buf,buf2);
d3004 3
a3006 1
  sprintf(buf2,"%s &1CHA&n: %s%d&n", cstar, CCSTAT(ch,C_NRM), GET_REAL_CHA(ch));
a3008 17
  sprintf(tmp1, "%d", GET_REAL_CHA(ch));
  sprintf(tmp2, "%d", GET_AFF_CHA(ch));

  j=strlen(tmp1);
  if (GET_REAL_CHA(ch)!=GET_AFF_CHA(ch))
  {
    sprintf(buf2,"%s(%s%d%s)&n",CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_AFF_CHA(ch),CCSEP(ch,C_NRM));
    strcat(buf,buf2);
    j=j+2+strlen(tmp2);
  }
  
  if (j < 12)
  for (i=1;i<(12-j);i++)
    strcat(buf," ");

  sprintf(buf2,"%s\r\n",cstar);
  strcat(buf,buf2);
d6214 2
d6217 1
a6217 1
			GET_QUEST_POINTS(ch) += 1;
@


1.53
log
@
Modified: DM

Changed:
- updated version of score (a little to do)
@
text
@d2467 2
a2468 2
  if ((strlen(GET_TITLE(ch))) < 34)				
  for (i=1;i<(35-((strlen(GET_TITLE(ch))) ? strlen(GET_TITLE(ch)) - 2 : 0));i++)
d2475 26
d2629 1
a2629 1
  strcpy(buf,"%s               &0Other              %s     &0Description        %s    &0Statistics   %s\r\n");
d2847 1
a2847 1
    sprintf(buf2,"%s(%s%d%s)",CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_AFF_DEX(ch),CCSEP(ch,C_NRM));
d3209 1
d3212 1
a3212 1
  /* Routine to show what spells a char is affected by */
d3273 1
a3273 1
  /* Routine to show what timers a char is affected by */
d3286 2
d3297 1
a3297 1
  send_to_char(cline, ch);
d3312 4
a3315 1
  sprintf(buf, "PUN:");
d3318 2
a3319 1
      sprintf(buf, "%s %s[%d]", buf, punish_types[i], PUN_HOURS(ch, i));
d3321 2
d3325 12
a3336 4
  if (i2 == 0)
    strcat(buf, " None.");
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
d3340 2
a3341 1
  sprintf(buf, "OFF:");
d3344 1
a3344 1
      sprintf(buf, "%s %s[&g%d&n]", buf, offence_types[i], HAS_OFFENDED(ch,i));
d3346 2
a3348 4
  if (i2 == 0)
    strcat(buf, " None.");
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
d3350 1
d3352 13
a3364 4
  // Mounting info
  if (MOUNTING(ch)) {
	sprintf(buf2, ", Mounted on: %s", (IS_NPC(ch) ? "Yes" : GET_NAME(MOUNTING(ch))) );
	strcat(buf, buf2);
d3366 7
a3372 3
  if (MOUNTING_OBJ(ch)) {
	sprintf(buf2, ", Mounted on: %s", MOUNTING_OBJ(ch)->short_description);
	strcat(buf, buf2);
a3373 3
  /* Clan Rank, Clan Name - ARTUS */
  sprintf(buf, "Clan:&g %d&n (&g%s&n) Rank: &g%d&n of&g %d&n\r\n", GET_CLAN(ch), ((GET_CLAN(ch) > 0) ? clan[find_clan_by_id(GET_CLAN(ch))].name : "none"), GET_CLAN_RANK(ch), ((GET_CLAN(ch) > 0) ? clan[find_clan_by_id(GET_CLAN(ch))].ranks : 0));
  send_to_char(buf, ch);
a3374 7
  send_to_char(cline, ch);
  //strcpy(buf,"");  
  //  if (GET_LEVEL(ch) < LVL_ISNOT_GOD){
  //    sprintf(buf, "You need %s%d%s exp to reach your next level.\r\n", 
//	CCEXP(ch,C_NRM),(level_exp((int)GET_LEVEL(ch))) - GET_EXP(ch),CCNRM(ch,C_NRM));
 //     send_to_char(buf, ch);  
 //  }
d3422 1
a3422 1
    sprintf(buf2, "You are autoassisting %s.\r\n",GET_NAME(AUTOASSIST(ch)));
d3457 1
a3457 1
    strcat(buf, "Your eyes are glowing red.\r\n");
d3474 3
a3476 3
  if( MOUNTING(ch) ) {
   	sprintf(buf2, "You are mounted on %s.\r\n", GET_NAME(MOUNTING(ch)) );
  	strcat(buf, buf2);
a3482 2


@


1.52
log
@Modified: DM

Changed:
- score command - couple of updates
@
text
@d1 1
a1 2
/*
************************************************************************
d64 1
d2417 1
a2417 1
#define CCNUMB(ch,lvl) CCBMAG(ch,lvl)	/* Numbers - Age, Time		*/
d2421 1
a2421 1
#define CCSTAT(ch,lvl) CCBMAG(ch,lvl)	/* Stats			*/
d2458 1
a2458 2
  sprintf(buf,"%s %sCharacter Name%s: %s%s", 
		cstar,CCHEAD(ch,C_NRM),CCNRM(ch,C_NRM),CCNAME(ch,C_NRM),ch_name);
d2460 2
a2461 2
  if ((strlen(ch_name)) < 18)
  for (i=1;i<(18-strlen(ch_name));i++)
d2464 1
a2464 2
  sprintf(buf2,"%s %sTitle%s: %s%s",
		cstar,CCHEAD(ch,C_NRM),CCNRM(ch,C_NRM),CCNAME(ch,C_NRM),GET_TITLE(ch));
d2475 123
d2603 2
a2604 2
  strcpy(buf,"%s               %sOther              %s     %sDescription        %s    %sStatistics   %s\r\n");
  sprintf(buf2,buf,cstar,CCHEAD(ch,C_NRM),cstar,CCHEAD(ch,C_NRM),cstar,CCHEAD(ch,C_NRM),cstar);
d2614 1
a2614 2
  sprintf(buf2,"%s %sClass%s        : %s%s%s",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCTEXT(ch,C_NRM),buf3,CCNRM(ch,C_NRM));
d2629 1
a2629 2
  sprintf(buf2,"%s %sRace%s         : %s%s%s",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCTEXT(ch,C_NRM),buf3,CCNRM(ch,C_NRM));
d2636 1
a2636 1
  sprintf(buf2,"%s %sSex%s   : ",cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM));
d2654 1
a2654 1
  sprintf(buf3,"%s%s%s",CCTEXT(ch,C_NRM),buf2,CCTEXT(ch,C_NRM));
d2672 2
a2673 2
  sprintf(buf2,"%s %sSTR%s: %s%d%s",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCSTAT(ch,C_NRM),GET_REAL_STR(ch),buf3);
d2684 2
a2685 1
      sprintf(buf3,"%s/%s%d",CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_AFF_ADD(ch));
d2688 2
a2689 2
    sprintf(buf2,"%s(%s%d%s%s)%s",
	CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_AFF_STR(ch),buf3,CCSEP(ch,C_NRM),CCNRM(ch,C_NRM));
d2717 3
a2719 3
  sprintf(buf, "%s %sHit points%s   : %s%d%s/%s%d%s+%s%d%s", 
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),buf2,GET_HIT(ch),CCSEP(ch,C_NRM),CCBGRN(ch,C_NRM),
	GET_MAX_HIT(ch),CCSEP(ch,C_NRM), CCGAIN(ch,C_NRM),hit_gain(ch),CCNRM(ch,C_NRM));
d2738 2
a2739 2
  sprintf(buf2,"%s %sAge%s   : %s%d%s",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCNUMB(ch,C_NRM),age(ch)->year,CCNRM(ch,C_NRM));
d2747 2
a2748 2
  sprintf(buf2,"%s %sCON%s: %s%d%s",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCSTAT(ch,C_NRM),GET_REAL_CON(ch),CCNRM(ch,C_NRM));
d2755 2
a2756 2
    sprintf(buf2,"%s(%s%d%s)%s",
	CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_AFF_CON(ch),CCSEP(ch,C_NRM),CCNRM(ch,C_NRM));
d2781 3
a2783 3
  sprintf(buf, "%s %sMana Points%s  : %s%d%s/%s%d%s+%s%d",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),buf2,GET_MANA(ch),CCSEP(ch,C_NRM),CCBGRN(ch,C_NRM),
	GET_MAX_MANA(ch),CCSEP(ch,C_NRM),CCGAIN(ch,C_NRM),mana_gain(ch));
d2799 4
a2802 3
  sprintf(buf2,"%s %sHeight%s/%sWeight%s: %s%d%s,%s%d%s",
		cstar,CCSUB(ch,C_NRM),CCSEP(ch,C_NRM),CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),
		CCNUMB(ch,C_NRM),GET_HEIGHT(ch),CCSEP(ch,C_NRM),CCNUMB(ch,C_NRM),GET_WEIGHT(ch),CCNRM(ch,C_NRM));
d2812 1
a2812 2
  sprintf(buf2,"%s %sDEX%s: %s%d",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCSTAT(ch,C_NRM),GET_REAL_DEX(ch));
d2845 3
a2847 3
  sprintf(buf, "%s %sMovement%s     : %s%d%s/%s%d%s+%s%d",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),buf2,GET_MOVE(ch),CCSEP(ch,C_NRM),CCBGRN(ch,C_NRM),
	GET_MAX_MOVE(ch),CCSEP(ch,C_NRM),CCGAIN(ch,C_NRM),move_gain(ch));
d2875 2
a2876 2
  sprintf(buf2,"%s %sLevel%s : %s%d%s",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),buf3,GET_LEVEL(ch),CCNRM(ch,C_SPR));
d2885 1
a2885 2
  sprintf(buf2,"%s %sINT%s: %s%d",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCSTAT(ch,C_NRM),GET_REAL_INT(ch));
d2895 1
a2895 1
    sprintf(buf2,"%s(%s%d%s)",CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_AFF_INT(ch),CCSEP(ch,C_NRM));
d2910 2
a2911 2
  sprintf(buf, "%s %sHitroll%s      : %s%d",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCDH(ch,C_NRM),ch->points.hitroll);
d2966 3
a2968 3
  sprintf(buf2,"%s %sAlign%s : %s%s%s(%s%d%s)",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),buf3,alignbuf,CCSEP(ch,C_NRM),buf3,
	GET_ALIGNMENT(ch),CCSEP(ch,C_NRM));
d2979 1
a2979 2
  sprintf(buf2,"%s %sWIS%s: %s%d",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCSTAT(ch,C_NRM),GET_REAL_WIS(ch));
d2988 1
a2988 1
    sprintf(buf2,"%s(%s%d%s)",CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_AFF_WIS(ch),CCSEP(ch,C_NRM));
d3003 2
a3004 2
  sprintf(buf, "%s %sDamroll%s      : %s%d",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCDH(ch,C_NRM),ch->points.damroll);
d3025 2
a3026 2
  sprintf(buf2,"%s %sGold%s  : %s%d",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCGOLD(ch,C_NRM),GET_GOLD(ch));
d3034 1
a3034 2
  sprintf(buf2,"%s %sCHA%s: %s%d",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCSTAT(ch,C_NRM),GET_REAL_CHA(ch));
d3043 1
a3043 1
    sprintf(buf2,"%s(%s%d%s)",CCSEP(ch,C_NRM),CCSTAT(ch,C_NRM),GET_AFF_CHA(ch),CCSEP(ch,C_NRM));
d3059 2
a3060 2
  sprintf(buf, "%s %sArmour Class%s : %s%d%s/%s10",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCACT(ch,C_NRM),GET_AC(ch),CCSEP(ch,C_NRM),CCACT(ch,C_NRM));
d3068 2
a3069 2
  sprintf(buf2,"%s %sBank%s  : %s%d",
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCGOLD(ch,C_NRM),GET_BANK_GOLD(ch));
d3090 2
a3091 2
  sprintf(buf, "%s %sThac%s0%s        : %s%d",
	cstar,CCSUB(ch,C_NRM),CCACT(ch,C_NRM),CCNRM(ch,C_NRM),CCACT(ch,C_NRM),thaco(ch, NULL)); 
d3101 3
a3103 3
  sprintf(buf2,"%s %sTime%s  : %s%d%sd%s%d%sh", 
	cstar,CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCNUMB(ch,C_NRM),playing_time.day,CCSEP(ch,C_NRM),
	CCNUMB(ch,C_NRM),playing_time.hours,CCSEP(ch,C_NRM));
a3122 46
  // creation date and invis info
  
  time_t ct = time(0);
  char *tmpstr;
  // Char creation date
  ct = ch->player.time.birth;
  tmpstr = asctime(localtime(&ct));
  sprintf(buf, "%s %sCreation Date%s : %s", cstar, CCSUB(ch, C_NRM), CCNRM(ch, C_NRM), tmpstr);

  // remove /n from asctime date...
  buf[strlen(buf)-1] = '\0';

  strcat(buf," ");
  strcat(buf, cstar);

  if (GET_INVIS_LEV(ch) > 0) {
    if (GET_INVIS_TYPE(ch) == INVIS_SPECIFIC) {
      sprintf(buf3,"%sInvis to %s[%s%s%s]", CCSUB(ch, C_NRM), CCNRM(ch, C_NRM),
	  CCYEL(ch, C_NRM), get_name_by_id(GET_INVIS_LEV(ch)), CCNRM(ch,C_NRM));
    } else if( GET_INVIS_TYPE(ch) == INVIS_SINGLE) {
      sprintf(buf3,"%sInvis to Lvl %s[%s%ds%s]", CCSUB(ch, C_NRM), 
	  CCNRM(ch, C_NRM), CCYEL(ch,C_NRM), GET_INVIS_LEV(ch), 
	  CCNRM(ch,C_NRM));
    } else if (GET_INVIS_TYPE(ch) == INVIS_NORMAL) {
      sprintf(buf3,"%sInvis Lvl %s[%s%d%s]", CCSUB(ch, C_NRM), 
	  CCNRM(ch, C_NRM),CCYEL(ch,C_NRM), GET_INVIS_LEV(ch), CCNRM(ch,C_NRM));
    } else { 
      sprintf(buf3,"%sInvis to Lvls %s[%s%d-%d%s]", CCSUB(ch, C_NRM),
	  CCNRM(ch, C_NRM), CCYEL(ch, C_NRM), GET_INVIS_LEV(ch), 
	  GET_INVIS_TYPE(ch), CCNRM(ch,C_NRM));
    }

    sprintf(buf2, " %s%s", buf3, CCNRM(ch, C_NRM)); 
    strcat(buf, buf2);

    if (strlen(buf2) < 57) 
      for (i=1; i < (57-strlen(buf2)); i++) {
        strcat(buf, " ");
      }

  } else {
    if (strlen(buf2) < 47) 
      for (i=1; i < (47-strlen(buf2)); i++) {
        strcat(buf, " ");
      }
  }
a3123 27
  strcat(buf, cstar);
  strcat(buf, "\r\n");

  send_to_char(buf, ch);

  /* Remort Levels - ARTUS */
  sprintf(buf2, "%s %sRemort Levels%s:  %sOne%s[%s%3d%s] %sTwo%s[%s%3d%s] %sMax%s[%s%3d%s] %sTotal%s[%s%3d%s]", 
      cstar, CCSUB(ch, C_NRM), CCNRM(ch, C_NRM), 
      CCSUB(ch, C_NRM), CCNRM(ch, C_NRM), CCCYN(ch, C_NRM), GET_REM_ONE(ch), CCNRM(ch, C_NRM), 
      CCSUB(ch, C_NRM), CCNRM(ch, C_NRM), CCCYN(ch, C_NRM), GET_REM_TWO(ch), CCNRM(ch, C_NRM), 
      CCSUB(ch, C_NRM), CCNRM(ch, C_NRM), CCCYN(ch, C_NRM), GET_MAX_LVL(ch), CCNRM(ch, C_NRM), 
      CCSUB(ch, C_NRM), CCNRM(ch, C_NRM), CCCYN(ch, C_NRM), (GET_REM_ONE(ch) + GET_REM_TWO(ch) + GET_LEVEL(ch)), CCNRM(ch, C_NRM)); 
      

  sprintf(buf, "%s", buf2);

  if (strlen(buf2) < 169) {
    for(i=1; i < (169-strlen(buf2)); i++) {
      strcat(buf, " ");
    }
  }
  strcat(buf, cstar);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

  send_to_char(cline, ch);

d3126 2
a3127 2
  sprintf(buf,"%s              %sInventory                                    %s                 %s%s\r\n",
		cstar,CCHEAD(ch,C_NRM),cstar,cstar,CCNRM(ch,C_NRM));
d3131 2
a3132 2
  sprintf(buf,"%s %sCarrying weight %s: %s%d",
                cstar, CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCNUMB(ch,C_NRM),IS_CARRYING_W(ch));
d3138 2
a3139 2
  sprintf(buf2,"%s %sCarrying Items %s: %s%d",
                cstar, CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCNUMB(ch,C_NRM),IS_CARRYING_N(ch));
d3154 2
a3155 2
  sprintf(buf,"%s %sCan Carry Weight%s: %s%d",
		cstar, CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCNUMB(ch,C_NRM),CAN_CARRY_W(ch));
d3162 2
a3163 2
  sprintf(buf2,"%s %sCan Carry Items%s: %s%d",
                cstar, CCSUB(ch,C_NRM),CCNRM(ch,C_NRM),CCNUMB(ch,C_NRM),CAN_CARRY_N(ch));
d3277 3
a3279 3
  sprintf(buf, "Social Points: %d, Social Rank: %s\r\n", GET_SOCIAL_POINTS(ch),
	social_ranks[GET_SOCIAL_STATUS(ch)]);
  send_to_char(buf, ch);
a3307 11
  /* Kill Counts - Artus */ // ... You want to get stats off the target, Artus
  sprintf(buf, "Kills: Imm[&g%d&n] By Imm[&g%d&n] Mob[&g%d&n] By Mob[&g%d&n] PC[&g%d&n] By PC[&g%d&n]\r\n", 
	GET_IMMKILLS(ch), GET_KILLSBYIMM(ch), GET_MOBKILLS(ch), 
	GET_KILLSBYMOB(ch), GET_PCKILLS(ch), GET_KILLSBYPC(ch));
  send_to_char(buf, ch);
  
  if (!IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_DISGUISE)) {
    sprintf(buf, "Mob memorised: TODO - name, vnum (%d), Disguised: %s.\r\n", 
        CHAR_MEMORISED(ch), CHAR_DISGUISED(ch) == 0 ? "No" : "Yes");
    send_to_char(buf, ch);
  }
a3319 4
  send_to_char(buf, ch);

  /* Remort Levels - ARTUS */
  sprintf(buf, "Remort Levels:  One[&g%3d&n] Two[&g%3d&n] Max[&g%3d&n] Total[&g%3d&n]\r\n", GET_REM_ONE(ch), GET_REM_TWO(ch), GET_MAX_LVL(ch), (GET_REM_ONE(ch) + GET_REM_TWO(ch) + GET_LEVEL(ch)));
@


1.51
log
@
Modified: DM

Changed:
- score fixes (and back to old_primal_score)
@
text
@d2476 2
d3006 74
a3225 13
  if (!IS_NPC(ch)) {
    if( GET_INVIS_TYPE(ch) == INVIS_SPECIFIC )
      sprintf(buf3,"Invis to [%s%s%s]",CCYEL(ch, C_NRM),get_name_by_id(GET_INVIS_LEV(ch)),CCNRM(ch,C_NRM));
    else if( GET_INVIS_TYPE(ch) == INVIS_SINGLE )
      sprintf(buf3,"Invis to Lvl [%s%ds%s]",CCYEL(ch,C_NRM),GET_INVIS_LEV(ch),CCNRM(ch,C_NRM));
    else if( GET_INVIS_TYPE(ch) == INVIS_NORMAL )
      sprintf(buf3,"Invis Lvl [%s%d%s]",CCYEL(ch,C_NRM),GET_INVIS_LEV(ch),CCNRM(ch,C_NRM));
    else
      sprintf(buf3,", Invis to Lvls [%s%d-%d%s]",CCYEL(ch,
            C_NRM),GET_INVIS_LEV(ch),GET_INVIS_TYPE(ch), CCNRM(ch,C_NRM));
 
    send_to_char(strcat(buf3, "\r\n"), ch);
  }
a3231 7
  time_t ct = time(0);
  char *tmpstr;
  // Char creation date
  ct = ch->player.time.birth;
  tmpstr = asctime(localtime(&ct));
  sprintf(buf, "Creation Date: %s", tmpstr);
  send_to_char(buf, ch);
a3261 4
  send_to_char(buf, ch);

  /* Remort Levels - ARTUS */
  sprintf(buf, "Remort Levels:  One[&g%3d&n] Two[&g%3d&n] Max[&g%3d&n] Total[&g%3d&n]\r\n", GET_REM_ONE(ch), GET_REM_TWO(ch), GET_MAX_LVL(ch), (GET_REM_ONE(ch) + GET_REM_TWO(ch) + GET_LEVEL(ch)));
@


1.50
log
@
Modified: DM

Changed:
- glance bug (glanced variable not initialised to FALSE)
- colour bleed on players glowing with a bright light
- blank title extra space removal
@
text
@d2469 2
a2470 2
  if ((strlen(GET_TITLE(ch))) < 34)
  for (i=1;i<(35-strlen(GET_TITLE(ch)));i++)
d2491 1
a2491 1
  sprintf(buf2,"%s %sClass%s         : %s%s%s",
d2494 2
a2495 2
  if ((strlen(buf3)) < 60)
  for (i=1;i<(60-strlen(buf3));i++)
d2610 1
a2610 1
  j = tmpl1 + tmpl2 + tmpl3;
d2886 13
d2901 2
a2902 2
  if (strlen(tmp) < 19)
  for (i=1;i<(19-strlen(tmp));i++)
a3062 1
  
a3360 1
// DM - TODO - redesign the score screen.
d3375 2
d3378 5
a3382 5
  if (SCORE_SETTINGS(ch) || *argument)
  {
  	primal_score(ch, argument);
  	return;
  }
d3384 1
a3396 6
  sprintf(buf + strlen(buf),
	"Your bonus to hit is %d, while your bonus to damage is %d.\r\n", 
		GET_HITROLL(ch), GET_DAMROLL(ch));

  if (IS_SET(GET_SPECIALS(ch), SPECIAL_MINOTAUR | SPECIAL_SUPERMAN))
	foundDamBonus = TRUE;
a3397 11
  if (foundDamBonus)
  {
	if (IS_SET(GET_SPECIALS(ch), SPECIAL_MINOTAUR))
		nTmp += (GET_DAMROLL(ch) * 0.05);

	if (IS_SET(GET_SPECIALS(ch), SPECIAL_SUPERMAN))
		nTmp += (GET_DAMROLL(ch) * 0.02);

	sprintf(buf + strlen(buf), "However, your effective damage bonus is %d.\r\n",
		GET_DAMROLL(ch) + (int)(nTmp+1));
  }
d3510 1
@


1.49
log
@
Modified: DM

Changed:
- colour fix for detect align
@
text
@d1450 6
a1455 1
    else  sprintf(buf, "&7%s %s&7", i->player.name, GET_TITLE(i));
d1493 1
a1493 1
      strcat(buf, " &r(Red Aura)&n");
d1758 1
a1758 1
  bool glancing;
@


1.48
log
@
Modified: DM

Changed:
- Added zone hints (index based boot)
- Balance [mo]edit info for unbalanced attribs
@
text
@d1408 1
a1408 1
    if (AFF_FLAGGED(i, AFF_INVISIBLE))
d1410 1
a1410 1
    else
d1412 1
d1416 5
a1420 4
      if (IS_EVIL(i))
	strcat(buf, "&r(Red Aura)&n ");
      else if (IS_GOOD(i))
	strcat(buf, "&b(Blue Aura)&n ");
@


1.47
log
@*** empty log message ***
@
text
@d90 1
d517 20
@


1.46
log
@*** empty log message ***
@
text
@d79 1
a79 1
int compute_thaco(struct char_data *ch);
d619 1
a619 1
	       	GET_HIT(victim), GET_MAX_HIT(victim), "Combat Skill Rating:", thaco(victim));
d2099 1
a2099 1
			sprintf(buf, "THAC0: %d\r\n", thaco(ch));
d2259 1
a2259 1
       sprintf(buf, "%s  &9THAC0:&n %-5d", buf, thaco(ch));
d2261 1
a2261 1
       sprintf(buf, "%s &9THAC0:&n %-5d", buf, thaco(ch));
d2931 1
a2931 1
	cstar,CCSUB(ch,C_NRM),CCACT(ch,C_NRM),CCNRM(ch,C_NRM),CCACT(ch,C_NRM),thaco(ch)); 
d2933 1
a2933 1
  sprintf(tmp, "%d", thaco(ch));
@


1.45
log
@Artus: Let remorts see the details of effects when < level 20.
@
text
@d2148 1
d2150 4
d2376 943
@


1.44
log
@Modified: DM

Changed:
- made MAGIC_EQ spells be shown in affects as Unlim
@
text
@d2659 2
a2660 2
        if (GET_LEVEL(ch) < 20)
                return;
@


1.43
log
@Modified: DM

Added:
- mob special bug check
@
text
@d2672 29
a2700 2
        sprintf(buf, "SPL: (%3dhr) %s%-21s%s ", aff->duration + 1,
          CCCYN(ch, C_NRM), skill_name(aff->type), CCNRM(ch, C_NRM));
@


1.42
log
@Modified: DM and Artus

Added:
- dual wielding
@
text
@d1495 3
@


1.41
log
@*** empty log message ***
@
text
@d1315 13
a1327 1
	send_to_char(where[wear_positions[j]], ch);
d1753 3
a1755 1
      act("$n glances at you.", TRUE, ch, 0, found_char, TO_VICT);
d2693 21
a2713 5
    if (GET_LEVEL(ch) < LVL_ISNOT_GOD){
      sprintf(buf, "You need &c%d&n exp to reach your next level.\r\n",
        level_exp(ch,GET_LEVEL(ch)) - GET_EXP(ch));
      send_to_char(buf, ch);
   }
d2733 13
a2745 1
      send_to_char(where[wear_positions[i]], ch);
d3045 1
d4704 1
a4704 1
	sprintf(buf, "You hear rumours of a gold rush at %s!\r\n",zone_table[ev->room->zone].name);
@


1.40
log
@*** empty log message ***
@
text
@d3007 1
d3013 1
a3013 1
              GET_LEVEL(tch), CLASS_ABBR(tch), GET_NAME(tch),
d3016 1
a3016 1
      send_to_char(buf, ch);
@


1.39
log
@Modified: DM

Added:
- !GOLDRUSH zone flag checking
@
text
@d29 3
d62 3
d85 3
a87 1

d97 7
d155 361
d735 1
a735 1
	int chance = 0, i, counter = 0;
d753 1
a753 1
		chance = 15;	// 15%
d755 1
a755 1
		chance = 5;	// 5%
d757 4
a760 1
		chance = 2;	// 2%
d777 10
d798 1
a798 1
		   if( number(1, chance) == chance) {  // favour thieves
d802 1
d804 10
d899 2
a900 2
  for (counter = found; counter; counter--) {
    load_char(get_name_by_id(immid[counter-1]), &tmp); 
d907 1
a907 1
                 GET_NAME(tch), (found - counter + 1),GET_IMMKILLS(tch)); 
d957 5
a961 3
    sprintf(buf, "&g%s's Info&n\r\n"
            "&y Email: &n%s\r\n&y Webpage:&n %s\r\n&y Personal: &n%s&n\r\n",
            GET_NAME(tch), 
d976 1
a976 1
    if (!str_cmp(buf1, "clear") == 0 ) {
d1415 1
a1415 2
    else
      sprintf(buf, "&7%s %s&7", i->player.name, GET_TITLE(i));
d1482 10
a1491 1
	list_one_char(i, ch);
d1570 9
d1581 3
a1583 2
    sprintf(buf2, "[%5d] %s [ %s]", GET_ROOM_VNUM(IN_ROOM(ch)),
	    world[ch->in_room].name, buf);
d3003 4
a3006 1
      sprintf(buf, "%s[%3d %s] %-12.12s%s%s",
d3133 3
a3135 5
      sprintf(buf, "%s[%3d %c %s %s %s] %s %s%s",
              (GET_LEVEL(tch) >= LVL_GOD ? CCBYEL(ch, C_SPR) :
               (GET_LEVEL(tch) >= LVL_ANGEL ? CCCYN(ch,C_SPR) :
               (GET_LEVEL(tch) >= LVL_IMMORT ? CCBBLU(ch,C_SPR) : ""))),
               // (GET_LEVEL(tch) >= LVL_CHAMP ? CCBLU(ch,C_SPR) : "")))),
d3142 4
a4329 2
#define BOUNTY_RETURN_ROOM	1000

d4517 3
a4519 3
	//handle_gold_rush(ev, <vnum1>);
	//handle_gold_rush(ev, <vnum2>);
	//handle_gold_rush(ev, <vnum3>);
d4544 15
d4578 1
a4578 1
					if( ev->ch == d->character )
d4590 1
a4590 1
				ev->ch = d->character;
a4600 2


d4612 1
a4612 1
	ev->ch = NULL;
d4633 1
d4677 143
d4849 2
d4853 1
d5014 1
a5014 1
			bounty_count + 1, GET_NAME(ev->ch));
d5062 1
a5062 2
		  if( get_id_by_name(arg) ==
		      get_id_by_name( GET_NAME(ev->ch) ) ) {
d5065 1
a5065 1
		     if( get_id_by_name(GET_NAME(ch)) == ev->info3 ) {
d5067 1
d5069 2
a5070 1
 
d5072 1
a5072 1
		       GET_GOLD(ch) += (int)(ev->info1 - (0.10*ev->info1));
d5083 1
a5083 1
			send_to_char("You uselessly try to collect the bounty.\r\n", ch);			
d5104 1
a5104 1
			   GET_NAME(ev->ch), ev->info1);
d5109 6
d5161 1
a5161 1
	ev->ch = vict; 		// Target
d5165 1
a5165 1
	ev->room= &world[ch->in_room];
a5176 1

@


1.38
log
@Modified: DM

Added:
- define for GOLD_OBJ_VNUM (chunk of gold for goldrushs)
@
text
@d4180 5
@


1.37
log
@Added stuff for healing trance..
@
text
@a3933 1
#define GOLD_OBJ_VNUM 13674
@


1.36
log
@Added: Timers, Glance, Listen
@
text
@d1018 2
@


1.35
log
@*** empty log message ***
@
text
@d107 1
d1016 2
d1293 1
d1309 6
a1314 1
    if (ch != found_char) {
d1318 2
d2100 18
d4007 76
@


1.34
log
@Artus - Cleanup after gold rush.. Will probably be removed once we've agreed
        on how this is going to be handled..
@
text
@d138 1
a138 1

d449 16
d481 7
a487 4
    if (GET_LEVEL(tch) >= LVL_IMMORT) {
      immid[found] = counter;
      immpts[found] = GET_IMMKILLS(ch);
      found++;
d2084 3
@


1.33
log
@*** empty log message ***
@
text
@d640 3
d2535 1
a2535 1
              (GET_LEVEL(tch) >= LVL_ETRNL1 ? CCBLU(ch, C_SPR) : ""))))),
d2660 1
a2660 1
               (GET_LEVEL(tch) >= LVL_IMMORT ? CCBLU(ch,C_SPR) : ""))),
d2672 1
a2672 1
               (GET_LEVEL(tch) >= LVL_IMMORT ? CCBLU(ch,C_SPR) : ""))));
d2681 1
a2681 1
        sprintf(buf, "%s [%s - %s]&n", buf, clan[c].name, clan[c].rank_name[(GET_CLAN_RANK(tch) - 1)]);
d3607 1
a3607 1
    sprintf(usage + strlen(usage), "\r\n&0Command Types:&n\r\n");
d3881 1
a3881 1

d3886 2
d3891 29
a3919 5
		sprintf(buf, "&yThe gold rush in %s has ended!",
			zone_table[zone].name); 
		mudlog(buf, BRF, 1, FALSE); // (msg, type, level, to_file)
		ev->type = EVENT_OVER;
		return;
d3948 2
a3949 2
				gold = read_object(real_object(13674), REAL);
				GET_OBJ_VAL(gold, 1) = number(1000, 1000000);
@


1.32
log
@Modified: Rod

Changed:
- commands socials to work ...
@
text
@d601 2
a602 1
		"It is &Yslightly damaged&n.",
d618 1
a618 1
	    dmgno = 5;
d620 1
a620 1
	    dmgno = 6;
d625 4
a628 2
		dmgno = dmgno;
	else if (damage == 0) 
d630 1
a630 1
        else if (damage <= 20)
d632 3
a634 3
	else if (damage <= 50)
	   dmgno = 3;
	else if (damage <= 70)
d636 1
a636 1
	else if (damage <= 95)
d638 1
a638 4
	else dmgno = 0;

//	log("Item %s, %d*100/%d = %lf", obj->short_description, GET_OBJ_DAMAGE(obj),
//		GET_OBJ_MAX_DAMAGE(obj), damage);
@


1.31
log
@Modified: Rod

Changed:
- rewrite of do_commands for command classifications
@
text
@d3574 1
a3574 1
         socials == cmd_sort_info[i].is_social)) {
@


1.30
log
@Modified: Artus - Clan/Punishment/PK
@
text
@d3488 19
d3508 2
d3511 3
a3513 5
ACMD(do_commands)
{
  int no, i, cmd_num;
  int wizhelp = 0, socials = 0;
  struct char_data *vict;
d3515 4
a3518 1
  one_argument(argument, arg);
d3520 12
a3531 4
  if (*arg) {
    if (!(vict = get_char_vis(ch, arg, FIND_CHAR_WORLD)) || IS_NPC(vict)) {
      send_to_char("Who is that?\r\n", ch);
      return;
d3533 2
a3534 3
    if (GET_LEVEL(ch) < GET_LEVEL(vict)) {
      send_to_char("You can't see the commands of people above your level.\r\n", ch);
      return;
d3536 7
a3542 2
  } else
    vict = ch;
d3544 14
a3557 4
  if (subcmd == SCMD_SOCIALS)
    socials = 1;
  else if (subcmd == SCMD_WIZHELP)
    wizhelp = 1;
d3559 2
a3560 1
  sprintf(buf, "The following &c%s%s&n are available to &b%s&n:\r\n",
d3564 2
a3565 2

  /* cmd_num starts at 1, not 0, to remove 'RESERVED' */
d3568 1
d3570 12
a3581 7
	GET_LEVEL(vict) >= cmd_info[i].minimum_level &&
	(cmd_info[i].minimum_level >= LVL_ETRNL1) == wizhelp &&
	(wizhelp || socials == cmd_sort_info[i].is_social)) {
      sprintf(buf + strlen(buf), "%-11s", cmd_info[i].command);
      if (!(no % 7))
	strcat(buf, "\r\n");
      no++;
d3586 19
d3606 38
a3643 1
  page_string(ch->desc, buf, TRUE);
@


1.29
log
@Modifed: DM

Changed: typo in toggle, colour bleed in toggle display
@
text
@d25 1
d42 1
a42 1
extern struct clan_data clan_info[NUM_CLANS];
d78 2
d129 2
a130 1
void display_clan_table(struct char_data *ch, struct clan_data *clan);
d427 1
a427 1

d2389 1
a2389 1
"&1usage: &4who [minlev[-maxlev]] [-i [clan name]] [-n name] [-c classlist]\r\n[-a] [-b] [-t] [-s] [-o] [-q] [-r] [-z]\r\n"
d2403 1
a2403 1
  int showClanOnly = 0, clanNumber = CLAN_UNDEFINED;
d2481 2
a2482 7
      for (i=0; i < NUM_CLANS; i++) {
        if (!strn_cmp(clan_search,clan_info[i].name,3)) {
          clanNumber = i;
          continue;
        }
      }            
      if (clanNumber==CLAN_UNDEFINED) {
d2484 1
a2484 1
        send_to_char("That is not a clan, type 'clans' to see the list.\r\n",ch);
d2488 1
a2488 1
      if (GET_CLAN_NUM(ch) == CLAN_UNDEFINED) {
d2493 1
a2493 1
        clanNumber = GET_CLAN_NUM(ch);
d2511 1
a2511 1
    if ((showClanOnly && GET_CLAN_NUM(tch) != clanNumber))
d2672 4
a2675 2
      if (GET_CLAN_NUM(tch) >= 0) {
        if (EXT_FLAGGED(tch, EXT_LEADER)) 
a2676 2
        else if (EXT_FLAGGED(tch, EXT_SUBLEADER))
          strcat(buf, CCCYN(ch, C_SPR));
d2678 1
a2678 1
        sprintf(buf, "%s [%s - %s]&n", buf, get_clan_disp(tch), get_clan_rank(tch));
d2715 2
d3413 1
a3413 1
          ONOFF(!EXT_FLAGGED(vict, EXT_NOCTALK)),
d3416 1
a3416 1
          YESNO(EXT_FLAGGED(vict, EXT_CLAN)),
d3539 1
d3542 2
a3543 1
 
d3545 1
d3598 1
d3601 1
d3619 1
d3633 2
a3634 1
 
d3655 1
@


1.28
log
@
Added:
-
- prompt_string in toggle
@
text
@d3325 1
a3325 1
    if ((victim = get_char_vis(ch,buf1,TRUE))) {
d3350 1
a3350 1
    strcat(prompt_string, "'");
@


1.27
log
@
Added:
- buffer length check in page_string to display corrupt message (originally
just in perform_immort_where
@
text
@d3336 3
a3338 1
  if (IS_NPC(ch))
d3345 24
d3381 2
a3382 1
          "    Page Length: %-3d    " "     Page Width: %-3d\r\n",
d3421 2
a3422 1
          GET_PAGE_LENGTH(vict), GET_PAGE_WIDTH(vict));
@


1.26
log
@
Added:
- newline after colourset usage help

Removed:
- check on players level in users command for idle ticks
@
text
@a3145 3
      if (strlen(buf) > MAX_STRING_LENGTH) {
        send_to_char("&RWarning, buffer length exceeded, output will be corrupt.&n\r\n", ch);          
      }
@


1.25
log
@
Changed:
- Fixed immlist, and removed debug info
@
text
@d2919 1
a2919 1
    if (d->character && STATE(d) == CON_PLAYING && (GET_LEVEL(d->character) <= GET_LEVEL(ch)))
d3627 1
a3627 1
  char *usage="&1Usage:&n &4colourset&n [-<0..9> { <colourcode> | Default }]";
@


1.24
log
@
Added:
- more debug info for immlist
@
text
@d447 4
a450 3
    strcpy(buf, get_name_by_id(counter));
    if (buf) {
      sprintf(buf1, "get_name_by_id(%ld) = %s\r\n", counter, buf);
d452 1
a452 8
      sprintf(buf1, "get_name_by_id(%ld) = NULL\r\n", counter);
    }
    send_to_char(buf1, ch);

    if (load_char(get_name_by_id(counter), &tmp) < 0) { 
      sprintf(buf, "failed to load char, counter = %ld\r\n", counter);
      send_to_char(buf, ch);
      continue;
a460 4
    sprintf(buf, "counter = %ld, char id = %ld, char name = %s\r\n",
                    counter, GET_IDNUM(tch), GET_NAME(tch));
    send_to_char(buf, ch);

a467 3

  sprintf(buf, "%d immorts found\r\n", found);
  send_to_char(buf, ch);
@


1.23
log
@
Added:
- debug output in immlist
@
text
@d440 1
a440 1
  int counter, found = 0;
d447 8
d456 1
a456 1
      sprintf(buf, "failed to load char, counter = %d\r\n", counter);
d467 1
a467 1
    sprintf(buf, "counter = %d, char id = %ld, char name = %s\r\n",
@


1.22
log
@
Added:
- debug line to output for immlist command

Changed:
- re-formatted immlist and sort functions
@
text
@d447 3
a449 1
    if (load_char(get_name_by_id(counter), &tmp) < 0) 
d451 1
d458 4
@


1.21
log
@
Added:
- Race abbreviations to who list
@
text
@d421 2
a422 16
	int i, j;
	long hold;

	for(i =0; i < num; i++)
            for(j=0; j < num - 1; j++ ) 
                if( list[j] > list[j+1] ){	    
	    	  hold = list[j];
		  list[j] = list[j+1];
		  list[j+1] = hold;

		  // Move the owner with it
		  hold = owners[j];
		  owners[j] = owners[j+1];
		  owners[j+1] = hold;
		}

d424 12
d438 41
a478 38
ACMD(do_immlist) {

	int counter, found = 0;
	struct char_data *tch;
	struct char_file_u tmp;
	long  immpts[NUM_PLAYERS], // kills vs imms
	      immid[NUM_PLAYERS];  // Id's of imms found


	for(counter = 1; counter <= top_idnum; counter++) {
               if( load_char(get_name_by_id(counter), &tmp) < 0) 
		    continue;
		// Player exists 
		CREATE(tch, struct char_data, 1);
		clear_char(tch);
		store_to_char(&tmp, tch);
		char_to_room(tch, 0);

		if( GET_LEVEL(tch) >= LVL_IMMORT ){
		   immid[found] = counter;
		   immpts[found] = GET_IMMKILLS(ch);
		   found++;
		}		  				
		extract_char(tch);
	}	

	// sort in ascending order
	sort(immpts, immid, found);

	// Now display the stats
	sprintf(buf, "\r\n   &r.-&R'-.&y_.&Y-'&w-&W Primal Immortals &w-&Y'-&y._.&R-'&r-.&n\r\n");
	sprintf(buf + strlen(buf), "\r\n\r\n       &BName          Rank     Kills\r\n");
	for(counter = found; counter; counter--) {
           load_char(get_name_by_id(immid[counter-1]), &tmp); 
	   CREATE(tch, struct char_data, 1);
	   clear_char(tch);
	   store_to_char(&tmp, tch);
	   char_to_room(tch, 0);
d480 2
a481 2
	   sprintf(buf+strlen(buf), "&y       %-12s  %2d         %ld&n\r\n", 
		GET_NAME(tch), (found - counter + 1),GET_IMMKILLS(tch) ); 
d483 4
a486 4
        }
	sprintf(buf + strlen(buf), "\r\n       &B%d &bImmortal%s listed.\r\n&n",
	  found, found == 1 ? "" : "s"); 	
	send_to_char(buf, ch);
@


1.20
log
@
Added:
- Initial inclusion of dgscripts
@
text
@a53 1
extern char *class_abbrevs[];
d2652 1
a2652 1
      sprintf(buf, "%s[%3d %c %s %s] %s %s%s",
d2661 1
@


1.19
log
@
Added:
- page length and page width values on toggle ...
@
text
@d25 1
d2994 1
@


1.18
log
@
Changed:
- print_object_location to take another arg - writeto:
  instead of sending straight to char, it is now paged.
@
text
@d3352 3
a3354 2
          "     Wimp Level: %-4s   "  "    Color Level: %-10s"        "Hint Channel: %-3s\r\n",
 
d3391 2
a3392 1
          ONOFF(!EXT_FLAGGED(vict, EXT_NOHINTS)));
@


1.17
log
@

Changed:
- 2 lines of formatting
@
text
@d81 1
a81 1
void print_object_location(int num, struct obj_data * obj, struct char_data * ch, int recur);
d3054 2
a3055 2
void print_object_location(int num, struct obj_data * obj, struct char_data * ch,
			        int recur)
d3058 1
a3058 1
    sprintf(buf, "&bO&n%3d. %-25s - ", num, obj->short_description);
d3060 1
a3060 1
    sprintf(buf, "%33s", " - ");
d3063 1
a3063 1
    sprintf(buf + strlen(buf), "&c[%5d]&n %s\r\n",
d3065 1
a3065 1
    send_to_char(buf, ch);
d3067 1
a3067 1
    sprintf(buf + strlen(buf), "carried by %s\r\n",
d3069 1
a3069 1
    send_to_char(buf, ch);
d3071 1
a3071 1
    sprintf(buf + strlen(buf), "worn by %s\r\n",
d3073 1
a3073 1
    send_to_char(buf, ch);
d3075 1
a3075 1
    sprintf(buf + strlen(buf), "inside %s%s\r\n",
d3077 6
a3082 3
    send_to_char(buf, ch);
    if (recur)
      print_object_location(0, obj->in_obj, ch, recur);
d3084 2
a3085 2
    sprintf(buf + strlen(buf), "in an unknown location\r\n");
    send_to_char(buf, ch);
d3098 3
d3102 1
a3102 1
    send_to_char("&gPlayers&n\r\n-------\r\n", ch);
d3108 1
a3108 1
	    sprintf(buf, "%-20s - &c[%5d]&n %s (%s) (in %s)\r\n",
d3114 1
a3114 1
	    sprintf(buf, "%-20s - &c[%5d]&n %s (%s)\r\n", GET_NAME(i),
d3117 2
a3118 1
	  send_to_char(buf, ch);
d3121 1
d3127 1
a3127 1
	sprintf(buf, "&rM&n%3d. %-25s - &c[%5d]&n %s\r\n", ++num, GET_NAME(i),
d3129 2
a3130 1
	send_to_char(buf, ch);
d3135 2
a3136 1
	print_object_location(++num, k, ch, TRUE);
d3140 6
@


1.16
log
@
Added:
- building, reporting checks for 'who'

Changed:
- formatting of do_info
@
text
@d3159 2
a3160 1
      sprintf(buf + strlen(buf), "&g[&m%3d - %2d&g]&n &c%9d&n", i, i+1, level_exp(ch, i));
d3162 2
a3163 1
      sprintf(buf + strlen(buf), "&g[&n%3d - %2d&g]&n &c%9d&n", i, i+1, level_exp(ch, i));
@


1.15
log
@

Added:
- new version info for version command
- users -a (all) list stuff
- item colouring on quest and unusable items
- reporting system stuff

Changed:
- gold rush fixes - added real_room() calls on virtual room nums
@
text
@d491 3
a493 3
	long tchid;
	struct char_data *tch;
	struct char_file_u tmp;
d495 4
a498 4
	if( IS_NPC(ch)) {
		send_to_char("You already know everything there is to know!\r\n", ch);
		return;
	}
d500 5
a504 4
        if( PLR_FLAGGED(ch, PLR_NOINFO) && (GET_LEVEL(ch) < LVL_GRGOD)) {
	   send_to_char("You can't set your info. Privilidges have been revoked.\r\n", ch);				
	   return;
	}
d506 11
a516 11
	two_arguments(argument, arg, buf1);
	// Just want to know about themselves?
	if( !*arg ) {
		sprintf(buf, "&gYour current details are:&n\r\n"
		  "&y Email:&n %s\r\n &yWebpage:&n %s\r\n&y Personal:&n %s&n\r\n",
		  GET_EMAIL(ch) == NULL ? "None" : GET_EMAIL(ch), 
		  GET_WEBPAGE(ch) == NULL ? "None" : GET_WEBPAGE(ch),
		  GET_PERSONAL(ch) == NULL ? "None" : GET_PERSONAL(ch));
		send_to_char(buf, ch);
		return;
	}
d518 22
a539 22
	// Looking for someone?
	if( !*buf1 ) {
		if( (tchid = get_id_by_name(arg)) < 1 ) {
			send_to_char("No such player!\r\n", ch);
			return;
		}
		// Load the character up
		CREATE(tch, struct char_data, 1);
		clear_char(tch);
		load_char(arg, &tmp);
		store_to_char(&tmp, tch);
		char_to_room(tch, 0);
		sprintf(buf, "&g%s's Info&n\r\n"
		  "&y Email: &n%s\r\n&y Webpage:&n %s\r\n&y Personal: &n%s&n\r\n",
		  GET_NAME(tch), 
		  GET_EMAIL(tch) == NULL ? "None" : GET_EMAIL(tch), 
		  GET_WEBPAGE(tch) == NULL ? "None" : GET_WEBPAGE(tch),
		  GET_PERSONAL(tch) == NULL ? "None" : GET_PERSONAL(tch));
		send_to_char(buf, ch);
		extract_char(tch);
		return;		 
	}
d541 17
a557 43
	//to_lower(arg);
	// We have both arguments
	if( strcmp(arg, "email") == 0 ) {
		if( GET_EMAIL(ch) )
			free(GET_EMAIL(ch));
                if( strcmp(buf1, "clear") == 0 ) {
                     GET_EMAIL(ch) = str_dup("None");
		     *buf1 = '\0';
		     send_to_char("You clear your email.\r\n", ch);
		}
		else {
                     GET_EMAIL(ch) = str_dup(buf1);
		     *buf1 = '\0';
		     send_to_char("You set your email.\r\n", ch);
		}
		return;
	}
	if( strcmp(arg, "webpage") == 0 ) {
		if( GET_WEBPAGE(ch))
			free(GET_WEBPAGE(ch));
                if( strcmp(buf1, "clear") == 0 ) {
	           GET_WEBPAGE(ch) = str_dup("None");
		   send_to_char("You clear your webpage.\r\n", ch);
 		}
		else {
		   GET_WEBPAGE(ch) = str_dup(buf1);
		   send_to_char("You set your webpage.\r\n", ch);
		}
                return;
	}
	if( strcmp(arg, "personal") == 0 ) {
		if( GET_PERSONAL(ch))
			free(GET_PERSONAL(ch));
		if( strcmp(buf1, "clear") == 0) {
		  GET_PERSONAL(ch) = str_dup("None");
		  send_to_char("You clear your personal info.\r\n",ch);
		}
		else {
		     GET_PERSONAL(ch) = str_dup(buf1);
		     send_to_char("You set your personal info.\r\n", ch);
		}
		return;
	}
d559 13
a571 1
	send_to_char("Set what?!\r\n", ch);
d573 14
d2497 2
a2498 1
    if (STATE(d) != CON_PLAYING)
d2694 3
a2696 1
      if (PLR_FLAGGED(tch, PLR_MAILING))
d2698 1
a2698 1
      else if (PLR_FLAGGED(tch, PLR_WRITING))
@


1.14
log
@
Added:
- hint - take on/off arguments (not finished as for some reason one_argument
         returns empty string when given on - have to figure out where this is
         disappearing to)
- memory allocation checks in list_obj_to_char
- do_equip/do_look - new eq positions
- new score
- log for gold rush init - causing a crash on ev->room->number every once in a
  while

Removed:
- uncommented eq damage logging (again)

TODO:
- finish hint on/off
- follow up gold rush init crash
@
text
@d35 1
d41 1
d85 1
d158 1
d160 1
a160 1
  one_argument(argument, buf);
d162 2
a163 5
  sprintf(buf2, "argument = '%s'\r\n", buf);
  send_to_char(buf2, ch);

  if (*buf) {
    if (!str_cmp(buf, "ON")) {
d168 1
a168 1
    } else if (!str_cmp(buf, "OFF")) {
d649 11
a659 1
    strcpy(buf, "&5");
d943 1
a943 1
      strcpy(buf, "*");
d945 2
a946 1
      *buf = '\0';
d957 1
a957 1
    strcat(buf, "&6");
d2696 2
d2729 1
a2729 1
"format: users [-l minlevel[-maxlevel]] [-n name] [-h host] [-c classlist] [-o] [-p]\r\n"
d2735 1
a2735 1
  char state[30], *timeptr, mode;
d2739 1
d2743 4
d2756 60
d2984 6
a2989 1
    send_to_char(strcat(strcpy(buf, circlemud_version), "\r\n"), ch);
d3725 8
d3736 2
a3741 1
		
d3766 1
a3766 1
	// Need the vnums of some objects to spec_proc for trade ins
d3844 1
d3860 17
a3876 3
                sprintf(buf, " Init gold rush: room %d", ev->room->number);
                log(buf);
		sector = SECT(ev->room->number);
d3880 1
a3880 1
		&& check_for_event(EVENT_GOLD_RUSH, world[(ev)->room->number].zone) );
d3886 1
a3886 1
	log("Room sector type is: %d.", sector);	
d3896 1
@


1.13
log
@
Added:
- Ahh, too much stuff, sorry was ages since this stuff was last checked in
@
text
@d156 19
d628 2
a629 2
	log("Item %s, %d*100/%d = %lf", obj->short_description, GET_OBJ_DAMAGE(obj),
		GET_OBJ_MAX_DAMAGE(obj), damage);
d714 1
a714 1
  sh_int *unique, item_num;
d720 3
a722 1
  CREATE(unique,sh_int,size*2);
d728 3
a730 1
  CREATE(u_item_ptrs,struct obj_data*,size);
d732 2
a733 1
    free(unique);
d777 6
a782 2
  free(unique);
  free(u_item_ptrs);
d869 4
a872 3
      if (GET_EQ(i, j) && CAN_SEE_OBJ(ch, GET_EQ(i, j))) {
	send_to_char(where[j], ch);
	show_obj_to_char(GET_EQ(i, j), ch, 1);
d1407 1
a1407 1
long getScoreDetail(char *argument)
d1409 1
a1409 1
	long lVector;
d1412 1
a1412 1
	if (strcmp(argument, "brief") == 0)
d1414 1
a1414 1
	else if (strcmp(argument, "long") == 0)
d1416 1
a1416 1
	else
d1418 2
d1448 1
d1450 3
d1462 3
a1464 1
			"  align    thaco      none\r\n", ch);
d1469 3
a1471 1
	if (strcmp(argument, "damroll") == 0)
d1509 2
d1655 1
d1665 1
d1670 1
d1672 1
a1672 1

d1677 1
a1677 1
      if (IS_SET(SCORE_SETTINGS(ch), (1 << i)) && IS_SET(lScoreDetail, (1 << i)))
d1682 129
d1812 53
d2203 13
a2215 6
    send_to_char(where[i], ch);
    if (GET_EQ(ch, i)) {
      if (CAN_SEE_OBJ(ch, GET_EQ(ch, i))) {
//	send_to_char(where[i], ch);
	show_obj_to_char(GET_EQ(ch, i), ch, 1);
	found = TRUE;
d2217 1
a2217 3
//	send_to_char(where[i], ch);
	send_to_char("Something.\r\n", ch);
	found = TRUE;
a2218 2
    } else {
      send_to_char("Nothing.\r\n", ch);
a2220 3
//  if (!found) {
//    send_to_char(" Nothing.\r\n", ch);
//  }
d3017 2
a3018 1
		zone_table[world[i->in_room].zone].name, GET_NAME(d->character));
d3028 2
a3029 1
      if (CAN_SEE(ch, i) && i->in_room != NOWHERE && isname(arg, i->player.name)) {
d3766 2
@


1.12
log
@
Changed:
- incorrect num_hints usage
@
text
@d82 1
d141 1
a141 1
  sprintf(buf, "&WHINT: &B%s&n", hint_table[rnumb]);
d158 1
a158 1
  sprintf(buf, "&WHINT: &B%s&n", hint_table[rnumb]);
d687 3
a689 1
                      int show);
d2937 1
a2937 1
    sprintf(buf, "Your current color level is %s.\r\n", ctypes[COLOR_LEV(ch)]);
d2942 1
a2942 1
    send_to_char("Usage: color { Off | Sparse | Normal | Complete }\r\n", ch);
d2948 1
a2948 1
  sprintf(buf, "Your %scolor%s is now %s.\r\n", CCRED(ch, C_SPR),
@


1.11
log
@
Added:
- hint command
- typo on hint toggling ...
@
text
@d138 1
a138 1
  rnumb = number(0, num_hints);
d155 1
a155 1
  rnumb = number(0, num_hints);
@


1.10
log
@
Added:
- newbie logging
- random hint channel

Changed:
- Rewrote the ignore code, ignore char all/tells, ignore level all/tells
@
text
@d108 1
d138 1
a138 1
  rnumb = number(0, num_hints-1);
d149 10
@


1.9
log
@
Added:
- help for who options
@
text
@d52 1
d57 3
d76 1
d130 20
d302 1
a302 1
		if( ((d->character)->in_room == ch->in_room) &&
d2129 1
a2129 1
"format: who [minlev[-maxlev]] [-i [clan name]] [-n name] [-c classlist] [-a] [-b] [-t] [-s] [-o] [-q] [-r] [-z]\r\n"
d2367 1
a2367 1
  int i;
d2445 5
a2449 2
      if ( GET_IGN_NUM(tch) > 0 || GET_IGN_LEVEL(tch) > 0)
        strcat(buf, " (snob)");
d3004 1
a3004 1
          "     Wimp Level: %-4s   " "    Color Level: %s\r\n",
d3041 2
a3042 1
          ctypes[COLOR_LEV(vict)]);
@


1.8
log
@
Added:
- extra who list options, default level descending
- !IS_NPC check on AFK

Changed:
- clone order fix
- max houses 100 -> 500
- house guests 10 -> 5
@
text
@d2104 1
a2104 1
"format: who [minlev[-maxlev]] [-n name] [-c classlist] [-s] [-o] [-q] [-r] [-z]\r\n"
d2138 1
a2138 1
      case 'w':
d2150 1
a2150 1
      case 'k':
d2279 2
a2280 6
  for (int i = 0; i< num_can_see; i++) {
     sprintf(buf,"%s\r\n",GET_NAME(theWhoList[i]));
     send_to_char(buf,ch);
  }
  
  print_who_info(theWhoList,num_can_see,ch);
d2337 3
a2339 112
/*
#define WHO_FORMAT \
"format: who [minlev[-maxlev]] [-n name] [-c classlist] [-s] [-o] [-q]
[-r] [-z]\r\n"

ACMD(do_who)
{
    struct descriptor_data *d;
    struct char_data *tch;
    char name_search[MAX_INPUT_LENGTH];
    char mode;
    size_t i;
    int low = 0, high = LVL_IMPL, localwho = 0, questwho = 0;
    int showclass = 0, short_list = 0, outlaws = 0, num_can_see = 0;
    int who_room = 0;
    int noElements = 0;
    int curEl;
    extern char *race_abbrevs[];
    int order_char_name = 0;

    skip_spaces(&argument);
    strcpy(buf, argument);
    name_search[0] = '\0';

    while (*buf) {
        half_chop(buf, arg, buf1);
        if (isdigit(*arg)) {
            sscanf(arg, "%d-%d", &low, &high);
            strcpy(buf, buf1);
        } else if (*arg == '-') {
            mode = *(arg + 1);  // just in case; we destroy arg in the switch
            switch (mode) {
            case 'o':
                order_char_name = 1;
                strcpy(buf, buf1);
                break;
            case 'k':
                outlaws = 1;
                strcpy(buf, buf1);
                break;
            case 'z':
                localwho = 1;
                strcpy(buf, buf1);
                break;
            case 's':
                short_list = 1;
                strcpy(buf, buf1);
                break;
            case 'q':
                questwho = 1;
                strcpy(buf, buf1);
                break;
            case 'l':
                half_chop(buf1, arg, buf);
                sscanf(arg, "%d-%d", &low, &high);
                break;
            case 'n':
                half_chop(buf1, name_search, buf);
                break;
            case 'r':
                who_room = 1;
                strcpy(buf, buf1);
                break;
            case 'c':
                half_chop(buf1, arg, buf);
                for (i = 0; i < strlen(arg); i++)
                    showclass |= find_class_bitvector(arg[i]);
                break;
            default:
                send_to_char(WHO_FORMAT, ch);
                return;
                break;
            }                   // end of switch 

        } else {                // endif 
            send_to_char(WHO_FORMAT, ch);
            return;
        }
    }                           // end while (parser)

    // 'Collect' players and add them to the array 
    for(noElements = 0, d = descriptor_list; d; d = d->next) {
        if(d->connected)
            continue;

        if(d->original)
            tch = d->original;
        else if(!(tch = d->character))
            continue;

        theWhoList[noElements++] = tch;
        num_can_see++;
    }

if (order_char_name) {    // Sort it using the built in libc-quicksort routine 
    qsort(theWhoList, noElements, sizeof(struct char_data  *), compareChars);
}
    print_who_info(theWhoList,noElements,ch);

    if (short_list && (num_can_see % 4))
        send_to_char("\r\n", ch);
    if (num_can_see == 0)
        sprintf(buf, "\r\nNo-one at all!\r\n");
    else if (num_can_see == 1)
        sprintf(buf, "\r\nOne lonely character displayed.\r\n");
    else
        sprintf(buf, "\r\n%d characters displayed.\r\n", num_can_see);
    send_to_char(buf, ch);
}
*/


d2748 2
a2749 2
		 world[d->character->in_room].name,
		zone_table[world[ch->in_room].zone].name, GET_NAME(d->character));
d2753 1
a2753 1
		    zone_table[world[ch->in_room].zone].name);
@


1.7
log
@
Added:
- olc stuff - sectors, zone flags

Changed:
- Heaps of little fixes ....
@
text
@d120 5
d2101 1
a2101 1

d2111 1
d2117 4
d2132 1
a2132 1
      mode = *(arg + 1);       /* just in case; we destroy arg in the switch */
d2134 16
a2149 1
      case 'o':
d2185 1
a2185 1
      }				/* end of switch */
d2187 1
a2187 1
    } else {			/* endif */
d2191 1
a2191 1
  }				/* end while (parser) */
d2193 24
a2216 1
  send_to_char("&y---------\r\n &rP&Rl&Ya&Wy&Ye&Rr&rs&n\r\n&y---------&n\r\n", ch);
d2230 2
d2249 1
d2251 1
a2251 1
              (GET_LEVEL(tch) >= LVL_ETRNL1 ? CCBLU(ch, C_SPR) : "")))),
d2257 1
d2259 207
d2473 1
d2484 1
a2484 1
               (GET_LEVEL(tch) == LVL_ETRNL1 ? "ET1" : "PLR"))))))))))))))))); 
d2552 1
a2552 2
      send_to_char(buf, ch);
    }				/* endif shortlist */
d2554 3
a2556 9
  if (short_list && (num_can_see % 4))
    send_to_char("\r\n", ch);
  if (num_can_see == 0)
    sprintf(buf, "\r\nNo-one at all!\r\n");
  else if (num_can_see == 1)
    sprintf(buf, "\r\nOne lonely character displayed.\r\n");
  else
    sprintf(buf, "\r\n%d characters displayed.\r\n", num_can_see);
  send_to_char(buf, ch);
a2557 1

@


1.6
log
@

Added:
- more shite
@
text
@d803 1
a803 1
    found = FALSE;
a804 6
    for (tmp_obj = i->carrying; tmp_obj; tmp_obj = tmp_obj->next_content) {
      if (CAN_SEE_OBJ(ch, tmp_obj) && (number(0, 20) < GET_LEVEL(ch))) {
	show_obj_to_char(tmp_obj, ch, 1);
	found = TRUE;
      }
    }
d806 10
a815 2
    if (!found)
      send_to_char("You can't see anything.\r\n", ch);
d983 1
a983 2
  sprintf(buf2, "%s[ Exits: %s]%s\r\n", CCCYN(ch, C_NRM),
	  *buf ? buf : "None! ", CCNRM(ch, C_NRM));
d1039 1
a1039 1
  send_to_char(CCCYN(ch, C_NRM), ch);
d3150 1
a3150 1
    sprintf(buf,"Personal colour settings:\r\n");
@


1.5
log
@

Added:
- Events
-

Changed:
- Score command
-

TODO:
- Finish the base
-
@
text
@d1 2
a2 1
/* ************************************************************************
d1382 1
a1382 1
			"  align    thaco      \r\n", ch);
d1423 2
d1430 6
d1549 3
d1596 14
d2167 1
a2167 1
  send_to_char("Players\r\n-------\r\n", ch);
d2395 1
a2395 1
      if (!CAN_SEE(ch, tch) || GET_LEVEL(tch) < low || GET_LEVEL(tch) > high)
d2606 1
a2606 1
	    sprintf(buf, "%-20s - &c[%5d]&n %s (in %s)\r\n",
d2608 2
a2609 1
		 world[d->character->in_room].name, GET_NAME(d->character));
d2611 3
a2613 2
	    sprintf(buf, "%-20s - &c[%5d]&n %s\r\n", GET_NAME(i),
		    GET_ROOM_VNUM(IN_ROOM(i)), world[i->in_room].name);
a3252 1

d3260 8
d3271 1
a3271 1
	switch(ev->info2)
d3273 1
a3273 1
		case 1:
d3275 3
@


1.4
log
@my new skills!


Added:
-
-

Removed:
-
-

Changed:
-
-

TODO:
-
-
@
text
@d1 1
a1 1
	/* ************************************************************************
d25 2
d52 2
d66 4
a69 1

d71 2
d76 1
d526 1
a526 1
char *show_object_damage(struct obj_data *obj) {
d528 1
a528 1
	char *damage_msgs[] = {
d542 1
a542 1
	  return "NULL"; 
d725 1
a725 1
    strcat(buf, " is in excellent condition.\r\n");
d727 1
a727 1
    strcat(buf, " has a few scratches.\r\n");
d729 1
a729 1
    strcat(buf, " has some small wounds and bruises.\r\n");
d731 1
a731 1
    strcat(buf, " has quite a few wounds.\r\n");
d733 1
a733 1
    strcat(buf, " has some big nasty wounds and scratches.\r\n");
d735 1
a735 1
    strcat(buf, " looks pretty hurt.\r\n");
d737 1
a737 1
    strcat(buf, " is in awful condition.\r\n");
d739 16
a754 1
    strcat(buf, " is bleeding awfully from big wounds.\r\n");
d769 1
d780 1
a780 1
   if (i->player.description)
d1213 1
a1213 1
	send_to_char(show_object_damage(obj), ch);
d1231 1
a1231 1
	send_to_char(desc, ch);
d1314 1
d1331 253
d1592 4
d1597 8
d3155 541
@


1.3
log
@
Changed:
- Fix for player colour.
@
text
@d1 1
a1 1
/* ************************************************************************
d49 1
d61 1
d67 1
d108 117
@


1.2
log
@
Added:
- Some initial colour coding for mobs and objects

Changed:
- Various inclusions from the existing primal base ...
- Including Sector fixes, clan guards, listing items

TODO:
- Fix colours for mobs/objects - A player comes up as a mob colour
@
text
@d746 1
a746 1
      sprintf(buf,"%s %s",i->player.name,
d749 1
a749 1
      sprintf(buf, "&6%s %s", i->player.name, GET_TITLE(i));
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d451 2
a452 1
    strcpy(buf, object->description);
d456 2
a457 1
    strcpy(buf, object->short_description);
d492 1
a492 1
  strcat(buf, "\r\n");
d496 1
a496 1

d512 65
d578 3
d697 7
a703 7
    " &yis lying here, dead.",
    " &yis lying here, mortally wounded.",
    " &yis lying here, incapacitated.",
    " &yis lying here, stunned.",
    " &yis sleeping here.",
    " &yis resting here.",
    " &yis sitting here.",
d705 1
a705 1
    " &yis standing here."
d723 1
d738 2
a739 1
    strcpy(buf, i->player.short_descr);
d749 1
a749 1
      sprintf(buf, "%s %s", i->player.name, GET_TITLE(i));
d762 1
a762 1
      strcat(buf, " &yis floating here.");
d767 1
a767 1
      strcat(buf, " &yis here, fighting ");
d778 1
a778 1
      strcat(buf, " &yis here struggling with thin air.");
d790 1
a790 1
  strcat(buf, "\r\n");
d912 1
a912 1
  send_to_char(CCGRN(ch, C_NRM), ch);
d914 1
a914 1
  send_to_char(CCYEL(ch, C_NRM), ch);
@

