head	1.34;
access;
symbols
	A3_0_59:1.1
	LATEST:1.1
	A3_0_1:1.1;
locks; strict;
comment	@ * @;


1.34
date	2005.06.10.05.08.34;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	2004.08.27.01.46.39;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.04.12.24.27;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.18.11.43.35;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.06.02.23.29;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.29.07.57.54;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.21.07.03.03;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.10.12.02.25;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.04.10.35.00;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.31.22.20.27;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.17.02.25.06;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.16.03.19.09;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	2003.11.12.22.50.32;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.12.11.00.13;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.01.00.23.51;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.29.12.23.11;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.20.12.01.49;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.20.08.17.56;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.30.13.36.23;	author rod;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.18.03.27.57;	author artus;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.15.11.37.31;	author artus;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.12.10.37.37;	author artus;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.02.02.29.00;	author primal;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.28.13.09.14;	author artus;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.28.13.07.53;	author artus;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.28.07.44.57;	author artus;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.27.10.22.29;	author artus;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.27.08.53.54;	author artus;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.26.06.47.58;	author artus;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.11.01.54;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.11.14.26.27;	author artus;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.11.14.01.34;	author artus;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.10.12.55.33;	author primal;	state dead;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.57;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Artus> Fixed bug where clan enhance <guard|healer> was double-charging.
@
text
@/**************************************************************************
 * File: clan.c                       Intended to be used with PrimalMUD, *
 * 				               a derivative of CircleMUD. *
 * 				                                          *
 * Info: This is the code for the new clan system..                       *
 * By  : Justin Katz (Artus on PrimalMUD - mud.laybyrinth.net.au 4000)    *
 *									  *
 * This code is based on an old mod of Mehdi Keddache's origin.           * 
 * Though, I think it's getting harder to tell :o)                        *
 *  								          *
 * CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
 * CircleMUD (C) 1993, 94 by the Trustees of the Johns Hopkins University *
 *                                                                        *
 * This text last modified, 2001-01-15, by Justin Katz.                   *
 **************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "interpreter.h"
#include "handler.h"
#include "clan.h"
#include "genmob.h"
#include "genwld.h"
#include "screen.h"

/* External */
extern void save_char_file_u(struct char_file_u st);
extern struct descriptor_data *descriptor_list;
extern struct index_data *mob_index;
extern struct room_data *world;
extern struct player_index_element *player_table;
extern int rev_dir[];
extern char *punish_types[];
extern char *offence_types[];
extern void do_odd_write(struct descriptor_data *d, ubyte wtype, int maxlen);
extern struct char_data *mob_proto;
extern struct char_data *character_list;
int update_mobile_strings(struct char_data *t, struct char_data *f);
void reset_zone(zone_rnum zone);
SPECIAL(shop_keeper);

/* Local */
int num_of_clans;
struct clan_rec clan[MAX_CLANS];
sh_int find_clan_by_sid(char *test);
int clan_room_dirs (char *arg);
int clan_can_hear(struct descriptor_data *d, int c);
int do_clan_heal(struct char_data *ch, struct char_data *vict); 
void do_clan_infocom (int clan_one, int clan_two, char *arg);
void clan_tax_update (struct char_data *ch, struct char_data *vict);
void clan_pk_update (struct char_data *winner, struct char_data *loser);
void clan_rel_inc(struct char_data *ch, struct char_data *vict, int amt);

const int clan_levels[] = {
  100000,      /*  1 */
  200000,
  500000,
  1000000,
  1500000,     /*  5 */
  2000000,
  2500000,
  3000000,
  4000000,
  5000000,     /* 10 */
  7500000,
  10000000,
  20000000,
  50000000,
  100000000,   /* 15 */
  250000000,
  500000000,
  1000000000,
  1000000000,
  1000000000,  /* 20 */
  1000000000,
  1000000000,
  1250000000,
  1500000000, 
  2000000000,  /* 25 */
  2000000000,  
  2000000000,  
  2000000000,  
  2000000000,  
  2000000000,  /* 30 */
  2000000000,  
  2000000000,  
  2000000000,  
  2000000000,
  2000000000   /* 35 */
};

char clan_privileges[NUM_CP+1][20] = { "recruit"  ,"promote"  ,"demote"   ,
	                               "banish"   ,"withdraw" ,"setapplev",
				       "setfees"  ,"enhance"  ,"room"     ,
				       "setdesc"  ,"enable"
                                     };

char clan_enablers[NUM_CO+1][20] = {   "hall"     ,"healer"   ,"talk"     ,
	                               "board"
			           };

/* Send The Standard Clan Screen */
void send_clan_format(struct char_data *ch)
{
  int c,r;

  if(!LR_FAIL(ch, LVL_CLAN_GOD))
  {
    send_to_char("Clan commands available to you:\r\n"
                 "   clan about         <clan num>\r\n"
		 "   clan balance       <clan num>\r\n"
		 "   clan banish        <player>\r\n"
		 "   clan create        <leader> <clan name>\r\n"
		 "   clan demote        <player>\r\n"
		 "   clan deposit       <clan num> <amount>\r\n"
		 "   clan destroy       <clan num>\r\n"
		 "   clan disable       <clan num> <option>\r\n"
		 "   clan enable        <clan num> <option>\r\n"
		 "   clan info          <clan num>\r\n"
		 "   clan promote       <player>\r\n"
		 "   clan recruit       <player>\r\n"
		 "   clan relations     <clan num>\r\n"
		 "   clan score\r\n"
		 "   clan set           <args>\r\n"
		 "   clan stat          <clan num>\r\n"
		 "   clan who           <clan num>\r\n"
		 "   clan withdraw      <clan num> <amount>\r\n",ch);
    return;
  }

  c=find_clan_by_id(GET_CLAN(ch));
  r=GET_CLAN_RANK(ch);

  send_to_char(  "Clan commands available to you:\r\n"
		 "   clan about         <clan num>\r\n",ch);

  if (c<0) {
    send_to_char("   clan apply         <clan num>\r\n"
                 "   clan info          <clan num>\r\n",ch);
    return;
  }

  if(r >= clan[c].privilege[CP_WITHDRAW])
    send_to_char("   clan balance\r\n", ch);
  if(r>=clan[c].privilege[CP_BANISH])
    send_to_char("   clan banish        <player>\r\n" ,ch);
  if(r>=clan[c].privilege[CP_DEMOTE])
    send_to_char("   clan demote        <player>\r\n",ch);

  send_to_char(  "   clan deposit       <amount>\r\n",ch);

  if(r>=clan[c].privilege[CP_ENHANCE])
    send_to_char("   clan describe      <guard|healer>\r\n",ch);
  if(r>=clan[c].privilege[CP_ENABLE])
    send_to_char("   clan enable        <option>\r\n", ch);
  if(r>=clan[c].privilege[CP_ENHANCE])
    send_to_char("   clan enhance       <guard|healer>\r\n",ch);

  send_to_char(  "   clan info          <clan num>\r\n",ch);

  if(r>=clan[c].privilege[CP_ENHANCE])
    send_to_char("   clan name          <guard|healer>\r\n",ch);
  if(r>=clan[c].privilege[CP_PROMOTE])
    send_to_char("   clan promote       <player>\r\n",ch);
  if(r>=clan[c].privilege[CP_RECRUIT])
    send_to_char("   clan recruit       <player>\r\n",ch);

  send_to_char(  "   clan relations\r\n",ch);

  if (r>=clan[c].privilege[CP_ROOM]) 
    send_to_char("   clan room          <args>\r\n",ch);

  send_to_char(  "   clan score\r\n",ch);

  if ((r >= clan[c].privilege[CP_SET_APPLEV]) || (r >= clan[c].privilege[CP_SET_FEES]) || (r >= clan[c].privilege[CP_SET_DESC]))
    send_to_char("   clan set           <args>\r\n",ch);

  send_to_char(  "   clan status\r\n"
		 "   clan who\r\n",ch);

  if(r >= clan[c].privilege[CP_WITHDRAW])
    send_to_char("   clan withdraw      <amount>\r\n",ch);
 
}

/* do_clan_reset - Resets clan mobs/rooms.. Will need to do boards too. */
void do_clan_reset (struct char_data *ch, char *arg)
{
  int c,i,j;
  struct char_data *guard=NULL, *healer=NULL, *oldmob=NULL;
  struct room_data *room=NULL;
  zone_rnum real_zone(zone_vnum vnum);
  int real;

  if (LR_FAIL(ch, LVL_CLAN_GOD))
  {
    send_clan_format(ch);
    return;
  }
  if (!*arg) {
    send_to_char("You must specify a clan number to reset.\r\n", ch);
    return;
  }
  if (((c=atoi(arg)) < 1) || (c > MAX_CLANS)) 
  {
    send_to_char("Clan number must be between 1 and 8.\r\n", ch);
    return;
  }

  c--;

  /* Firstly, The Mobs :o) Checks out OK.. */
  if ((real = real_mobile(c + (CLAN_ZONE * 100))) > -1)
  {
    guard = &mob_proto[real];
    free(GET_LDESC(guard));
    free(GET_DDESC(guard));
    GET_LDESC(guard) = str_dup("A clan guard stands here.\r\n");
    GET_DDESC(guard) = str_dup("This clan guard has not been described yet.\r\n");
    GET_HIT(guard) = GET_MANA(guard) = GET_NDD(guard) = GET_SDD(guard) = 1;
    GET_LEVEL(guard) = GET_HITROLL(guard) = GET_DAMROLL(guard) = 50;
    GET_MOVE(guard) = 10000; 
    GET_AC(guard) = -100;
  } else {
    sprintf(buf, "Clan guard [%d] not found while resetting!", (c + (CLAN_ZONE * 100)));
    basic_mud_log (buf);
  }
  if ((real = real_mobile(c + (CLAN_ZONE * 100) + MAX_CLANS)) > -1)
  {
    healer = &mob_proto[real];
    free(GET_LDESC(healer));
    free(GET_DDESC(healer));
    GET_LDESC(healer) = str_dup("A clan healer stands here.\r\n");
    GET_DDESC(healer) = str_dup("This clan healer has not been described yet.\r\n");
    GET_HIT(healer) = GET_MANA(healer) = GET_NDD(healer) = GET_SDD(healer) = 1;
    GET_LEVEL(healer) = GET_HITROLL(healer) = GET_DAMROLL(healer) = 50;
    GET_MOVE(healer) = 10000;
    GET_AC(healer) = -100;
  } else {
    sprintf(buf, "Clan healer [%d] not found while resetting!", (c + (CLAN_ZONE * 100)));
    basic_mud_log(buf);
  }
  if ((guard != NULL) || (healer != NULL)) {
    for (oldmob = character_list; oldmob; oldmob = oldmob->next) {
      if ((guard != NULL) && (guard->nr == oldmob->nr)) 
        update_mobile_strings(oldmob, &mob_proto[guard->nr]);
      if ((healer != NULL) && (healer->nr == oldmob->nr))
        update_mobile_strings(oldmob, &mob_proto[healer->nr]);
    }
  }
  if (save_mobiles(real_zone(CLAN_ZONE)) == FALSE)
    send_to_char("Failed to save mobiles.\r\n", ch);

  /* Ok, Now, It's time to think about the rooms.. Scarey shit.. HERE */

  if ((real = real_room(c + (CLAN_ZONE*100))) != NOWHERE)
  {
    room = &world[real]; /* Guard Post */
    free(room->name);
    room->name = strdup("Guard Post");
    free(room->description);
    room->description = strdup("This guard post is yet to be described.\r\n");
    REMOVE_BIT(room->room_flags, ROOM_REGEN_2);
  } else {
    sprintf(buf, "Clan room [%d] not found while resetting!", (c + (CLAN_ZONE*100)));
    basic_mud_log(buf);
  }

  if ((real = real_room(c + MAX_CLANS + (CLAN_ZONE*100))) != NOWHERE)
  {
    room = &world[real]; /* Hall */
    free(room->name);
    room->name = strdup("Clan Hall");
    for (i = 0; i < NUM_OF_DIRS; i++)
      if (!(((c % 2 == 1) && (i == EAST)) || ((c % 2 == 0) && (i == WEST))))
        room->dir_option[i] = NULL;
  
    free(room->description);
    room->description = strdup("This clan hall is yet to be described.\r\n");
    REMOVE_BIT(room->room_flags, ROOM_REGEN_2);
  } else {
    sprintf(buf, "Clan room [%d] not found while resetting!", (c + MAX_CLANS + (CLAN_ZONE*100)));
    basic_mud_log(buf);
  }
  for (i = 2;i <= CLAN_ROOM_MAX;i++)
  { /* Rooms */
    if ((real = real_room(c + (CLAN_ZONE*100) + (i*MAX_CLANS))) != NOWHERE) {
      room = &world[real]; 
      free(room->name);
      room->name = strdup("Clan Room");
      for (j = 0; j < NUM_OF_DIRS; j++)
        room->dir_option[j] = NULL;
      free(room->description);
      room->description = strdup("This clan room is yet to be described.\r\n");
      REMOVE_BIT(room->room_flags, ROOM_REGEN_2);
    } else {
      sprintf(buf, "Clan room [%d] not found while resetting!", (c + (CLAN_ZONE*100) + (i*MAX_CLANS)));
      basic_mud_log(buf);
    }
  }
  if (save_rooms(real_zone(CLAN_ZONE)) == FALSE)
    send_to_char("Failed to save rooms!\r\n", ch);

  send_to_char("Finished resetting clan.\r\n", ch);
  return;
}

/* Simple routine.. Should stop clans getting too much coin :p */
void clan_coinage (int c, int amount)
{
  amount /= 100;
  if (amount > 0)
    clan[c].treasure = MIN(clan[c].treasure + amount, 2000000000);
  else
    clan[c].treasure = MAX(clan[c].treasure + amount, 0);
  return;
}

/* Clan Relation Change (clan 1,clan 2, amt_to_change) */
void clan_rel_change (int us, int them, int amt)
{
  if ((us < 0) || (them < 0) || (us > num_of_clans) || (them > num_of_clans) ||
      (us == them) || (amt == 0))
    return;
  if (amt > 0)
    GET_CLAN_REL(us, them) = MAX(GET_CLAN_REL(us, them) + amt, CLAN_REL_MIN);
  else
    GET_CLAN_REL(us, them) = MIN(GET_CLAN_REL(us, them) + amt, CLAN_REL_MAX);
  GET_CLAN_REL(them, us) = GET_CLAN_REL(us, them);
}

void clan_rel_inc (struct char_data *ch, struct char_data *vict, int amt)
{
  int us, them, amount;
  amount = amt;

  if (!(vict) || !(ch) || (vict == ch) || IS_NPC(ch) || IS_NPC(vict) ||
      (GET_CLAN(ch) == GET_CLAN(vict)) || 
      (GET_CLAN(ch) < 1) || (GET_CLAN(vict) < 1))
    return;
  us = find_clan_by_id(GET_CLAN(ch));
  them = find_clan_by_id(GET_CLAN(vict));
  if ((us < 0) || (them < 0)) 
    return;
  if (GET_CLAN_RANK(ch) == clan[us].ranks)
    amount += amt;
  if (GET_CLAN_RANK(vict) == clan[them].ranks)
    amount += amt;
  if (GET_CLAN_RANK(ch) == (clan[us].ranks - 1))
    amount += (int)(amt / 2);
  if (GET_CLAN_RANK(vict) == (clan[them].ranks - 1))
    amount += (int)(amt / 2);
  clan_rel_change(us, them, amt);
}

/* Determines whether a char is privledged enough for certain clan commands. */
int clan_check_priv (struct char_data *ch, int priv)
{
  int clan_num;
  if (!LR_FAIL(ch, LVL_CLAN_GOD))
    return CPC_IMM;
  if ((clan_num=find_clan_by_id(GET_CLAN(ch))) < 0)
  {
    send_to_char("You don't belong to any clan.\r\n", ch);
    return CPC_NOPRIV;
  }
  if ((priv>=0) && (GET_CLAN_RANK(ch)<clan[clan_num].privilege[priv]))
  {
    send_to_char("You are not ranked highly enough within your clan.\r\n", ch);
    return CPC_NOPRIV;
  }
  if ((priv==CP_LEADER) && (GET_CLAN_RANK(ch) < clan[clan_num].ranks))
  {
    send_to_char("You are not ranked highly enough within your clan.\r\n", ch);
    return CPC_NOPRIV;
  }
  return CPC_PRIV;
}

/* Clan Exp Gaining... */
void gain_clan_exp (struct char_data *ch, long amount)
{
  int c=0;
  char cin[80];

  if (((c = find_clan_by_id(GET_CLAN(ch))) < 0) || (clan[c].level >= 35))
    return;
  amount /= 1000; 
  if (amount <= 0)
    amount = 1;
  clan[c].exp = MIN((clan[c].exp + amount), 2000000000);
  while (clan[c].exp > clan_levels[clan[c].level])
  { /* Clan Levels */
    clan[c].exp -= clan_levels[clan[c].level];
    clan[c].level++;
    sprintf(cin, "%s has advanced to level %d.", clan[c].name, clan[c].level);
    do_clan_infocom(0, 0, cin);
  }
  save_clans();
}

/* Creating a new clan */
void do_clan_create (struct char_data *ch, char *arg)
{
  struct char_data *leader = NULL;
  char arg1[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH],cin[80];
  int new_id=0,i;

  if ((!*arg) || (LR_FAIL(ch, LVL_CLAN_GOD)))
  {
    send_clan_format(ch);
    return;
  }

  if(num_of_clans == MAX_CLANS)
  {
    send_to_char("Max clans reached. WOW!\r\n",ch);
    return; 
  }

  half_chop(arg, arg1, arg2);

  if (!(leader=generic_find_char(ch,arg1,FIND_CHAR_ROOM)))
  {
    send_to_char("The leader of the new clan must be present.\r\n",ch);
    return;
  }

  if (strlen(arg2) >= 32)
  {
    send_to_char("Clan name too long! (32 characters max)\r\n",ch);
    return; 
  }

  if ((GET_LEVEL(leader) >= LVL_IS_GOD) && (CLAN_NO_IMM > 0))
  {
    send_to_char("You cannot set an immortal as the leader of a clan.\r\n",ch);
    return; 
  }

  if (GET_LEVEL(leader) < LVL_CLAN_MIN)
  {
    send_to_char("You cannot set someone that inexperienced as the clan leader.\r\n", ch);
    return;
  }
  
  if ((GET_CLAN(leader) != 0) && (GET_CLAN_RANK(leader) != 0))
  {
    send_to_char("The leader already belongs to a clan!\r\n",ch);
    return; 
  }

  if (find_clan(arg2) != -1)
  {
    send_to_char("That clan name alread exists!\r\n",ch);
    return;
  }

  strncpy(clan[num_of_clans].name, CAP((char *)arg2), 32);
  for (i = 1; i <= MAX_CLANS; i++)
    if (find_clan_by_id(i) < 0)
    {
      new_id=i;
      break;
    }
  clan[num_of_clans].id=new_id;
  clan[num_of_clans].ranks =  2;
  strcpy(clan[num_of_clans].rank_name[0],"Member");
  strcpy(clan[num_of_clans].rank_name[1],"Leader");
  clan[num_of_clans].treasure = 0 ;
  clan[num_of_clans].members = 1 ;
  clan[num_of_clans].power = GET_LEVEL(leader) ;
  clan[num_of_clans].app_fee = 500000 ;
  clan[num_of_clans].taxrate = 5 ;
  clan[num_of_clans].app_level = DEFAULT_APP_LVL ;
  for(i = 0; i < 5; i++)
    clan[num_of_clans].spells[i]=0;
  for(i = 0; i < 20; i++)
    clan[num_of_clans].privilege[i]=clan[num_of_clans].ranks;
  for(i = 0; i < MAX_CLANS; i++)
  {
    GET_CLAN_REL(i, num_of_clans) = 0;
    GET_CLAN_REL(num_of_clans, i) = 0;
    GET_CLAN_FRAGS(num_of_clans, i) = 0;
    GET_CLAN_DEATHS(i, num_of_clans) = 0;
    GET_CLAN_FRAGS(i, num_of_clans) = 0;
    GET_CLAN_DEATHS(num_of_clans, i) = 0;
  }

  clan[num_of_clans].options = 0;
  
  strcpy(clan[num_of_clans].description, "A newly formed clan.");
  num_of_clans++;
  save_clans();
  send_to_char("Clan created\r\n", ch);
  GET_CLAN(leader) = clan[num_of_clans-1].id;
  GET_CLAN_RANK(leader) = clan[num_of_clans-1].ranks;
  REMOVE_BIT(EXT_FLAGS(leader), EXT_PKILL);
  save_char(leader, leader->in_room);
  sprintf(cin, "A new clan, %s has been formed.", clan[num_of_clans-1].name);
  do_clan_infocom(0, 0, cin);

  return;
}

/* Clan Scoreboard -- Needs Work! TODO - ARTUS 
 * Requires sorting, better algorithm.. */
void do_clan_score (struct char_data *ch)
{
  int i, j;

  struct clan_score {
    char name[32];
    int frags;
    int power;
  };

  struct clan_score cscore[MAX_CLANS];

  send_to_char("Clan Scoreboard... Under Construcation\r\n"
	       "--------------------------------------\r\n", ch);

  for (i=0;i<num_of_clans;i++) {
    cscore[i].frags = 0;
    strncpy(cscore[i].name, clan[i].name, 32);
    cscore[i].power = clan[i].power;
    for (j=0;j<num_of_clans;j++) {
      if (i == j) 
	continue;
      cscore[i].frags += GET_CLAN_FRAGS(i, j) - GET_CLAN_DEATHS(i, j);
    }
  }

  for (i=0;i<num_of_clans;i++) 
  {
    sprintf(buf, "%-32s        Frags: %6d  Power: %6d\r\n", cscore[i].name, cscore[i].frags, cscore[i].power);
    send_to_char(buf, ch);
  }
  
  return;
}

/* Clan charging */
int do_clan_charge (struct char_data *ch, int amount)
{
  if (!LR_FAIL(ch, LVL_CLAN_GOD))
    return 1;
  if (GET_GOLD(ch) < amount)
    return 0;
  GET_GOLD(ch) -= amount;
  return 1;
}

/* Clan destruction */     
void do_clan_destroy (struct char_data *ch, char *arg)
{

  int i,j;
  extern int top_of_p_table;
  struct char_file_u chdata;
  struct char_data *victim=NULL;
  char cin[80];

  if(LR_FAIL(ch, LVL_CLAN_GOD))
  {
    send_clan_format(ch);
    return;
  }

  if (!*arg)
  {
    send_to_char("You must specify which clan to destroy.\r\n", ch);
    return;
  }

  if (!is_number(arg))
  {
    send_to_char("You must destroy clans by their number!\r\n", ch);
    return;
  }
  if ((i = find_clan_by_sid(arg)) < 0) 
  {
    send_to_char("Unknown or invalid clan number specified.\r\n", ch);
    return; 
  }
  sprintf(cin, "Clan %s has been destroyed.", clan[i].name);
  do_clan_infocom(0, 0, cin);

  for (j = 0; j <= top_of_p_table; j++){
    if((victim=get_player_online(ch, (player_table+j)->name, FIND_CHAR_INVIS))) 
    {
      if(GET_CLAN(victim)==clan[i].id) 
      {
        GET_CLAN(victim)=0;
        GET_CLAN_RANK(victim)=0;
        save_char(victim, victim->in_room); 
      } 
    } else {
      load_char((player_table + j)->name, &chdata);
      if(chdata.player_specials_saved.clan==clan[i].id)
      {
        chdata.player_specials_saved.clan=0;
        chdata.player_specials_saved.clan_rank=0;
        save_char_file_u(chdata); 
      } 
    } 
  }
  
  do_clan_reset(ch, arg);

  for (j = 0; j <= num_of_clans; j++)
  {
    GET_CLAN_REL(j, i)   = 0;
    GET_CLAN_FRAGS(j, i) = 0;
    GET_CLAN_DEATHS(j, i)= 0;
  }
  
  memset(&clan[i], sizeof(struct clan_rec), 0);
  for (j = i; j < num_of_clans - 1; j++) 
    clan[j] = clan[j + 1];
  num_of_clans--;
  send_to_char("Clan deleted.\r\n", ch);
  save_clans();
  return;
}

/* Statting Clans.. Needs colourising. TODO - ARTUS
 * Coloring can be done after integration - I don't have & codes.. */
void do_clan_stat (struct char_data *ch, char *arg)
{
  int c, i, crap=0;

  if (LR_FAIL(ch, LVL_CLAN_GOD))
  {
    send_clan_format(ch);
    return;
  }

  if (!(*arg))
  {
    send_to_char ("What clan did you want to stat, anyway?\r\n", ch);
    return;
  }
  if ((c=find_clan_by_sid(arg)) < 0) {
    send_to_char ("That clan seems to only exist in your imagination.\r\n", ch);
    return;
  }

  /* Line 1: Name, IDnum, Rnum */
  sprintf(buf, "Clan '%s' IDNUM: [%d] RNUM: [%d]\r\n", clan[c].name, clan[c].id, c);

  /* Line 2: Members, Power, Bank, Ranks */
  sprintf(buf, "%sMembers: [%d] Power: [%d] Bank: [%ld00] Ranks: [%d]\r\n", buf, clan[c].members, clan[c].power, clan[c].treasure, clan[c].ranks);

  /* Line 3: Level, Exp */
  sprintf(buf, "%sLevel: [%d] Exp: [%ld]\r\n", buf, clan[c].level, clan[c].exp);
  
  /* Line 4: Taxrate, Applev, Spells */
  sprintf(buf, "%sTaxrate: [%d] Applev: [%d] Spells: [%d/%d/%d/%d/%d]\r\nRelations: ", buf, clan[c].taxrate, clan[c].app_level, clan[c].spells[0], clan[c].spells[1], clan[c].spells[2], clan[c].spells[3], clan[c].spells[4]);
  
  /* Line 5: Relations */
  for (i = 0; i < num_of_clans; i++)
    sprintf(buf, "%s%d(%d)%s", buf, clan[i].id, GET_CLAN_REL(c, i), ((i < (num_of_clans-1)) ? " " : "\r\nFrags: "));

  /* Line 6: Frags-Deaths */
  for (i = 0; i < num_of_clans; i++)
    sprintf(buf, "%s%d(%d-%d)%s", buf, clan[i].id, GET_CLAN_FRAGS(c, i), 
	    GET_CLAN_DEATHS(c, i), 
	    ((i < (num_of_clans-1)) ? " " : "\r\nOptions: "));

  /* Line 7: Options */
  for (i = 0; i < NUM_CO; i++) {
    if (CLAN_HASOPT(c, i)) {
      sprintf(buf, "%s%s%s", buf, ((crap > 0) ? ", " : ""), clan_enablers[i]);
      crap = 1;
    }
  }
  if (crap > 0)
    strcat(buf, "\r\nPrivileges: ");
  else
    strcat(buf, "None Enabled.\r\nPrivileges: ");

  crap = 0;
    

  /* Line 8: Privileges */
  for (i = 0; i < NUM_CP; i++)
    sprintf(buf, "%s%s[%d]%s", buf, clan_privileges[i], clan[c].privilege[i], ((i < (NUM_CP-1)) ? ", " : "\r\nRanks: "));

  /* Line 9: Rank Titles */
  for (i = 0; i < clan[c].ranks; i++)
    sprintf(buf, "%s%d-%s%s", buf, (i+1), clan[c].rank_name[i], ((i < (clan[c].ranks-1)) ? ", " : "\r\n"));

  send_to_char(buf, ch);
}

/* Recruiting New Members */
void do_clan_recruit (struct char_data *ch, char *arg)
{
  struct char_data *vict=NULL;
  int clan_num=-1,immcom=FALSE;
  char cin[80];

  if (!(*arg))
  {
    send_to_char("Just who did you want to recruit?\r\n", ch);
    return; 
  }

  switch (clan_check_priv(ch, CP_RECRUIT))
  {
    case CPC_NOCLAN:
    case CPC_NOPRIV:
      return;
    case CPC_IMM:
      immcom=TRUE;
      break;
    case CPC_PRIV:
      clan_num = find_clan_by_id(GET_CLAN(ch));
      break;
    default: 
      send_to_char("Bug. Please report.\r\n", ch);
      return;
  }

  if(!(vict=generic_find_char(ch,arg,FIND_CHAR_ROOM)))
  {
    send_to_char("Er, Who ??\r\n",ch);
    return;
  }

  if (immcom)
    if ((clan_num = find_clan_by_id(GET_CLAN(vict))) == -1)
    {
      send_to_char("They don't seem to be in a clan.\r\n", ch);
      return;
    }

  if(GET_CLAN(vict) != clan[clan_num].id)
  {
    if(GET_CLAN_RANK(vict) > 0)
      send_to_char("They're already in a clan.\r\n",ch);
    else 
      send_to_char("They haven't applied to your clan.\r\n",ch);
    return;
  }
  if(GET_CLAN_RANK(vict) > 0) {
    send_to_char("They're already in your clan.\r\n",ch);
    return;
  }
  if (GET_LEVEL(vict) >= LVL_IS_GOD)
  {
    send_to_char("You cannot recruit immortals in clans.\r\n",ch);
    return; 
  }
  
  GET_CLAN_RANK(vict)++;
  save_char(vict, vict->in_room);
  clan[clan_num].power += GET_LEVEL(vict);
  clan[clan_num].members++;
  sprintf(buf, "You're application to %s has been accepted.\r\n", clan[clan_num].name);
  send_to_char(buf, vict);
  send_to_char("Okay.\r\n",ch);
  sprintf(cin, "%s has been recruited.", GET_NAME(vict));
  do_clan_infocom(GET_CLAN(vict), 0, cin);
  return;
}

/* Cutdown version of get_player_vis .. used by do_clan_banish - ARTUS */
struct char_data *get_player (struct char_data *ch, char *name)
{
  struct char_data *i;
  for (i = character_list; i; i = i->next) 
  {
    if (IS_NPC(i))
      continue;
    if (str_cmp(i->player.name, name))
      continue;
    if (GET_INVIS_LEV(i) > GET_LEVEL(ch))
      continue;
    return i;
  }
  return NULL;
}

/* Banishing Members - Works on online and offline. */
void do_clan_banish (struct char_data *ch, char *arg)
{
  extern int top_of_p_table;
  extern FILE *player_fl;
  int clan_num=-1,immcom=FALSE,i,player_i = 0;
  char cin[80];
  struct char_data *vict;

  if (!(*arg)) {
    send_to_char("Just who did you want to banish?\r\n", ch);
    return;
  }

  switch (clan_check_priv(ch, CP_BANISH)) {
    case CPC_NOCLAN:
    case CPC_NOPRIV:
      return;
    case CPC_IMM:
      immcom=TRUE;
      break;
    case CPC_PRIV:
      clan_num = find_clan_by_id(GET_CLAN(ch));
      break;
    default:
      send_to_char("Bug. Please report.\r\n", ch);
      return;
  }

  if ((vict = get_player(ch, arg)) != NULL) {
    if (immcom)
      clan_num = find_clan_by_id(GET_CLAN(vict));

    if (!immcom && (GET_CLAN(vict) != clan[clan_num].id)) {
      send_to_char("They don't seem to belong to your clan.\r\n", ch);
      return;
    }
    if (!immcom && (GET_CLAN_RANK(vict) >= GET_CLAN_RANK(ch))) {
      send_to_char("You cannot banish someone who is of equal or higher rank than yourself.\r\n", ch);
      return;
    }
    sprintf(buf, "%s has been banished from your clan.\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
    send_to_char("You have been banished from your clan.\r\n", vict);
    GET_CLAN(vict) = 0;
    GET_CLAN_RANK(vict) = 0;
    clan[clan_num].members--;
    clan[clan_num].power -= GET_LEVEL(vict);
    sprintf(cin, "%s has been banished.", GET_NAME(vict));
    SET_BIT(PLR_FLAGS(vict), PLR_CRASH);
    do_clan_infocom(clan[clan_num].id, 0, cin);
    return;
  }

  if (immcom) {
    send_to_char("Couldn't find that player online.. Perhaps you need to set file 'x' clan 0.\r\n", ch);
    return;
  }

  for (i = 0; i <= top_of_p_table; i++) {
    struct char_file_u tch;
    if ((player_i = load_char(player_table[i].name, &tch)) >= 0) {
      if ((!strcasecmp(tch.name, arg)) && (tch.player_specials_saved.clan == clan[clan_num].id)) {
	if (tch.player_specials_saved.clan_rank >= GET_CLAN_RANK(ch)) {
          send_to_char("Cannot banish someone who's not ranked lower than yourself.\r\n", ch);
	  return;
	}
	i = top_of_p_table;
        sprintf(cin, "%s has been banished.", tch.name);
        do_clan_infocom(clan[clan_num].id, 0, cin);
	tch.player_specials_saved.clan = 0;
	tch.player_specials_saved.clan_rank = 0;
        fseek(player_fl, (player_i) * sizeof(struct char_file_u), SEEK_SET);
        fwrite(&tch, sizeof(struct char_file_u), 1, player_fl);
	fflush(player_fl);
        clan[clan_num].members--;
        clan[clan_num].power-=tch.level;
	return;
      }
    }
  }
  
  send_to_char("Could not find anyone by that name belonging to your clan.\r\n", ch);
  return;
}

/* Demotions */
void do_clan_demote (struct char_data *ch, char *arg)
{
  struct char_data *vict=NULL;
  int clan_num=-1,immcom=FALSE;
  char cin[80];

  if (!(*arg)) {
    send_to_char("Just who did you want to demote?\r\n", ch);
    return; 
  }

  switch (clan_check_priv(ch, CP_DEMOTE)) {
    case CPC_NOCLAN:
    case CPC_NOPRIV:
      return;
    case CPC_IMM:
      immcom = TRUE;
      break;
    case CPC_PRIV:
      clan_num = find_clan_by_id(GET_CLAN(ch));
      break;
    default:
      send_to_char("Bug. Please report.\r\n", ch);
      return;
  }
  if(!(vict=generic_find_char(ch,arg,FIND_CHAR_ROOM)))
  {
    send_to_char("Er, Who ??\r\n",ch);
    return; 
  }
  if(!immcom && GET_CLAN(vict)!=clan[clan_num].id)
  {
    send_to_char("They're not in your clan.\r\n",ch);
    return; 
  }
  if (immcom)
  {
    if ((clan_num = find_clan_by_id(GET_CLAN(vict))) == -1)
    {
      send_to_char("They're not in a clan.\r\n", ch);
      return;
    }
  }
  if(GET_CLAN_RANK(vict)==1)
  {
    send_to_char("They can't be demoted any further, use banish now.\r\n",ch);
    return; 
  }
  if(GET_CLAN_RANK(vict)>=GET_CLAN_RANK(ch) && !immcom)
  {
    send_to_char("You cannot demote a person of this rank!\r\n",ch);
    return; 
  }
  GET_CLAN_RANK(vict)--;
  save_char(vict, vict->in_room);
  sprintf(buf, "%s has demoted you to %s.\r\n", ((CAN_SEE(ch, vict)) ? ch->player.name : "someone"), clan[clan_num].rank_name[GET_CLAN_RANK(vict) - 1]);
  send_to_char(buf, vict);
  send_to_char("Done.\r\n", ch);
  sprintf(cin, "%s has been demoted to %s.", GET_NAME(vict), clan[clan_num].rank_name[GET_CLAN_RANK(vict) - 1]);
  do_clan_infocom(GET_CLAN(vict), 0, cin);
  return;
}

/* Promotions */
void do_clan_promote (struct char_data *ch, char *arg)
{
  struct char_data *vict=NULL;
  int clan_num=-1,immcom=FALSE;
  char cin[80];

  if (!(*arg)) {
    send_to_char("Who is it you wish to promote?\r\n", ch);
    return; 
  }

  switch (clan_check_priv(ch, CP_DEMOTE)) {
    case CPC_IMM:
      immcom = TRUE;
      break;
    case CPC_NOCLAN:
    case CPC_NOPRIV:
      return;
    case CPC_PRIV:
      clan_num = find_clan_by_id(GET_CLAN(ch));
      break;
    default:
      send_to_char("Bug. Please report.\r\n", ch);
      return;
  }

  if(!(vict=generic_find_char(ch,arg,FIND_CHAR_ROOM)))
  {
    send_to_char("Er, Who ??\r\n",ch);
    return; 
  }

  if (immcom)
  {
    if ((clan_num = find_clan_by_id(GET_CLAN(vict))) == -1)
    {
      send_to_char("They aren't even in a clan.\r\n", ch);
      return;
    }
  }
  
  if(!immcom && GET_CLAN(vict) != GET_CLAN(ch)) {
    send_to_char("They're not in your clan.\r\n",ch);
    return; 
  }

  if(GET_CLAN_RANK(vict) == 0) {
    send_to_char("Their application has not been approved yet.\r\n",ch);
    return; 
  }
  if(!immcom && (GET_CLAN_RANK(vict) >= GET_CLAN_RANK(ch))) {
    send_to_char("You cannot promote that person over your rank!\r\n",ch);
    return; 
  }
  if(GET_CLAN_RANK(vict) == clan[clan_num].ranks) {
    send_to_char("You cannot promote someone over the top rank!\r\n",ch);
    return; 
  }
  GET_CLAN_RANK(vict)++;
  save_char(vict, vict->in_room);
  sprintf(buf, "%s has promoted you to %s.\r\n", ((CAN_SEE(ch, vict)) ? ch->player.name : "someone"), clan[clan_num].rank_name[GET_CLAN_RANK(vict) - 1]);
  send_to_char(buf, vict);
  send_to_char("Done.\r\n", ch);
  sprintf(cin, "%s promoted to %s.", GET_NAME(vict), clan[clan_num].rank_name[GET_CLAN_RANK(vict) - 1]);
  do_clan_infocom(GET_CLAN(vict), 0, cin);
  return;
}

/* Member Listing.. Probably should be sorted. TODO - ARTUS */
void do_clan_who (struct char_data *ch, char *arg)
{
  extern int top_of_p_table;
  int test_clan, clan_num;
  unsigned int i;
  char line_disp[90];

  switch (clan_check_priv(ch, -1)) {
    case CPC_NOCLAN:
    case CPC_NOPRIV:
      return;
    case CPC_IMM:
      if ((test_clan=find_clan_by_sid(arg)) < 0) {
	send_to_char("That clan seems to exist only in your world.\r\n", ch);
	return;
      }
      test_clan=clan[test_clan].id;
      break;
    case CPC_PRIV: 
      test_clan=GET_CLAN(ch);
      break;
    default:
      send_to_char("Bug. Please report.\r\n", ch);
      return;
  }

  clan_num = find_clan_by_id(test_clan);

  sprintf(buf, "\r\nMembers of %s\r\n", clan[clan_num].name);
  for (i = 0; i <= (strlen(clan[clan_num].name) + 10); i++)
    strcat(buf, "-"); /* Happy, DM? :o) - ARTUS */
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
  for (i = 0; (int)i <= top_of_p_table; i++) {
    struct char_file_u tch;
    if (load_char(player_table[i].name, &tch) >= 0) {
      if ((tch.player_specials_saved.clan == test_clan) && (tch.player_specials_saved.clan_rank > 0)) {
        sprintf(line_disp,"%-15s  %s\r\n", tch.name, clan[clan_num].rank_name[tch.player_specials_saved.clan_rank-1]);
        send_to_char(line_disp,ch); 
      }
    }
  }
  return;
}

void do_clan_about (struct char_data *ch, char *arg) {
  int clan_num;
  
  if ((clan_num = find_clan_by_sid(arg)) < 0) {
    if ((clan_num = find_clan_by_id(GET_CLAN(ch))) < 0) {
      send_to_char ("There is no such clan.\r\n", ch);
      return;
    }
  }

  sprintf(buf, "Description of \"%s\":\r\n\r\n", clan[clan_num].name);
  sprintf(buf, "%s%s\r\n", buf, clan[clan_num].description);
  page_string(ch->desc, buf, 1);
  return;
}

/* Clan Info */
void do_clan_infocom (int clan_one, int clan_two, char *arg) {

  struct descriptor_data *i;

  if (arg == NULL)
    return;

  for (i = descriptor_list; i; i = i->next) {
    if (STATE(i) != CON_PLAYING || IS_NPC(i->character)) /* switch */
      continue;
    if (LR_FAIL(i->character, LVL_CLAN_GOD))
    {
      if ((GET_CLAN(i->character) < 1) && 
	  (GET_LEVEL(i->character) < LVL_CLAN_GOD))
        continue;
      if ((GET_CLAN_RANK(i->character) < 1))
        continue;
      if (((clan_one > 0) || (clan_two > 0)) && 
	  (GET_CLAN(i->character) != clan_one) && 
	  (GET_CLAN(i->character) != clan_two))
        continue;
    }
    if (EXT_FLAGGED(i->character, EXT_NOCI))
      continue;
    if (PLR_FLAGGED(i->character, PLR_WRITING))
      continue;

    if (GET_LEVEL(i->character) >= LVL_CLAN_GOD) 
      sprintf(buf, "CLAN: [ (%d) %s ]\r\n", clan_one, arg);
    else 
      sprintf(buf, "CLAN: [ %s ]\r\n", arg);
    send_to_char(CCGRN(i->character, C_NRM), i->character);
    send_to_char(buf, i->character);
    send_to_char(CCNRM(i->character, C_NRM), i->character);
  }

  return;
}

/* Display players status within the clan */
void do_clan_status (struct char_data *ch)
{
  char line_disp[90];
  int clan_num;

  clan_num = find_clan_by_id(GET_CLAN(ch));

  if(GET_CLAN_RANK(ch)==0)
  {
    if(clan_num>=0) {
      sprintf(line_disp,"You applied to %s\r\n",clan[clan_num].name);
      send_to_char(line_disp,ch);
      return; 
    }
    send_to_char("You do not belong to a clan!\r\n",ch);
    return; 
  }
  sprintf(line_disp,"You are %s (Rank %d) of %s (ID %d)\r\n",
          clan[clan_num].rank_name[GET_CLAN_RANK(ch)-1],GET_CLAN_RANK(ch),
          clan[clan_num].name,clan[clan_num].id);
  send_to_char(line_disp,ch);

  return;
}

/* Applications to clans.. */
void do_clan_apply (struct char_data *ch, char *arg)
{
  int clan_num, immcom=FALSE;
  char cin[80];

  if((GET_LEVEL(ch) >= LVL_IS_GOD) && (CLAN_NO_IMM == 1))
  {
    send_to_char("Gods cannot apply for any clan.\r\n",ch);
    return; 
  }
  if(!LR_FAIL(ch, LVL_CLAN_GOD))
    immcom = TRUE;

  if(GET_CLAN_RANK(ch) > 0)
  {
    send_to_char("You already belong to a clan!\r\n",ch);
    return; 
  }
  if (!(*arg)) {
    send_to_char("To which clan were you wanting to apply? (Try \"clan list\")\r\n", ch);
    return; 
  }
  if ((clan_num = find_clan_by_sid(arg)) < 0) {
    send_to_char("Unknown clan specified.\r\n", ch);
    return; 
  }

  if (LR_FAIL(ch, clan[clan_num].app_level))
  {
    sprintf(buf, "You must be at least level %d to join %s.\r\n", clan[clan_num].app_level, clan[clan_num].name);
    send_to_char(buf, ch);
    return; 
  }
  if(do_clan_charge(ch, clan[clan_num].app_fee) < 1) {
    sprintf(buf, "You can't afford the %d coin application fee.\r\n", clan[clan_num].app_fee);
    send_to_char(buf, ch);
    return; 
  }

  clan_coinage (clan_num, clan[clan_num].app_fee);

  save_clans();
  GET_CLAN(ch)=clan[clan_num].id;
  REMOVE_BIT(EXT_FLAGS(ch), EXT_PKILL);
  save_char(ch, ch->in_room);
  sprintf(buf, "You submit your application and %d coins to %s.\r\n", clan[clan_num].app_fee, clan[clan_num].name);
  send_to_char(buf, ch);
  sprintf(cin, "%s has applied.", GET_NAME(ch));
  do_clan_infocom(GET_CLAN(ch), 0, cin);
  return;
}

/* Clan Info */
void do_clan_info (struct char_data *ch, char *arg)
{
  int i=0,j=0,x=0,y=0;

  if(num_of_clans == 0) {
    send_to_char("No clans have formed yet.\r\n",ch);
    return; 
  }

  if(!(*arg)) {
    sprintf(buf, "\r");
    for(i=0; i < num_of_clans; i++)
      sprintf(buf, "%s[%-2d]  %-20s  Level: %2d  Appfee: %9d  Tax Rate: %d%%\r\n",buf
 , clan[i].id, clan[i].name,clan[i].level,clan[i].app_fee,clan[i].taxrate);
    page_string(ch->desc,buf, 1);
    return; 
  }
  if ((i=find_clan_by_sid(arg)) < 0) {
    send_to_char("Which clan?!\r\n", ch);
    return;
  }

  sprintf(buf, "Info for the level %d clan, %s:\r\n",clan[i].level,clan[i].name);
  send_to_char(buf, ch);
  sprintf(buf, "Ranks      : %d\r\nTitles     : ",clan[i].ranks);
  for(j=0;j<clan[i].ranks;j++)
    sprintf(buf, "%s%s%s ",buf,clan[i].rank_name[j],((j==clan[i].ranks - 1) ? "." : ","));
    sprintf(buf, "%s\r\nMembers    : %d\r\nPower      : %d\r\n",buf, clan[i].members, clan[i].power);
  for(j = 0; j < num_of_clans; j++) 
  {
    x += GET_CLAN_FRAGS(i, j);
    y += GET_CLAN_DEATHS(i, j);
  }
  sprintf(buf, "%sKill/Deaths: %d/%d\r\n", buf, x, y);
  
  for(j=0; j<5;j++)
    if(clan[i].spells[j])
      sprintf(buf, "%s%d ",buf,clan[i].spells[j]);
  sprintf(buf, "%s\r\n",buf);
  send_to_char(buf, ch);
  sprintf(buf,"Clan privileges:\r\n");
  for(j=0; j<NUM_CP;j++)
    sprintf(buf, "%s   %-10s: %s%s",buf,clan_privileges[j],clan[i].rank_name[clan[i].privilege[j]-1], (((j % 2) == 0) ? "     " : "\r\n"));
  sprintf(buf, "%s%s",buf,(((NUM_CP % 2) == 1) ? "\r\n\r\n" : "\r\n"));
  send_to_char(buf, ch);
  sprintf(buf, "Application fee  : %d gold\r\nTax Rate         : %d%%\r\n", clan[i].app_fee, clan[i].taxrate);
  send_to_char(buf, ch);
  sprintf(buf, "Application level: %d\r\n", clan[i].app_level);
  send_to_char(buf, ch);

  return;
}

/* Find clan by either string idnum or name */
sh_int find_clan_by_sid(char *test)
{
  if (is_number(test)) 
    return find_clan_by_id(atoi(test));

  for (int i = 0; i < num_of_clans; i++)
    if (is_abbrev(test, clan[i].name))
      return i;

  return -1;
}

/* Finding index of clan by ID number. */
sh_int find_clan_by_id(int idnum)
{
  int i;
  for( i=0; i < num_of_clans; i++)
    if(idnum==(clan[i].id))
      return i;
  return -1;
}

/* Finding index of clan by clan name.. Only really used for dupe name check */
sh_int find_clan(char *name)
{
  int i;
  for( i=0; i < num_of_clans; i++)
    if(strcmp(CAP(name), CAP(clan[i].name))==0)
      return i;
  return -1;
}

/* Save clans to disk */
void save_clans()
{
  FILE *fl;

  if (!(fl = fopen(CLAN_FILE, "wb"))) {
    basic_mud_log("SYSERR: Unable to open clan file");
    return; 
  }

  fwrite(&num_of_clans, sizeof(int), 1, fl);
  fwrite(clan, sizeof(struct clan_rec), num_of_clans, fl);
  fclose(fl);
  return;
}

/* Initialise clans */
void init_clans()
{
  FILE *fl;
  int i,j;
  extern int top_of_p_table;
  struct char_file_u chdata;

  memset(clan,0,sizeof(struct clan_rec)*MAX_CLANS);
  num_of_clans=0;
  i=0;

  if (!(fl = fopen(CLAN_FILE, "rb"))) {
    basic_mud_log("   Clan file does not exist. Will create a new one");
    save_clans();
    return; 
  }

  fread(&num_of_clans, sizeof(int), 1, fl);
  fread(clan, sizeof(struct clan_rec), num_of_clans, fl);
  fclose(fl);

  basic_mud_log("   Calculating powers and members");
  for(i=0;i<num_of_clans;i++) {
    clan[i].power=0;
    clan[i].members=0;
  }
  for (j = 0; j <= top_of_p_table; j++){
    load_char((player_table + j)->name, &chdata);
    if((i=find_clan_by_id(chdata.player_specials_saved.clan))>=0) {
      clan[i].power+=chdata.level;
      clan[i].members++;
    }
  }
  return;
}

/* Clan balance, withdraw, deposit */
void do_clan_bank(struct char_data *ch, char *arg, int action)
{
  int clan_num,immcom=0,result;
  long amount=0;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];

  if (action >= CB_BALANCE)
    result = clan_check_priv(ch, CP_WITHDRAW);
  else
    result = clan_check_priv(ch, -1);
  
  switch (result) {
    case CPC_IMM:  
      immcom = 1; 
      half_chop(arg,arg1,arg2);
      strcpy(arg,arg2);
      if ((clan_num = find_clan_by_sid(arg1)) < 0) {
	send_to_char("That clan does not seem to exist.\r\n", ch);
	return;
      }
      break;
    case CPC_NOCLAN:
    case CPC_NOPRIV:
      return;
    case CPC_PRIV:
      clan_num = find_clan_by_id(GET_CLAN(ch));
      break;
    default: send_to_char("Bug. Please report.\r\n", ch); return;
  }

  if ((!(*arg)) && (action != CB_BALANCE)) {
    sprintf(buf, "How much did you want to %s?\r\n", ((action == CB_DEPOSIT) ? "Deposit" : "Withdraw"));
    send_to_char(buf, ch);
    return; 
  }
 
  amount=atoi(arg);

  switch(action) {
    case CB_BALANCE:
      if (clan[clan_num].treasure > 0) 
        sprintf (buf, "The treasury of %s is at %ld00 coins.\r\n", clan[clan_num].name, clan[clan_num].treasure);
      else 
        sprintf (buf, "The treasury of %s is seeking donations.\r\n", clan[clan_num].name);
      send_to_char(buf, ch);
      break;
    case CB_WITHDRAW:
      if ((amount < 100) || ((amount % 100) > 0)) {
	send_to_char("You must withdraw a multiple of 100 coins.\r\n", ch);
	return;
      }
      if ((int)clan[clan_num].treasure < (amount / 100)) {
	send_to_char("Your clan is not *that* wealthy!\r\n", ch);
	return;
      }
      GET_GOLD(ch)+=(amount);
      clan[clan_num].treasure-=(amount / 100);
      send_to_char("You withdraw from the clan's treasure.\r\n",ch);
      break;
    case CB_DEPOSIT:
      if ((amount < 100) || ((amount % 100) > 0)) {
	send_to_char("You must deposit in multiples of 100 coins.\r\n", ch);
	return;
      }
      if(!immcom) { 
        if (GET_GOLD(ch) < amount) {
  	  send_to_char("You don't have that much gold!\r\n", ch);
	  return;
        }
	GET_GOLD(ch)-=amount;
      }
      clan_coinage(clan_num, amount);
      send_to_char("You add to the clan's treasure.\r\n",ch);
      break;
    default:
      send_to_char("Problem in command, please report.\r\n",ch);
      break;
  }
  save_char(ch, ch->in_room); 
  save_clans();
  return;
}

/* Changing tax rate, appfee */
void do_clan_changefees(struct char_data *ch, char *arg, int action)
{
  int clan_num,immcom=0;
  long amount=0;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];

  if (!(*arg)) {
    switch(action) {
      case CM_APPFEE:
	if (LR_FAIL(ch, LVL_CLAN_GOD))
	  send_to_char("Syntax: clan set appfee <amount>\r\n", ch);
	else
	  send_to_char("Syntax: clan set appfee <clan num> <amount>\r\n", ch);
        break;
      case CM_DUES:
	if (LR_FAIL(ch, LVL_CLAN_GOD))
	  send_to_char("Syntax: clan set tax <2-50>  (This number is a percentage.\r\n", ch);
	else
	  send_to_char("Syntax: clan set tax <clan num> <2-50>  (Percentage)\r\n", ch);
	break;
      default:
	send_to_char("Bug in command. Please report.\r\n", ch);
    }
    return; 
  }

  switch (clan_check_priv(ch, CP_SET_FEES)) {
    case CPC_IMM:
      immcom = 1;
      half_chop(arg,arg1,arg2);
      strcpy(arg,arg2);
      if ((clan_num = find_clan_by_sid(arg1)) < 0) {
	send_to_char("That clan doesn't appear to exist.\r\n", ch);
	return;
      }
      break;
    case CPC_NOCLAN:
    case CPC_NOPRIV:
      return;
    case CPC_PRIV:
      clan_num=find_clan_by_id(GET_CLAN(ch));
      break;
    default:
      send_to_char("Bug. Please report.\r\n", ch);
      return;
  }

  if(!(*arg)) {
    send_to_char("Set it to how much?\r\n",ch);
    return;
  }

  if(!is_number(arg)) {
    send_to_char("Set it to what?\r\n",ch);
    return;
  }

  amount=atoi(arg);

  switch(action) {
    case CM_APPFEE:
      if ((amount < CLAN_MIN_APP) || (amount > CLAN_MAX_APP)) {
	sprintf(buf, "Application fee must be between %d and %d coins.\r\n", CLAN_MIN_APP, CLAN_MAX_APP);
	send_to_char(buf, ch);
	return;
      }
      amount = (int)(amount / 100); /* I know this seems silly.. But need the result to be */
      amount *= 100; /* a multiple of 100 coins. Trust me. - ARTUS          */
      clan[clan_num].app_fee=amount;
      send_to_char("You change the application fee.\r\n",ch);
      break;
    case CM_DUES:
      if ((amount < CLAN_MIN_TAX) || (amount > CLAN_MAX_TAX)) {
        sprintf(buf, "Clan tax must be between %d and %d\r\n", CLAN_MIN_TAX, CLAN_MAX_TAX);
      }
      if (do_clan_charge(ch, CLC_CHGFEE) < 1) {
        sprintf(buf, "You need %d gold to change the tax rate.\r\n", CLC_CHGFEE);
        send_to_char(buf, ch);
        return;
      }
      clan[clan_num].taxrate=amount;
      sprintf(buf, "Taxrate changed to %ld. (%d coins deducted.)\r\n", amount,
              (immcom) ? 0 : CLC_CHGFEE);
      send_to_char(buf,ch);
      break;
    default:
      send_to_char("Problem in command, please report.\r\n",ch);
      break;
  }

  save_clans();
  return;
}

/* Changing Number of clan ranks.. */
void do_clan_set_ranks(struct char_data *ch, char *arg)
{
  int i,j;
  int clan_num,immcom=0;
  int new_ranks,amtreq=0;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  char cin[80];
  extern int top_of_p_table;
  struct char_file_u chdata;
  struct char_data *victim=NULL;

  switch (clan_check_priv(ch, CP_LEADER)) {
    case CPC_NOCLAN:
    case CPC_NOPRIV:
      return;
    case CPC_IMM:
      immcom=1;
      half_chop(arg,arg1,arg2);
      strcpy(arg,arg2);
      if ((clan_num = find_clan_by_sid(arg1)) < 0) {
        send_to_char("Unknown clan specified.\r\n", ch);
        return;
      }
      break;
    case CPC_PRIV:
      clan_num=find_clan_by_id(GET_CLAN(ch));
      break;
    default:
      send_to_char("Bug. Please report.\r\n", ch);
      return;
  }

  if(!(*arg)) {
    send_to_char("Set how many ranks?\r\n",ch);
    return;
  } 

  if(!is_number(arg) && immcom) {
    send_to_char("Set the ranks to what?\r\n",ch);
    return;
  }

  new_ranks=atoi(arg);

  if (new_ranks == clan[clan_num].ranks) {
    sprintf(buf, "%s already consists of %d ranks.\r\n", clan[clan_num].name, clan[clan_num].ranks);
    send_to_char(buf, ch);
    return;
  }

  if (new_ranks > clan[clan_num].ranks)
    for (i = (clan[clan_num].ranks+1); i <= new_ranks; i++)
      amtreq += (i * CLC_ADDRANK);

  if(new_ranks<2 || new_ranks>20) {
    send_to_char("Number of ranks must be between 2 and 20.\r\n",ch);
    return;
  }

  if(do_clan_charge(ch, amtreq) < 1) {
    sprintf(buf, "You will need %d coins to expand to %d ranks.\r\n", amtreq, new_ranks);
    send_to_char(buf, ch);
    return;
  }

  for (j = 0; j <= top_of_p_table; j++)
  {
    if((victim=get_player_online(ch, (player_table +j)->name, FIND_CHAR_INVIS)))
    {
      if(GET_CLAN(victim)==clan[clan_num].id) 
      {
        if(GET_CLAN_RANK(victim)<clan[clan_num].ranks && GET_CLAN_RANK(victim)>0)
          GET_CLAN_RANK(victim)=MIN(GET_CLAN_RANK(victim), new_ranks - 1); /* Should Keep Ranks In Some Orderly Fashion */
        if(GET_CLAN_RANK(victim)==clan[clan_num].ranks)
          GET_CLAN_RANK(victim)=new_ranks;
        save_char(victim, victim->in_room);
      }
    } else {
      load_char((player_table + j)->name, &chdata);
      if(chdata.player_specials_saved.clan==clan[clan_num].id) {
        if(chdata.player_specials_saved.clan_rank<clan[clan_num].ranks && chdata.player_specials_saved.clan_rank>0)
          chdata.player_specials_saved.clan_rank=MIN(chdata.player_specials_saved.clan_rank, new_ranks -1); /* Rank preservation technique */
        if(chdata.player_specials_saved.clan_rank==clan[clan_num].ranks)
          chdata.player_specials_saved.clan_rank=new_ranks;
        save_char_file_u(chdata);
      }
    }
  }

  if (clan[clan_num].ranks > new_ranks)
    sprintf(cin, "Number of ranks reduced to %d.", new_ranks);
  if (clan[clan_num].ranks < new_ranks)
    sprintf(cin, "Number of ranks increased to %d.", new_ranks);

  do_clan_infocom(clan[clan_num].id, 0, cin);
  sprintf(buf, "Number of ranks is now %d. (%d coins deducted)\r\n", new_ranks,
      (immcom) ? 0 : amtreq);
  send_to_char(buf, ch);
  strcpy(clan[clan_num].rank_name[new_ranks - 1], clan[clan_num].rank_name[clan[clan_num].ranks - 1]);  
  if (new_ranks > clan[clan_num].ranks) {
    for(i=0;i<new_ranks-1;i++) {
      if (i >= (clan[clan_num].ranks - 1))
        strcpy(clan[clan_num].rank_name[i],"Undefined Rank");
    }
  } 

  for(i=0;i<NUM_CP;i++)
    if (clan[clan_num].privilege[i]==clan[clan_num].ranks)
      clan[clan_num].privilege[i]=new_ranks;
    else
      clan[clan_num].privilege[i]=MIN(clan[clan_num].privilege[i], new_ranks);

  clan[clan_num].ranks=new_ranks;

  save_clans();
  return;
}

/* Changing clan rank titles */
void do_clan_titles( struct char_data *ch, char *arg)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH], cin[80];
  int clan_num=0,rank;

  if (!(*arg)) {
    if (LR_FAIL(ch, LVL_CLAN_GOD))
      send_to_char("Syntax: clan set title <rank #> <title>\r\n", ch);
    else
      send_to_char("Syntax: clan set title <clan #> <rank #> <title>\r\n", ch);
    return; 
  }

  if (GET_LEVEL(ch) < LVL_IS_GOD)
  {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0)
    {
      send_to_char("You don't belong to any clan!\r\n",ch);
      return;
    }
    if(GET_CLAN_RANK(ch)!=clan[clan_num].ranks) {
      send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
      return;
    }
  } else {
    if (LR_FAIL(ch, LVL_CLAN_GOD))
    {
      send_to_char("You do not have clan privileges.\r\n", ch);
      return; 
    }
    half_chop(arg,arg1,arg2);
    strcpy(arg,arg2);
    if((clan_num=find_clan_by_sid(arg1))<0) {
      send_to_char("Unknown clan specified.\r\n",ch);
      return;
    }
  }

  half_chop(arg,arg1,arg2);

  if(is_number(arg1) < 1) {
    send_to_char("You need to specify a rank number.\r\n",ch);
    return; 
  }

  rank=atoi(arg1);

  if(rank<1 || rank>clan[clan_num].ranks) {
    send_to_char("This clan has no such rank number.\r\n",ch);
    return; 
  }

  if(strlen(arg2)<1 || strlen(arg2)>19) {
    send_to_char("You need a clan title of under 20 characters.\r\n",ch);
    return; 
  }

  if(do_clan_charge(ch, CLC_RANKTITLE) < 1) {
    sprintf(buf, "Changing rank titles will cost you %d.\r\n", CLC_RANKTITLE);
    send_to_char(buf, ch);
    return;
  }
  sprintf(cin, "Rank %d changed to: %s.", rank, arg2);
  do_clan_infocom(clan[clan_num].id, 0, cin);

  strcpy(clan[clan_num].rank_name[rank-1],arg2);
  save_clans();
  sprintf(buf, "Done for %d coins.\r\n", (!LR_FAIL(ch, LVL_CLAN_GOD)) ? 0 : CLC_RANKTITLE);
  send_to_char(buf, ch);
  return;
}

/* CHange clans minimum application level. */
void do_clan_application( struct char_data *ch, char *arg)
{
  int clan_num,immcom=0;
  int applevel;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  char cin[80];

  switch (clan_check_priv(ch, CP_SET_APPLEV)) {
    case CPC_NOCLAN:
    case CPC_NOPRIV:
      return;
    case CPC_IMM:
      immcom=1;
      half_chop(arg,arg1,arg2);
      strcpy(arg,arg2);
      if ((clan_num = find_clan_by_sid(arg1)) < 0) {
        send_to_char("Unknown clan specified.\r\n", ch);
        return;
      }
      break;
    case CPC_PRIV:
      clan_num=find_clan_by_id(GET_CLAN(ch));
      break;
    default:
      send_to_char("Bug. Please report.\r\n", ch);
      return;
  }

  if (!(*arg))
  {
    if (LR_FAIL(ch, LVL_CLAN_GOD))
      send_to_char("Syntax: clan set applev <level>\r\n", ch);
    else
      send_to_char("Syntax: clan set applev <clan #> <level>\r\n", ch);
    return; 
  }

  applevel=atoi(arg);

  if(applevel<LVL_CLAN_MIN || applevel>100) {
    sprintf(buf, "The application level must be between %d and 100.\r\n",LVL_CLAN_MIN);
    send_to_char(buf, ch);
    return;
  }

  if (do_clan_charge(ch, CLC_CHGAPPLEV) < 1) {
    sprintf(buf, "Changing the application level requires %d coins.\r\n", CLC_CHGAPPLEV);
    send_to_char(buf, ch);
    return;
  }

  sprintf(buf, "Players must now be level %d to apply to %s.\r\n", applevel, clan[clan_num].name);
  send_to_char(buf, ch);

  sprintf(cin, "Application level changed to %d.", applevel);
  do_clan_infocom(clan[clan_num].id, 0, cin);

  clan[clan_num].app_level=applevel;
  save_clans();

  return;
}

/* Set Clan Privledges */
void do_clan_sp(struct char_data *ch, char *arg, int priv)
{
  int clan_num,immcom=0;
  int rank;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];

  if (!(*arg))
  {
    if (LR_FAIL(ch, LVL_CLAN_GOD))
      send_to_char("Syntax: clan set privilege <privilege> <rank #>\r\n", ch);
    else
      send_to_char("Syntax: clan set privilege <privilege> <clan #> <rank #>\r\n", ch);
    return; 
  }

  switch (clan_check_priv(ch, CP_LEADER)) {
    case CPC_NOCLAN:
    case CPC_NOPRIV:
      return;
    case CPC_IMM:
      immcom=1;
      half_chop(arg,arg1,arg2);
      strcpy(arg,arg2);
      if ((clan_num = find_clan_by_sid(arg1)) < 0) {
        send_to_char("Unknown clan specified.\r\n", ch);
        return;
      }
      break;
    case CPC_PRIV:
      clan_num=find_clan_by_id(GET_CLAN(ch));
      break;
    default:
      send_to_char("Bug. Please report.\r\n", ch);
      return;
  }

  if(!(*arg)) {
    send_to_char("Set the privilege to which rank?\r\n",ch);
    return;
  }

  if(!is_number(arg)) {
    send_to_char("Set the privilege to what?\r\n",ch);
    return;
  }

  rank=atoi(arg);

  if(rank<1 || rank>clan[clan_num].ranks) {
    send_to_char("There is no such rank in the clan.\r\n",ch);
    return;
  }

  send_to_char("Done.\r\n", ch);

  clan[clan_num].privilege[priv]=rank;
  save_clans();

  return;
}

/* Change clan description (clan about) */
void do_clan_set_desc(struct char_data *ch, char *arg)
{
  int clan_num;

  switch(clan_check_priv(ch, CP_SET_DESC)) {
    case CPC_NOPRIV:
    case CPC_NOCLAN:
      return;
    case CPC_PRIV:
      clan_num=find_clan_by_id(GET_CLAN(ch));
      break;
    case CPC_IMM:
      if (!(*arg)) {
        send_to_char("Which clan's description did you want to set?\r\n", ch);
        return;
      }
      if ((clan_num = find_clan_by_sid(arg)) < 0) {
        send_to_char("Unknown clan specified.\r\n", ch);
        return; 
      }
      break;
    default:
      send_to_char("Bug. Please report.\r\n", ch);
      return;
  }

  if ((GET_GOLD(ch) < CLC_SETDESC) && LR_FAIL(ch, LVL_CLAN_GOD))
  {
    sprintf(buf, "Changing the clan description will cost %d coins.\r\n", CLC_SETDESC);
    send_to_char(buf, ch);
    return;
  }

  if(strlen(clan[clan_num].description)==0) {
    strcat(clan[clan_num].description, "An unfinished clan."); 
    sprintf(buf, "Enter the description for \"%s\": (/h for help)\r\n\r\n",clan[clan_num].name);
    send_to_char(buf, ch);
  } else {
    send_to_char("Enter new description: (/h for help)\r\n\r\n", ch);
    sprintf(buf, "Old description for \"%s\":\r\n", clan[clan_num].name);
    send_to_char(buf, ch);
    page_string(ch->desc, clan[clan_num].description, 1);
  }
 /******************
  * Should look at changing it in future to return something... So that we
  * know whether for the description was changed or not, and can reimburse 
  * the coin if that be the case... *shrugs*.. Dunno how it'd work.. Coin 
  * at this stage will be taken in modify.c...
  ******************/
  do_odd_write(ch->desc, PWT_CLANDESC, CLAN_DESC_LENGTH);
}

/* Clan Privileges */
void do_clan_set_priv( struct char_data *ch, char *arg)
{
  char arg1[MAX_INPUT_LENGTH] ,arg2[MAX_INPUT_LENGTH];
  int i;

  half_chop(arg,arg1,arg2);

  if (is_abbrev(arg1,"setabout" )) { do_clan_sp(ch,arg2,CP_SET_DESC);   return ;}
  if (is_abbrev(arg1,"recruit"  )) { do_clan_sp(ch,arg2,CP_RECRUIT);    return ;}
  if (is_abbrev(arg1,"banish"   )) { do_clan_sp(ch,arg2,CP_BANISH);     return ;}
  if (is_abbrev(arg1,"promote"  )) { do_clan_sp(ch,arg2,CP_PROMOTE);    return ;}
  if (is_abbrev(arg1,"demote"   )) { do_clan_sp(ch,arg2,CP_DEMOTE);     return ;}
  if (is_abbrev(arg1,"withdraw" )) { do_clan_sp(ch,arg2,CP_WITHDRAW);   return ;}
  if (is_abbrev(arg1,"setfees"  )) { do_clan_sp(ch,arg2,CP_SET_FEES);   return ;}
  if (is_abbrev(arg1,"setapplev")) { do_clan_sp(ch,arg2,CP_SET_APPLEV); return ;}
  if (is_abbrev(arg1,"enhance"  )) { do_clan_sp(ch,arg2,CP_ENHANCE);    return ;}
  if (is_abbrev(arg1,"room"     )) { do_clan_sp(ch,arg2,CP_ROOM);       return ;}
  if (is_abbrev(arg1,"setdesc"  )) { do_clan_sp(ch,arg2,CP_SET_DESC);   return ;}
  if (is_abbrev(arg1,"enable"   )) { do_clan_sp(ch,arg2,CP_ENABLE);     return ;
}
  send_to_char("Clan privileges:\r\n", ch);
  for(i=0;i<NUM_CP;i++) {
    sprintf(arg1,"\t%s\r\n",clan_privileges[i]);
    send_to_char(arg1,ch); 
  }  
}
 
/* Clan Room Stuff */
void do_clan_room(struct char_data *ch, char *arg)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  int clan_num = 0;
  zone_rnum real_zone(zone_vnum vnum);

  switch(clan_check_priv(ch, CP_SET_DESC)) {
    case CPC_NOPRIV:
    case CPC_NOCLAN:
      return;
    case CPC_PRIV:
      clan_num=find_clan_by_id(GET_CLAN(ch));
      break;
    case CPC_IMM:
      send_to_char("Use OLC you slacker.\r\n", ch);
      return;
    default:
      send_to_char("Bug. Please report.\r\n", ch);
      return;
  }
  if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
    send_to_char("You don't belong to any clan!\r\n",ch);
    return; 
  }
  if ((GET_ROOM_VNUM((ch)->in_room) < (CLAN_ZONE * 100)) || (GET_ROOM_VNUM((ch)->in_room) > ((CLAN_ZONE * 100)+351))) { 
    send_to_char("That room doesn't appear to belong to your clan!\r\n", ch);
    return;
  }
  clan_num = (clan[clan_num].id - 1);
  if (((GET_ROOM_VNUM((ch)->in_room)-(CLAN_ZONE*100)) % MAX_CLANS) != clan_num) {
    send_to_char("You don't appear to be in your clan hall.\r\n", ch);
    return;
  }
  half_chop(arg, arg1, arg2);
  if (is_abbrev(arg1, "title")) {
    if (strlen(arg2) < 2) {
      send_to_char("You must specify the new title.\r\n", ch);
      return;
    }
    if (strlen(arg2) > 75) {
      send_to_char("New title is too long, please keep to under 75 chars.\r\n", ch);
      return;
    }
    if (do_clan_charge(ch, CLC_ROOMTD) < 1) {
      sprintf(buf, "You'll need %d gold coins to change the room title.\r\n", CLC_ROOMTD);
      send_to_char(buf, ch);
      return;
    }
    free(world[ch->in_room].name);
    world[ch->in_room].name = strdup(arg2);
    
    if (save_rooms(world[ch->in_room].zone) == TRUE) {
      sprintf(buf, "Done. (%d coins deducted).\r\n", CLC_ROOMTD);
      send_to_char(buf, ch);
    } else {
      send_to_char("Failed to save clan zone to disk.\r\n", ch);
      if (LR_FAIL(ch, LVL_CLAN_GOD))
	GET_GOLD(ch) += CLC_ROOMTD;
    }
    return;
  }
  if (is_abbrev(arg1, "regen")) {
    if ((GET_ROOM_VNUM((ch)->in_room) < (CLAN_ZONE * 100 + MAX_CLANS-1))) {
      send_to_char("Cannot make the guard post 2xRegen.\r\n", ch);
      return;
    }
    if (ROOM_FLAGGED((ch)->in_room, ROOM_REGEN_2)) {
      send_to_char("This room is already marked REGENx2.\r\n", ch);
      return;
    }
    if (do_clan_charge(ch, CLC_REGENROOM) < 1) {
      sprintf(buf, "You'll need %d coins to make this room REGENx2.\r\n", CLC_REGENROOM);
      send_to_char(buf, ch);
      return;
    }
    TOGGLE_BIT(world[ch->in_room].room_flags, ROOM_REGEN_2);
    clan_num = save_rooms(world[ch->in_room].zone);
    if (clan_num == TRUE) {
      sprintf(buf, "Current room is now Regen*2. (%d coins deducted).\r\n",
          CLC_REGENROOM);
      send_to_char(buf, ch);
      return;
    }
    send_to_char("Failed to save clan zone to disk.\r\n", ch);
    if (LR_FAIL(ch, LVL_CLAN_GOD))
      GET_GOLD(ch) += CLC_REGENROOM;
    return;
  }
  if (is_abbrev(arg1, "description")) {
    if ((GET_GOLD(ch) < CLC_ROOMTD) && LR_FAIL(ch, LVL_CLAN_GOD))
    {
      sprintf(buf, "Changing a room's description costs %d coins, which you do not have.\r\n", CLC_ROOMTD);
      send_to_char(buf, ch);
      return;
    }
    ch->player_specials->write_extra = ch->in_room;
    do_odd_write(ch->desc, PWT_ROOM, 800);
    return;
  }
  if (is_abbrev(arg1, "build")) {
    int i, j, new_room = -1, direction;
    if ((GET_ROOM_VNUM((ch)->in_room) < (CLAN_ZONE * 100 + MAX_CLANS-1)))
    {
      send_to_char("Cannot build rooms off the guard post.\r\n", ch);
      return;
    }
    direction = clan_room_dirs(arg2);
    if (direction < 0)
    {
      send_to_char("What kind of direction is that?!\r\n", ch);
      return;
    }
    for (i = 1; i < CLAN_ROOM_MAX; i++)
    {
      char found = 1;
      for (j = 0; j < NUM_OF_DIRS; j++)
        if (W_EXIT(real_room((i * MAX_CLANS) + clan_num + (CLAN_ZONE * 100)), j))
          found = 0;
      if ((found == 1) && (new_room < 1)) 
        new_room = real_room((i * MAX_CLANS) + clan_num + (CLAN_ZONE * 100));
    }
    if (world[ch->in_room].dir_option[direction])
    {
      send_to_char("There already seems to be a room there!\r\n", ch);
      return;
    }
    if (new_room <= 0)
    {
      send_to_char("There is no room to expand your hall further.\r\n", ch);
      return;
    }
    if (do_clan_charge(ch, CLC_BUILD) < 1)
    {
      sprintf(buf, "Hiring builders for your new room will cost %d coins.\r\n", CLC_BUILD);
      send_to_char(buf, ch);
      return;
    }
    CREATE(world[ch->in_room].dir_option[direction], struct room_direction_data, 1);
    CREATE(world[new_room].dir_option[rev_dir[direction]], struct room_direction_data, 1);
    world[ch->in_room].dir_option[direction]->to_room = new_room;
    world[new_room].dir_option[rev_dir[direction]]->to_room = ch->in_room;
    clan_num = save_rooms(real_zone(CLAN_ZONE));
    if (clan_num != TRUE)
    {
      send_to_char("Failed to save clan zone to disk.\r\n", ch);
      if (LR_FAIL(ch, LVL_CLAN_GOD))
        GET_GOLD(ch) += CLC_BUILD;
      return;
    }
    sprintf(buf, "The builders charge %d coins for their work.\r\n", CLC_BUILD);
    send_to_char(buf, ch);
    return;
  }

/* Demolish -- This is currently unsafe.. It doesn't crash, it just causes
 * problems.. Eventually I should get around to rewriting it so it can be
 * useful.. *shrugs*..                                                   */

/*  if (is_abbrev(arg1, "demolish")) {
    int direction, old_rnum, demlow, demhigh;
    send_clan_format(ch);
    return;
    if ((GET_ROOM_VNUM((ch)->in_room) < (CLAN_ZONE * 100 + MAX_CLANS-1))) {
      send_to_char("Cannot demolish rooms off the guard post.\r\n", ch);
      return;
    }
    demlow = (CLAN_ZONE * 100) + (MAX_CLANS * 2);
    demhigh = demlow + (MAX_CLANS * CLAN_ROOM_MAX) - 1; 
    direction = clan_room_dirs(arg2);
    if (direction == -1) {
      send_to_char("You seem unable to demolish in that direction.\r\n", ch);
      return;
    } else if (direction == -2) {
      send_to_char("What kind of direction is that?!\r\n", ch);
      return;
    }
    if (!(world[ch->in_room].dir_option[direction])) {
      send_to_char("There doesn't appear to be a room there!\r\n", ch);
      return;
    }
    old_rnum = world[ch->in_room].dir_option[direction]->to_room;
      if ((world[old_rnum].number < demlow) || (world[old_rnum].number > demhigh)) {
      send_to_char("There doesn't seem to be any way to demolish that room.\r\n", ch);
      return;
    }
    world[old_rnum].dir_option[rev_dir[direction]] = NULL;
    world[ch->in_room].dir_option[direction] = NULL;
    send_to_char("The ground shakes violently as your clan room caves in to nothing.\r\n", ch);
    save_rooms(real_zone(CLAN_ZONE));
    return;
  } */
   
  send_to_char("The following room changes are available:-\r\n\r\n"
               "   clan room title    <title>\r\n"
               "   clan room desc\r\n"
               "   clan room regen\r\n"
               "   clan room build    <dir>\r\n", ch);
//               "   clan room demolish <dir>\r\n", ch);
}

/* Change name of healer/guard */
void do_clan_name_mob(struct char_data *ch, char *arg)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  int clan_num=0;
  struct char_data *mob, *live_mob;
  
  zone_rnum real_zone(zone_vnum vnum);

  switch(clan_check_priv(ch, CP_ENHANCE))
  {
    case CPC_NOPRIV:
    case CPC_NOCLAN:
      return;
    case CPC_PRIV:
      clan_num=find_clan_by_id(GET_CLAN(ch));
      break;
    case CPC_IMM:
      send_to_char("Use OLC you slacker.\r\n", ch);
      return;
    default:
      send_to_char("Bug. Please report.\r\n", ch);
      return;
  }

  if ((clan_num=find_clan_by_id(GET_CLAN(ch))) < 0)
  {
    send_to_char("You don't seem to belong to a clan.\r\n", ch);
    return;
  }

  clan_num = clan[clan_num].id - 1;
  half_chop(arg,arg1,arg2);

  if (is_abbrev(arg1, "guard"))
  {
    if (!(mob=generic_find_char(ch, arg1, FIND_CHAR_ROOM)))
    {
      send_to_char("Your clan guard doesn't seem to be here.\r\n", ch);
      return;
    }
    if (GET_MOB_VNUM(mob) != CLAN_ZONE*100+clan_num)
    {
      send_to_char("Why would you want to name their guard?!\r\n", ch);
      return;
    }
    if (strlen(arg2) < 10)
    {
      send_to_char("Guard's name must be at least 10 chars.\r\n", ch);
      return;
    }
    if (strlen(arg2) >= 78)
    {
      send_to_char("Guard's name cannot exceed 78 characters.\r\n", ch);
      return;
    }
    if (do_clan_charge(ch, CLC_MOBDESC) < 1)
    {
      sprintf(buf, "Naming your guard will cost %d coins.\r\n", CLC_MOBDESC);
      send_to_char(buf, ch);
      return;
    }

    sprintf(buf, "Done. (%d coins deducted).\r\n", CLC_MOBDESC);
    send_to_char(buf, ch);
    strcat(arg2, "\r\n");

    /* Should probably put this in a function when can be fragged - ARTUS */
    mob=&mob_proto[mob->nr];
    free(GET_LDESC(mob));
    GET_LDESC(mob) = str_dup(arg2);

    if (save_mobiles(real_zone(CLAN_ZONE)) == FALSE)
    {
      send_to_char("Unable to save zone file.\r\n", ch);
      GET_GOLD(ch) += CLC_MOBDESC;
    }
    for (live_mob = character_list; live_mob; live_mob = live_mob->next)
      if (mob->nr == live_mob->nr)
        update_mobile_strings(live_mob, &mob_proto[mob->nr]);

    return;
  }
  if (is_abbrev(arg1, "healer"))
  {
    if (!(mob=generic_find_char(ch, arg1, FIND_CHAR_ROOM)))
    {
      send_to_char("Your clan healer doesn't seem to be here.\r\n", ch);
      return;
    }
    if (GET_MOB_VNUM(mob) != (CLAN_ZONE*100+clan_num+MAX_CLANS))
    {
      send_to_char("Why would you want to name their healer?!\r\n", ch);
      return;
    }
    if (strlen(arg2) < 10)
    {
      send_to_char("Healer's name must be at least 10 characters.\r\n", ch);
      return;
    }
    if (strlen(arg2) >= 78)
    {
      send_to_char("Healer's name cannot exceed 78 characters.\r\n", ch);
      return;
    }
    if (do_clan_charge(ch, CLC_MOBDESC) < 1)
    {
      sprintf(buf, "Naming your healer will cost %d coins.\r\n", CLC_MOBDESC);
      send_to_char(buf, ch);
      return;
    }
    sprintf(buf, "Done. (%d coins deducted).\r\n", CLC_MOBDESC);
    send_to_char(buf, ch);

    strcat(arg2, "\r\n");
    mob=&mob_proto[mob->nr];
    free(GET_LDESC(mob));
    GET_LDESC(mob) = str_dup(arg2);

    if (save_mobiles(real_zone(CLAN_ZONE)) == FALSE)
    {
      send_to_char("Unable to save zone file.\r\n", ch);
      GET_GOLD(ch) += CLC_MOBDESC;
    }

    for (live_mob = character_list; live_mob; live_mob = live_mob->next)
      if (mob->nr == live_mob->nr)
        update_mobile_strings(live_mob, &mob_proto[mob->nr]);

    return;
  }

  send_to_char("Just what did you want to name?\r\n", ch);
  return;
  
}

/* Change description of healers/guards */
void do_clan_describe_mob(struct char_data *ch, char *arg)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  int clan_num=0;
  struct char_data *mob;
  zone_rnum real_zone(zone_vnum vnum);

  switch(clan_check_priv(ch, CP_ENHANCE)) {
    case CPC_NOPRIV:
    case CPC_NOCLAN:
      return;
    case CPC_PRIV:
      clan_num=find_clan_by_id(GET_CLAN(ch));
      break;
    case CPC_IMM:
      send_to_char("Use OLC you slacker.\r\n", ch);
      return;
    default:
      send_to_char("Bug. Please report.\r\n", ch);
      return;
  }

  clan_num = clan[clan_num].id - 1;
  half_chop(arg,arg1,arg2);

  if (is_abbrev(arg1, "guard"))
  {
    strcpy(arg1, "clanguard");
    if (!(mob=generic_find_char(ch, arg1, FIND_CHAR_ROOM)))
    {
      send_to_char("Your clan guard doesn't seem to be here.\r\n", ch);
      return;
    }
    if (GET_MOB_VNUM(mob) != CLAN_ZONE*100+clan_num)
    {
      send_to_char("Why would you want to describe their guard?!\r\n", ch);
      return;
    }
  } else if (is_abbrev(arg1, "healer")) {
    sprintf(arg1, "clanhealer");
    if (!(mob=generic_find_char(ch, arg1, FIND_CHAR_ROOM)))
    {
      send_to_char("Your clan healer doesn't seem to be here.\r\n", ch);
      return;
    }
    if (GET_MOB_VNUM(mob) != (CLAN_ZONE*100+clan_num+MAX_CLANS))
    {
      send_to_char("Why would you want to describe their healer?!\r\n", ch);
      return;
    }
  } else {
    send_to_char("Describe what?!?\r\n", ch);
    return;
  }
  if (GET_GOLD(ch) < CLC_MOBDESC)
  {
    sprintf(buf, "Changing it's appearance will require %d coins.\r\n", CLC_MOBDESC);
    send_to_char(buf, ch);
  }
  ch->player_specials->write_extra = mob->nr;
  do_odd_write(ch->desc, PWT_MOB, EXDSCR_LENGTH);
  return;
}

/* Display Clan Relations to members */

/* Ideas for relationships and their affects...
 *
 * Well... Atm, relationships are just text... That's no fun now is it..
 * To Consider:
 * 
 * Blood War - Clan members auto pk each other (devin)
 * War - Cannot bribe way into hall, cannot group (artus) [Done]
 *
 * Peaceful - Bonus when grouping (artus)
 * Alliance - Enter halls at free will. (artus) [Done]
 * 
 */

void do_clan_showrel (struct char_data *ch, char *arg) {
  int i, n, c;

  switch (clan_check_priv(ch, -1)) {
    case CPC_NOPRIV:
    case CPC_NOCLAN:
      return;
      break;
    case CPC_IMM:
      if((c=find_clan_by_sid(arg))<0) {
	send_to_char("Unknown clan specified.\r\n", ch);
	return;
      }
      break;
    case CPC_PRIV:
      c=find_clan_by_id(GET_CLAN(ch));
      break;
    default:
      send_to_char("Bug in command. Please report.\r\n", ch);
      return;
  }

  if (num_of_clans == 1) {
    send_to_char ("There is only one clan in existance.\r\n", ch);
    return;
  }

  send_to_char("Clan Relationships:\r\n"
	       "-------------------\r\n", ch);
  for (i = 0; i < num_of_clans; i++) {
    n = 0;
    if (i == c)
      continue;
    
    n = GET_CLAN_REL(c, i);
    sprintf(buf, "%-32s:  %5d  (", clan[i].name, n);
    if ((n >= CLAN_REL_MIN) && (n < CLAN_REL_BLOOD_WAR))
      strcat (buf, "blood feud");
    else if (n < CLAN_REL_WAR)
      strcat (buf, "war");
    else if (n < CLAN_REL_ANGER) 
      strcat (buf, "angered");
    else if (n < CLAN_REL_UPSET)
      strcat (buf, "upset");
    else if (n < CLAN_REL_NEUTRAL)
      strcat (buf, "neutral");
    else if (n < CLAN_REL_FRIENDLY)
      strcat (buf, "friendly");
    else if (n < CLAN_REL_TRADE)
      strcat (buf, "trade");
    else if (n < CLAN_REL_PEACEFUL)
      strcat (buf, "peaceful");
    else if (n < CLAN_REL_MAX)
      strcat (buf, "alliance");
    else /* Should never get here right... */
      strcat (buf, "VALUE OOB!");
    strcat (buf, ")\r\n");
    send_to_char(buf, ch);
  }
  return;
}

/* Clan Enable Format */
void send_clan_enable_f(struct char_data *ch)
{
  int c,r;
  c=find_clan_by_id(GET_CLAN(ch));
  r=GET_CLAN_RANK(ch);
  if (c < 0) 
  {
    if (LR_FAIL(ch, LVL_CLAN_GOD))
    {
      send_to_char("You don't seem to belong to a clan.\r\n", ch);
      return;
    }
    send_to_char("The following clan options can be enabled/disabled:-\r\n"
	         "hall    - Clan Hall\r\n"
	         "healer  - Clan Healer\r\n"
	         "board   - Clan Board\r\n"
	         "ctalk   - Clan && Clan Leader Channels.\r\n", ch);
    return;
  }
  if (r < clan[c].privilege[CP_ENABLE]) 
  {
    send_to_char("You are not privileged enough to use this command.\r\n",ch);
    return;
  }
  sprintf(buf, "The following clan options can be enabled:-\r\n");
  sprintf(buf, "%shall      - Clan Hall%s\r\n", buf, (CLAN_HASOPT(c, CO_HALL) ? " (enabled)" : ""));
  sprintf(buf, "%shealer    - Clan Healer%s\r\n", buf, (CLAN_HASOPT(c, CO_HEALER) ? " (enabled)" : ""));
  sprintf(buf, "%sboard     - Clan Board%s\r\n", buf, (CLAN_HASOPT(c, CO_BOARD) ? " (enabled)" : ""));
  sprintf(buf, "%sctalk     - Clan && Clan Leader Channels.%s\r\n", buf, (CLAN_HASOPT(c, CO_TALK) ? " (enabled)" : ""));
  send_to_char(buf, ch);
}

/* Clan Enable */
void do_clan_enable(struct char_data *ch, char *arg) 
{

  int c=0;
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

  if (!(*arg)) {
    send_clan_enable_f(ch);
    return;
  }

  switch (clan_check_priv(ch, CP_ENABLE)) {
    case CPC_NOPRIV:
    case CPC_NOCLAN:
      return;
    case CPC_IMM:
      half_chop(arg,arg1,arg2);
      strcpy(arg,arg2);
      if((c=find_clan_by_sid(arg1))<0) {
	send_to_char("Unknown clan specified.\r\n", ch);
	return;
      }
      break;
    case CPC_PRIV:
      if((c=find_clan_by_id(GET_CLAN(ch))) < 0) {
	send_to_char("Bug in command. Please report.\r\n", ch);
	return;
      }
      break;
    default:
      send_to_char("Bug in command. Please report.\r\n", ch);
      return;
  }

  if (is_abbrev(arg, "hall")) {
    if (CLAN_HASOPT(c, CO_HALL)) {
      send_to_char("Your clan already seems to have a hall.\r\n", ch);
      return;
    }
    if (do_clan_charge(ch, CLC_ENHALL) > 0) {
      sprintf(buf, "Done. (%d coins deducted).\r\n", CLC_ENHALL);
      send_to_char(buf, ch);
      SET_BIT(COF_FLAGS(c), (1 << CO_HALL));
      do_clan_infocom(clan[c].id, 0, "Your clan hall has been enabled.");
      save_clans();
      return;
    } 
    sprintf(buf, "Readying the clan hall requires %d coins.\r\n", CLC_ENHALL);
    send_to_char(buf, ch);
    return;
  }
  if (is_abbrev(arg,"ctalk")) {
    if (CLAN_HASOPT(c, CO_TALK)) {
      send_to_char("Your clan already has their chanel enabled.\r\n", ch);
      return;
    } 
    if (do_clan_charge(ch, CLC_ENTALK) > 0) {
      sprintf(buf, "Done. (%d coins deducted.)\r\n", CLC_ENTALK);
      send_to_char(buf, ch);
      SET_BIT(COF_FLAGS(c), (1 << CO_TALK));
      do_clan_infocom(clan[c].id, 0, "Clan Channel Now Enabled.");
      save_clans();
      return;
    }
    sprintf(buf, "You will need %d coins to activate the clantalk channel.\r\n", CLC_ENTALK);
    send_to_char(buf, ch);
    return;
  }
  if (is_abbrev(arg,"healer")) {
    if (CLAN_HASOPT(c, CO_HEALER)) {
      send_to_char("Your clan's healer has already been set up.\r\n", ch);
      return;
    }
    if (do_clan_charge(ch, CLC_ENHEAL) > 0) {
      sprintf(buf, "Done. (%d coins deducted).\r\n", CLC_ENHEAL);
      send_to_char(buf, ch);
      SET_BIT(COF_FLAGS(c), (1 << CO_HEALER));
      do_clan_infocom(clan[c].id, 0, "Clan Healer Now Enabled.");
      save_clans();
      return;
    }
    sprintf(buf, "You will need %d coins to activate the clan healer.\r\n", CLC_ENHEAL);
    send_to_char(buf, ch);
    return;
  }
  if (is_abbrev(arg,"board")) {
    if (CLAN_HASOPT(c, CO_BOARD)) {
      send_to_char("Your clan's board is already enabled.\r\n", ch);
      return;
    }
    if (do_clan_charge(ch, CLC_ENBOARD) > 0) {
      sprintf(buf, "Done. (%d coins deducted).\r\n", CLC_ENBOARD);
      send_to_char(buf, ch);
      SET_BIT(COF_FLAGS(c), (1 << CO_BOARD));
      do_clan_infocom(clan[c].id, 0, "Clan Board Now Enabled.");
      save_clans();
      return;
    }
    sprintf(buf, "You will need %d coins to activate the clan board.\r\n", CLC_ENBOARD);
    send_to_char(buf, ch);
    return;
  }
  send_clan_enable_f(ch);
  return;
}

/* Enhance Guards/Healers */
void do_clan_enhance(struct char_data *ch, char *arg)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  int clan_num=0, old_vnum=0, amtreq=0, i=0;
  struct char_data *mob;	       /* For Mob Copies..         */
  struct char_data *oldmob;       
  zone_rnum real_zone(zone_vnum vnum); /* For Saving To File       */
  room_rnum gpost;		       /* Remember where mob was.. */

  switch (clan_check_priv(ch, CP_ENHANCE)) {
    case CPC_NOPRIV:
    case CPC_NOCLAN:
      return;
    case CPC_IMM:
      send_to_char("Use OLC you slacker!\r\n", ch);
      break;
    case CPC_PRIV:
      clan_num=find_clan_by_id(GET_CLAN(ch));
      break;
    default:
      send_to_char("Bug in command. Please report.\r\n", ch);
      return;
  }
  
  clan_num = clan[clan_num].id - 1;
  half_chop(arg,arg1,arg2);
  if (is_abbrev(arg1, "guard")) {
    sprintf(arg1, "clanguard");
    if (!(oldmob=generic_find_char(ch, arg1, FIND_CHAR_ROOM)))
    {
      send_to_char("Your clan guard doesn't seem to be here.\r\n", ch);
      return;
    }
    if (GET_MOB_VNUM(oldmob) != CLAN_ZONE*100+clan_num)
    {
      send_to_char("Why would you want to enhance their guard?!\r\n", ch);
      return;
    }
    if (GET_LEVEL(oldmob) >= 100)
    {
      send_to_char("They don't come any tougher than that!\r\n", ch);
      return;
    }
    amtreq = CLC_EGUARD;
    for (i = 50; i <= 90; i += 10)
      if (GET_LEVEL(oldmob) > i)
	amtreq += CLC_EGUARD;
    if (do_clan_charge(ch, amtreq) < 1)
    {
      sprintf(buf, "Enhancing your guard will require %d coins.\r\n", amtreq);
      send_to_char(buf, ch);
      return;
    }
  } else if (is_abbrev(arg1, "healer")) {
    sprintf(arg1, "clanhealer");
    if (!(oldmob=generic_find_char(ch, arg1, FIND_CHAR_ROOM)))
    {
      send_to_char("Your clan healer doesn't seem to be here.\r\n", ch);
      return;
    }
    if (GET_MOB_VNUM(oldmob) != (CLAN_ZONE*100+clan_num+MAX_CLANS))
    {
      send_to_char("Why would you want to enhance their healer?!\r\n", ch);
      return;
    }
    if (GET_LEVEL(oldmob) >= 100)
    {
      send_to_char("They don't come any tougher than that!\r\n", ch);
      return;
    }

    amtreq = CLC_EHEAL;
    for (i = 50; i <= 90; i += 10)
      if (GET_LEVEL(oldmob) > i)
	amtreq += CLC_EHEAL;

    if (do_clan_charge(ch, amtreq) < 1)
    {
      sprintf(buf, "Enhancing your healer requires %d coins.\r\n", amtreq);
      send_to_char(buf, ch);
      return;
    }
  } else {
    send_to_char("Enhance what?!?\r\n", ch);
    return;
  }

  gpost = oldmob->in_room;

  /* Firstly, Lets work with the stuff from do_clan_reset .. */
  mob = &mob_proto[oldmob->nr];
  
  switch (GET_LEVEL(mob))
  {
    case 60:
      GET_LEVEL(mob) = 70;
      GET_NDD(mob) = GET_SDD(mob) = 25;
      GET_HITROLL(mob) = 75;
      GET_DAMROLL(mob) = 75;
      GET_HIT(mob) = GET_MANA(mob) = 1;
      GET_MOVE(mob) = 10000;
      GET_AC(mob) = -125;
      break;
    case 70:
      GET_LEVEL(mob) = 80;
      GET_NDD(mob) = GET_SDD(mob) = 25;
      GET_HITROLL(mob) = 90;
      GET_DAMROLL(mob) = 90;
      GET_HIT(mob) = GET_MANA(mob) = 1;
      GET_MOVE(mob) = 15000;
      GET_AC(mob) = -140;
      break;
    case 80:
      GET_LEVEL(mob) = 90;
      GET_NDD(mob) = GET_SDD(mob) = 30;
      GET_HITROLL(mob) = GET_DAMROLL(mob) = 115;
      GET_HIT(mob) = GET_MANA(mob) = 1;
      GET_MOVE(mob) = 20000;
      GET_AC(mob) = -200;
      break;
    case 90:
      GET_LEVEL(mob) = 100;
      GET_NDD(mob) = GET_SDD(mob) = 50;
      GET_HITROLL(mob) = GET_DAMROLL(mob) = 127;
      GET_HIT(mob) = GET_MANA(mob) = 1;
      GET_MOVE(mob) = 30000;
      GET_AC(mob) = -250;
      break;
    default:
      GET_LEVEL(mob) = 60;
      GET_NDD(mob) = GET_SDD(mob) = 25;
      GET_HITROLL(mob) = 65;
      GET_DAMROLL(mob) = 65;
      GET_HIT(mob) = GET_MANA(mob) = 1;
      GET_MOVE(mob) = 8000;
      GET_AC(mob) = -110;
      break;
  }

  for (oldmob = character_list; oldmob; oldmob = oldmob->next)
    if (oldmob->nr == mob->nr) 
      extract_char(oldmob);

  old_vnum = save_mobiles(real_zone(CLAN_ZONE));

  reset_zone(real_zone(CLAN_ZONE));

  sprintf(buf, "Training it to level %d cost %d coins.\r\n", GET_LEVEL(mob),
      amtreq);

  send_to_char(buf, ch);
  return;

}

/* Clan Set */
void do_clan_set(struct char_data *ch, char *arg)
{
  char arg1[MAX_INPUT_LENGTH] ,arg2[MAX_INPUT_LENGTH];
  int c=0,r=0;

  half_chop(arg,arg1,arg2);

  if (is_abbrev(arg1, "about"    )) { do_clan_set_desc(ch,arg2);        return ; }
  if (is_abbrev(arg1, "ranks"    )) { do_clan_set_ranks(ch,arg2);       return ; }
  if (is_abbrev(arg1, "title"    )) { do_clan_titles(ch,arg2);          return ; }
  if (is_abbrev(arg1, "privilege")) { do_clan_set_priv(ch,arg2);        return ; }
  if (is_abbrev(arg1, "tax"      )) { do_clan_changefees(ch,arg2,CM_DUES);   return ; }
  if (is_abbrev(arg1, "appfee"   )) { do_clan_changefees(ch,arg2,CM_APPFEE); return ; }
  if (is_abbrev(arg1, "applev"   )) { do_clan_application(ch,arg2);     return ; }

  if (!LR_FAIL(ch, LVL_CLAN_GOD))
  {
    send_to_char("The following set commands are available to you:\r\n\r\n"
		 "   clan set about     <clan #>\r\n"
		 "   clan set appfee    <clan #>    <amount>\r\n"
                 "   clan set applev    <clan #>    <level>\r\n"
                 "   clan set privilege <privilege> <clan #>   <rank>\r\n"
                 "   clan set ranks     <clan #>    <number>\r\n"
                 "   clan set tax       <clan #>    <2-50>\r\n"
                 "   clan set title     <clan #>    <rank #>   <title>\r\n",ch);
    return;
  }

  if ((c=find_clan_by_id(GET_CLAN(ch))) < 0) 
  {
    send_to_char("But you do not belong to a clan!\r\n", ch);
    return;
  }
  
  r=GET_CLAN_RANK(ch);

  if ((r < clan[c].privilege[CP_SET_DESC]) &&
      (r < clan[c].privilege[CP_SET_FEES]) &&
      (r < clan[c].privilege[CP_SET_APPLEV])) {
    send_to_char("You are not privileged enough to use this command.\r\n", ch);
    return;
  }

  send_to_char("You have access to the following set commands:\r\n\r\n", ch);
	  
  if(r>=clan[c].privilege[CP_SET_DESC])
    send_to_char("   clan set about\r\n", ch);
  if(r>=clan[c].privilege[CP_SET_FEES])
    send_to_char("   clan set appfee    <amount>\r\n",ch);
  if(r>=clan[c].privilege[CP_SET_APPLEV])
    send_to_char("   clan set applev    <level>\r\n",ch);
  if(r==clan[c].ranks)
    send_to_char("   clan set privilege <privilege> <rank>\r\n"
                 "   clan set rank      <num ranks>\r\n",ch);
  if(r>=clan[c].privilege[CP_SET_FEES])
    send_to_char("   clan set tax       <2-50>\r\n",ch);
  if(r==clan[c].ranks)
    send_to_char("   clan set title     <rank #> <title>\r\n",ch);
  return;

}

/* Used To Check Validity of Room Build/Demolish Arguments. */
int clan_room_dirs (char *arg) {
  if (is_abbrev(arg, "north"))
    return(NORTH);
  if (is_abbrev(arg, "south"))
    return(SOUTH);
  if (is_abbrev(arg, "east"))
    return(EAST);
  if (is_abbrev(arg, "west"))
    return(WEST);
  if (is_abbrev(arg, "up"))
    return(UP);
  if (is_abbrev(arg, "down")) 
    return(DOWN);
  else 
    return (-1);
}

/* Determine what to do */
ACMD(do_clan)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

  half_chop(argument, arg1, arg2);

  if (is_abbrev(arg1, "create"  )) { do_clan_create(ch,arg2);   return ;}
  if (is_abbrev(arg1, "destroy" )) { do_clan_destroy(ch,arg2);  return ;}
  if (is_abbrev(arg1, "recruit" )) { do_clan_recruit(ch,arg2);  return ;}
  if (is_abbrev(arg1, "banish"  )) { do_clan_banish(ch,arg2);   return ;}
  if (is_abbrev(arg1, "who"     )) { do_clan_who(ch,arg2);      return ;}
  if (!LR_FAIL(ch, LVL_CLAN_GOD))
    if (is_abbrev(arg1, "stat"  )) { do_clan_stat(ch,arg2);     return ;}
  if (is_abbrev(arg1, "status"  )) { do_clan_status(ch);        return ;}
  if (is_abbrev(arg1, "info"    )) { do_clan_info(ch,arg2);     return ;}
  if (is_abbrev(arg1, "list"    )) { do_clan_info(ch,arg2);     return ;}
  if (is_abbrev(arg1, "apply"   )) { do_clan_apply(ch,arg2);    return ;}
  if (is_abbrev(arg1, "demote"  )) { do_clan_demote(ch,arg2);   return ;}
  if (is_abbrev(arg1, "promote" )) { do_clan_promote(ch,arg2);  return ;}
  if (is_abbrev(arg1, "set"     )) { do_clan_set(ch,arg2);      return ;}
  if (is_abbrev(arg1, "about"   )) { do_clan_about(ch, arg2);   return ;}
  if (is_abbrev(arg1, "enhance" )) { do_clan_enhance(ch,arg2);  return ;}
  if (is_abbrev(arg1, "name"    )) { do_clan_name_mob(ch,arg2);     return ;}
  if (is_abbrev(arg1, "describe")) { do_clan_describe_mob(ch,arg2); return ;}
  if (is_abbrev(arg1, "room"    )) { do_clan_room(ch,arg2);     return ;}
  if (is_abbrev(arg1, "withdraw")) { do_clan_bank(ch,arg2,CB_WITHDRAW); return ;}
  if (is_abbrev(arg1, "deposit" )) { do_clan_bank(ch,arg2,CB_DEPOSIT);  return ;}
  if (is_abbrev(arg1, "balance" )) { do_clan_bank(ch,arg2,CB_BALANCE);  return ;}
  if (is_abbrev(arg1, "relations")){ do_clan_showrel(ch,arg2);  return ;} 
  if (is_abbrev(arg1, "score"   )) { do_clan_score(ch);         return ;}
  if (is_abbrev(arg1, "enable"  )) { do_clan_enable(ch,arg2);   return ;}
  if (is_abbrev(arg1, "reset"   )) { do_clan_reset(ch,arg2);    return ;}
  send_clan_format(ch);
}

/* Enable player killing. -- Irreversable except by joining a clan. */
ACMD(do_pkill)
{
  if (IS_NPC(ch))
  {
    send_to_char("NPCs cannot be pkill.\r\n", ch);
    return;
  }
  if (GET_LEVEL(ch) >= LVL_CHAMP + MIN(5, GET_UNHOLINESS(ch)))
  {
    send_to_char("Thou shall not kill mortals.\r\n", ch);
    return;
  }
  if ((EXT_FLAGGED(ch, EXT_PKILL)) || 
      ((GET_CLAN(ch) > 0) && (find_clan_by_id(GET_CLAN(ch)) >= 0)))
  {
    send_to_char("You are already pkill material.\r\n", ch);
    return;
  }
  skip_spaces(&argument);
  if ((!(*argument)) || (strcasecmp("enable", argument)))
  {
    send_to_char("Becoming pkill is irreversable, until you join a clan.\r\n"
		 "To become pkill, enter 'pkill enable'.\r\n", ch);
    return;
  }
  send_to_char("You enter the violent world of player killing.\r\n", ch);
  SET_BIT(EXT_FLAGS(ch), EXT_PKILL);
}
  
/* Used by healer specproc.. */
int do_clan_heal(struct char_data *ch, struct char_data *vict)
{
  int clan_num, add_h = 0, add_m = 0, add_v = 0;

  clan_num = (1 + GET_MOB_VNUM(ch) - (CLAN_ZONE * 100) - MAX_CLANS);
  if ((clan_num < 1) || (clan_num > MAX_CLANS))
  {
    sprintf(buf, "SYSERR: %s (#%d) calling do_clan_heal()", GET_NAME(ch),
	    GET_MOB_VNUM(ch));
    mudlog(buf, NRM, LVL_GOD, TRUE);
    return FALSE;
  }

  if (GET_CLAN(vict) != clan_num)
    return FALSE;

  if ((GET_HIT(vict) >= GET_MAX_HIT(vict)) && 
      (GET_MOVE(vict) >= GET_MAX_MOVE(vict)) && 
      (GET_MANA(vict) >= GET_MAX_MANA(vict)))
    return FALSE;

  switch GET_LEVEL(ch)
  {
    case 50: /* Level 50, Heal */
      add_h = 100 + number(0, 50);
      break;
    case 60: /* Level 60, Adv Heal */
      add_h = 300 + number(0, 50);
      break;
    case 70: /* Level 70, Adv Heal / Refresh */
      add_h = 300 + number(0, 50);
      add_v = 75 + number(0, 25);
      break;
    case 80: /* Level 80, Adv Heal / Refresh / Mana */
      add_h = 300 + number(0, 50);
      add_v = 75 + number(0, 25);
      add_m = 100 + number(0, 25);
      break;
    case 90: /* Level 90, Div Heal / Refresh / Adv Mana */
      add_h = 400 + number(0, 75);
      add_v = 75 + number(0, 25);
      add_m = 300 + number(0, 50);
      break;
    case 100: /* Level 100, (Restore/2), Div Heal, Refresh, Adv Mana */
      if ((GET_HIT(vict) < (GET_MAX_HIT(vict) >> 1)) || 
	  (GET_MOVE(vict) < (GET_MAX_MOVE(vict) >> 1)) || 
	  (GET_MANA(vict) < (GET_MAX_MANA(vict) >> 1)))
      {
        GET_MOVE(vict) = MAX((GET_MAX_MOVE(vict) >> 1) + 1, GET_MOVE(vict));
        GET_MANA(vict) = MAX((GET_MAX_MANA(vict) >> 1) + 1, GET_MANA(vict));
        GET_HIT(vict) = MAX((GET_MAX_HIT(vict) >> 1)+ 1, GET_HIT(vict));
	return TRUE;
      }
      add_h = 400 + number(0, 75);
      add_v = 75 + number(0, 25);
      add_m = 300 + number(0, 50);
      break;
    case 110: /* Level 110 (Imm Set Only), Restore - Should make em Jizzm */
      GET_HIT(vict) = GET_MAX_HIT(vict);
      GET_MANA(vict) = GET_MAX_MANA(vict);
      GET_MOVE(vict) = GET_MAX_MOVE(vict);
      return TRUE;
    default:
      send_to_char("The clan healer is too busy contemplating the meaning of life to heal you.\r\n", vict);
      sprintf(buf, "Default case in do_clan_heal. (Mob Vnum: %d)\r\n", 
	      GET_MOB_VNUM(ch));
      mudlog(buf, NRM, LVL_GRGOD, TRUE);
      return FALSE;
  }
  if (GET_HIT(vict) < GET_MAX_HIT(vict))
  {
    GET_HIT(vict) += add_h;
    if (GET_HIT(vict) > GET_MAX_HIT(vict))
      GET_HIT(vict) = GET_MAX_HIT(vict);
    return TRUE;
  }
  if ((GET_MANA(vict) < GET_MAX_MANA(vict)) && (add_m > 0))
  {
    GET_MANA(vict) += add_m;
    if (GET_MANA(vict) > GET_MAX_MANA(vict))
      GET_MANA(vict) = GET_MAX_MANA(vict);
    return TRUE;
  }
  if ((GET_MOVE(vict) < GET_MAX_MOVE(vict)) && (add_v > 0))
  {
    GET_MOVE(vict) += add_v;
    if (GET_MOVE(vict) > GET_MAX_MOVE(vict))
      GET_MOVE(vict) = GET_MAX_MOVE(vict);
    return TRUE;
  }
  return FALSE;
}


/* Function for collecting taxes.. */
void clan_tax_update (struct char_data *ch, struct char_data *vict)
{
  int clan_num, tax_taken;

  if (IS_NPC(ch)) 
    return;
  if ((GET_CLAN(ch) < 1) || (GET_CLAN_RANK(ch) < 1))
    return;

  clan_num = find_clan_by_id(GET_CLAN(ch));
  if (clan_num < 0) 
    return;

  tax_taken = (GET_GOLD(vict) * clan[clan_num].taxrate) / 100;
  tax_taken /= 100;
  tax_taken *= 100;

  if (tax_taken < 100)
    return;

  sprintf(buf, "Your clan takes %d coins in taxes.\r\n", tax_taken);
  send_to_char(buf, ch);
  clan_coinage(clan_num, tax_taken);
  GET_GOLD(vict) -= tax_taken;
}

/* Whether or not clan members can hear whats going on.. */
int clan_can_hear(struct descriptor_data *d, int c) {
  if (STATE(d) != CON_PLAYING) 
    return FALSE;
  if (EXT_FLAGGED(d->character, EXT_NOCT))
    return FALSE;
  if (PLR_FLAGGED(d->character, PLR_WRITING))
    return FALSE;
  if (ROOM_FLAGGED(d->character->in_room, ROOM_SOUNDPROOF))
    return FALSE;
  if (!LR_FAIL(d->character, LVL_CLAN_GOD))
    return TRUE;
  if (GET_CLAN(d->character) < 1)
    return FALSE;

  if (c < 0) {
    if (GET_CLAN_RANK(d->character) != clan[find_clan_by_id(GET_CLAN(d->character))].ranks)
      return FALSE;
  } else if (GET_CLAN(d->character) != c) {
      return FALSE;
  }
  if (!CLAN_HASOPT(find_clan_by_id(GET_CLAN(d->character)), CO_TALK))
    return FALSE;

  return TRUE;
}

#if 0 // Artus> Now Unused.
/* Make mobs fight players that are AGGRAVATE punished. */
int pun_aggro_check (struct char_data *ch)
{
  struct char_data *i;
  int found = 0;

  for (i = world[ch->in_room].people; i; i = i->next_in_room) {
    if (!IS_NPC(i))
      continue;
    if ((STATE(ch->desc) == CON_PLAYING) && (i->in_room == ch->in_room) && (FIGHTING(i) == NULL) && (CAN_SEE(i, ch)) && (AWAKE(i)) && (mob_index[GET_MOB_RNUM(i)].func != shop_keeper) && !MOB_FLAGGED(i, MOB_NOKILL)) {
      act("$n senses dishonour in you, and attacks hastily.", FALSE, i, 0, ch, TO_VICT );
      hit(i, ch, -1); // -1 - TYPE_UNDEFINED
      found = 1;
    }
  }
  return found;
}
#endif

/* Function for updating punishment on tick.. */
void punish_update (struct char_data *ch) 
{
  int i;
  char *unpunish_messages[] = {
    "The ice around you suddenly melts away to nothing.\r\n", /* Freeze */
    "You feel your freedom to speak return.\r\n", /* Mute */
    "Your ability to change your title returns.\r\n", /* Notitle */
    "A lag monster sneaks out from your backpack and disappears.\r\n", /* Lag */
    "You feel more eager to learn.\r\n", /* Low_Exp */
    "Your blood starts to course normally once more.\r\n", /* Low_Regen */
    "You feel the anger towards you lessen.\r\n" /* Aggravate */
  };

  if (PUN_FLAGS(ch) == 0)
    return;

  for (i = 0; i < 31; i++) 
    if (ch->player_specials->saved.phours[i] > 0) 
    {
      ch->player_specials->saved.phours[i]--;
      if (ch->player_specials->saved.phours[i] == 0) 
      {
	REMOVE_BIT(PUN_FLAGS(ch), (1 << i));
        send_to_char(unpunish_messages[i], ch);
      }
    }
}

/* Determine the punishment number by name.. */
int parse_punish(char *arg)
{
  int i;

  for (i = 0; i < NUM_PUNISHES; i++)
    if (is_abbrev(arg, punish_types[i]))
      return i;

  return -1;
}

/* Determine the offence number by name.. */
int parse_offence(char *arg)
{
  int i;

  if (!strcmp("0", arg))
    return -1;

  for (i = 0; i < NUM_OFFENCES; i++)
    if (is_abbrev(arg, offence_types[i]))
      return i;

  return -2;
}

/* Function For Setting Punishments - Victim, PUN_xxx, Num_Hours, OFF_xxx */
void perform_punish (struct char_data * ch, int ptype, int hours, int offence)
{
  if (IS_NPC(ch)) /* Mobs can fuck themselves :o) */
    return;

  if (hours == 0) { /* Remove Punishment on 0 hours */
    REMOVE_BIT(PUN_FLAGS(ch), (1 << ptype));
    PUN_HOURS(ch, ptype) = 0;
    return;
  }

  if ((offence >= 0) && (hours != 0))
  {
    HAS_OFFENDED(ch, offence)++;
    if (HAS_OFFENDED(ch, offence) < 1) HAS_OFFENDED(ch, offence) = 1;
  }

  if (hours < 0) { /* Unlimited on <0 hours */
    SET_BIT(PUN_FLAGS(ch), (1 << ptype));
    PUN_HOURS(ch, ptype) = -1;
    return;
  }

  if (PUN_HOURS(ch, ptype) < 0)
    return;

  /* Set it already :o) */
  SET_BIT(PUN_FLAGS(ch), (1 << ptype));
  PUN_HOURS(ch, ptype) = hours;
  return;
}

/* Function for updating frag counts && relations on pk. */
/* BUG: From time to time, it seems this function gets called twice,
 * probably have to look at somewhere else to call it from.. */
void clan_pk_update (struct char_data *winner, struct char_data *loser)
{
  int win_clan, lose_clan, relmod, level_diff, severity;
  char cin[80];
  int level_exp(struct char_data *ch, int level);

  /* No Mobs */
  if (IS_NPC(winner) || IS_NPC(loser))
    return;

  /* Credit players for kills/deaths... */
  if (GET_LEVEL(loser) >= LVL_CHAMP)
    GET_IMMKILLS(winner)++;
  else
    GET_PCKILLS(winner)++;
  if (GET_LEVEL(winner) >= LVL_CHAMP)
    GET_KILLSBYIMM(loser)++;
  else
    GET_KILLSBYPC(loser)++;
  

  REMOVE_BIT(EXT_FLAGS(loser), EXT_PKILL);

  /* TODO - Work out some funky algorithms && punishments for pking little
   * guys as big guys and shit.. */

  if ((INSTIGATOR(winner) == TRUE) && (GET_LEVEL(winner) < LVL_ANGEL))
  {
    level_diff = GET_LEVEL(winner) - GET_LEVEL(loser);
    level_diff -= 10;
    if (GET_LEVEL(winner) >= LVL_CHAMP)
      severity = level_diff * 3;
    else if (GET_LEVEL(winner) >= LVL_ETRNL1)
      severity = level_diff * 2;
    else
      severity = level_diff;
    if (severity > 1) {
      level_diff = number(0, (NUM_PUNISHES-1));
      severity += HAS_OFFENDED(winner, OFF_PKILL);
      sprintf (buf, "Killing someone that small is weak. You are punished for the next %d hours.\r\n", severity);
      send_to_char(buf, winner);
      perform_punish(winner, level_diff, (PUN_HOURS(winner, level_diff) + severity), OFF_PKILL);
    }
  }

  if (GET_LEVEL(loser) >= LVL_CHAMP)
  {
    if ((GET_LEVEL(winner) < GET_LEVEL(loser)) &&
	(GET_LEVEL(loser) == LVL_CHAMP + GET_UNHOLINESS(loser)))
    {
      demote_level(loser, GET_LEVEL(loser)-1, "Lost PK vs Lesser.");
      GET_EXP(loser) = level_exp(loser, GET_LEVEL(loser)) / 2;
    }
  }

  /* Remove Instigator Bits */
  INSTIGATOR(winner) = FALSE;
  INSTIGATOR(loser)  = FALSE;

  win_clan = find_clan_by_id(GET_CLAN(winner));
  lose_clan= find_clan_by_id(GET_CLAN(loser));
  
  if (lose_clan < 0) /* Loser didn't belong to a clan. Who cares? */
    return;

  if (win_clan < 0) 
  {
    sprintf(cin, "%s pkilled by %s.", GET_NAME(loser), GET_NAME(winner));
    do_clan_infocom(GET_CLAN(loser), 0, cin);
    return;
  }

  if (win_clan == lose_clan)
  {
    sprintf(cin, "%s pkilled by %s.", GET_NAME(loser), GET_NAME(winner));
    do_clan_infocom(GET_CLAN(loser), 0, cin);
    return;
  }

  sprintf(cin, "%s pkilled by %s.", GET_NAME(loser), GET_NAME(winner));
  do_clan_infocom(GET_CLAN(loser), GET_CLAN(winner), cin);

  relmod = 0;
  if (GET_CLAN_RANK(loser) == clan[lose_clan].ranks)
    relmod -= 50;
  if (GET_CLAN_RANK(winner) == clan[win_clan].ranks)
    relmod -= 50;

  if (GET_CLAN_RANK(loser) == clan[lose_clan].ranks-1)
    relmod -= 25;
  if (GET_CLAN_RANK(winner) == clan[win_clan].ranks-1)
    relmod -= 25;

  if (GET_CLAN_RANK(winner) < clan[win_clan].ranks-1)
    relmod -= 10;
  if (GET_CLAN_RANK(loser) < clan[lose_clan].ranks-1)
    relmod -= 10;

  GET_CLAN_FRAGS(win_clan, lose_clan)++;
  GET_CLAN_DEATHS(lose_clan, win_clan)++;

  clan_rel_change(win_clan, lose_clan, relmod);
  save_clans();
}

/* Specprocs */
SPECIAL(clan_healer)
{
  struct char_data *to = NULL;
  struct char_data *self = (struct char_data *) me;
  int clan_id = ((GET_MOB_VNUM(self) - (CLAN_ZONE * 100) - MAX_CLANS)+1);

  if (cmd) 
    return FALSE;

  if (GET_MOB_VZNUM(self) != CLAN_ZONE)
  {
    sprintf(buf, "SYSERR: %s (#%d) calling clan_healer specproc.", 
	    GET_NAME(self), GET_MOB_VNUM(self));
    mudlog(buf, NRM, LVL_ANGEL, TRUE);
    return FALSE;
  }
  
  if (!CLAN_HASOPT(find_clan_by_id(clan_id), CO_HEALER))
    return (TRUE);

  for (to = world[self->in_room].people; to; to = to->next_in_room)
    if (!IS_NPC(to))
      if (do_clan_heal(self, to))
	send_to_char ("The clan healer touches you. You feel mildly healthier.\r\n", to);
      
  return (TRUE);
}

/* Clan Guard Specproc */
SPECIAL(clan_guard)
{
  struct char_data *self = (struct char_data *) me;
  int amount, clan_id, amt_req = 0, us, them;

  clan_id = ((GET_MOB_VNUM(self) - (CLAN_ZONE * 100))+1);

  if (!ch->desc || IS_NPC(ch))
    return (FALSE); /* Mobs can stay outside. */

  if (!CMD_IS("enter") && !(CMD_IS("bribe")))
    return (FALSE); /* Common practice, really. */

  us = find_clan_by_id(clan_id);
  them = find_clan_by_id(GET_CLAN(ch));

  if (LR_FAIL(ch, LVL_CLAN_GOD))
  {
    if ((them < 0)) // Char is not in clan.
    {
      act("$n slaps you, 'Thou art not a part of this clan. Begone!'", FALSE, self, 0, ch, TO_VICT);
      act("$N slaps $n.", FALSE, ch, 0, self, TO_ROOM);
      return(TRUE);
    } 

    if (!CLAN_HASOPT(find_clan_by_id(clan_id), CO_HALL)) 
    {
      act("$n &rtells you, 'This clan's hall has not been built yet.'&n", FALSE, self, 0, ch, TO_VICT);
      return (TRUE);
    }

    if (CMD_IS("enter")) 
    { /* Only Allow Clan members... */
      if ((us != them) && !CLAN_AT_PEACE(us, them))
      {
	act("$n slaps you, 'Thou art not a part of this clan. Begone!'", FALSE, self, 0, ch, TO_VICT);
	act("$N slaps $n.", FALSE, ch, 0, self, TO_ROOM);
	return(TRUE);
      } else if (GET_CLAN_RANK(ch)==0) {
	act("$n &rtells you, 'Thy application must be approved before entering.'&n", FALSE, self, 0, ch, TO_VICT);
	return(TRUE);
      }
      act ("$n waves a hand over you, and you find yourself in the clan room.", FALSE, self, 0, ch, TO_VICT);
      act ("$n has been transferred away to $s calling.", FALSE, ch, 0, 0, TO_ROOM);
    } else if (CMD_IS("bribe")) { /* There is nothing money cannot buy. */
      if (CLAN_BRIBING == 0) /* Bribing has been turned off. */
	return(FALSE);
      if ((us != them) && !CLAN_AT_PEACE(us, them)) 
      {
	amount = atoi(argument);
	if (amount < 1) 
	{
	  send_to_char("How much did you want to bribe the guard??\r\n", ch);
	  return(TRUE);
	}
	if (amount > GET_GOLD(ch)) 
	{
	  send_to_char("You don't have that much gold!\r\n", ch);
	  return(TRUE);
	}
	GET_GOLD(ch) -= amount;
	clan_coinage(us, amount);
	/* Modify Relationships.. */
	if (GET_CLAN(ch)) 
	{
	  if (GET_CLAN_RANK(ch) == clan[them].ranks)
	    clan_rel_change(us, them, -25);
	  else
	    clan_rel_change(us, them, -10);
	}
	if (CLAN_BRIBING == 2) 
	{  /* Clan Bribing is in "Bastard" Mode :o)      */
	  act("$n takes the gold and laughs in your face.", FALSE, self, 0, ch, TO_VICT);
	  act("$N laughs hard at $n", FALSE, ch, 0, self, TO_ROOM);
	  return (FALSE);
	}
	switch(GET_LEVEL(self)) 
	{ /* Possible theory on guard strengtehning at the clans cost..
	   * I'm sure we can work something better out later if it's not
	   * good enough as is.. */
	   case 110: amt_req = 2000000000; break;
	   case 100: amt_req = 10000 * GET_LEVEL(ch); break;
	   case 90: amt_req = 5000 * GET_LEVEL(ch); break;
	   case 80: amt_req = 2500 * GET_LEVEL(ch); break;
	   case 70: amt_req = 1000 * GET_LEVEL(ch); break;
	   case 60: amt_req = 100 * GET_LEVEL(ch); break;
	   case 50: amt_req = 0; break;
	   default: amt_req = 0;
	}
	if (amt_req < CLAN_MIN_BRIB) /* Basic attempt at stopping level 10  */
	  amt_req = CLAN_MIN_BRIB;   /* getting in too cheaply              */
	if (CLAN_AT_WAR(us, them))
	  amt_req += (int)(amt_req / 2);
	else if (GET_CLAN_REL(us, them) < CLAN_REL_ANGER)
	  amt_req += (int)(amt_req / 3);
	else if (GET_CLAN_REL(us, them) > CLAN_REL_TRADE)
	  amt_req -= (int)(amt_req / 3);
	if ((amount < amt_req) || (GET_CLAN_REL(us, them) < CLAN_REL_BLOOD_WAR))
	{
	  act("$n takes the gold and laughs in your face.", FALSE, self, 0, ch, TO_VICT);
	  act("$N laughs hard at $n.", FALSE, ch, 0, self, TO_ROOM);
	  return(TRUE);
	}
	if (amount < (amt_req + (amt_req / 4))) /* The in-between range...   */
	  if (number(0, 5) > 0)
	  {    /* Anything higher and the guard will cum */
	    act("$n takes the gold and laughs in your face.", FALSE, 
		self, 0, ch, TO_VICT);
	    act("$N laughs hard at $n.", FALSE, ch, 0, self, TO_ROOM);
	    return(TRUE);
	  }
	act("$n quickly pockets the coin and sneaks you inside.", FALSE, 
	    self, 0, ch, TO_VICT);
	act("$N whistles dixie as $n disappears.", FALSE, ch, 0, self, TO_ROOM);
      } else {
	act("$n looks at the gold, 'Don't worry about it, this one's on me!'", 
	    FALSE, self, 0, ch, TO_VICT);
      } // Same Clan/Relation Check.
    } // Bribe command.
  } // Clan God Test
  char_from_room(ch);
  char_to_room(ch, real_room(GET_MOB_VNUM(self) + MAX_CLANS));
  look_at_room(ch, 0);
  if (amt_req < 1)
    act("$n has arrived in the clan hall.", FALSE, ch, 0, 0, TO_ROOM);
  return(TRUE);
}

/* Sentence - Display current punishments.. */
ACMD (do_sentence)
{
  int i, found=0;

  sprintf(buf, "You are waiting out the following sentences:-\r\n");
  for (i = 0; i < NUM_PUNISHES; i++) {
    if (ch->player_specials->saved.phours[i] == 0)
      continue;
    if (ch->player_specials->saved.phours[i] > 0)
      sprintf(buf, "%s  (%3dhr): %s\r\n", buf, ch->player_specials->saved.phours[i], punish_types[i]);
    else
      sprintf(buf, "%s  (unlim): %s\r\n", buf, punish_types[i]);
    found = 1;
  }
  if (found == 0) {
    send_to_char("You have not been sentenced, you must have been well-behaved.\r\n", ch);
    return;
  }
  send_to_char(buf, ch);
}

/* Punish - Replaces Mute, Freeze and a shitload of others. */
ACMD (do_punish)
{
  char victim[MAX_INPUT_LENGTH];
  char punishment[MAX_INPUT_LENGTH];
  char offence[MAX_INPUT_LENGTH];
  char hours[MAX_INPUT_LENGTH];
  char reason[MAX_INPUT_LENGTH];
  int subc=0,onum=0;
  struct char_data *vict;
  int min_levels[] = {
	  LVL_GRGOD, /* Freeze     */
	  LVL_ANGEL, /* Mute       */
	  LVL_GRGOD, /* Notitle    */
	  LVL_GRGOD, /* Laggy      */
	  LVL_GRGOD, /* Low_Exp    */
	  LVL_GRGOD, /* Low_Regen  */
	  LVL_GRGOD, /* Aggro      */
  };
  char syntax[] = "Syntax: punish <victim> <punishment> <hours> <offence> <reason>\r\n";

  /* Args: <victim> <punishment> <hours> <offence> <reason> */

  if (!*argument) {
    send_to_char(syntax, ch);
    return;
  }
  half_chop(argument, victim, argument);
  if (!*argument) { // list_punishments();
    int i;
    sprintf(buf, "Punishments Available To You: \r\n  ");
    if (LR_FAIL(ch, LVL_ANGEL))
    {
      strcat(buf, "None.\r\n");
      send_to_char(buf, ch);
      return;
    }
    if (GET_LEVEL(ch) == LVL_ANGEL)
    {
      strcat(buf, "Mute.\r\n");
      send_to_char(buf, ch);
      return;
    }
    for (i = 0; i < NUM_PUNISHES; i++)
      sprintf(buf, "%s %s", buf, punish_types[i]);
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
    return;
  }
  half_chop(argument, punishment, argument);
  if (!*argument)
  {
    send_to_char("Number of hours not specified. (0 = off, -1 = Permanent).\r\n", ch);
    return;
  }
  half_chop(argument, hours, argument);
  if ((!*argument) && (strcmp(hours, "0")))
  { // list_offences();
    int i;
    sprintf(buf, "Available Offences:  0,");
    for (i = 0; i < NUM_OFFENCES; i++)
      sprintf(buf, "%s %s", buf, offence_types[i]);
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
    return;
  }
  half_chop(argument, offence, reason);
  if ((!*reason) && (strcmp(hours, "0")))
  {
    send_to_char(syntax, ch);
    return;
  }

  if (!(vict=generic_find_char(ch, victim, FIND_CHAR_WORLD)))
  {
    send_to_char("Doesn't seem to be anyone by that name around.\r\n", ch);
    return;
  }
  // DM - added level check
  if (GET_LEVEL(ch) <= GET_LEVEL(vict))
  {
    send_to_char("I think not!\r\n", ch);
    return;
  }
  if ((subc=parse_punish(punishment)) < 0)
  {
    send_to_char("There is no such punishment.\r\n", ch);
    return;
  }
  if ((onum=parse_offence(offence)) < -1)
  {
    send_to_char("There is no such offence.\r\n", ch);
    return;
  }
  if ((!is_number(hours)) && (strcmp(hours, "-1")))
  {
    send_to_char("Value of hours must be numeric.\r\n", ch);
    return;
  }
  if ((strlen(reason) < 10) && (strcmp(hours, "0")))
  {
    send_to_char("Reason must be at least 10 characters.\r\n", ch);
    return;
  }

  /* OK, The input looks good.. Lets be bastards. */

  if (LR_FAIL(ch, min_levels[subc]))
  {
    send_to_char("Punishment unavailable.\r\n", ch);
    return;
  }
  if ((min_levels[subc] < 1) && LR_FAIL(ch, LVL_GRGOD))
  {
    send_to_char("Punishment unavailable (Missing min_level).\r\n", ch);
    return;
  }
  if (atoi(hours) > 0)
    sprintf(buf, "(GC) &7%s&n has punished &7%s&n for &1%s&n. (&1%d&nhrs of &1%s&n).",      GET_NAME(ch), GET_NAME(vict),
            (onum >= 0) ? offence_types[onum] : "N/A", atoi(hours),
	    punish_types[subc]);
  else if (atoi(hours) == 0)
    sprintf(buf, "(GC) &7%s&n has removed the &1%s&n punishment on &7%s&n.",
	    GET_NAME(ch), punish_types[subc], GET_NAME(vict));
  else // (atoi(hours) < 0)
    sprintf(buf, "(GC) &7%s&n has punished &7%s&n for &1%s&n. (Indefinite &1%s&n).",        GET_NAME(ch), GET_NAME(vict), 
	    (onum >= 0) ? offence_types[onum] : "N/A", punish_types[subc]);
  mudlog(buf, NRM, MAX(LVL_ANGEL, GET_INVIS_LEV(ch)), TRUE);
  send_to_char("Done.\r\n", ch);
  if (atoi(hours) != 0)
    sprintf(buf, "&RYou have been punished for &1%s&r. Type \"&gsentence&R\" for details.\r\n", (onum >= 0) ? offence_types[onum] : "something");
  else
    sprintf(buf, "&RYou are no longer punished for &1%s&R.\r\n",
	    (onum >= 0) ? offence_types[onum] : "something");
  send_to_char(buf, vict);
  perform_punish(vict, subc, atoi(hours), onum);
}

/* Clan Talk / Leader channels. */
ACMD (do_ctalk)
{
  struct descriptor_data *i;
  int c=0, minlev=1; 
  char level_string[5]="\0\0\0\0";

  skip_spaces (&argument);
  
  if (!LR_FAIL(ch, LVL_CLAN_GOD))
  {
    c = atoi(argument);
    if (find_clan_by_id(c) < 0)
    {
      send_to_char ("That clan doesn't seem to exist..\r\n", ch);
      return;
    }
    while ((*argument != ' ') && (*argument != '\0')) 
      argument++;
    while (*argument == ' ') argument++;
  } else if ((c=GET_CLAN(ch)) == 0 || GET_CLAN_RANK(ch)==0) {
    send_to_char ("You're not part of any clan.\r\n", ch);
    return;
  } 
  if (!CLAN_HASOPT(find_clan_by_id(c), CO_TALK))
  {
    send_to_char ("Clan talking has not been enabled for your clan.\r\n", ch);
    return;
  }
  skip_spaces (&argument);	 

  if (!*argument) 
{
    send_to_char ("Perhaps you should think about what you want to say first..\r\n", ch);
    return;
  }
  
  if ((*argument == '#') && (CLAN_LVL_TALK == 1) && 
      LR_FAIL(ch, LVL_CLAN_GOD))
  {
    argument++;
    minlev = atoi (argument);
    if (minlev > GET_CLAN_RANK(ch))
    {
      send_to_char ("You can't clan talk above your own rank!\r\n", ch);
      return;
    }
    while (*argument != ' ') argument++;
    while (*argument == ' ') argument++;
    if (minlev > 1)
      sprintf(level_string, " (%02d)", minlev);
  }
  if (CLAN_LVL_TALK < 1) 
    minlev = 1;
  
  sprintf (buf1, "You clan talk%s, '%s'\r\n", level_string, argument);
  send_to_char (buf1, ch);

  for (i = descriptor_list; i; i=i->next) {
    if ((i != ch->desc) && (clan_can_hear(i, c))) {
      if (i->character->player_specials->saved.clan_rank >= minlev) {
       sprintf (buf, "%s clan talks%s, '%s'\r\n",
                ((!CAN_SEE(i->character, ch)) ? "someone" : ch->player.name),
		level_string, argument);
	  send_to_char (buf, i->character);
      } else if (!LR_FAIL(ch, LVL_CLAN_GOD)) {
        sprintf (buf, "%s clan talks [%d]%s, '%s'\r\n",
		((!CAN_SEE(i->character, ch)) ? "someone" : ch->player.name),
		GET_CLAN(ch), level_string, argument);
        send_to_char (buf, i->character);
      }
    }
  }
}

/* Clan Leader Talk Channel */
ACMD (do_cltalk) 
{
  struct descriptor_data *i;
  int c=0;

  skip_spaces (&argument);
  
  c=find_clan_by_id(GET_CLAN(ch));
  if ((c < 0) && LR_FAIL(ch, LVL_CLAN_GOD))
  {
    send_to_char("You don't belong to a clan, let alone lead one!\r\n", ch);
    return;
  }
  if (LR_FAIL(ch, LVL_CLAN_GOD) && (GET_CLAN_RANK(ch) < clan[c].ranks))
  {
    send_to_char("Only clan leaders may use this channel.\r\n", ch);
    return;
  }
  if (EXT_FLAGGED(ch, EXT_NOCT))
  {
    send_to_char("You are not currently on that channel.\r\n", ch);
    return;
  }
  if (!*argument)
  {
    send_to_char("Just what did you want to say to the other leaders?\r\n", ch);
    return;
  }
  /* Yeah, I tried using && here, but the problem with that is clan[-1].options
   * doesn't exist =) -- ARTUS */
  if (GET_LEVEL(ch) < LVL_CLAN_GOD)
    if (!CLAN_HASOPT(find_clan_by_id(GET_CLAN(ch)), CO_TALK))
    {
      send_to_char ("Clan talking has not been enabled for your clan.\r\n", ch);
      return;
    }

  sprintf (buf1, "You leader talk, '%s'\r\n", argument);
  send_to_char (buf1, ch);

  for (i = descriptor_list; i; i=i->next) {
    if ((i != ch->desc) && (clan_can_hear(i, -1))) {
      sprintf (buf, "%s leader talks, '%s'\r\n",
               ((!CAN_SEE(i->character, ch)) ? "someone" : ch->player.name), 
	       argument);
      send_to_char (buf, i->character);
    }
  }
}
@


1.33
log
@Artus> Anyone up to and including LVL_IMMORT can now be part of a clan.
@
text
@a2685 3
  if (old_vnum != FALSE)
    if (LR_FAIL(ch, LVL_CLAN_GOD))
      GET_GOLD(ch) -= amtreq;
d2842 2
a2843 2
  clan_num = (GET_MOB_VNUM(ch) - (CLAN_ZONE * 100) - MAX_CLANS);
  if ((clan_num < 0) || (clan_num > MAX_CLANS-1))
a2849 1
  clan_num = clan[clan_num].id;
@


1.32
log
@Artus> Required changes for new find_xxx functions.
       Tax is now only deducted from recruited members.
@
text
@d440 1
a440 1
  if ((GET_LEVEL(leader) > LVL_IMMORT) && (CLAN_NO_IMM > 0))
d756 1
a756 1
  if (GET_LEVEL(vict) > LVL_IMMORT)
d1144 2
a1145 1
  if((GET_LEVEL(ch) > LVL_IMMORT) && (CLAN_NO_IMM == 1)) {
d1646 1
a1646 1
  if (GET_LEVEL(ch)<=LVL_IMMORT)
d2813 2
a2814 1
  if (IS_NPC(ch)) {
d2818 1
a2818 1
  if (!LR_FAIL(ch, LVL_IMMORT))
d2850 1
a2850 1
    mudlog(buf, NRM, LVL_IMMORT, TRUE);
d3113 1
a3113 1
  if (GET_LEVEL(loser) >= LVL_IMMORT)
d3117 1
a3117 1
  if (GET_LEVEL(winner) >= LVL_IMMORT)
d3132 1
a3132 1
    if (GET_LEVEL(winner) == LVL_IMMORT)
d3146 2
a3147 2
	  
  if ((GET_LEVEL(loser) == LVL_IMMORT) && (GET_LEVEL(winner) < LVL_IMMORT))
d3149 6
a3154 2
    demote_level(loser, 99, "Lost PK vs Mortal.");
    GET_EXP(loser) = level_exp(loser, GET_LEVEL(loser)) / 2;
a3503 1
  
d3505 10
a3514 6
    sprintf(buf, "(GC) &7%s&n has punished &7%s&n for &1%s&n. (&1%d&nhrs of &1%s&n).", GET_NAME(ch), GET_NAME(vict), (onum >= 0) ? offence_types[onum] : "N/A", atoi(hours), punish_types[subc]);
  if (atoi(hours) == 0)
    sprintf(buf, "(GC) &7%s&n has removed the &1%s&n punishment on &7%s&n.", GET_NAME(ch), punish_types[subc], GET_NAME(vict));
  if (atoi(hours) < 0)
    sprintf(buf, "(GC) &7%s&n has punished &7%s&n for &1%s&n. (Indefinite &1%s&n).", GET_NAME(ch), GET_NAME(vict), (onum >= 0) ? offence_types[onum] : "N/A", punish_types[subc]);
  mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
d3519 2
a3520 1
    sprintf(buf, "&RYou are no longer punished for &1%s&R.\r\n", (onum >= 0) ? offence_types[onum] : "something");
@


1.31
log
@Artus> Clan Tax.
@
text
@d428 2
a429 1
  if (!(leader=get_char_vis(ch,arg1,FIND_CHAR_ROOM))) {
d575 2
a576 1
  if (!*arg) {
d581 2
a582 1
  if (!is_number(arg)) {
d595 1
a595 1
    if((victim=get_char_online(ch, (player_table+j)->name, FIND_CHAR_WORLD))) 
d605 2
a606 1
      if(chdata.player_specials_saved.clan==clan[i].id) {
d709 2
a710 1
  if (!(*arg)) {
d715 2
a716 1
  switch (clan_check_priv(ch, CP_RECRUIT)) {
d731 2
a732 1
  if(!(vict=get_char_room_vis(ch,arg))) {
d737 3
a739 2
  if (immcom) {
    if ((clan_num = find_clan_by_id(GET_CLAN(vict))) == -1) {
a742 1
  }
d744 2
a745 1
  if(GET_CLAN(vict) != clan[clan_num].id) {
d903 2
a904 1
  if(!(vict=get_char_room_vis(ch,arg))) {
d908 2
a909 1
  if(!immcom && GET_CLAN(vict)!=clan[clan_num].id) {
d913 4
a916 2
  if (immcom) {
    if ((clan_num = find_clan_by_id(GET_CLAN(vict))) == -1) {
d921 2
a922 1
  if(GET_CLAN_RANK(vict)==1) {
d926 2
a927 1
  if(GET_CLAN_RANK(vict)>=GET_CLAN_RANK(ch) && !immcom) {
d968 2
a969 1
  if(!(vict=get_char_room_vis(ch,arg))) {
d974 4
a977 2
  if (immcom) {
    if ((clan_num = find_clan_by_id(GET_CLAN(vict))) == -1) {
d1151 2
a1152 1
  if(GET_CLAN_RANK(ch) > 0) {
d1578 3
a1580 2
  for (j = 0; j <= top_of_p_table; j++) {
    if((victim=get_char_online(ch, (player_table +j)->name, FIND_CHAR_WORLD))) 
d2123 2
a2124 1
  switch(clan_check_priv(ch, CP_ENHANCE)) {
d2139 2
a2140 1
  if ((clan_num=find_clan_by_id(GET_CLAN(ch))) < 0) {
d2148 4
a2151 2
  if (is_abbrev(arg1, "guard")) {
    if (!(mob=get_char_vis(ch, arg1, FIND_CHAR_ROOM))) {
d2155 2
a2156 1
    if (GET_MOB_VNUM(mob) != CLAN_ZONE*100+clan_num) {
d2160 2
a2161 1
    if (strlen(arg2) < 10) {
d2165 2
a2166 1
    if (strlen(arg2) >= 78) {
d2170 2
a2171 2

    if (do_clan_charge(ch, CLC_MOBDESC) < 1) {
d2186 2
a2187 1
    if (save_mobiles(real_zone(CLAN_ZONE)) == FALSE) {
d2197 4
a2200 2
  if (is_abbrev(arg1, "healer")) {
    if (!(mob=get_char_vis(ch, arg1, FIND_CHAR_ROOM))) {
d2204 2
a2205 1
    if (GET_MOB_VNUM(mob) != (CLAN_ZONE*100+clan_num+MAX_CLANS)) {
d2209 2
a2210 1
    if (strlen(arg2) < 10) {
d2214 2
a2215 1
    if (strlen(arg2) >= 78) {
d2219 2
a2220 2

    if (do_clan_charge(ch, CLC_MOBDESC) < 1) {
a2224 1

d2233 2
a2234 1
    if (save_mobiles(real_zone(CLAN_ZONE)) == FALSE) {
d2277 5
a2281 3
  if (is_abbrev(arg1, "guard")) {
    sprintf(arg1, "clanguard");
    if (!(mob=get_char_vis(ch, arg1, FIND_CHAR_ROOM))) {
d2285 2
a2286 1
    if (GET_MOB_VNUM(mob) != CLAN_ZONE*100+clan_num) {
d2292 2
a2293 1
    if (!(mob=get_char_vis(ch, arg1, FIND_CHAR_ROOM))) {
d2297 2
a2298 1
    if (GET_MOB_VNUM(mob) != (CLAN_ZONE*100+clan_num+MAX_CLANS)) {
d2306 2
a2307 1
  if (GET_GOLD(ch) < CLC_MOBDESC) {
d2562 2
a2563 1
    if (!(oldmob=get_char_vis(ch, arg1, FIND_CHAR_ROOM))) {
d2567 2
a2568 1
    if (GET_MOB_VNUM(oldmob) != CLAN_ZONE*100+clan_num) {
d2572 2
a2573 1
    if (GET_LEVEL(oldmob) >= 100) {
d2581 2
a2582 2

    if (do_clan_charge(ch, amtreq) < 1) {
d2589 2
a2590 1
    if (!(oldmob=get_char_vis(ch, arg1, FIND_CHAR_ROOM))) {
d2594 2
a2595 1
    if (GET_MOB_VNUM(oldmob) != (CLAN_ZONE*100+clan_num+MAX_CLANS)) {
d2599 2
a2600 1
    if (GET_LEVEL(oldmob) >= 100) {
d2610 2
a2611 1
    if (do_clan_charge(ch, amtreq) < 1) {
d2626 2
a2627 1
  switch (GET_LEVEL(mob)) {
d2941 1
a2941 1
  if (GET_CLAN(ch) < 1)
d3454 1
a3454 2
  if (!(vict=get_char_online(ch, victim, FIND_CHAR_WORLD)) ||
      !CAN_SEE(ch, vict))
@


1.30
log
@Artus> Now warning free :o)
@
text
@d2889 2
a2890 1
void clan_tax_update (struct char_data *ch, struct char_data *vict) {
d2899 2
d3060 2
a3061 2
  /* Mobs ... Who gives a shit? */
  if ((IS_NPC(loser)) || (IS_NPC(winner)))
@


1.29
log
@Artus> Cleaned up.
@
text
@d702 1
a702 3
  int clan_num,immcom=FALSE;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
d788 1
a788 3
  int clan_num,immcom=FALSE,i,player_i = 0;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
d873 1
a873 3
  int clan_num,immcom=FALSE;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
d931 1
a931 3
  int clan_num,immcom=FALSE;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
d997 2
a998 1
  int i, test_clan, clan_num;
d1027 1
a1027 1
  for (i = 0; i <= top_of_p_table; i++) {
d1365 1
a1365 1
      if (clan[clan_num].treasure < (amount / 100)) {
d1480 1
a1480 1
      sprintf(buf, "Taxrate changed to %d. (%d coins deducted.)\r\n", amount,
@


1.28
log
@Artus> Modifications to the healer, so it should work now :o).
       Cleaned up a bit.
@
text
@d3084 2
a3085 1
  if ((INSTIGATOR(winner) == TRUE) && (GET_LEVEL(winner) < LVL_ANGEL)) {
d3103 2
a3104 1
  if ((GET_LEVEL(loser) == LVL_IMMORT) && (GET_LEVEL(winner) < LVL_IMMORT)) {
@


1.27
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@a208 1

a232 1

a316 1
 
d343 2
a344 2
      (GET_CLAN(ch) < 1) || (GET_CLAN(vict) < 1) || 
      (GET_CLAN(ch) == GET_CLAN(vict)))
d420 2
a421 1
  if(num_of_clans == MAX_CLANS) {
d1075 2
a1076 1
      if ((GET_CLAN(i->character) <0) && (GET_LEVEL(i->character) < LVL_CLAN_GOD))
d1080 3
a1082 1
      if (((clan_one > 0) || (clan_two > 0)) && (GET_CLAN(i->character) != clan_one) && (GET_CLAN(i->character) != clan_two))
d1110 2
a1111 1
  if(GET_CLAN_RANK(ch)==0) {
d2003 2
a2004 1
    if ((GET_ROOM_VNUM((ch)->in_room) < (CLAN_ZONE * 100 + MAX_CLANS-1))) {
d2009 2
a2010 1
    if (direction < 0) {
d2014 2
a2015 1
    for (i = 1; i < CLAN_ROOM_MAX; i++) {
d2023 2
a2024 1
    if (world[ch->in_room].dir_option[direction]) {
d2028 2
a2029 1
    if (new_room <= 0) {
d2033 2
a2034 1
    if (do_clan_charge(ch, CLC_BUILD) < 1) {
d2044 2
a2045 1
    if (clan_num != TRUE) {
d2782 2
a2783 1
  if ((EXT_FLAGGED(ch, EXT_PKILL)) || (GET_CLAN(ch) > 0))
a2798 16
/* Is char playing? */
/* // No Longer Used.
struct char_data *is_playing(char *vict_name)
{
  extern struct descriptor_data *descriptor_list;
  struct descriptor_data *i, *next_i;
  
  for (i = descriptor_list; i; i = next_i) {
    next_i = i->next;
    if (i->connected == CON_PLAYING && !strcmp(CAP(i->character->player.name),CAP(vict_name)))
      return i->character;
  }
  return NULL;
}
*/

d2800 2
a2801 1
int do_clan_heal(struct char_data *ch, struct char_data *vict) {
d2804 9
a2812 3
/*  clan_num = clan[(GET_MOB_VNUM(ch) - (CLAN_ZONE * 100) - MAX_CLANS)].id;
 *  Changed to the following to fix indexing bug.. - ARTUS */
  clan_num = (GET_MOB_VNUM(ch) - (CLAN_ZONE * 100) - MAX_CLANS-1);
d2814 1
a2814 1
  if(GET_CLAN(vict) != clan_num)
d2817 3
a2819 1
  if((GET_HIT(vict) >= GET_MAX_HIT(vict)) && (GET_MOVE(vict) >= GET_MAX_MOVE(vict)) && (GET_MANA(vict) >= GET_MAX_MANA(vict)))
d2822 2
a2823 1
  switch GET_LEVEL(ch) {
d2845 7
a2851 4
      if ((GET_HIT(vict) < (GET_MAX_HIT(vict) / 2))|| (GET_MOVE(vict) < (GET_MAX_MOVE(vict) / 2)) || (GET_MANA(vict) < (GET_MAX_MANA(vict) / 2))) {
        GET_MOVE(vict) = MAX((GET_MAX_MOVE(vict) /2) + 1, GET_MOVE(vict));
        GET_MANA(vict) = MAX((GET_MAX_MANA(vict) /2) + 1, GET_MANA(vict));
        GET_HIT(vict) = MAX((GET_MAX_HIT(vict) /2)+ 1, GET_HIT(vict));
d2870 2
a2871 1
  if (GET_HIT(vict) < GET_MAX_HIT(vict)) {
d2877 2
a2878 1
  if ((GET_MANA(vict) < GET_MAX_MANA(vict)) && (add_m > 0)) {
d2884 2
a2885 1
  if ((GET_MOVE(vict) < GET_MAX_MOVE(vict)) && (add_v > 0)) {
d3162 1
d3167 9
a3175 1
  if (!CLAN_HASOPT(find_clan_by_id((GET_MOB_VNUM(self) - CLAN_ZONE*100) % MAX_CLANS + 1), CO_HEALER))
d3178 2
a3179 2
  for (to = world[self->in_room].people; to; to = to->next_in_room) {
    if (!IS_NPC(to)) {
a3181 2
    }
  }
@


1.26
log
@Artus> Intermittent build.
act.informative.c: Affect/Timers now display something when no affects/timers
                   are present.
                   Sense curse now senses objects inside containers.
act.movement.c   : Optimised the aggravate stuff a little.
act.offensive.c  : Logging death by pit trap.
act.other.c      : Logging death by suicide.
                   Superman now sets affects rather than actual stats, for STR
                   and CON (CON bonus is +1, STR is 21 - GET_REAL_STR
                   Logging death by arrow.
clan.c           : Removed aggravate_check() function, no longer used.
db.c             : Now initialising character specials.
dg_mobcmd.c      : Logging death by mdamage.
dg_objcmd.c      : Logging death by odamage.
dg_wldcmd.c      : Logging death by wdamage.
fight.c          : New optional msg paramater to die(), for if the death was
                   not caused by a character.
                   Deaths are now logged to info channel.
handler.c        : Modified ability affect function to permit more than one
                   affect modifier per special. (Required for superman)
spec_procs.c     : Logging death by pit trap, archers and room blast.
spells.h         : Added SPELL_SUPERMAN for special affect modifiers.
utils.h          : Updated die() prototype to match changes in fight.c.
@
text
@d112 2
a113 1
  if(GET_LEVEL(ch) >= LVL_CLAN_GOD) {
d200 2
a201 1
  if (GET_LEVEL(ch) < LVL_CLAN_GOD) {
d368 1
a368 1
  if (GET_LEVEL(ch) >= LVL_CLAN_GOD)
d417 1
a417 1
  if ((!*arg) || (GET_LEVEL(ch) < LVL_CLAN_GOD)) 
d552 1
a552 1
  if (GET_LEVEL(ch) >= LVL_CLAN_GOD)
d570 2
a571 1
  if(GET_LEVEL(ch) < LVL_CLAN_GOD) {
d636 2
a637 1
  if (GET_LEVEL(ch) < LVL_CLAN_GOD) {
d642 2
a643 1
  if (!(*arg)) {
d752 2
a753 1
  if(GET_LEVEL(vict) > LVL_IMMORT) {
d1075 2
a1076 1
    if (GET_LEVEL(i->character) < LVL_CLAN_GOD) {
d1136 1
a1136 1
  if(GET_LEVEL(ch) >= LVL_CLAN_GOD)
d1152 2
a1153 1
  if(GET_LEVEL(ch) < clan[clan_num].app_level) {
d1413 1
a1413 1
	if (GET_LEVEL(ch) < LVL_CLAN_GOD) 
d1419 1
a1419 1
	if (GET_LEVEL(ch) < LVL_CLAN_GOD)
d1624 1
a1624 1
    if (GET_LEVEL(ch) < LVL_CLAN_GOD) 
d1631 4
a1634 2
  if(GET_LEVEL(ch)<=LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
d1643 2
a1644 1
    if(GET_LEVEL(ch)<LVL_CLAN_GOD) {
d1685 1
a1685 1
  sprintf(buf, "Done for %d coins.\r\n", ((GET_LEVEL(ch) >= LVL_CLAN_GOD) ? 0 : CLC_RANKTITLE));
d1720 3
a1722 2
  if (!(*arg)) {
    if (GET_LEVEL(ch) < LVL_CLAN_GOD) 
d1763 3
a1765 2
  if (!(*arg)) {
    if (GET_LEVEL(ch) < LVL_CLAN_GOD)
d1845 2
a1846 1
  if ((GET_LEVEL(ch) < LVL_CLAN_GOD) && (GET_GOLD(ch) < CLC_SETDESC)) {
d1956 1
a1956 1
      if (GET_LEVEL(ch) < LVL_CLAN_GOD)
d1984 1
a1984 1
    if (GET_LEVEL(ch) < LVL_CLAN_GOD)
d1989 2
a1990 1
    if ((GET_LEVEL(ch) < LVL_CLAN_GOD) && (GET_GOLD(ch) < CLC_ROOMTD)) {
d2038 1
a2038 1
      if (GET_LEVEL(ch) < LVL_CLAN_GOD);
d2359 4
a2362 2
  if (c < 0) {
    if (GET_LEVEL(ch) < LVL_CLAN_GOD) {
d2373 2
a2374 1
  if (r < clan[c].privilege[CP_ENABLE]) {
d2638 1
a2638 1
    if (GET_LEVEL(ch) < LVL_CLAN_GOD)
d2660 2
a2661 1
  if (GET_LEVEL(ch) >= LVL_CLAN_GOD) {
d2673 2
a2674 1
  if ((c=find_clan_by_id(GET_CLAN(ch))) < 0) {
d2737 1
a2737 1
  if (GET_LEVEL(ch) >= LVL_CLAN_GOD)
d2768 2
a2769 2

  if (GET_LEVEL(ch) > LVL_IMMORT) {
d2773 2
a2774 1
  if ((EXT_FLAGGED(ch, EXT_PKILL)) || (GET_CLAN(ch) > 0)){
d2779 2
a2780 1
  if ((!(*argument)) || (strcasecmp("enable", argument))) {
d2919 1
a2919 1
  if (GET_LEVEL(d->character) >= LVL_CLAN_GOD)
d3186 1
a3186 1
  if (GET_LEVEL(ch) < LVL_CLAN_GOD)
d3351 2
a3352 1
    if (GET_LEVEL(ch) < LVL_ANGEL) {
d3357 2
a3358 1
    if (GET_LEVEL(ch) == LVL_ANGEL) {
d3370 2
a3371 1
  if (!*argument) {
d3376 2
a3377 1
  if ((!*argument) && (strcmp(hours, "0"))) { // list_offences();
d3387 2
a3388 1
  if ((!*reason) && (strcmp(hours, "0"))) {
d3400 2
a3401 1
  if (GET_LEVEL(ch) <= GET_LEVEL(vict)) {
d3405 2
a3406 1
  if ((subc=parse_punish(punishment)) < 0) {
d3410 2
a3411 1
  if ((onum=parse_offence(offence)) < -1) {
d3415 2
a3416 1
  if ((!is_number(hours)) && (strcmp(hours, "-1"))) {
d3420 2
a3421 1
  if ((strlen(reason) < 10) && (strcmp(hours, "0"))) {
d3428 2
a3429 1
  if (GET_LEVEL(ch) < min_levels[subc]) {
d3433 2
a3434 1
  if ((min_levels[subc] < 1) && (GET_LEVEL(ch) < LVL_GRGOD)) {
d3464 2
a3465 1
  if (GET_LEVEL(ch) >= LVL_CLAN_GOD) {
d3467 2
a3468 1
    if (find_clan_by_id(c) < 0) {
d3479 2
a3480 1
  if (!CLAN_HASOPT(find_clan_by_id(c), CO_TALK)) {
d3486 2
a3487 1
  if (!*argument) {
d3492 3
a3494 1
  if ((*argument == '#') && (CLAN_LVL_TALK == 1) && (GET_LEVEL(ch) <= LVL_IMMORT)) {
d3497 2
a3498 1
    if (minlev > GET_CLAN_RANK(ch)) {
d3520 1
a3520 1
      } else if (GET_LEVEL(i->character) >= LVL_CLAN_GOD) {
d3539 2
a3540 1
  if ((c < 0) && (GET_LEVEL(ch) < LVL_CLAN_GOD)) {
d3544 2
a3545 1
  if ((GET_LEVEL(ch) < LVL_CLAN_GOD) && (GET_CLAN_RANK(ch) < clan[c].ranks)) {
d3549 2
a3550 1
  if (EXT_FLAGGED(ch, EXT_NOCT)) {
d3554 2
a3555 1
  if (!*argument) {
d3562 2
a3563 1
    if (!CLAN_HASOPT(find_clan_by_id(GET_CLAN(ch)), CO_TALK)) {
@


1.25
log
@Artus> Moving stuff across to live.

act.informative.c:
  Info on it's own will now display the info file. Use me or self to see your
own info.
  Score and Exp now both show gained and remaining exp.
  Gold value is now to a max of 30000. (60000 in lvl 40+ zones, 120 in 70+)
  Gold rushes no longer occur in !GOLDRUSH zones, city sectors, etc.

act.other.c:
  Mana retained on remort is now floored at 100 instead of 50.
  Added elitist bonus for chars who play past the earliest remort point(s).

act.wizard.c:
  Gold rush events are now only advertised within the world they occur.

genolc.h:
  Added special #defines for different OLC levels whether running live or test.
  (Noted by compiling with -DPRIMAL_LIVE)

interpreter.c:
  Aliases will now be saved automatically, when added or remoed.
  Added elitist_modifier() to modifier calculation.
  Replaced Huh?!? with HUH.

limits.c:
  NPC corpses are no longer emptied before they are purged. Too much clutter.

spells.c:
  Reduced the amount of weight applied by create water to 1/3 of what it was.

comm.c:       Added send_to_not_zone_world()
db.c:         Added elitist_modifier() to modifier calculation.
dg_mobcmd.c:  Replaced Huh?!? with the define, HUH.
dg_scripts.h: Changed version string so it will fit on one line :o)
fight.c:      Eq should no longer be damaged when a hit fails.
handler.c:    Now, when the sleep spell wears of an NPC, it will wake up.
structs.h:    Added HUH define.
utils.c:      Added elitist_modifier() calculation.
utils.h:      Added elitist_modifier() prototype.
@
text
@d2914 1
d2924 1
a2924 1
    if ((STATE(ch->desc) == CON_PLAYING) && (i->in_room == ch->in_room) && (FIGHTING(i) == NULL) && (CAN_SEE(i, ch)) && (AWAKE(i)) && (mob_index[GET_MOB_RNUM(i)].func != shop_keeper)) {
d2932 1
a2937 1

d2948 6
a2953 2
  for (i = 0; i < 31; i++) {
    if (ch->player_specials->saved.phours[i] > 0) {
d2955 2
a2956 1
      if (ch->player_specials->saved.phours[i] == 0) {
a2960 1
  }
@


1.24
log
@Artus> Mostly just cosmetic changes, mostly for underwater stuff..
       Added some more stuff to dg_scripts:

       %actor.affected(aff_bit)% - Is actor affected by whatever.
       %self.people(countpc)%    - (Rooms): Count players.
       %self.people(countnpc)%   - (Rooms): Count npcs.
       %self.people(countall)%   - (Rooms): Count chars.
       %firstchar.<room_vnum>%   - First character in room <vnum>

       Possibly a bugfix to one of the forest specials that was attacking you
       if you were affected by poison.
@
text
@d765 1
a765 1
struct char_data *get_player (struct char_data * ch, char *name)
d768 2
a769 2

  for (i = character_list; i; i = i->next) {
@


1.23
log
@Artus>
Trap Obj is now VNUM 25599 aka TRAP_OBJ
Modified board code to handle clan boards.
Reduced number of clans to 8 (was 32).
Added a few new clan defines.. GET_CLAN_REL(us, them); CLAN_AT_PEACE(us, them),
  CLAN_AT_WAR(us, them); CLAN_ALLIED(us, them);...
Fixed up the clan destroy routine.
Set slowns to default on.
Remove loop for assigning clan mobs, replaced with sequential assigns.
@
text
@d1948 1
a1948 1
    if ((GET_ROOM_VNUM((ch)->in_room) < (CLAN_ZONE * 100 + 31))) {
d1986 1
a1986 1
    if ((GET_ROOM_VNUM((ch)->in_room) < (CLAN_ZONE * 100 + 31))) {
d2040 1
a2040 1
    if ((GET_ROOM_VNUM((ch)->in_room) < (CLAN_ZONE * 100 + 31))) {
d2789 1
a2789 1
  clan_num = (GET_MOB_VNUM(ch) - (CLAN_ZONE * 100) - 31);
@


1.22
log
@Artus> Fixed primal scream.
       Added sanity checking to clan_rel_inc().
       do_cast() no longer resets mana to maxmana(), fixes dark ritual and
	 vampire.
       Reports should no longer mail the same person twice.
@
text
@a49 1
//struct char_data *is_playing(char *vict_name);
d208 3
a210 2
  if (((c=atoi(arg)) < 1) || (c > 32 )) {
    send_to_char("Clan number must be between 1 and 32.\r\n", ch);
d217 2
a218 1
  if ((real = real_mobile(c + (CLAN_ZONE * 100))) > -1) {
d233 2
a234 1
  if ((real = real_mobile(c + (CLAN_ZONE * 100) + 32)) > -1) {
d261 2
a262 1
  if ((real = real_room(c + (CLAN_ZONE*100))) != NOWHERE) {
d274 2
a275 1
  if ((real = real_room(c + 32 + (CLAN_ZONE*100))) != NOWHERE) {
d287 1
a287 1
    sprintf(buf, "Clan room [%d] not found while resetting!", (c + 32 + (CLAN_ZONE*100)));
d290 3
a292 2
  for (i = 2;i <= CLAN_ROOM_MAX;i++) { /* Rooms */
    if ((real = real_room(c + (CLAN_ZONE*100) + (i*32))) != NOWHERE) {
d302 1
a302 1
      sprintf(buf, "Clan room [%d] not found while resetting!", (c + (CLAN_ZONE*100) + (i*32)));
d326 1
a326 1
void clan_rel_change (int clan_x, int clan_y, int amt)
d328 2
a329 2
  int x, y;
  if ((clan_x < 1) || (clan_y < 1) || (clan_x > MAX_CLANS) || (clan_y > MAX_CLANS))
d331 5
a335 15
  if (clan_x == clan_y)
    return;
  if (amt == 0) 
    return;

  x = find_clan_by_id(clan_x);
  y = find_clan_by_id(clan_y);
  
  if (amt > 0) {
    clan[x].relations[clan_y] = MAX(clan[x].relations[clan_y] + amt, CLAN_REL_MIN);
    clan[y].relations[clan_x] = MAX(clan[y].relations[clan_x] + amt, CLAN_REL_MIN);
  } else {
    clan[x].relations[clan_y] = MIN(clan[x].relations[clan_y] + amt, CLAN_REL_MAX);
    clan[y].relations[clan_x] = MIN(clan[y].relations[clan_x] + amt, CLAN_REL_MAX);
  }
d340 1
a340 2
  int c, d, amount;
  c = d = 0;
d347 5
a351 3
  c = find_clan_by_id(GET_CLAN(ch));
  d = find_clan_by_id(GET_CLAN(vict));
  if (GET_CLAN_RANK(ch) == clan[c].ranks)
d353 1
a353 1
  if (GET_CLAN_RANK(vict) == clan[d].ranks)
d355 1
a355 1
  if (GET_CLAN_RANK(ch) == (clan[c].ranks - 1))
d357 1
a357 1
  if (GET_CLAN_RANK(vict) == (clan[d].ranks - 1))
d359 1
a359 1
  clan_rel_change(clan[c].id, clan[d].id, amt);
d415 2
a416 1
  if ((!*arg) || (GET_LEVEL(ch) < LVL_CLAN_GOD)) {
d433 2
a434 1
  if (strlen(arg2) >= 32) {
d439 2
a440 1
  if ((GET_LEVEL(leader) > LVL_IMMORT) && (CLAN_NO_IMM > 0)) {
d445 2
a446 1
  if (GET_LEVEL(leader) < LVL_CLAN_MIN) {
d451 2
a452 1
  if ((GET_CLAN(leader) != 0) && (GET_CLAN_RANK(leader) != 0)) {
d457 2
a458 1
  if (find_clan(arg2) != -1) {
d465 2
a466 1
    if ((new_id == 0) && (find_clan_by_id(i) < 0))
d468 2
d484 8
a491 6
  for(i = 0; i < MAX_CLANS; i++) {
    if ((clan[i].id > 0) && (i != num_of_clans))
      clan[i].relations[new_id] = 0;
      clan[num_of_clans].relations[i] = 0;
      clan[num_of_clans].frags[i] = 0;
      clan[num_of_clans].deaths[i] = 0;
d534 1
a534 2
      cscore[i].frags += clan[i].frags[clan[j].id];
      cscore[i].frags -= clan[i].deaths[clan[j].id];
d538 2
a539 1
  for (i=0;i<num_of_clans;i++) {
d608 2
d611 7
d619 1
a619 2

  for (j = i; j < num_of_clans - 1; j++) {
a620 5
    clan[j].relations[i] = 0;
    clan[j].frags[i] = 0;
    clan[j].deaths[i] = 0;
  }
  
a621 3

  do_clan_reset(ch, arg);

d661 1
a661 1
    sprintf(buf, "%s%d(%d)%s", buf, clan[i].id, clan[c].relations[clan[i].id], ((i < (num_of_clans-1)) ? " " : "\r\nFrags: "));
d665 3
a667 1
    sprintf(buf, "%s%d(%d-%d)%s", buf, clan[i].id, clan[c].frags[clan[i].id], clan[c].deaths[clan[i].id], ((i < (num_of_clans-1)) ? " " : "\r\nOptions: "));
d1198 4
a1201 3
  for(j = 0; j < num_of_clans; j++) {
    x += clan[i].frags[clan[j].id];
    y += clan[i].deaths[clan[j].id];
d1915 1
a1915 1
  if (((GET_ROOM_VNUM((ch)->in_room)-(CLAN_ZONE*100)) % 32) != clan_num) {
d1998 1
a1998 1
        if (W_EXIT(real_room((i * 32) + clan_num + (CLAN_ZONE * 100)), j))
d2001 1
a2001 1
        new_room = real_room((i * 32) + clan_num + (CLAN_ZONE * 100));
d2158 1
a2158 1
    if (GET_MOB_VNUM(mob) != (CLAN_ZONE*100+clan_num+32)) {
d2244 1
a2244 1
    if (GET_MOB_VNUM(mob) != (CLAN_ZONE*100+clan_num+32)) {
d2310 1
a2310 1
    n = clan[c].relations[clan[i].id];
d2532 1
a2532 1
    if (GET_MOB_VNUM(oldmob) != (CLAN_ZONE*100+clan_num+32)) {
d2787 1
a2787 1
/*  clan_num = clan[(GET_MOB_VNUM(ch) - (CLAN_ZONE * 100) - 32)].id;
d3021 2
a3022 1
void clan_pk_update (struct char_data *winner, struct char_data *loser) {
d3074 4
a3077 1
  if (GET_CLAN(loser) < 1) /* Loser didn't belong to a clan. Who cares? */
d3080 2
a3081 1
  if (GET_CLAN(winner) < 1) {
d3086 3
a3088 2
   
  if (GET_CLAN(winner) == GET_CLAN(loser)) {
a3093 3
  win_clan = find_clan_by_id(GET_CLAN(winner));
  lose_clan= find_clan_by_id(GET_CLAN(loser));

d3113 2
a3114 2
  clan[win_clan].frags[GET_CLAN(loser)]++;
  clan[lose_clan].deaths[GET_CLAN(winner)]++;
d3116 1
a3116 1
  clan_rel_change(clan[win_clan].id, clan[lose_clan].id, relmod);
d3129 1
a3129 1
  if (!CLAN_HASOPT(find_clan_by_id((GET_MOB_VNUM(self) - CLAN_ZONE*100) % 32 + 1), CO_HEALER))
d3146 1
a3146 1
  int amount, clan_id, amt_req = 0;
d3156 2
a3157 5
  // if (clan[find_clan_by_id(clan_id)].options[CO_HALL] < 1) {
  if (!CLAN_HASOPT(find_clan_by_id(clan_id), CO_HALL)) {
    act("$n &rtells you, 'This clan's hall has not been built yet.'&n", FALSE, self, 0, ch, TO_VICT);
    return (TRUE);
  }
d3159 4
a3162 2
  if (CMD_IS("enter")) { /* Only allow Imms && Clan members... */
    if ((GET_LEVEL(ch) < LVL_CLAN_GOD) && ((GET_CLAN(ch) != clan_id) || (clan[find_clan_by_id(GET_CLAN(ch))].relations[clan_id] > CLAN_REL_PEACEFUL))) {
d3166 6
a3171 3
    } else if ((GET_CLAN_RANK(ch)==0) && (GET_LEVEL(ch) < LVL_CLAN_GOD)) {
      act("$n &rtells you, 'Thy application must be approved before entering.'&n", FALSE, self, 0, ch, TO_VICT);
      return(TRUE);
d3173 7
a3179 15
    act ("$n waves a hand over you, and you find yourself in the clan room.", FALSE, self, 0, ch, TO_VICT);
    act ("$n has been transferred away to $s calling.", FALSE, ch, 0, 0, TO_ROOM);
  }
  if (CMD_IS("bribe")) { /* There is nothing money cannot buy. */
    if (CLAN_BRIBING == 0) /* Bribing has been turned off. */
      return(FALSE);

    if ((GET_LEVEL(ch) <= LVL_CLAN_GOD) && (GET_CLAN(ch) != clan_id)) {
      amount = atoi(argument);
      if (amount < 1) {
	send_to_char("How much did you want to bribe the guard??\r\n", ch);
	return(TRUE);
      }
      if (amount > GET_GOLD(ch)) {
	send_to_char("You don't have that much gold!\r\n", ch);
d3181 2
a3182 47
      }
      GET_GOLD(ch) -= amount;
      clan_coinage(find_clan_by_id(clan_id), amount);

      /* Modify Relationships.. */
      if (GET_CLAN(ch)) {
	if (GET_CLAN_RANK(ch) == clan[find_clan_by_id(GET_CLAN(ch))].ranks)
	  clan_rel_change(clan_id, GET_CLAN(ch), -25);
	else
	  clan_rel_change(clan_id, GET_CLAN(ch), -10);
      }
      
      if (CLAN_BRIBING == 2) {  /* Clan Bribing is in "Bastard" Mode :o)      */
	act("$n takes the gold and laughs in your face.", FALSE, self, 0, ch, TO_VICT);
	act("$N laughs hard at $n", FALSE, ch, 0, self, TO_ROOM);
	return (FALSE);
      }

      switch(GET_LEVEL(self)) { /* Possible theory on guard strengtehning at  *
				 * the clans cost.. I'm sure we can work      *
				 * something better out later if it's not     *
				 * good enough as is..                        */
	 case 110: amt_req = 2000000000; break;
	 case 100: amt_req = 10000 * GET_LEVEL(ch); break;
	 case 90: amt_req = 5000 * GET_LEVEL(ch); break;
	 case 80: amt_req = 2500 * GET_LEVEL(ch); break;
	 case 70: amt_req = 1000 * GET_LEVEL(ch); break;
	 case 60: amt_req = 100 * GET_LEVEL(ch); break;
	 case 50: amt_req = 0; break;
	 default: amt_req = 0;
      }

      if (amt_req < CLAN_MIN_BRIB) /* Basic attempt at stopping level 10     */
	amt_req = CLAN_MIN_BRIB;   /* getting in too cheaply                 */

      if (clan[find_clan_by_id(GET_CLAN(ch))].relations[clan_id] < CLAN_REL_WAR)
	amt_req += (int)(amt_req / 2);
      else if (clan[find_clan_by_id(GET_CLAN(ch))].relations[clan_id] < CLAN_REL_ANGER)
	amt_req += (int)(amt_req / 3);
      else if (clan[find_clan_by_id(GET_CLAN(ch))].relations[clan_id] > CLAN_REL_TRADE)
	amt_req -= (int)(amt_req / 3);
      else if (clan[find_clan_by_id(GET_CLAN(ch))].relations[clan_id] > CLAN_REL_PEACEFUL)
	amt_req -= (int)(amt_req / 2);

      if ((amount < amt_req) || (clan[find_clan_by_id(GET_CLAN(ch))].relations[clan_id] < CLAN_REL_BLOOD_WAR)) {
	act("$n takes the gold and laughs in your face.", FALSE, self, 0, ch, TO_VICT);
	act("$N laughs hard at $n.", FALSE, ch, 0, self, TO_ROOM);
d3185 57
a3241 2
      if (amount < (amt_req + (amt_req / 4))) { /* The in-between range...   */
	if (number(0, 5) > 0) {    /* Anything higher and the guard will cum */
d3246 17
a3262 7
      }
      act("$n has accepted your bribe.", FALSE, self, 0, ch, TO_VICT);
      act("$N whistles dixie as $n disappears.", FALSE, ch, 0, self, TO_ROOM);
    } else {
      act("$n looks at the gold, 'Don't worry about it, this one's on me!'", FALSE, self, 0, ch, TO_VICT);
    } 
  }
d3266 1
a3266 1
  if (amt_req < 1) { 
a3267 1
  }
@


1.21
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@a345 1

d349 3
a351 10
  if (vict == ch)
    return;

  if (IS_NPC(ch) || IS_NPC(vict))
    return;

  if ((GET_CLAN(ch) < 1) || (GET_CLAN(vict) < 1))
    return;

  if (GET_CLAN(ch) == GET_CLAN(vict))
a352 1
  
a354 4

  if (c == d)
    return;

a362 1
  
d367 2
a368 1
int clan_check_priv (struct char_data *ch, int priv) {
d372 2
a373 1
  if ((clan_num=find_clan_by_id(GET_CLAN(ch))) < 0) {
d377 2
a378 1
  if ((priv>=0) && (GET_CLAN_RANK(ch)<clan[clan_num].privilege[priv])) {
d382 2
a383 1
  if ((priv==CP_LEADER) && (GET_CLAN_RANK(ch) < clan[clan_num].ranks)) {
d396 1
a396 3
  c = find_clan_by_id(GET_CLAN(ch));

  if (clan[c].level >= 35)
a397 1

a400 1

d402 2
a403 2

  if (clan[c].exp > clan_levels[clan[c].level]) { /* Clan Levels */
a408 1

a414 1
	
@


1.20
log
@Artus> Added extra fflush() calls.. May/not help crash saves recovering ;o)
@
text
@d229 1
a229 1
    log (buf);
d244 1
a244 1
    log(buf);
d268 1
a268 1
    log(buf);
d284 1
a284 1
    log(buf);
d298 1
a298 1
      log(buf);
d1268 1
a1268 1
    log("SYSERR: Unable to open clan file");
d1291 1
a1291 1
    log("   Clan file does not exist. Will create a new one");
d1300 1
a1300 1
  log("   Calculating powers and members");
@


1.19
log
@Artus> Gravity, Some minor changes to clan messages, Violence check for
       violent spells.
@
text
@d864 1
@


1.18
log
@Artus> A3_0_315
@
text
@d222 1
a222 1
    GET_DDESC(guard) = str_dup("It looks unfinished.\r\n");
d237 1
a237 1
    GET_DDESC(healer) = str_dup("It looks unfinished.\r\n");
d2274 1
a2274 1
 * War - Cannot bribe way into hall, cannot group (artus)
d2277 1
a2277 1
 * Alliance - Enter halls at free will. (artus)
d2839 6
a2844 1
    default: return FALSE;
@


1.17
log
@Latest Version
@
text
@d50 1
a50 1
struct char_data *is_playing(char *vict_name);
d591 2
a592 1
  if ((i = find_clan_by_sid(arg)) < 0) {
d600 4
a603 2
    if((victim=is_playing((player_table +j)->name))) {
      if(GET_CLAN(victim)==clan[i].id) {
d1563 4
a1566 2
    if((victim=is_playing((player_table +j)->name))) {
      if(GET_CLAN(victim)==clan[clan_num].id) {
d2773 1
d2781 1
a2781 1
    if (i->connected == CON_PLAYING && !strcmp(i->character->player.name,CAP(vict_name)))
d2786 1
d2998 1
d3000 2
a3001 1

d3345 3
a3347 1
  if (!(vict=is_playing(victim))) {
d3385 1
a3385 1
    sprintf(buf, "&7%s&n has been punished by &1%s&n for &c%d&n hours.", GET_NAME(vict), punish_types[subc], atoi(hours));    
d3387 1
a3387 1
    sprintf(buf, "&7%s&n is no loger punished by &1%s&n.", GET_NAME(vict), punish_types[subc]);
d3389 1
a3389 1
    sprintf(buf, "&7%s&n&n has been punished indefinately by &1%s&n.", GET_NAME(vict), punish_types[subc]);
d3391 6
a3396 2
  send_to_char(buf, ch);
  send_to_char("\r\n", ch);
@


1.16
log
@
Modified: DM

Changed:
- colour touches
@
text
@d3340 5
d3374 1
a3374 1
    sprintf(buf, "%s has been punished by %s for %d hours.\r\n", GET_NAME(vict), punish_types[subc], atoi(hours));    
d3376 1
a3376 1
    sprintf(buf, "%s is no loger punished by %s.\r\n", GET_NAME(vict), punish_types[subc]);
d3378 2
a3379 1
    sprintf(buf, "%s has been punished indefinately by %s.\r\n", GET_NAME(vict), punish_types[subc]);
d3381 1
@


1.15
log
@Artus- Added clan_rel_inc function to call from spells/skills, which modifies
       the clan relationships, as required.
@
text
@d3146 1
a3146 1
    act("$n tells you, 'This clan's hall has not been built yet.'", FALSE, self, 0, ch, TO_VICT);
d3156 1
a3156 1
      act("$n tells you, 'Thy application must be approved before entering.'", FALSE, self, 0, ch, TO_VICT);
@


1.14
log
@Artus - Couple of minor changes to relationships.
@
text
@d58 1
d341 37
a377 1
 
a3192 2
      /* Add stuff to check relationships in here.. TODO - ARTUS */

d3210 10
a3219 1
      if (amount < amt_req) {      /* Cheapskates R Us */
@


1.13
log
@Artus - Changed to use CLAN_REL_XXX
@
text
@d780 3
@


1.12
log
@Artus - Pk stuff changed.. Punishments tweaked, added demote for champs killed
        by mortals..
@
text
@d334 2
a335 2
    clan[x].relations[clan_y] = MAX(clan[x].relations[clan_y] + amt, -3000);
    clan[y].relations[clan_x] = MAX(clan[y].relations[clan_x] + amt, -3000);
d337 2
a338 2
    clan[x].relations[clan_y] = MIN(clan[x].relations[clan_y] + amt, 3000);
    clan[y].relations[clan_x] = MIN(clan[y].relations[clan_x] + amt, 3000);
d2272 3
a2274 3
    if (n < -2000)
      strcat (buf, "blood war");
    else if (n < -1500)
d2276 1
a2276 1
    else if (n < -1000) 
d2278 1
a2278 1
    else if (n < -500)
d2280 1
a2280 1
    else if (n < 500)
d2282 1
a2282 1
    else if (n < 1000)
d2284 1
a2284 1
    else if (n < 1500)
d2286 1
a2286 1
    else if (n < 2000)
d2288 1
a2288 1
    else if (n >= 2000)
d3111 1
a3111 1
    if ((GET_LEVEL(ch) < LVL_CLAN_GOD) && (GET_CLAN(ch) != clan_id)) {
@


1.11
log
@Artus - And another two I missed :p
@
text
@d2946 1
a2946 1
    ch->player_specials->saved.phours[ptype] = 0;
d2950 3
a2952 3
  if ((offence >= 0) && (hours != 0)) { /* Increment Offences */
    ch->player_specials->saved.offences[offence]++;
  }
d2956 1
a2956 1
    ch->player_specials->saved.phours[ptype] = -1;
d2960 1
a2960 1
  if (ch->player_specials->saved.phours[ptype] < 0)
d2965 1
a2965 1
  ch->player_specials->saved.phours[ptype] = hours;
d2975 1
d3008 1
d3011 1
a3011 1
      perform_punish(winner, level_diff, (winner->player_specials->saved.phours[level_diff] + severity), OFF_PKILL);
a3014 1
/* 
d3016 2
a3017 6
    / * Demote Champs Back To 99 Here :o) TODO - ARTUS 
       Probably be done after integration, hopefully the primal stuff has
       a nice demote function to call upon.. Then just be a simple matter
       of demoting them, and setting the exp to half. Will probably write
       to mudlog too.
     * /
a3018 1
*/
@


1.10
log
@Artus - Couple of text clean ups.
@
text
@d2103 1
a2103 3
    if (save_mobiles(real_zone(CLAN_ZONE)) != FALSE) {
      send_to_char("Guard's Title Saved.\r\n", ch);
    } else {
d2145 1
a2145 3
    if (save_mobiles(real_zone(CLAN_ZONE)) != FALSE) {
      send_to_char("Healer's Title Saved.\r\n", ch);
    } else {
@


1.9
log
@Artus - Minor change to clan_pk_update to make mods to kills and killedbys..
@
text
@d2079 2
a2080 2
    if (!(arg2)) {
      send_to_char("Set your guard's name to what?\r\n", ch);
d2124 2
a2125 2
    if (!(arg2)) {
      send_to_char("Set your healer's name to what?\r\n", ch);
d2128 2
a2129 2
    if (strlen(arg2) >= 80) {
      send_to_char("Healer's name cannot exceed 80 characters.\r\n", ch);
d2148 1
a2148 1
      send_to_char("Guard's Title Saved.\r\n", ch);
@


1.8
log
@Artus - Doh missed one :p
@
text
@d2984 11
@


1.7
log
@Artus - Lots of bugfixes.
@
text
@d2608 1
@


1.6
log
@Artus - Fixed up a bunch of bugs that prevented imms from doing shit like
        depositing/withdrawing/promoting/demoting/etc..
@
text
@d59 38
d200 1
a200 1
    send_to_char("Hands off.\r\n", ch);
a368 38
  long clevels[] = {
    100000,      /*  1 */
    200000,
    500000,
    1000000,
    1500000,     /*  5 */
    2000000,
    2500000,
    3000000,
    4000000,
    5000000,     /* 10 */
    7500000,
    10000000,
    20000000,
    50000000,
    100000000,   /* 15 */
    250000000,
    500000000,
    1000000000,
    1000000000,
    1000000000,  /* 20 */
    1000000000,
    1000000000,
    1250000000,
    1500000000, 
    2000000000,  /* 25 */
    2000000000,  
    2000000000,  
    2000000000,  
    2000000000,  
    2000000000,  /* 30 */
    2000000000,  
    2000000000,  
    2000000000,  
    2000000000,
    2000000000   /* 35 */
  };

d371 1
a371 1
  if (clan[c].level >= 25)
d380 2
a381 2
  if (clan[c].exp > clevels[clan[c].level]) { /* Clan Levels */
    clan[c].exp -= clevels[clan[c].level];
d540 1
a540 1
  if (!*arg) {
d545 3
a547 8
  if(GET_LEVEL(ch) < LVL_CLAN_GOD) {
    if ((i=find_clan_by_id(GET_CLAN(ch))) >= 0) {
      sprintf(buf, "Clan %s has been destroyed. Enjoy!\r\n", clan[i].name);
      send_to_char(buf, ch);
      return;
    }
    send_to_char("When pigs fly!\r\n", ch);
    return; 
d602 5
d672 1
a672 1
    send_clan_format(ch);
d696 5
a700 3
  if((immcom) && (clan_num = find_clan_by_id(GET_CLAN(ch)) == -1)) {
    send_to_char("Then don't seem to be in a clan.\r\n", ch);
    return;
d703 1
a703 1
  if(GET_CLAN(vict)!=clan[clan_num].id) {
d760 1
a760 1
    send_clan_format(ch);
d842 1
a842 1
    send_clan_format(ch);
d868 5
a872 3
  if(immcom && (clan_num = find_clan_by_id(GET_CLAN(vict)) == -1)) {
    send_to_char("They're not in a clan.\r\n", ch);
    return;
d902 1
a902 1
    send_clan_format(ch);
d926 5
a930 3
  if (immcom && (clan_num = find_clan_by_id(GET_CLAN(vict)) == -1)) {
    send_to_char("They aren't even in a clan.\r\n", ch);
    return;
d1099 4
a1107 5
  if (!(*arg)) {
    send_to_char("To which clan were you wanting to apply? (Try \"clan list\")\r\n", ch);
    return; 
  }

d1303 1
a1303 1
  if ((!(*arg)) && (action != CB_BALANCE && GET_LEVEL(ch)<LVL_CLAN_GOD)) {
d1305 1
d1365 16
a1380 1
    send_clan_format(ch);
d1388 2
a1389 2
      strcpy(arg,arg1);
      if ((clan_num = find_clan_by_sid(arg2)) < 0) {
d1440 1
a1440 1
              CLC_CHGFEE);
a1464 5
  if (!(*arg)) {
    send_clan_format(ch);
    return; 
  }

d1472 2
a1473 2
      strcpy(arg,arg1);
      if ((clan_num = find_clan_by_sid(arg2)) < 0) {
d1500 1
d1546 2
a1547 2
  sprintf(buf, "Number of ranks is now %d. (%d coins detected)\r\n", new_ranks,
      amtreq);
d1576 4
a1579 1
    send_clan_format(ch);
d1634 1
a1634 1
  sprintf(buf, "Done for %d coins.\r\n", CLC_RANKTITLE);
d1639 1
a1639 1
/* Apply to clan */
a1647 5
  if (!(*arg)) {
    send_clan_format(ch);
    return; 
  }

d1655 2
a1656 2
      strcpy(arg,arg1);
      if ((clan_num = find_clan_by_sid(arg2)) < 0) {
d1669 6
a1674 3
  if(!(*arg)) {
    send_to_char("Set to which level?\r\n",ch);
    return;
d1712 4
a1715 1
    send_clan_format(ch);
d1726 2
a1727 2
      strcpy(arg,arg1);
      if ((clan_num = find_clan_by_sid(arg2)) < 0) {
a1808 12
  * Once this is going, Don't ask me how I did it.. Or to repeat it.. The
  * in-built editor stuff is a fucking bitch to say the least. - ARTUS.
  *
  * Well.. At long last. I think it's going!
  * Hurdle overcome. Time to start doing some more shit :o)
  *
  * Oh shit.. Looks like I am going to have to repeat it.. BITCH! In the 
  * room description editor.. I think that can go to low priority ;o)..
  *
  * Wow.. Look at that.. Made a nice little routine that makes this kinda
  * shit a synch. (act.modify.c, do_odd_write())
  *
d1838 1
a1838 1
  send_to_char("\r\nClan privileges:\r\n", ch);
d1852 17
a1868 12
  if(GET_LEVEL(ch)<=LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
      return; 
    }
    if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_ROOM]) {
      send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
      return; 
    }
  } else {
    send_to_char("Use OLC you slacker.\r\n",ch);
    return;
d1991 5
d2046 14
a2059 3
  if (GET_LEVEL(ch) > LVL_IMMORT) {
    send_to_char("Use olc slacker, and if you can't.. Whinge :o)\r\n", ch);
    return;
d2061 1
a2065 4
  if (GET_CLAN_RANK(ch) < clan[clan_num].privilege[CP_ENHANCE]) {
    send_to_char("You aren't privileged enough to name your mobs.\r\n", ch);
    return;
  }
d2174 13
a2186 10
  if(GET_LEVEL(ch)<=LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
      return; }
    if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_ENHANCE]) {
      send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
      return; }
  } else {
    send_to_char("Use OLC you slacker.\r\n",ch);
    return;
d2188 1
a2188 1
  
d2255 1
a2255 4
      if((c=find_clan_by_id(GET_CLAN(ch))) < 0) {
	send_to_char("Bug in command. Please report.\r\n", ch);
	return;
      }
a2347 1
      break;
d2350 2
a2351 2
      strcpy(arg,arg1);
      if((c=find_clan_by_sid(arg2))<0) {
a2439 9

/* Bug: 1 - After enhancing, seems to load 4 into a room rather than 1.. ??!
 * Bug: 2 - After enhancing, specproc seems to get lost..
 *
 * This hopefully will be fixed by freeing the former address, and creating
 * a new one, then going from there.. only one way to find out :o)..
 *
 * .... This is fine now i think...
 */
d2449 13
a2461 10
  if(GET_LEVEL(ch)<=LVL_IMMORT) {
    if((clan_num=find_clan_by_id(GET_CLAN(ch)))<0) {
      send_to_char("You don't belong to any clan!\r\n",ch);
      return; }
    if(GET_CLAN_RANK(ch)<clan[clan_num].privilege[CP_ENHANCE]) {
      send_to_char("You're not influent enough in the clan to do that!\r\n",ch);
      return; }
  } else {
    send_to_char("Use OLC you slacker.\r\n",ch);
    return;
d2608 6
a2613 6
		 "   clan set appfee    <amount>    <clan num>\r\n"
                 "   clan set applev    <level>     <clan num>\r\n"
                 "   clan set privilege <privilege> <rank>     <clan num>\r\n"
                 "   clan set ranks     <number>    <clan num>\r\n"
                 "   clan set tax       <2-50>      <clan num>\r\n"
                 "   clan set title     <clan num>  <rank #>   <title>\r\n",ch);
d2654 1
a2654 1
  else if (is_abbrev(arg, "south"))
d2656 1
a2656 1
  else if (is_abbrev(arg, "east"))
d2658 1
a2658 1
  else if (is_abbrev(arg, "west"))
d2660 1
a2660 1
  else if (is_abbrev(arg, "up"))
d2662 1
a2662 1
  else if (is_abbrev(arg, "down")) 
a2687 1
//  if (is_abbrev(arg1, "reset"   )) { do_clan_reset(ch,arg2);    return ;}
d2712 4
a2719 1

a3308 2
    /* Sorry, DM, Removed requested switch statement in favor of something
     * smaller :o) */
@


1.5
log
@*** empty log message ***
@
text
@d78 1
a78 1
		 "   clan banish        <player> <clan num>\r\n"
d80 2
a81 2
		 "   clan demote        <player> <clan num>\r\n"
		 "   clan deposit       <amount> <clan num>\r\n"
d83 2
a84 2
		 "   clan disable       <option> <clan num>\r\n"
		 "   clan enable        <option> <clan num>\r\n"
d86 2
a87 2
		 "   clan promote       <player> <clan num>\r\n"
		 "   clan recruit       <player> <clan num>\r\n"
d93 1
a93 1
		 "   clan withdraw      <clan num>\r\n",ch);
d666 1
a666 1
  int clan_num,immcom=0;
d681 1
a681 7
      immcom=1;
      half_chop(arg,arg1,arg2);
      strcpy(arg,arg1);
      if ((clan_num = find_clan_by_sid(arg2)) < 0) {
        send_to_char("You must specify a clan id between 0 and 32.\r\n", ch);
        return;
      }
d695 6
d751 1
a751 1
  int clan_num,immcom=0,i,player_i = 0;
d767 1
a767 7
      immcom=1;
      half_chop(arg,arg1,arg2);
      strcpy(arg,arg1);
      if ((clan_num = find_clan_by_sid(arg2)) < 0) {
        send_to_char("Unknown clan specified.\r\n", ch);
        return; 
      } 
d778 1
a778 1
    if (GET_CLAN(vict) != clan[clan_num].id) {
d782 1
a782 1
    if (GET_CLAN_RANK(vict) >= GET_CLAN_RANK(ch)) {
d799 5
d834 1
a834 1
  int clan_num,immcom=0;
a848 6
      half_chop(arg,arg1,arg2);
      strcpy(arg,arg1);
      if((clan_num=find_clan_by_sid(arg2)) < 0) {
	send_to_char("That clan doesn't seem to exist.\r\n", ch);
	return;
      }
d862 1
a862 1
  if(GET_CLAN(vict)!=clan[clan_num].id) {
d866 4
d880 1
a880 1
  sprintf(buf, "%s has demoted you to %s.\r\n", ((CAN_SEE(ch, vict)) ? "someone" : ch->player.name), clan[clan_num].rank_name[GET_CLAN_RANK(vict)]);
d883 1
a883 1
  sprintf(cin, "%s has been demoted to %s.", GET_NAME(vict), clan[clan_num].rank_name[GET_CLAN_RANK(vict)]);
d892 1
a892 1
  int clan_num,immcom=0;
a903 6
      half_chop(arg,arg1,arg2);
      strcpy(arg,arg1);
      if ((clan_num = find_clan_by_sid(arg2)) < 0) {
        send_to_char("Unknown clan specified.\r\n", ch);
        return; 
      } 
d922 6
a927 1
  if(GET_CLAN(vict) != clan[clan_num].id) {
d931 1
d936 1
a936 1
  if((GET_CLAN_RANK(vict) >= GET_CLAN_RANK(ch)) && !immcom) {
a943 5
  if(do_clan_charge(ch, CLC_PROMOTE) < 1) {
    sprintf(buf, "They can't afford the %d coin promotion fee.\r\n", CLC_PROMOTE);
    send_to_char(buf, ch);
    return;
  }
d946 1
a946 1
  sprintf(buf, "%s has promoted you to %s. (%d coins deducted.)\r\n", ((CAN_SEE(ch, vict)) ? "someone" : ch->player.name), clan[clan_num].rank_name[GET_CLAN_RANK(vict)], CLC_PROMOTE);
d949 1
a949 1
  sprintf(cin, "%s promoted to %s.", GET_NAME(vict), clan[clan_num].rank_name[GET_CLAN_RANK(vict)]);
d1283 1
a1283 1
      strcpy(arg,arg1);
@


1.4
log
@Modified: Artus - Removed spells.h include.
@
text
@d45 1
d57 1
d152 1
a152 3
/* do_clan_reset - Debug function of ARTUS's. 
 * This function will end up tearing down clan halls and setting healers and
 * guards back to the way they should be... Wish me luck! TODO - ARTUS */
d156 2
a157 2
  struct char_data *guard, *healer, *oldmob;
  struct room_data *room;
d159 1
d178 13
a190 22
  guard = &mob_proto[real_mobile(c + (CLAN_ZONE * 100))];
  healer = &mob_proto[real_mobile(c + (CLAN_ZONE * 100) + 32)];
  free(GET_LDESC(guard));
  free(GET_LDESC(healer));
  free(GET_DDESC(guard));
  free(GET_DDESC(healer));
  GET_LDESC(guard) = str_dup("A clan guard stands here.\r\n");
  GET_LDESC(healer) = str_dup("A clan healer stands here.\r\n");
  GET_DDESC(guard) = str_dup("It looks unfinished.\r\n");
  GET_DDESC(healer) = str_dup("It looks unfinished.\r\n");
  GET_LEVEL(guard) = GET_LEVEL(healer) = 50;
  GET_NDD(guard) = GET_SDD(guard) = GET_NDD(healer) = GET_SDD(healer) = 1;
  GET_HITROLL(guard) = GET_DAMROLL(guard) = GET_HITROLL(healer) = GET_DAMROLL(healer) = 50;
  GET_HIT(guard) = GET_MANA(guard) = GET_HIT(healer) = GET_MANA(healer) = 1;
  GET_MOVE(guard) = GET_MOVE(healer) = 10000;
  GET_AC(guard) = 100;
  
  for (oldmob = character_list; oldmob; oldmob = oldmob->next) {
    if (guard->nr == oldmob->nr)
      update_mobile_strings(oldmob, &mob_proto[guard->nr]);
    if (healer->nr == oldmob->nr)
      update_mobile_strings(oldmob, &mob_proto[healer->nr]);
d193 22
a218 1
  /* Vnums work out fine.. Need to get the rnums now.. */
d220 19
a238 18
  // sprintf(buf, "Clan Rooms: G%d, H%d", (c + (CLAN_ZONE*100)), (c + 32 + (CLAN_ZONE * 100)));
  room = &world[real_room(c + (CLAN_ZONE*100))]; /* Guard Post */
  free(room->name);
  room->name = strdup("Guard Post");
  free(room->description);
  room->description = strdup("This guard post is yet to be described.\r\n");
  REMOVE_BIT(room->room_flags, ROOM_REGEN_2);

  room = &world[real_room(c + 32 + (CLAN_ZONE*100))]; /* Hall */
  free(room->name);
  room->name = strdup("Clan Hall");
  for (i = 0; i < NUM_OF_DIRS; i++)
    if (!(((c % 2 == 1) && (i == EAST)) || ((c % 2 == 0) && (i == WEST))))
      room->dir_option[i] = NULL;
    
  free(room->description);
  room->description = strdup("This clan hall is yet to be described.\r\n");
  REMOVE_BIT(room->room_flags, ROOM_REGEN_2);
a239 6
  for (i = 2;i <= CLAN_ROOM_MAX;i++) {
    room = &world[real_room(c + (CLAN_ZONE*100) + (i * 32))]; /* Rooms */
    free(room->name);
    room->name = strdup("Clan Room");
    for (j = 0; j < NUM_OF_DIRS; j++)
      room->dir_option[j] = NULL;
d241 1
a241 1
    room->description = strdup("This clan room is yet to be described.\r\n");
d243 18
d474 1
d954 1
a954 1
  sprintf(buf, "%s has promoted you to %s.", ((CAN_SEE(ch, vict)) ? "someone" : ch->player.name), clan[clan_num].rank_name[GET_CLAN_RANK(vict)]);
d958 1
a958 1
  do_clan_infocom(GET_CLAN(vict), 0, buf1);
d1128 1
a1128 1
  sprintf(buf, "You submit your application to %s.\r\n", clan[clan_num].name);
d1411 1
a1411 1
      amount /= 100; /* I know this seems silly.. But need the result to be */
d1426 3
a1428 1
      send_to_char("You change the tax rate.\r\n",ch);
d1537 3
a1539 1

d1622 2
a1623 1
  send_to_char("Done.\r\n",ch);
d1892 2
a1893 1
      send_to_char("The title of your clan room has been changed.\r\n", ch);
d1918 3
a1920 1
      send_to_char("Current room is now REGENX2.\r\n", ch);
d1981 2
a1982 1
    send_to_char("You watch in amazement as a clan room builds itself before you.\r\n", ch);
d2075 1
a2075 1
    sprintf(buf, "Set guard's name to '%s'.\r\n", arg2);
d2084 1
a2084 1
    if (save_mobiles(real_zone(CLAN_ZONE)) != FALSE)
d2086 1
a2086 1
    else
d2088 2
a2089 1

d2120 1
a2120 1
    sprintf(buf, "Set healer's name to '%s'.\r\n", arg2);
d2128 7
d2355 2
a2356 1
      send_to_char("Your clan hall is now ready for you to move in.\r\n", ch);
d2372 2
a2373 1
      send_to_char("Clan talk is now enabled for your clan.\r\n", ch);
d2389 2
a2390 1
      send_to_char("Your clan healer is now set up.\r\n", ch);
d2406 2
a2407 1
      send_to_char("Your clan board is now set up.\r\n", ch);
d2429 1
d2567 2
a2568 1
  sprintf(buf, "%s has been enhanced to level %d.\r\n", GET_NAME(mob), GET_LEVEL(mob));
d2857 1
a2857 1
void pun_aggro_check (struct char_data *ch)
d2860 1
d2865 1
a2865 1
    if ((FIGHTING(i) == NULL) && (CAN_SEE(i, ch)) && (AWAKE(i))) {
d2868 1
d2871 1
d2968 2
@


1.3
log
@Modified: Artus - New clan system.. Punishment stuff..
@
text
@a24 1
#include "spells.h"
d2816 1
a2816 1
      hit(i, ch, TYPE_UNDEFINED);
@


1.2
log
@

Added:
-
-

Removed:
-
-

Changed:
-
-

TODO:
-
-
@
text
@d1 16
d19 1
d22 2
d25 1
a25 2
#include "db.h"
#include "comm.h"
d28 29
d58 5
a62 1
extern struct clan_data clan_info[NUM_CLANS];
d64 6
a69 5
/***************************************************************************/
/* Clan functions -Hal, cleaned up by DM                                   */
/***************************************************************************/
 
ACMD(do_signup)
d71 22
a92 3
 
  if (GET_LEVEL(ch) < 10) {
    send_to_char("You can't join a clan till level 10!\r\n", ch);
d95 10
a104 3
 
  if (GET_CLAN_NUM(ch) >= 0) {
    send_to_char("You are already in a clan!\r\n", ch);
d107 41
a148 7
  if (EXT_FLAGGED(ch, EXT_CLAN)) {
    send_to_char("You don't want to join a clan now.\r\n", ch);
    REMOVE_BIT(EXT_FLAGS(ch), EXT_CLAN);
  } else {
    send_to_char("You want to join a clan now.\r\n", ch );
    SET_BIT(EXT_FLAGS(ch), EXT_CLAN);
  }
d150 5
a154 2
 
ACMD(do_recruit)
d156 7
a162 7
  struct char_data *vict;
  char vict_name[MAX_INPUT_LENGTH];
 
  one_argument(argument, vict_name);
 
  if (!EXT_FLAGGED(ch, EXT_LEADER) && !EXT_FLAGGED(ch, EXT_SUBLEADER)) {
    send_to_char("You are not a clan leader or a knight.\r\n", ch);
d165 2
a166 3
 
  if (!(vict = get_char_room_vis(ch, vict_name))) { 
    send_to_char("There is no one here by that name to recruit\r\n", ch);
d169 3
a171 4
 
  if (IS_NPC(vict)) {
    sprintf(buf, "You can't recruit %s!\r\n", HMHR(vict));
    send_to_char(buf, ch);
d174 74
d249 16
a264 4
  if (GET_CLAN_NUM(vict) >= 0) {
    sprintf(buf, "%s is already in a clan!\r\n", HSSH(vict));
    buf[0] = toupper(buf[0]);
    send_to_char(buf, ch);
d266 10
d278 69
a346 3
  if (!(EXT_FLAGGED(vict, EXT_CLAN))) {
    sprintf(buf, "%s does not want to be in a clan.\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
d348 12
d361 2
a362 6
 
  GET_CLAN_NUM(vict)=GET_CLAN_NUM(ch);
  sprintf(buf, "You are now a member of the %s.\r\n", get_clan_disp(vict));
  send_to_char(buf, vict);
  sprintf(buf, "%s is now a member of the %s.\r\n", GET_NAME(vict), get_clan_disp(vict));
  send_to_char(buf, ch);
d364 3
a366 2
 
ACMD(do_knight)
d368 39
a406 7
  struct char_data *vict;
  char vict_name[MAX_INPUT_LENGTH];
 
  one_argument(argument, vict_name);
 
  if (!(vict = get_char_room_vis(ch, vict_name))) {
    send_to_char("There is no one here by that name to knight.\r\n", ch);
d409 30
a438 20
 
  if (check_clan(ch, vict, 0)) {
    if (EXT_FLAGGED(vict, EXT_LEADER)) {
      send_to_char("But they are aready a leader.\r\n", ch);
      return;
    }
 
    if (EXT_FLAGGED(vict, EXT_SUBLEADER)) {
      sprintf(buf, "%s has been striped of %s knighthood.\r\n", GET_NAME(vict), HSHR(vict));
      send_to_char(buf, ch);
      sprintf(buf, "Your knighthood has been taken from you.\r\n" );
      send_to_char(buf, vict);
      REMOVE_BIT(EXT_FLAGS(vict), EXT_SUBLEADER);
    } else {
      sprintf(buf, "%s is now a knight.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
      sprintf(buf, "You are now a knight.\r\n");
      send_to_char(buf, vict);
      SET_BIT(EXT_FLAGS(vict), EXT_SUBLEADER);
    }
d440 14
d455 4
a458 2
 
ACMD(do_banish)
d460 23
a482 8
  struct char_data *vict;  char
  vict_name[MAX_INPUT_LENGTH];
 
  one_argument(argument, vict_name);
 
  if (!(vict = get_char_room_vis(ch, vict_name))) {
    send_to_char("There is no one here by that name to banish\r\n", ch);
    return;
d484 3
a486 16
 
  if (check_clan(ch, vict, 0)) {
    sprintf(buf, "You have been banished from the %s.\r\n", get_clan_disp(vict));
    send_to_char(buf, vict);
    sprintf(buf, "%s has been banished from the %s.\r\n", GET_NAME(vict), get_clan_disp(vict));
    GET_CLAN_NUM(vict) = -1;
 
    GET_CLAN_LEV(vict) = 0;
    REMOVE_BIT(EXT_FLAGS(vict), EXT_CLAN);
 
    if (EXT_FLAGGED(vict, EXT_SUBLEADER))
      REMOVE_BIT(EXT_FLAGS(vict), EXT_SUBLEADER);
 
    if (EXT_FLAGGED(vict, EXT_LEADER))
      REMOVE_BIT(EXT_FLAGS(vict), EXT_LEADER);
 
d489 13
d503 3
a505 2
 
ACMD(do_demote)
d507 9
a515 7
  struct char_data *vict;
  char vict_name[MAX_INPUT_LENGTH];
 
  one_argument(argument, vict_name);
 
  if (!(vict = get_char_room_vis(ch, vict_name))) {
    send_to_char("There is no one here by that name to demote\r\n", ch);
d518 4
a521 8
 
  if (check_clan(ch, vict, 0)) {
    if (GET_CLAN_LEV(vict) != 0) {
      GET_CLAN_LEV(vict)--;
      sprintf(buf, "You have been demoted to the rank of %s.\r\n", get_clan_rank(vict));
      send_to_char(buf, vict);
 
      sprintf(buf, "%s has been demoted to the rank of %s.\r\n", GET_NAME(vict), get_clan_rank(vict));
d523 24
d548 25
a572 4
      sprintf(buf, "%s aready has the lowest rank.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
    }
  } 
d574 4
a577 2
 
ACMD(do_promote)
d579 8
a586 7
  struct char_data *vict;
  char vict_name[MAX_INPUT_LENGTH];
 
  one_argument(argument, vict_name);
 
  if (!(vict = get_char_room_vis(ch, vict_name))) {
    send_to_char("There is no one here by that name to promote\r\n", ch);
d589 26
a614 13
 
  if (check_clan(ch, vict, 0)) {
    if (GET_CLAN_LEV(vict) != (NUM_CLAN_RANKS - 1)) {
      GET_CLAN_LEV(vict) ++ ;
 
      sprintf(buf, "You have been promoted to the rank of %s.\r\n", get_clan_rank(vict));
      send_to_char(buf, vict);
 
      sprintf(buf, "%s has been promoted to the rank of %s.\r\n", GET_NAME(vict), get_clan_rank(vict));
      send_to_char(buf, ch);
    } else {
      sprintf(buf, "%s has aready reached the highest rank.\r\n", GET_NAME(vict));
      send_to_char(buf, ch);
d617 17
d636 2
a637 1
char *get_clan_rank(struct char_data *ch)
d639 62
a700 5
  if ((GET_CLAN_NUM(ch) < 0) || (GET_CLAN_NUM(ch) >= NUM_CLANS) 
	|| (GET_CLAN_LEV(ch) < 0 || GET_CLAN_LEV(ch) > NUM_CLAN_RANKS)) 
    return "";
  else
    return clan_info[GET_CLAN_NUM(ch)].ranks[GET_CLAN_LEV(ch)] ;
d702 3
a704 2
 
char *get_clan_disp(struct char_data *ch)
d706 12
a717 4
  if ((GET_CLAN_NUM(ch) < 0) || (GET_CLAN_NUM(ch) >= NUM_CLANS)) 
    return "";
  else
    return clan_info[GET_CLAN_NUM(ch)].disp_name ;
d719 3
a721 2
 
char *get_clan_name(int cnum)
d723 7
a729 5
  if ((cnum < 0) || (cnum >= NUM_CLANS)) 
    return "";
  else
    return clan_info[cnum].name ;
} 
d731 3
a733 12
int check_clan(struct char_data *ch, struct char_data *vict, int sub_allow)
{
  char buf [100];
 
  if (sub_allow) {
    if (!EXT_FLAGGED(ch, EXT_LEADER) && !EXT_FLAGGED(ch, EXT_SUBLEADER)) {
      send_to_char("You are not a clan leader or a knight.\r\n", ch);
          return 0;
    }
  } else if (!EXT_FLAGGED(ch, EXT_LEADER)) {
    send_to_char("You are not a clan leader.\r\n", ch);
    return 0;
d735 20
a754 5
 
  if (!(EXT_FLAGGED(vict, EXT_CLAN))) {
    sprintf(buf, "%s is not even in a clan.\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
    return 0;
d756 11
a766 3
 
  if (GET_CLAN_NUM(vict) != GET_CLAN_NUM(ch)) {
    sprintf(buf, "%s is not in your clan.\r\n", GET_NAME(vict));
d768 9
a776 1
    return 0;
a777 3
 
  return 1;
} 
d779 24
a802 10
/* DM - search for clan by name */
struct clan_data *get_clan_by_name(char *name)
{
  int i;
 
  for (i=0; i < NUM_CLANS; i++)
    if (isname(name, clan_info[i].name))
      return &(clan_info[i]);
 
  return NULL;
d804 3
a806 3
 
/* DM - search for clan by num */
struct clan_data *get_clan_by_num(int num)
d808 450
a1257 2
  if ((num >= 0) && (num < NUM_CLANS))
    return &(clan_info[num]);
d1259 2114
a3372 1
    return NULL;
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@@

