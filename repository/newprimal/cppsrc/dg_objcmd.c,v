head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	2004.02.23.03.02.19;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.10.12.02.26;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.06.04.32.50;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.04.10.35.00;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.09.05.42.45;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.27.06.16.00;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.21.02.48.05;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.13.01.05.29;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.26.06.49.03;	author primal;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.09.03.36.42;	author artus;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.02.04.34.46;	author primal;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Artus> Added ozoneecho (%zoneecho%)
@
text
@/**************************************************************************
*  File: objcmd.c                                                         *
*  Usage: contains the command_interpreter for objects,                   *
*         object commands.                                                *
*                                                                         *
*                                                                         *
*  $Author: mud $
*  $Date: 2004/01/10 12:02:26 $
*  $Revision: 1.10 $
**************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "screen.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h" // Artus> for SKILL_PERCEPTION (required by OBJN)

extern struct room_data *world;
extern struct index_data *obj_index;
extern const char *dirs[];
extern int dg_owner_purged;

char_data *get_char_by_obj(obj_data *obj, char *name);
obj_data *get_obj_by_obj(obj_data *obj, char *name);
void sub_write(char *arg, char_data *ch, byte find_invis, int targets);
room_data *get_room(char *name);
long asciiflag_conv(char *flag);

#define OCMD(name)  \
   void (name)(obj_data *obj, char *argument, int cmd, int subcmd)


struct obj_command_info {
   char *command;
   void        (*command_pointer)(obj_data *obj, char *argument, int cmd, int subcmd);
   int subcmd;
};


/* do_osend */
#define SCMD_OSEND         0
#define SCMD_OECHOAROUND   1



/* attaches object name and vnum to msg and sends it to script_log */
void obj_log(obj_data *obj, char *msg)
{
    char buf[MAX_INPUT_LENGTH + 100];

    void script_log(char *msg);

    sprintf(buf, "Obj (%s, VNum %d): %s",
           obj->short_description, GET_OBJ_VNUM(obj), msg);
    script_log(buf);
}


/* returns the real room number that the object or object's carrier is in */
int obj_room(obj_data *obj)
{
    if (obj->in_room != NOWHERE)
       return obj->in_room;
    else if (obj->carried_by)
       return IN_ROOM(obj->carried_by);
    else if (obj->worn_by)
       return IN_ROOM(obj->worn_by);
    else if (obj->in_obj)
       return obj_room(obj->in_obj);
    else
       return NOWHERE;
}


/* returns the real room number, or NOWHERE if not found or invalid */
sh_int find_obj_target_room(obj_data *obj, char *rawroomstr)
{
    int tmp;
    sh_int location;
    char_data *target_mob;
    obj_data *target_obj;
    char roomstr[MAX_INPUT_LENGTH];

    one_argument(rawroomstr, roomstr);

    if (!*roomstr)
       return NOWHERE;

    if (isdigit(*roomstr) && !strchr(roomstr, '.'))
    {
       tmp = atoi(roomstr);
       if ((location = real_room(tmp)) < 0)
           return NOWHERE;
    }

    else if ((target_mob = get_char_by_obj(obj, roomstr)))
       location = IN_ROOM(target_mob);
    else if ((target_obj = get_obj_by_obj(obj, roomstr)))
    {
       if (target_obj->in_room != NOWHERE)
           location = target_obj->in_room;
       else 
           return NOWHERE;
    }
    else
       return NOWHERE;
  
    /* a room has been found.  Check for permission */
    if (ROOM_FLAGGED(location, ROOM_GODROOM) || 
#ifdef ROOM_IMPROOM
       ROOM_FLAGGED(location, ROOM_IMPROOM) ||
#endif
       ROOM_FLAGGED(location, ROOM_HOUSE))
       return NOWHERE;

    if (ROOM_FLAGGED(location, ROOM_PRIVATE) &&
       world[location].people && world[location].people->next_in_room)
       return NOWHERE;

    return location;
}



/* Object commands */

OCMD(do_oecho)
{
    int room;

    skip_spaces(&argument);
  
    if (!*argument) 
       obj_log(obj, "oecho called with no args");

    else if ((room = obj_room(obj)) != NOWHERE)
    {
       if (world[room].people)
           sub_write(argument, world[room].people, TRUE, TO_ROOM | TO_CHAR);
    }
  
    else
       obj_log(obj, "oecho called by object in NOWHERE");
}

// Artus> ZoneEcho.
OCMD(do_ozoneecho)
{
  int room;
  void send_to_zone(const char *msg, zone_rnum zone);

  skip_spaces(&argument);
  if (!*argument) 
  {
    obj_log(obj, "ozoneecho called with no args");
    return;
  }
  if ((room = obj_room(obj)) == NOWHERE)
  {
    obj_log(obj, "ozoneecho called by object in NOWHERE");
    return;
  }
  send_to_zone(argument, world[room].zone);
}

OCMD(do_oforce)
{
    char_data *ch, *next_ch;
    int room;
    char arg1[MAX_INPUT_LENGTH], *line;

    line = one_argument(argument, arg1);
  
    if (!*arg1 || !*line)
    {
       obj_log(obj, "oforce called with too few args");
       return;
    }
  
    if (!str_cmp(arg1, "all"))
    {
       if ((room = obj_room(obj)) == NOWHERE) 
           obj_log(obj, "oforce called by object in NOWHERE");
       else
       {
           for (ch = world[room].people; ch; ch = next_ch)
           {
               next_ch = ch->next_in_room;
       
               if (LR_FAIL(ch, LVL_IS_GOD))
               {
                   command_interpreter(ch, line);
               } else if (ch->desc) {
		 sprintf(buf, "%s tried to force you to %s.\r\n", OBJN(obj, ch),
		         argument);
		 send_to_char(buf, ch);
	       }
           }
       }      
    }
  
    else
    {
       if ((ch = get_char_by_obj(obj, arg1)))
       {
           if (LR_FAIL(ch, LVL_IS_GOD))
           {
               command_interpreter(ch, line);
           } else if (ch->desc) {
	     sprintf(buf, "%s tried to force you to %s.\r\n", OBJN(obj, ch),
		     argument);
	     send_to_char(buf, ch);
	   }
       }
    
       else
           obj_log(obj, "oforce: no target found");
    }
}


OCMD(do_osend)
{
    char buf[MAX_INPUT_LENGTH], *msg;
    char_data *ch;
    room_rnum tr;
  
    msg = any_one_arg(argument, buf);

    if (!*buf)
    {
       obj_log(obj, "osend called with no args");
       return;
    }

    skip_spaces(&msg);

    if (!*msg)
    {
       obj_log(obj, "osend called without a message");
       return;
    }

    if ((ch = get_char_by_obj(obj, buf)))
    {
       if (subcmd == SCMD_OSEND)
           sub_write(msg, ch, TRUE, TO_CHAR);
       else if (subcmd == SCMD_OECHOAROUND)
           sub_write(msg, ch, TRUE, TO_ROOM);
    } else if (is_number(buf) && ((tr = real_room(atoi(buf))) >= 0)) {
      strcat(msg, "\r\n");
      send_to_room(msg, tr);
    }
    else
       obj_log(obj, "no target found for osend");
}

/* increases the target's exp */
OCMD(do_oexp)
{
    char_data *ch;
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

    two_arguments(argument, name, amount);

    if (!*name || !*amount)
    {
       obj_log(obj, "oexp: too few arguments");
       return;
    }
    
    if ((ch = get_char_by_obj(obj, name))) 
       gain_exp(ch, atoi(amount));
    else
    {
       obj_log(obj, "oexp: target not found");
       return;
    }
}


/* set the object's timer value */
OCMD(do_otimer)
{
  char arg[MAX_INPUT_LENGTH];

  one_argument(argument, arg);

  if (!*arg)
    obj_log(obj, "otimer: missing argument");
  else if (!isdigit(*arg)) 
    obj_log(obj, "otimer: bad argument");
  else
    GET_OBJ_TIMER(obj) = atoi(arg);
}


/* transform into a different object */
/* note: this shouldn't be used with containers unless both objects */
/* are containers! */
OCMD(do_otransform)
{
  char arg[MAX_INPUT_LENGTH];
  obj_data *o, tmpobj;
  struct char_data *wearer=NULL;
  int pos=-1;

  one_argument(argument, arg);

  if (!*arg)
    obj_log(obj, "otransform: missing argument");
  else if (!isdigit(*arg)) 
    obj_log(obj, "otransform: bad argument");
  else {
    o = read_object(atoi(arg), VIRTUAL);
    if (o==NULL) {
      obj_log(obj, "otransform: bad object vnum");
      return;
    }

    if (obj->worn_by) {
      pos = obj->worn_on;
      wearer = obj->worn_by;
      unequip_char(obj->worn_by, pos, FALSE);
    }

    /* move new obj info over to old object and delete new obj */
    memcpy(&tmpobj, o, sizeof(*o));
    tmpobj.in_room = obj->in_room;
    tmpobj.carried_by = obj->carried_by;
    tmpobj.worn_by = obj->worn_by;
    tmpobj.worn_on = obj->worn_on;
    tmpobj.in_obj = obj->in_obj;
    tmpobj.contains = obj->contains;
    tmpobj.id = obj->id;
    tmpobj.proto_script = obj->proto_script;
    tmpobj.script = obj->script;
    tmpobj.next_content = obj->next_content;
    tmpobj.next = obj->next;
    memcpy(obj, &tmpobj, sizeof(*obj));

    if (wearer) {
      equip_char(wearer, obj, pos, FALSE);
    }

    extract_obj(o);
  }
}


/* purge all objects an npcs in room, or specified object or mob */
OCMD(do_opurge)
{
    char arg[MAX_INPUT_LENGTH];
    char_data *ch, *next_ch;
    obj_data *o, *next_obj;
    int rm;

    one_argument(argument, arg);
  
    if (!*arg)
    {
       if ((rm = obj_room(obj)) != NOWHERE)
       {
           for (ch = world[rm].people; ch; ch = next_ch )
           {
               next_ch = ch->next_in_room;
               if (IS_NPC(ch))
                   extract_char(ch);
           }
    
           for (o = world[rm].contents; o; o = next_obj )
           {
               next_obj = o->next_content;
               if (o != obj)
	       {
		 if (GET_CORPSEID(o) != 0) 
		   obj_log(obj, "opurge: Refusing to purge player's corpse!");
		 else
		   extract_obj(o);
	       }
           }
       }
    
       return;
    }
  
    if (!(ch = get_char_by_obj(obj, arg)))
    {
       if ((o = get_obj_by_obj(obj, arg))) 
       {
	 if (GET_CORPSEID(o) != 0)
	 {
	   obj_log(obj, "opurge: Refusing to purge player's corpse!");
	   return;
	 }
         if (o==obj) dg_owner_purged = 1;
         extract_obj(o);
       } else 
           obj_log(obj, "opurge: bad argument");
    
       return;
    }
  
    if (!IS_NPC(ch))
    {
       obj_log(obj, "opurge: purging a PC");
       return;
    }
  
    extract_char(ch);
}


OCMD(do_oteleport)
{
    char_data *ch, *next_ch;
    sh_int target, rm;
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

    two_arguments(argument, arg1, arg2);
  
    if (!*arg1 || !*arg2)
    {
       obj_log(obj, "oteleport called with too few args");
       return;
    }

    target = find_obj_target_room(obj, arg2);
  
    if (target == NOWHERE) 
       obj_log(obj, "oteleport target is an invalid room");
  
    else if (!str_cmp(arg1, "all"))
    {
       rm = obj_room(obj);
       if (target == rm)
	 obj_log(obj, "oteleport target is itself");
       for (ch = world[rm].people; ch; ch = next_ch)
       {
	 next_ch = ch->next_in_room;
	 if (LR_FAIL(ch, LVL_IS_GOD))
	 {
	   char_from_room(ch);
	   char_to_room(ch, target);
	 } else if (ch->desc) {
	   sprintf(buf, "%s tried to teleport you to room %d.\r\n", 
	           OBJN(obj, ch), world[target].number);
	   send_to_char(buf, ch);
	 }
       }
    } else {
       if ((ch = get_char_by_obj(obj, arg1)))
       {
	 if (LR_FAIL(ch, LVL_IS_GOD))
	 {
	   char_from_room(ch);
	   char_to_room(ch, target);
	 } else if (ch->desc) {
	   sprintf(buf, "%s tried to teleport you to room %d.\r\n", 
	           OBJN(obj, ch), world[target].number);
	   send_to_char(buf, ch);
	 }
       } else
	 obj_log(obj, "oteleport: no target found");
    }
}


OCMD(do_dgoload)
{
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int number = 0, room;
    char_data *mob;
    obj_data *object;

    two_arguments(argument, arg1, arg2);

    if (!*arg1 || !*arg2 || !is_number(arg2) || ((number = atoi(arg2)) < 0))
    {
        obj_log(obj, "oload: bad syntax");
        return;
    }
 
    if ((room = obj_room(obj)) == NOWHERE)
    {
        obj_log(obj, "oload: object in NOWHERE trying to load");
        return;
    }
    
    if (is_abbrev(arg1, "mob"))
    {
        if ((mob = read_mobile(number, VIRTUAL)) == NULL)
        {
            obj_log(obj, "oload: bad mob vnum");
            return;
        }
        char_to_room(mob, room);
        load_mtrigger(mob);
    }
     
    else if (is_abbrev(arg1, "obj"))
    {
        if ((object = read_object(number, VIRTUAL)) == NULL)
        {
            obj_log(obj, "oload: bad object vnum");
            return;
        }

        obj_to_room(object, room);
        load_otrigger(object);
    }
         
    else
        obj_log(obj, "oload: bad type");

}

OCMD(do_odamage) {
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
    int dam = 0;
    char_data *ch;

    two_arguments(argument, name, amount);

    if (!*name || !*amount || !isdigit(*amount)) 
    {
       obj_log(obj, "odamage: bad syntax");
       return;
    }

    dam = atoi(amount);

    if ((ch = get_char_by_obj(obj, name))) 
    {
       if (!(LR_FAIL(ch, LVL_IS_GOD)))
       {
           send_to_char("Being the cool immortal you are, you sidestep a trap, obviously placed to kill you\r\n.", ch);
           return;
       }
       if (!IS_NPC(ch) || !MOB_FLAGGED(ch, MOB_NOKILL))
       {
	 // Artus> Replaced with damage() call.
	 // GET_HIT(ch) -= dam;
	 damage(NULL, ch, dam, TYPE_UNDEFINED, FALSE);
	 update_pos(ch);
       }
       switch (GET_POS(ch)) 
       {
	 case POS_MORTALLYW:
	   act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
	   send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
	   break;
	 case POS_INCAP:
	   act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
	   send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
	   break;
	 case POS_STUNNED:
	   act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
	   send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
	   break;
	 case POS_DEAD:
	   act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
	   send_to_char("You are dead!  Sorry...\r\n", ch);
	   break;
	 default:                        /* >= POSITION SLEEPING */
	   if (dam > (GET_MAX_HIT(ch) >> 2))
	       act("That really did HURT!", FALSE, ch, 0, 0, TO_CHAR);
	   if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)) 
	   {
	     sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
		     CCRED(ch, C_SPR), CCNRM(ch, C_SPR));
	     send_to_char(buf2, ch);
	   }
       }
       if (GET_POS(ch) == POS_DEAD) 
       {
/*       Artus> Logging will be handled by die().
         if (!IS_NPC(ch)) 
	 {
	   sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
		   world[ch->in_room].name);
	   mudlog(buf2, BRF, 0, TRUE);
	 }
*/
	 if (!IS_NPC(ch))
	 {
	   char diemsg[MAX_STRING_LENGTH] = "";
	   sprintf(diemsg, "object #%d (%s)", GET_OBJ_VNUM(obj), obj->name);
	   die(ch, NULL, diemsg);
	 } else
	   die(ch, NULL);
       }
    }
    else
       obj_log(obj, "odamage: target not found");
}


OCMD(do_odoor)
{
    char target[MAX_INPUT_LENGTH], direction[MAX_INPUT_LENGTH];
    char field[MAX_INPUT_LENGTH], *value;
    room_data *rm;
    struct room_direction_data *exit;
    int dir, fd, to_room;

    const char *door_field[] = {
       "purge",
       "description",
       "flags",
       "key",
       "name",
       "room",
       "\n"
    };


    argument = two_arguments(argument, target, direction);
    value = one_argument(argument, field);
    skip_spaces(&value);

    if (!*target || !*direction || !*field) {
       obj_log(obj, "odoor called with too few args");
       return;
    }
  
    if ((rm = get_room(target)) == NULL) {
       obj_log(obj, "odoor: invalid target");
       return;
    }
  
    if ((dir = search_block(direction, dirs, FALSE)) == -1) {
       obj_log(obj, "odoor: invalid direction");
       return;
    }

    if ((fd = search_block(field, door_field, FALSE)) == -1) {
       obj_log(obj, "odoor: invalid field");
       return;
    }

    exit = rm->dir_option[dir];

    /* purge exit */
    if (fd == 0) {
       if (exit) {
           if (exit->general_description)
               free(exit->general_description);
           if (exit->keyword)
               free(exit->keyword);
           free(exit);
           rm->dir_option[dir] = NULL;
       }
    }

    else {
       if (!exit) {
           CREATE(exit, struct room_direction_data, 1);
           rm->dir_option[dir] = exit; 
       }
    
       switch (fd) {
       case 1:  /* description */
           if (exit->general_description)
               free(exit->general_description);
           CREATE(exit->general_description, char, strlen(value) + 3);
           strcpy(exit->general_description, value);
           strcat(exit->general_description, "\r\n");
           break;
       case 2:  /* flags       */
           exit->exit_info = (sh_int)asciiflag_conv(value);
           break;
       case 3:  /* key         */
           exit->key = atoi(value);
           break;
       case 4:  /* name        */
           if (exit->keyword)
               free(exit->keyword);
           CREATE(exit->keyword, char, strlen(value) + 1);
           strcpy(exit->keyword, value);
           break;
       case 5:  /* room        */
           if ((to_room = real_room(atoi(value))) != NOWHERE)
               exit->to_room = to_room;
           else
               obj_log(obj, "odoor: invalid door target");
           break;
       }
    }
}


OCMD(do_osetval)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  int position, new_value;

  two_arguments(argument, arg1, arg2);
  if (!arg1 || !*arg1 || !arg2 || !*arg2 ||
      !is_number(arg1) || !is_number(arg2)) {
    obj_log(obj, "osetval: bad syntax");
    return;
  }

  position = atoi(arg1);
  new_value = atoi(arg2);
  if (position>=0 && position<NUM_OBJ_VAL_POSITIONS)
    GET_OBJ_VAL(obj, position) = new_value;
  else
    obj_log(obj, "osetval: position out of bounds!");
}

const struct obj_command_info obj_cmd_info[] = {
    { "RESERVED", 0, 0 },/* this must be first -- for specprocs */

    { "oecho"      , do_oecho    , 0 },
    { "oechoaround", do_osend    , SCMD_OECHOAROUND },
    { "oexp"       , do_oexp     , 0 },
    { "oforce"     , do_oforce   , 0 },
    { "oload"     , do_dgoload  , 0 },
    { "opurge"     , do_opurge   , 0 },
    { "osend"      , do_osend    , SCMD_OSEND },
    { "osetval"    , do_osetval  , 0 },
    { "oteleport"  , do_oteleport, 0 },
    { "odamage"    , do_odamage,   0 },
    { "otimer"     , do_otimer   , 0 },
    { "otransform" , do_otransform, 0 },
    { "odoor"      , do_odoor    , 0 },
    { "ozoneecho"  , do_ozoneecho, 0 },
    
    { "\n", 0, 0 }     /* this must be last */
};



/*
 *  This is the command interpreter used by objects, called by script_driver.
 */
void obj_command_interpreter(obj_data *obj, char *argument)
{
    int cmd, length;
    char *line, arg[MAX_INPUT_LENGTH];
  
    skip_spaces(&argument);
  
    /* just drop to next line for hitting CR */
    if (!*argument)
       return;

    line = any_one_arg(argument, arg);


    /* find the command */
    for (length = strlen(arg),cmd = 0;
        *obj_cmd_info[cmd].command != '\n'; cmd++)
       if (!strncmp(obj_cmd_info[cmd].command, arg, length))
           break;
  
    if (*obj_cmd_info[cmd].command == '\n')
    {
       sprintf(buf2, "Unknown object cmd: '%s'", argument);
       obj_log(obj, buf2);
    }
    else
       ((*obj_cmd_info[cmd].command_pointer) 
        (obj, line, cmd, obj_cmd_info[cmd].subcmd));
}

@


1.10
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d8 2
a9 2
*  $Date: 2004/01/06 04:32:50 $
*  $Revision: 1.9 $
d154 19
d738 1
@


1.9
log
@Artus>
act.informative.c: Fixed bug where examining a container was always listng the
                   objects in the first container matched.
                   Gold rush finishing is now only displayed within the same
		   world.
act.movement.c   : Environmental damage is now passed through damage().
act.offensive.c  : Throw() now calls damage().
act.other.c      : When you fail to create a torch, it hurts.
dg_mobcmd.c      : mdamage() now calls damage().
dg_objcmd.c      : odamage() now calls damage().
dg_wldcmd.c      : wdamage() now calls damage().
fight.c          : Changed damage() to allow a NULL ch.
interpreter.c    : Falling because fly has worn off now calls damage().
limits.c         : No waterbreathe underwater now calls damage().
magic.c          : Added handle_fireball() for fire breathing, fireball, type
                   stuff..
                   Random chance of objs in inventory/open containers burning
                   up :o)
spec_assign.c    : Removed some unused/wasted assigns: corridor_guard,
                   receiptionist, virus, bacteria.
spec_procs.c     : Removed some unused/wasted procs. Changed lots of tali's
                   indenting.
                   Fixed gaping hole in deadlyblade proc.
                   Replaced GET_HIT(vict) -= with damage(ch, vict...
spell_parser.c   : Added awake and can_see checks to magic fail = mob attacks.
@
text
@d8 2
a9 2
*  $Date: 2004/01/04 10:35:00 $
*  $Revision: 1.8 $
d179 1
a179 1
               if (GET_LEVEL(ch)<LVL_ANGEL)
d195 1
a195 1
           if (GET_LEVEL(ch)<LVL_ANGEL)
d431 1
a431 1
	 if (GET_LEVEL(ch) < LVL_ANGEL) 
d444 1
a444 1
	 if (GET_LEVEL(ch) < LVL_ANGEL) 
d525 1
a525 1
       if (GET_LEVEL(ch)>=LVL_ANGEL) 
@


1.8
log
@Artus> Intermittent build.
act.informative.c: Affect/Timers now display something when no affects/timers
                   are present.
                   Sense curse now senses objects inside containers.
act.movement.c   : Optimised the aggravate stuff a little.
act.offensive.c  : Logging death by pit trap.
act.other.c      : Logging death by suicide.
                   Superman now sets affects rather than actual stats, for STR
                   and CON (CON bonus is +1, STR is 21 - GET_REAL_STR
                   Logging death by arrow.
clan.c           : Removed aggravate_check() function, no longer used.
db.c             : Now initialising character specials.
dg_mobcmd.c      : Logging death by mdamage.
dg_objcmd.c      : Logging death by odamage.
dg_wldcmd.c      : Logging death by wdamage.
fight.c          : New optional msg paramater to die(), for if the death was
                   not caused by a character.
                   Deaths are now logged to info channel.
handler.c        : Modified ability affect function to permit more than one
                   affect modifier per special. (Required for superman)
spec_procs.c     : Logging death by pit trap, archers and room blast.
spells.h         : Added SPELL_SUPERMAN for special affect modifiers.
utils.h          : Updated die() prototype to match changes in fight.c.
@
text
@d8 2
a9 2
*  $Date: 2003/12/09 05:42:45 $
*  $Revision: 1.7 $
d532 3
a534 1
	 GET_HIT(ch) -= dam;
@


1.7
log
@Artus>
\r\n appended to gold rush message: act.informative.c

Imms no longer affected by underwater: act.movement.c, limits.c

Changed remort some more.. New special, tracker (SPECIAL_TRACKER):
act.other.c, act.wizard.c, constants.c, graph.c, structs.h, utils.c

Object and Room triggers can now %send% <room vnum> <message>:
dg_objcmd.c, dg_wldcmd.c

%self.direction% now has a vnum subfield to return the exit room's vnum.
(Eg: %self.north(vnum)%): dg_scripts.c

%actor.hisher%, %actor.himher%, %actor.heshe% implemented: dg_scripts.c

vnum, name, can_see, can_see_me added to %actor.next_in_room%, returning char
vnum, char name, if actor can see char, and if char can see actor respectively:
dg_scripts.c

Changed "do not know that spell" to "do not know of that spell": spell_parser.c

Changed "do not of know that skill/spell" to "do not know of..": utils.c

SECT_UNDERWATER and SECT_INSIDE now checked in OUTSIDE() macro: utils.h
@
text
@d8 2
a9 2
*  $Date: 2003/11/27 06:16:00 $
*  $Revision: 1.6 $
d515 2
a516 1
    if (!*name || !*amount || !isdigit(*amount)) {
d523 4
a526 2
    if ((ch = get_char_by_obj(obj, name))) {
       if (GET_LEVEL(ch)>=LVL_ANGEL) {
d535 27
a561 26
       switch (GET_POS(ch)) {
       case POS_MORTALLYW:
           act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
           send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
           break;
       case POS_INCAP:
           act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
           send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
           break;
       case POS_STUNNED:
           act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
           send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
           break;
       case POS_DEAD:
           act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
           send_to_char("You are dead!  Sorry...\r\n", ch);
           break;

       default:                        /* >= POSITION SLEEPING */
           if (dam > (GET_MAX_HIT(ch) >> 2))
               act("That really did HURT!", FALSE, ch, 0, 0, TO_CHAR);
           if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)) {
               sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
                       CCRED(ch, C_SPR), CCNRM(ch, C_SPR));
               send_to_char(buf2, ch);
                   }
d563 17
a579 7
       if (GET_POS(ch) == POS_DEAD) {
           if (!IS_NPC(ch)) {
               sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
                       world[ch->in_room].name);
               mudlog(buf2, BRF, 0, TRUE);
           }
           die(ch, NULL);
@


1.6
log
@Artus> Breakin now requires mount skill, and is tested vs it.
       Remort ability list changed some more, also remort ability parser.
       DGScript Force/Teleport commands now tell >=LVL_ANGEL what they were
       trying to do..
       MultiWeapon is once more required for dual wield.
       Lowered exp gained whilst grouping by about 30%.
@
text
@d8 2
a9 2
*  $Date: 2003/11/21 02:48:05 $
*  $Revision: 1.5 $
d215 1
d239 3
a242 1

@


1.5
log
@Artus>
act.informative.c: Added Sense Wounds.
constants.c      : Added Sense Wounds.
db.c             : Fixed spell effectiveness.
dg_mobcmd.c      : mpurge will no longer purge player corpses.
dg_objcmd.c      : opurge will no longer purge player corpses.
dg_wldcmd.c      : wpurge will no longer purge player corpses.
fight.c          : Added Sense Wounds.
magic.c          : Added Sense Wounds.
spell_parser.c   : Added Sense Wounds.. Trialling changes do damage
                   done by headbutt, flytackle, piledrive.
spells.h         : Added Sense Wounds.
structs.h        : Added Sense Wounds.
@
text
@d8 2
a9 2
*  $Date: 2003/11/13 01:05:29 $
*  $Revision: 1.4 $
d24 1
d182 5
a186 1
               }
d198 5
a202 1
           }
d424 1
a424 2
           obj_log(obj, "oteleport target is itself");

d427 10
a436 6
           next_ch = ch->next_in_room;
           
	   if (GET_LEVEL(ch) < LVL_ANGEL) {
             char_from_room(ch);
             char_to_room(ch, target);
	   }
d438 1
a438 4
    }
  
    else
    {
d441 11
a451 8
	   if (GET_LEVEL(ch) < LVL_ANGEL) {
             char_from_room(ch);
             char_to_room(ch, target);
	   }
       }
    
       else
           obj_log(obj, "oteleport: no target found");
@


1.4
log
@Artus> Added !KILL flag for mobs... Things like gamina, postmaster, etc, can
       have this set, which should make it pretty damn impossible for them to
       die..
       Modified more stuff for dark ritual and vampires.. Have added a switch
       statement to affect_remove, which should be a good central place to
       handle triggers on affect removal.. Mainly to reset mana/move/hit to
       make sure they're not higher than max values when removing werewolf/
       vampire.
@
text
@d7 3
a9 3
*  $Author: primal $
*  $Date: 2002/02/26 06:49:03 $
*  $Revision: 1.3 $
d353 6
a358 1
                   extract_obj(o);
d367 10
a376 4
       if ((o = get_obj_by_obj(obj, arg))) {
            if (o==obj) dg_owner_purged = 1;
           extract_obj(o);
        } else 
@


1.3
log
@
Modified: DM

Changed: (This is a group checkin)
- many many bug fixes
@
text
@d7 3
a9 3
*  $Author: artus $
*  $Date: 2001/06/09 03:36:42 $
*  $Revision: 1.2 $
d501 5
a505 2
       GET_HIT(ch) -= dam;
       update_pos(ch);
@


1.2
log
@Modified (un)equip_chars...
@
text
@d7 3
a9 3
*  $Author: primal $
*  $Date: 2001/02/02 04:34:46 $
*  $Revision: 1.1 $
a32 1
void die(struct char_data * ch, struct char_data *killer);
d178 1
a178 1
               if (GET_LEVEL(ch)<LVL_IMMORT)
d190 1
a190 1
           if (GET_LEVEL(ch)<LVL_IMMORT)
d410 4
a413 2
           char_from_room(ch);
           char_to_room(ch, target);
d421 4
a424 2
           char_from_room(ch);
           char_to_room(ch, target);
d497 2
a498 2
       if (GET_LEVEL(ch)>=LVL_IMMORT) {
           send_to_char("Being the cool immortal you are, you sidestep a trap, obviously placed to kill you.", ch);
@


1.1
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d7 3
a9 3
*  $Author: galion $
*  $Date: 1996/08/04 23:10:16 $
*  $Revision: 3.8 $
d302 1
a302 1
      unequip_char(obj->worn_by, pos);
d321 1
a321 1
      equip_char(wearer, obj, pos);
@

