head	1.19;
access;
symbols;
locks; strict;
comment	@ * @;


1.19
date	2004.06.04.12.24.56;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.15.22.40.25;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.10.03.21.04;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.06.02.23.30;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.23.03.01.11;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.29.13.20.05;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.10.22.30.58;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.10.12.02.26;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.06.04.32.50;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.04.10.35.00;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.31.22.20.28;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.24.01.25.58;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.17.02.25.06;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.27.06.16.00;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.21.02.48.05;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.13.01.05.29;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.26.06.49.03;	author primal;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.09.03.37.07;	author artus;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.02.04.34.46;	author primal;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Artus> Required changes for new find_xxx functions.
@
text
@/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/

/***************************************************************************
 *  The MOBprograms have been contributed by N'Atas-ha.  Any support for   *
 *  these routines should not be expected from Merc Industries.  However,  *
 *  under no circumstances should the blame for bugs, etc be placed on     *
 *  Merc Industries.  They are not guaranteed to work on all systems due   *
 *  to their frequent use of strxxx functions.  They are also not the most *
 *  efficient way to perform their tasks, but hopefully should be in the   *
 *  easiest possible way to install and begin using. Documentation for     *
 *  such installation can be found in INSTALL.  Enjoy........    N'Atas-Ha *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "dg_scripts.h"
#include "db.h"
#include "utils.h"
#include "handler.h"
#include "interpreter.h"
#include "comm.h"
#include "spells.h"
#include "screen.h"


extern struct descriptor_data *descriptor_list;
extern sh_int find_target_room(char_data * ch, char *rawroomstr);
extern struct index_data *mob_index;
extern struct room_data *world;
extern int dg_owner_purged;
extern const char *dirs[];

void begin_hunting(struct char_data *ch, struct char_data *vict);
void sub_write(char *arg, char_data *ch, byte find_invis, int targets);
long asciiflag_conv(char *flag);
room_data *get_room(char *name);

/*
 * Local functions.
 */

/* attaches mob's name and vnum to msg and sends it to script_log */
void mob_log(char_data *mob, char *msg)
{
    char buf[MAX_INPUT_LENGTH + 100];

    void script_log(char *msg);

    sprintf(buf, "Mob (%s, VNum %d): %s",
           GET_SHORT(mob), GET_MOB_VNUM(mob), msg);
    script_log(buf);
}
/*
** macro to determine if a mob is permitted to use these commands
*/
#define MOB_OR_IMPL(ch) \
  (IS_NPC(ch) && (!(ch)->desc || GET_LEVEL((ch)->desc->original)>=LVL_IMPL))



/* mob commands */

/* prints the argument to all the rooms aroud the mobile */
ACMD(do_masound)
{
    sh_int was_in_room;
    int  door;
  
    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }

    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
  
    if (!*argument)
    {
       mob_log(ch, "masound called with no argument");
       return;
    }

    skip_spaces(&argument);
  
    was_in_room = IN_ROOM(ch);
    for (door = 0; door < NUM_OF_DIRS; door++)
    {
       struct room_direction_data *exit;
    
       if (((exit = world[was_in_room].dir_option[door]) != NULL) &&
           exit->to_room != NOWHERE && exit->to_room != was_in_room)
       {
           IN_ROOM(ch) = exit->to_room;
           sub_write(argument, ch, TRUE, TO_ROOM);
       }
    }
  
    IN_ROOM(ch) = was_in_room;
}


ACMD(do_mdamage) 
{
  char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
  int dam = 0;
  struct char_data *vict = NULL, *k = NULL;

  if (!(MOB_OR_IMPL(ch)))
  {
    send_to_char(HUH, ch);
    return;
  }

  two_arguments(argument, name, amount);

  if (!*name || !*amount || !isdigit(*amount)) 
  {
    mob_log(ch, "mdamage: bad syntax");
    return;
  }

  dam = atoi(amount);

  vict = get_char(name);
  if (vict)
  {
    // Artus> Sanity.
    for (k = world[IN_ROOM(ch)].people; k; k = k->next)
      if (k == vict) 
	break;
    if (!(k))
    {
      mob_log(ch, "mdamage: victim has disappeared!");
      return;
    }
    if (!LR_FAIL(vict, LVL_IS_GOD))
    {
      send_to_char("Being the cool immortal you are, you sidestep a trap, obviously placed to kill you.\r\n", vict);
      return;
    }
    if (!IS_NPC(vict) || !MOB_FLAGGED(vict, MOB_NOKILL))
    {
      // Artus> Replaced with damage() call.
      // GET_HIT(vict) -= dam;
      damage(ch, vict, dam, TYPE_UNDEFINED, TRUE);
      update_pos(vict);
      switch (GET_POS(vict)) 
      {
        case POS_MORTALLYW:
	  act("$n is mortally wounded, and will die soon, if not aided.", TRUE, vict, 0, 0, TO_ROOM);
	  send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", vict);
	  break;
	case POS_INCAP:
	  act("$n is incapacitated and will slowly die, if not aided.", TRUE, vict, 0, 0, TO_ROOM);
	  send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", vict);
	  break;
	case POS_STUNNED:
	  act("$n is stunned, but will probably regain consciousness again.", TRUE, vict, 0, 0, TO_ROOM);
	  send_to_char("You're stunned, but will probably regain consciousness again.\r\n", vict);
	  break;
	case POS_DEAD:
	  act("$n is dead!  R.I.P.", FALSE, vict, 0, 0, TO_ROOM);
	  send_to_char("You are dead!  Sorry...\r\n", vict);
	  break;
	default:                        /* >= POSITION SLEEPING */
	  if (dam > (GET_MAX_HIT(vict) >> 2))
	    act("That really did HURT!", FALSE, vict, 0, 0, TO_CHAR);
	  if (GET_HIT(vict) < (GET_MAX_HIT(vict) >> 2)) 
	  {
	    sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
		    CCRED(vict, C_SPR), CCNRM(vict, C_SPR));
	    send_to_char(buf2, vict);
	  }
       } // End Switch.
       if (GET_POS(vict) == POS_DEAD) 
       {
	 /* Artus> Logging is handled in die(). 
	 if (!IS_NPC(vict)) 
	 {
	   sprintf(buf2, "%s killed by %s mdamage at %s", GET_NAME(vict), 
		   GET_NAME(ch), world[vict->in_room].name);
	   mudlog(buf2, NRM, LVL_GOD, TRUE);
	 } */
	 die(vict, ch);
       } // Dead Check.
    } // Nokill Check.
  } else
    mob_log(ch, "mdamage: target not found");
}

/* lets the mobile kill any player or mobile without murder*/
ACMD(do_mkill) 
{
    char arg[MAX_INPUT_LENGTH];
    char_data *victim;
  
    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }

    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
  
    one_argument(argument, arg);
    
    if (!*arg) {
       mob_log(ch, "mkill called with no argument");
       return;
    }

    if (*arg == UID_CHAR)
    {
      if (!(victim = get_char(arg)))
      {
        sprintf(buf, "mkill: victim (%s) not found",arg);
       mob_log(ch, buf);
       return;
      }
    } else if (!(victim = generic_find_char(ch, arg, FIND_CHAR_ROOM))) {
        sprintf(buf, "mkill: victim (%s) not found",arg);
       mob_log(ch, buf);
       return;
    }

    if (victim == ch)
    {
       mob_log(ch, "mkill: victim is self");
       return;
    }

    if (IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
    {
       mob_log(ch, "mkill: charmed mob attacking master");
       return;
    }

    if (FIGHTING(ch))
    {
       mob_log(ch, "mkill: already fighting");
       return;
    }
    
    hit(ch, victim, TYPE_UNDEFINED);
    return;
}


/*
 * lets the mobile destroy an object in its inventory
 * it can also destroy a worn object and it can destroy 
 * items using all.xxxxx or just plain all of them
 */
ACMD(do_mjunk)
{
    char arg[MAX_INPUT_LENGTH];
    int pos, junk_all = 0;
    obj_data *obj;
    obj_data *obj_next;
  
    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;

    one_argument(argument, arg);
  
    if (!*arg)
    {
       mob_log(ch, "mjunk called with no argument");
       return;
    }

    if (!str_cmp(arg, "all")) junk_all = 1;

    if ((find_all_dots(arg) != FIND_INDIV) && !junk_all)
    {
      if ((pos = find_obj_eqpos(ch,arg)) >= 0)
      {
	obj = GET_EQ(ch, pos);
        unequip_char(ch, pos, FALSE);
	extract_obj(obj);
	return;
      }
      if ((obj = find_obj_list(ch, arg, ch->carrying)) != NULL)
        extract_obj(obj);
      return;
    } else {
      for (obj = ch->carrying; obj != NULL; obj = obj_next)
      {
        obj_next = obj->next_content;
	if (arg[3] == '\0' || isname(arg+4, obj->name))
	  extract_obj(obj);
      }
      while ((pos=find_obj_eqpos(ch,arg)) >= 0)
      {
	obj = GET_EQ(ch, pos);
        unequip_char(ch, pos, FALSE);
	extract_obj(obj);
      }   
    }
    return;
}

/* prints the message to everyone in the room other than the mob and victim */
ACMD(do_mechoaround)
{
    char arg[MAX_INPUT_LENGTH];
    char_data *victim;
    char *p;

    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
  
    p = one_argument(argument, arg);
    skip_spaces(&p);
    
    if (!*arg)
    {
       mob_log(ch, "mechoaround called with no argument");
       return;
    }
  
    if (*arg == UID_CHAR)
    {
      if (!(victim = get_char(arg)))
      {
        sprintf(buf, "mechoaround: victim (%s) does not exist",arg);
       mob_log(ch, buf);
       return;
      }
    } else if (!(victim = generic_find_char(ch, arg, FIND_CHAR_ROOM))) {
      sprintf(buf, "mechoaround: victim (%s) does not exist",arg);
      mob_log(ch, buf);
      return;
    }

    sub_write(p, victim, TRUE, TO_ROOM);
}


/* sends the message to only the victim */
ACMD(do_msend)
{
    char arg[MAX_INPUT_LENGTH];
    char_data *victim;
    char *p;

    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }

    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
  
    p = one_argument(argument, arg);
    skip_spaces(&p);
  
    if (!*arg)
    {
       mob_log(ch, "msend called with no argument");
       return;
    }

    if (*arg == UID_CHAR)
    {
      if (!(victim = get_char(arg)))
      {
        sprintf(buf, "msend: victim (%s) does not exist",arg);
        mob_log(ch, buf);
        return;
      }
    } else if (!(victim = generic_find_char(ch, arg, FIND_CHAR_ROOM))) {
      sprintf(buf, "msend: victim (%s) does not exist",arg);
      mob_log(ch, buf);
      return;
    }
  
    sub_write(p, victim, TRUE, TO_CHAR);
}

// Artus> Zone Echo.
ACMD(do_mzoneecho)
{
  char *p;
  void send_to_zone(const char *msg, zone_rnum zone);

  if (!MOB_OR_IMPL(ch))
  {
    send_to_char(HUH, ch);
    return;
  }
  if (AFF_FLAGGED(ch, AFF_CHARM))
    return;
  if (IN_ROOM(ch) == NOWHERE)
  {
    mob_log(ch, "mzoneecho called from mobile in NOWHERE.");
    return;
  }
  if (!*argument)
  {
    mob_log(ch, "mzoneecho called with no arguments");
    return;
  }
  p = argument;
  skip_spaces(&p);
  send_to_zone(p, world[IN_ROOM(ch)].zone);
}


/* prints the message to the room at large */
ACMD(do_mecho)
{
    char *p;
  
    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
  
    if (!*argument) {
       mob_log(ch, "mecho called with no arguments");
       return;
    }
    p = argument;
    skip_spaces(&p);
  
    sub_write(p, ch, TRUE, TO_ROOM);
}


/*
 * lets the mobile load an item or mobile.  All items
 * are loaded into inventory, unless it is NO-TAKE. 
 */
ACMD(do_mload)
{
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int number = 0;
    char_data *mob;
    obj_data *object;
  
    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }

    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;

    if( ch->desc && GET_LEVEL(ch->desc->original) < LVL_IMPL)
       return;
  
    two_arguments(argument, arg1, arg2);
  
    if (!*arg1 || !*arg2 || !is_number(arg2) || ((number = atoi(arg2)) < 0)) {
       mob_log(ch, "mload: bad syntax");
       return;
    }

    if (is_abbrev(arg1, "mob")) {
       if ((mob = read_mobile(number, VIRTUAL)) == NULL) {
           mob_log(ch, "mload: bad mob vnum");
           return;
       }
       char_to_room(mob, IN_ROOM(ch));
        load_mtrigger(mob);
    }
  
    else if (is_abbrev(arg1, "obj")) {
       if ((object = read_object(number, VIRTUAL)) == NULL) {
           mob_log(ch, "mload: bad object vnum");
           return;
       }
       if (CAN_WEAR(object, ITEM_WEAR_TAKE)) {
           obj_to_char(object, ch, __FILE__, __LINE__);
       } else {
           obj_to_room(object, IN_ROOM(ch));
       }
        load_otrigger(object);
    }

    else
       mob_log(ch, "mload: bad type");
}


/*
 * lets the mobile purge all objects and other npcs in the room,
 * or purge a specified object or mob in the room.  It can purge
 *  itself, but this will be the last command it does.
 */
ACMD(do_mpurge)
{
  char arg[MAX_INPUT_LENGTH];
  char_data *victim;
  obj_data  *obj;
  
  if (!MOB_OR_IMPL(ch))
  {
    send_to_char(HUH, ch);
    return;
  }
  
  if (AFF_FLAGGED(ch, AFF_CHARM))
    return;

  if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
    return;
 
  one_argument(argument, arg);
 
  if (!*arg)
  {
    /* 'purge' */
    char_data *vnext;
    obj_data  *obj_next;
    for (victim = world[IN_ROOM(ch)].people; victim; victim = vnext)
    {
      vnext = victim->next_in_room;
      if (IS_NPC(victim) && victim != ch)
	extract_char(victim);
    }
    for (obj = world[IN_ROOM(ch)].contents; obj; obj = obj_next)
    {
      obj_next = obj->next_content;
      extract_obj(obj);
    }
    return;
  }

  if (*arg == UID_CHAR)
    victim = get_char(arg);
  else victim = generic_find_char(ch, arg, FIND_CHAR_ROOM);

  if (victim == NULL)
  {
    if ((obj = generic_find_obj(ch, arg, FIND_OBJ_EQUIP | FIND_OBJ_INV |
					 FIND_OBJ_ROOM)))
    {
      if (GET_CORPSEID(obj) == 0)
	extract_obj(obj);
      else
	mob_log(ch, "mpurge: Refusing to purge player's corpse.");
    } else 
      mob_log(ch, "mpurge: bad argument");
    return;
  }
  if (!IS_NPC(victim))
  {
     mob_log(ch, "mpurge: purging a PC");
     return;
  }
  if (victim==ch)
    dg_owner_purged = 1;
  extract_char(victim);
}


/* lets the mobile goto any location it wishes that is not private */
ACMD(do_mgoto)
{
    char arg[MAX_INPUT_LENGTH];
    sh_int location;
  
    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }

    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
  
    one_argument(argument, arg);

    if (!*arg) {
       mob_log(ch, "mgoto called with no argument");
       return;
    }
  
    if ((location = find_target_room(ch, arg)) == NOWHERE) {
       mob_log(ch, "mgoto: invalid location");
       return;
    }
  
    if (FIGHTING(ch))
       stop_fighting(ch);
    
    char_from_room(ch);
    char_to_room(ch, location);
}

/* lets the mob heal themself */
ACMD(do_mrestore)
{
  int amount;

  if (!MOB_OR_IMPL(ch))
  {
    send_to_char(HUH, ch);
    return;
  }

  if (AFF_FLAGGED(ch, AFF_CHARM))
    return;

  skip_spaces(&argument);

  if (!(*argument) || (!isdigit(*argument) && (*argument != '-')))
  {
    sprintf(buf, "mrestore: bad argument (%s)", argument);
    mob_log(ch, buf);
    return;
  }

  if (GET_HIT(ch) >= GET_MAX_HIT(ch))
    return;
  amount = atoi(argument);
  amount = GET_HIT(ch) + amount;
  GET_HIT(ch) = MAX(0, MIN(amount, GET_MAX_HIT(ch)));
}

/* lets the mobile do a command at another location. Very useful */
ACMD(do_mat)
{
    char arg[MAX_INPUT_LENGTH];
    sh_int location;
    sh_int original;
  
    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
  
    argument = one_argument( argument, arg );
  
    if (!*arg || !*argument) {
       mob_log(ch, "mat: bad argument");
       return;
    }
  
    if ((location = find_target_room(ch, arg)) == NOWHERE) {
       mob_log(ch, "mat: invalid location");
       return;
    }
  
    original = IN_ROOM(ch);
    char_from_room(ch);
    char_to_room(ch, location);
    command_interpreter(ch, argument);
    
    /*
     * See if 'ch' still exists before continuing!
     * Handles 'at XXXX quit' case.
     */
    if (IN_ROOM(ch) == location) {
       char_from_room(ch);
       char_to_room(ch, original);
    }
}


/*
 * lets the mobile transfer people.  the all argument transfers
 * everyone in the current room to the specified location
 */
ACMD(do_mteleport)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  sh_int target;
  char_data *vict, *next_ch;
  
  if (!MOB_OR_IMPL(ch))
  {
    send_to_char(HUH, ch);
    return;
  }
  
  if (AFF_FLAGGED(ch, AFF_CHARM))
    return;

  argument = two_arguments(argument, arg1, arg2);
    
  if (!*arg1 || !*arg2)
  {
    mob_log(ch, "mteleport: bad syntax");
    return;
  }

  target = find_target_room(ch, arg2);

  if (target == NOWHERE)
    mob_log(ch, "mteleport target is an invalid room");
  else if (!str_cmp(arg1, "all"))
  {
    if (target == IN_ROOM(ch))
    {
      mob_log(ch, "mteleport all target is itself");
      return;
    }
    for (vict = world[IN_ROOM(ch)].people; vict; vict = next_ch)
    {
      next_ch = vict->next_in_room;
      if (LR_FAIL(vict, LVL_IS_GOD))
      {
	char_from_room(vict);
	char_to_room(vict, target);
      } else if (vict->desc) {
	sprintf(buf, "%s tried to teleport you to room %d.\r\n", 
		GET_NAME(ch), world[target].number);
	send_to_char(buf, vict);
      }
    }
  } else {
    if (*arg1 == UID_CHAR)
    {
      if (!(vict = get_char(arg1)))
      {
	sprintf(buf, "mteleport: victim (%s) does not exist",arg1);
	mob_log(ch, buf);
	return;
      }
    } else if (!(vict = generic_find_char(ch, arg1, FIND_CHAR_WORLD))) {
      sprintf(buf, "mteleport: victim (%s) does not exist",arg1);
      mob_log(ch, buf);
      return;
    }
    // DM - immorts need them for uses like the script to take u to the island
    if (LR_FAIL(ch, LVL_IS_GOD))
    {
      char_from_room(vict);
      char_to_room(vict, target);
    } else if (vict->desc) {
      sprintf(buf, "%s tried to teleport you to room %d.\r\n", GET_NAME(ch),
	      world[target].number);
      send_to_char(buf, vict);
    }
  }
}

/*
 * lets the mobile force someone to do something.  must be mortal level
 * and the all argument only affects those in the room with the mobile
 */
ACMD(do_mforce)
{
  char arg[MAX_INPUT_LENGTH];

  if (!MOB_OR_IMPL(ch))
  {
    send_to_char(HUH, ch);
    return;
  }
  if (AFF_FLAGGED(ch, AFF_CHARM))
    return;
  
  if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
    return;
  
  argument = one_argument(argument, arg);
  
  if (!*arg || !*argument)
  {
    mob_log(ch, "mforce: bad syntax");
    return;
  }
  
  if (!str_cmp(arg, "all"))
  {
    struct descriptor_data *i;
    char_data *vch;
    for (i = descriptor_list; i ; i = i->next)
    {
      if ((i->character != ch) && !i->connected &&
	  (IN_ROOM(i->character) == IN_ROOM(ch)))
      {
	vch = i->character;
        if (GET_LEVEL(vch) < GET_LEVEL(ch) && CAN_SEE(ch, vch) &&
	    LR_FAIL(vch, LVL_IS_GOD))
	  command_interpreter(vch, argument);
	else if (!LR_FAIL(vch, LVL_IS_GOD) && (vch->desc))
	{
	  sprintf(buf, "%s tried to force you to %s.\r\n",
		  GET_NAME(ch), argument);
	  send_to_char(buf, ch);
        }
      }
    }
  } else {
    char_data *victim;
    if (*arg == UID_CHAR)
    {
      if (!(victim = get_char(arg)))
      {
	sprintf(buf, "mforce: victim (%s) does not exist",arg);
	mob_log(ch, buf);
	return;
      }
    } else if ((victim = generic_find_char(ch, arg, FIND_CHAR_ROOM)) == NULL) {
      mob_log(ch, "mforce: no such victim");
      return;
    }
    if (victim == ch)
    {
      mob_log(ch, "mforce: forcing self");
      return;
    }
    if (LR_FAIL(ch, LVL_IS_GOD))
      command_interpreter(victim, argument); 
    else if (victim->desc)
    {
      sprintf(buf, "%s tried to force you to %s.\r\n",
	      GET_NAME(ch), argument);
      send_to_char(buf, ch);
    }
  }
}


/* increases the target's exp */
ACMD(do_mexp)
{
  char_data *victim;
  char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

  mob_log(ch, "WARNING: mexp command is depracated! Use: %actor.exp(amount-to-add)%");

  if (!MOB_OR_IMPL(ch))
  {
    send_to_char(HUH, ch);
    return;
  }

  if (AFF_FLAGGED(ch, AFF_CHARM))
    return;

  if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
    return;  

  two_arguments(argument, name, amount);

  if (!*name || !*amount)
  {
    mob_log(ch, "mexp: too few arguments");
    return;
  }

  if (*name == UID_CHAR)
  {
    if (!(victim = get_char(name)))
    {
      sprintf(buf, "mexp: victim (%s) does not exist",name);
      mob_log(ch, buf);
      return;
    }
  } else if (!(victim = generic_find_char(ch, name, FIND_CHAR_WORLD))) {
    sprintf(buf, "mexp: victim (%s) does not exist",name);
    mob_log(ch, buf);
    return;
  }
  gain_exp(victim, atoi(amount));      
}


/* increases the target's gold */
ACMD(do_mgold)
{
  struct char_data *victim;
  char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

  mob_log(ch, "WARNING: mgold command is depracated! Use: %actor.gold(amount-to-add)%");

  if (!MOB_OR_IMPL(ch))
  {
    send_to_char(HUH, ch);
    return;
  }

  if (AFF_FLAGGED(ch, AFF_CHARM))
    return;

  if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
    return;  

  two_arguments(argument, name, amount);

  if (!*name || !*amount)
  {
    mob_log(ch, "mgold: too few arguments");
    return;
  }
  if (*name == UID_CHAR)
  {
    if (!(victim = get_char(name)))
    {
      sprintf(buf, "mgold: victim (%s) does not exist",name);
      mob_log(ch, buf);
      return;
    }
  } else if (!(victim = generic_find_char(ch, name, FIND_CHAR_WORLD))) {
    sprintf(buf, "mgold: victim (%s) does not exist",name);
    mob_log(ch, buf);
    return;
  }
  if ((GET_GOLD(victim) += atoi(amount)) < 0)
  {
    mob_log(ch, "mgold subtracting more gold than character has");
    GET_GOLD(victim) = 0;
  }
}


/* hunt for someone */
ACMD(do_mhunt)
{
  char_data *victim;
  char arg[MAX_INPUT_LENGTH];

  if (!MOB_OR_IMPL(ch))
  {
    send_to_char(HUH, ch);
    return;
  }
  
  if (AFF_FLAGGED(ch, AFF_CHARM))
    return;
  
  if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
    return;
  
  one_argument(argument, arg);

  if (!*arg)
  {
    mob_log(ch, "mhunt called with no argument");
    return;
  }

  if (FIGHTING(ch)) return;

  if (*arg == UID_CHAR)
  {
    if (!(victim = get_char(arg)))
    {
      sprintf(buf, "mhunt: victim (%s) does not exist", arg);
      mob_log(ch, buf);
      return;
    }
  } else if (!(victim = generic_find_char(ch, arg, FIND_CHAR_WORLD))) {
    sprintf(buf, "mhunt: victim (%s) does not exist", arg);
    mob_log(ch, buf);
    return;
  }
  begin_hunting(ch, victim);
}


/* place someone into the mob's memory list */
ACMD(do_mremember)
{
  char_data *victim;
  struct script_memory *mem;
  char arg[MAX_INPUT_LENGTH];

  if (!MOB_OR_IMPL(ch))
  {
    send_to_char(HUH, ch);
    return;
  }

  if (AFF_FLAGGED(ch, AFF_CHARM))
    return;

  if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
    return;

  argument = one_argument(argument, arg);

  if (!*arg)
  {
    mob_log(ch, "mremember: bad syntax");
    return;
  }

  if (*arg == UID_CHAR)
  {
    if (!(victim = get_char(arg)))
    {
      sprintf(buf, "mremember: victim (%s) does not exist", arg);
      mob_log(ch, buf);
      return;
    }
  } else if (!(victim = generic_find_char(ch, arg, FIND_CHAR_ROOM | 
	                                           FIND_CHAR_WORLD))) {
    sprintf(buf, "mremember: victim (%s) does not exist", arg);
    mob_log(ch, buf);
    return;
  }

  /* create a structure and add it to the list */
  CREATE(mem, struct script_memory, 1);
  if (!SCRIPT_MEM(ch)) 
    SCRIPT_MEM(ch) = mem;
  else {
    struct script_memory *tmpmem = SCRIPT_MEM(ch);
    while (tmpmem->next) tmpmem = tmpmem->next;
    tmpmem->next = mem;
  }

  /* fill in the structure */
  mem->id = GET_ID(victim);
  if (argument && *argument)
    mem->cmd = strdup(argument);
}


/* remove someone from the list */
ACMD(do_mforget)
{
  char_data *victim;
  struct script_memory *mem, *prev;
  char arg[MAX_INPUT_LENGTH];

  if (!MOB_OR_IMPL(ch))
  {
    send_to_char(HUH, ch);
    return;
  }

  if (AFF_FLAGGED(ch, AFF_CHARM))
    return;

  if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
    return;

  one_argument(argument, arg);

  if (!*arg)
  {
    mob_log(ch, "mforget: bad syntax");
    return;
  }

  if (*arg == UID_CHAR)
  {
    if (!(victim = get_char(arg)))
    {
      sprintf(buf, "mforget: victim (%s) does not exist", arg);
      mob_log(ch, buf);
      return;
    }
  } else if (!(victim = generic_find_char(ch, arg, FIND_CHAR_ROOM |
	                                           FIND_CHAR_WORLD))) {
    sprintf(buf, "mforget: victim (%s) does not exist", arg);
    mob_log(ch, buf);
    return;
  }

  mem = SCRIPT_MEM(ch);
  prev = NULL;
  while (mem)
  {
    if (mem->id == GET_ID(victim))
    {
      if (mem->cmd)
	free(mem->cmd);
      if (prev==NULL)
      {
	SCRIPT_MEM(ch) = mem->next;
	free(mem);
	mem = SCRIPT_MEM(ch);
      } else {
	prev->next = mem->next;
	free(mem);
	mem = prev->next;
      }
    } else {
      prev = mem;
      mem = mem->next;
    }
  }
}


/* transform into a different mobile */
ACMD(do_mtransform)
{
  char arg[MAX_INPUT_LENGTH];
  char_data *m, tmpmob;
  obj_data *obj[NUM_WEARS];
  int keep_hp = 1; /* new mob keeps the old mob's hp/max hp/exp */
  int pos;

  if (!MOB_OR_IMPL(ch))
  {
    send_to_char(HUH, ch);
    return;
  }
  
  if (AFF_FLAGGED(ch, AFF_CHARM))
     return;
  
  if (ch->desc)
  {
    send_to_char("You've got no VNUM to return to, dummy! try 'switch'\r\n",
		 ch);
    return;
  }
  
  one_argument(argument, arg);

  if (!*arg)
    mob_log(ch, "mtransform: missing argument");
  else if (!isdigit(*arg) && *arg!='-')
    mob_log(ch, "mtransform: bad argument");
  else
  {
    if (isdigit(*arg))
      m = read_mobile(atoi(arg), VIRTUAL);
    else
    {
      keep_hp = 0;
      m = read_mobile(atoi(arg+1), VIRTUAL);
    }
    if (m==NULL)
    {
      mob_log(ch, "mtransform: bad mobile vnum");
      return;
    }

    /* move new obj info over to old object and delete new obj */

    for (pos = 0; pos < NUM_WEARS; pos++)
    {
      if (GET_EQ(ch, pos))
        obj[pos] = unequip_char(ch, pos, FALSE);
      else
        obj[pos] = NULL;
    }

    /* put the mob in the same room as ch so extract will work */
    char_to_room(m, IN_ROOM(ch));

    memcpy(&tmpmob, m, sizeof(*m));
    tmpmob.id = ch->id;
    tmpmob.affected = ch->affected;
    tmpmob.carrying = ch->carrying;
    tmpmob.proto_script = ch->proto_script;
    tmpmob.script = ch->script;
    tmpmob.memory = ch->memory;
    tmpmob.next_in_room = ch->next_in_room;
    tmpmob.next = ch->next;
    tmpmob.next_fighting = ch->next_fighting;
    tmpmob.followers = ch->followers;
    tmpmob.master = ch->master;

    GET_WAS_IN(&tmpmob) = GET_WAS_IN(ch);
    if (keep_hp)
    {
      GET_HIT(&tmpmob) = GET_HIT(ch);
      GET_MAX_HIT(&tmpmob) = GET_MAX_HIT(ch);
      GET_EXP(&tmpmob) = GET_EXP(ch);
    }
    GET_GOLD(&tmpmob) = GET_GOLD(ch);
    GET_POS(&tmpmob) = GET_POS(ch);
    IS_CARRYING_W(&tmpmob) = IS_CARRYING_W(ch);
    IS_CARRYING_N(&tmpmob) = IS_CARRYING_N(ch);
    FIGHTING(&tmpmob) = FIGHTING(ch);
    begin_hunting(&tmpmob, HUNTING(ch));
    memcpy(ch, &tmpmob, sizeof(*ch));

    for (pos = 0; pos < NUM_WEARS; pos++) 
      if (obj[pos])
        equip_char(ch, obj[pos], pos, FALSE);

    extract_char(m);
  }
}


ACMD(do_mdoor)
{
  char target[MAX_INPUT_LENGTH], direction[MAX_INPUT_LENGTH];
  char field[MAX_INPUT_LENGTH], *value;
  room_data *rm;
  struct room_direction_data *exit;
  int dir, fd, to_room;

  const char *door_field[] = {
    "purge",
    "description",
    "flags",
    "key",
    "name",
    "room",
    "\n"
  };


  if (!MOB_OR_IMPL(ch))
  {
    send_to_char(HUH, ch);
    return;
  }
  
  if (AFF_FLAGGED(ch, AFF_CHARM))
    return;
  
  argument = two_arguments(argument, target, direction);
  value = one_argument(argument, field);
  skip_spaces(&value);

  if (!*target || !*direction || !*field)
  {
    mob_log(ch, "mdoor called with too few args");
    return;
  }
  
  if ((rm = get_room(target)) == NULL)
  {
    mob_log(ch, "mdoor: invalid target");
    return;
  }
  
  if ((dir = search_block(direction, dirs, FALSE)) == -1)
  {
    mob_log(ch, "mdoor: invalid direction");
    return;
  }

  if ((fd = search_block(field, door_field, FALSE)) == -1)
  {
    mob_log(ch, "odoor: invalid field");
    return;
  }

  exit = rm->dir_option[dir];

  /* purge exit */
  if (fd == 0)
  {
    if (exit)
    {
      if (exit->general_description)
	free(exit->general_description);
      if (exit->keyword)
	free(exit->keyword);
      free(exit);
      rm->dir_option[dir] = NULL;
    }
  } else {
    if (!exit)
    {
      CREATE(exit, struct room_direction_data, 1);
      rm->dir_option[dir] = exit; 
    }
    
    switch (fd)
    {
      case 1:  /* description */
	if (exit->general_description)
	  free(exit->general_description);
	CREATE(exit->general_description, char, strlen(value) + 3);
	strcpy(exit->general_description, value);
	strcat(exit->general_description, "\r\n");
        break;
      case 2:  /* flags       */
        exit->exit_info = (sh_int)asciiflag_conv(value);
        break;
      case 3:  /* key         */
        exit->key = atoi(value);
        break;
      case 4:  /* name        */
        if (exit->keyword)
	  free(exit->keyword);
	CREATE(exit->keyword, char, strlen(value) + 1);
	strcpy(exit->keyword, value);
	break;
      case 5:  /* room        */
	if ((to_room = real_room(atoi(value))) != NOWHERE)
	  exit->to_room = to_room;
	else
	  mob_log(ch, "mdoor: invalid door target");
	break;
    }
  }
}
@


1.18
log
@Artus> Modified mdamage to prevent crash.
@
text
@d232 4
a235 2
    if (*arg == UID_CHAR) {
      if (!(victim = get_char(arg))) {
d240 1
a240 1
    } else if (!(victim = get_char_room_vis(ch, arg))) {
d246 2
a247 1
    if (victim == ch) {
d252 2
a253 1
    if (IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim ) {
d258 2
a259 1
    if (FIGHTING(ch)) {
d292 2
a293 1
    if (!*arg) {
d300 12
a311 9
    if ((find_all_dots(arg) != FIND_INDIV) && !junk_all) {
       if ((obj=get_object_in_equip_vis(ch,arg,ch->equipment,&pos))!= NULL) {
           unequip_char(ch, pos, FALSE);
           extract_obj(obj);
           return;
       }
       if ((obj = get_obj_in_list_vis(ch, arg, ch->carrying)) != NULL )
           extract_obj(obj);
       return;
d313 12
a324 11
       for (obj = ch->carrying; obj != NULL; obj = obj_next) {
           obj_next = obj->next_content;
           if (arg[3] == '\0' || isname(arg+4, obj->name)) {
               extract_obj(obj);
           }
       }
       while ((obj=get_object_in_equip_vis(ch,arg,ch->equipment,&pos)))
       {
           unequip_char(ch, pos, FALSE);
           extract_obj(obj);
       }   
d348 2
a349 1
    if (!*arg) {
d354 4
a357 2
    if (*arg == UID_CHAR) {
      if (!(victim = get_char(arg))) {
d362 4
a365 4
    } else if (!(victim = get_char_room_vis(ch, arg))) {
        sprintf(buf, "mechoaround: victim (%s) does not exist",arg);
       mob_log(ch, buf);
       return;
d391 2
a392 1
    if (!*arg) {
d397 4
a400 2
    if (*arg == UID_CHAR) {
      if (!(victim = get_char(arg))) {
d402 2
a403 2
       mob_log(ch, buf);
       return;
d405 4
a408 4
    } else if (!(victim = get_char_room_vis(ch, arg))) {
        sprintf(buf, "msend: victim (%s) does not exist",arg);
       mob_log(ch, buf);
       return;
d532 3
a534 3
    char arg[MAX_INPUT_LENGTH];
    char_data *victim;
    obj_data  *obj;
d536 5
a540 5
    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }
d542 2
a543 2
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
d545 20
a564 22
    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
       return;
  
    one_argument(argument, arg);
  
    if (!*arg) {
       /* 'purge' */
       char_data *vnext;
       obj_data  *obj_next;
    
       for (victim = world[IN_ROOM(ch)].people; victim; victim = vnext) {
           vnext = victim->next_in_room;
           if (IS_NPC(victim) && victim != ch)
               extract_char(victim);
       }
    
       for (obj = world[IN_ROOM(ch)].contents; obj; obj = obj_next) {
           obj_next = obj->next_content;
           extract_obj(obj);
       }
    
       return;
d566 2
a567 4
  
    if (*arg == UID_CHAR)
      victim = get_char(arg);
    else victim = get_char_room_vis(ch, arg);
d569 3
a571 17
    if (victim == NULL) {
       if ((obj = get_obj_vis(ch, arg))) 
       {
	 if (GET_CORPSEID(obj) == 0)
           extract_obj(obj);
	 else
	   mob_log(ch, "mpurge: Refusing to purge player's corpse.");
       } else 
           mob_log(ch, "mpurge: bad argument");
       
       return;
    }
    
    if (!IS_NPC(victim)) {
       mob_log(ch, "mpurge: purging a PC");
       return;
    }
d573 21
a593 3
    if (victim==ch) dg_owner_purged = 1;
    
    extract_char(victim);
d711 3
a713 3
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    sh_int target;
    char_data *vict, *next_ch;
d715 5
a719 5
    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }
d721 2
a722 2
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
d724 1
a724 1
    argument = two_arguments(argument, arg1, arg2);
d726 5
a730 4
    if (!*arg1 || !*arg2) {
       mob_log(ch, "mteleport: bad syntax");
       return;
    }
d732 1
a732 1
    target = find_target_room(ch, arg2);
d734 8
a741 21
    if (target == NOWHERE)
       mob_log(ch, "mteleport target is an invalid room");

    else if (!str_cmp(arg1, "all")) {
       if (target == IN_ROOM(ch)) {
           mob_log(ch, "mteleport all target is itself");
           return;
       }

       for (vict = world[IN_ROOM(ch)].people; vict; vict = next_ch) {
           next_ch = vict->next_in_room;

	   if (LR_FAIL(vict, LVL_IS_GOD)) {
               char_from_room(vict);
               char_to_room(vict, target);
           } else if (vict->desc) {
	     sprintf(buf, "%s tried to teleport you to room %d.\r\n", 
		     GET_NAME(ch), world[target].number);
	     send_to_char(buf, vict);
	   }
       }
d743 4
a746 16

    else {
      if (*arg1 == UID_CHAR) {
        if (!(vict = get_char(arg1))) {
          sprintf(buf, "mteleport: victim (%s) does not exist",arg1);
          mob_log(ch, buf);
          return;
        }
      } else if (!(vict = get_char_vis(ch, arg1, FIND_CHAR_WORLD))) {
        sprintf(buf, "mteleport: victim (%s) does not exist",arg1);
       mob_log(ch, buf);
       return;
      }

      // DM - immorts need them for uses like the script to take u to the island
      if (LR_FAIL(ch, LVL_IS_GOD))
d748 2
a749 2
        char_from_room(vict);
        char_to_room(vict, target);
d751 2
a752 2
	sprintf(buf, "%s tried to teleport you to room %d.\r\n", GET_NAME(ch),
	        world[target].number);
d756 25
a782 1

d789 1
a789 1
    char arg[MAX_INPUT_LENGTH];
d791 7
a797 5
    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }
d799 2
a800 2
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
d802 1
a802 2
    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
       return;
d804 5
a808 1
    argument = one_argument(argument, arg);
d810 39
a848 3
    if (!*arg || !*argument) {
       mob_log(ch, "mforce: bad syntax");
       return;
d850 7
a856 46
  
    if (!str_cmp(arg, "all")) {
       struct descriptor_data *i;
       char_data *vch;
    
       for (i = descriptor_list; i ; i = i->next) {
           if ((i->character != ch) && !i->connected &&
               (IN_ROOM(i->character) == IN_ROOM(ch))) {
               vch = i->character;
               if (GET_LEVEL(vch) < GET_LEVEL(ch) && CAN_SEE(ch, vch) &&
                   LR_FAIL(vch, LVL_IS_GOD)) {
                   command_interpreter(vch, argument);
               } else if (!LR_FAIL(vch, LVL_IS_GOD) && (vch->desc)) {
		 sprintf(buf, "%s tried to force you to %s.\r\n",
		         GET_NAME(ch), argument);
		 send_to_char(buf, ch);
	       }
           }
       }
    } else {
       char_data *victim;
       
        if (*arg == UID_CHAR) {
          if (!(victim = get_char(arg))) {
            sprintf(buf, "mforce: victim (%s) does not exist",arg);
           mob_log(ch, buf);
           return;
          }
       } else if ((victim = get_char_room_vis(ch, arg)) == NULL) {
           mob_log(ch, "mforce: no such victim");
           return;
       }
    
       if (victim == ch) {
           mob_log(ch, "mforce: forcing self");
           return;
       }
    
       if (LR_FAIL(ch, LVL_IS_GOD))
	 command_interpreter(victim, argument); 
       else if (victim->desc)
       {
	 sprintf(buf, "%s tried to force you to %s.\r\n",
		 GET_NAME(ch), argument);
	 send_to_char(buf, ch);
       }
d858 1
d865 2
a866 2
    char_data *victim;
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
d868 1
a868 1
    mob_log(ch, "WARNING: mexp command is depracated! Use: %actor.exp(amount-to-add)%");
d870 5
d876 5
a880 11
    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
  
    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
       return;  
d882 1
a882 1
    two_arguments(argument, name, amount);
d884 5
a888 4
    if (!*name || !*amount) {
       mob_log(ch, "mexp: too few arguments");
       return;
    }
d890 7
a896 10
    if (*name == UID_CHAR) {
      if (!(victim = get_char(name))) {
        sprintf(buf, "mexp: victim (%s) does not exist",name);
       mob_log(ch, buf);
       return;
      }
    } else if (!(victim = get_char_vis(ch, name, FIND_CHAR_WORLD))) {
        sprintf(buf, "mexp: victim (%s) does not exist",name);
       mob_log(ch, buf);
       return;
d898 6
a903 2
  
    gain_exp(victim, atoi(amount));      
d910 2
a911 2
    char_data *victim;
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
d913 1
a913 1
    mob_log(ch, "WARNING: mgold command is depracated! Use: %actor.gold(amount-to-add)%");
d915 5
d921 2
a922 11
    if (!MOB_OR_IMPL(ch))
    {
       send_to_char(HUH, ch);
       return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
  
    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
       return;  
d924 2
a925 1
    two_arguments(argument, name, amount);
d927 1
a927 4
    if (!*name || !*amount) {
       mob_log(ch, "mgold: too few arguments");
       return;
    }
d929 12
a940 15
    if (*name == UID_CHAR) {
      if (!(victim = get_char(name))) {
        sprintf(buf, "mgold: victim (%s) does not exist",name);
       mob_log(ch, buf);
       return;
      }
    } else if (!(victim = get_char_vis(ch, name, FIND_CHAR_WORLD))) {
        sprintf(buf, "mgold: victim (%s) does not exist",name);
       mob_log(ch, buf);
       return;
    }
  
    if ((GET_GOLD(victim) += atoi(amount)) < 0) {
       mob_log(ch, "mgold subtracting more gold than character has");
       GET_GOLD(victim) = 0;
d942 10
d991 1
a991 1
  } else if (!(victim = get_char_vis(ch, arg, FIND_CHAR_WORLD))) {
d1003 23
a1025 3
    char_data *victim;
    struct script_memory *mem;
    char arg[MAX_INPUT_LENGTH];
d1027 3
a1029 1
    if (!MOB_OR_IMPL(ch))
d1031 3
a1033 15
       send_to_char(HUH, ch);
       return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
  
    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
       return;
  
    argument = one_argument(argument, arg);
  
    if (!*arg) {
       mob_log(ch, "mremember: bad syntax");
       return;
d1035 6
d1042 9
a1050 20
    if (*arg == UID_CHAR) {
      if (!(victim = get_char(arg))) {
        sprintf(buf, "mremember: victim (%s) does not exist", arg);
       mob_log(ch, buf);
       return;
      }
    } else if (!(victim = get_char_vis(ch, arg, FIND_CHAR_WORLD))) {
        sprintf(buf, "mremember: victim (%s) does not exist", arg);
       mob_log(ch, buf);
       return;
    }

    /* create a structure and add it to the list */
    CREATE(mem, struct script_memory, 1);
    if (!SCRIPT_MEM(ch)) SCRIPT_MEM(ch) = mem;
    else {
      struct script_memory *tmpmem = SCRIPT_MEM(ch);
      while (tmpmem->next) tmpmem = tmpmem->next;
      tmpmem->next = mem;
    }
d1052 4
a1055 5
    /* fill in the structure */
    mem->id = GET_ID(victim);
    if (argument && *argument) {
      mem->cmd = strdup(argument);
    }
d1062 23
a1084 3
    char_data *victim;
    struct script_memory *mem, *prev;
    char arg[MAX_INPUT_LENGTH];
d1086 3
a1088 1
    if (!MOB_OR_IMPL(ch))
d1090 3
a1092 15
       send_to_char(HUH, ch);
       return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
  
    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
       return;
  
    one_argument(argument, arg);
  
    if (!*arg) {
       mob_log(ch, "mforget: bad syntax");
       return;
d1094 6
d1101 17
a1117 5
    if (*arg == UID_CHAR) {
      if (!(victim = get_char(arg))) {
        sprintf(buf, "mforget: victim (%s) does not exist", arg);
       mob_log(ch, buf);
       return;
d1119 3
a1121 4
    } else if (!(victim = get_char_vis(ch, arg, FIND_CHAR_WORLD))) {
        sprintf(buf, "mforget: victim (%s) does not exist", arg);
       mob_log(ch, buf);
       return;
d1123 1
a1123 20

    mem = SCRIPT_MEM(ch);
    prev = NULL;
    while (mem) {
      if (mem->id == GET_ID(victim)) {
        if (mem->cmd) free(mem->cmd);
        if (prev==NULL) {
          SCRIPT_MEM(ch) = mem->next;
          free(mem);
          mem = SCRIPT_MEM(ch);
        } else {
          prev->next = mem->next;
          free(mem);
          mem = prev->next;
        }
      } else {
        prev = mem;
        mem = mem->next;
      }
   }
@


1.17
log
@Artus> Now uses begin_hunting() and stop_hunting().
@
text
@d125 7
a131 1
  struct char_data *vict = NULL;
d146 9
d216 2
a217 1
    if (!MOB_OR_IMPL(ch)) {
d276 2
a277 1
    if (!MOB_OR_IMPL(ch)) {
d326 2
a327 1
    if (!MOB_OR_IMPL(ch)) {
d366 2
a367 1
    if (!MOB_OR_IMPL(ch)) {
d432 2
a433 1
    if (!MOB_OR_IMPL(ch)) {
d463 2
a464 1
    if (!MOB_OR_IMPL(ch)) {
d520 2
a521 1
    if (!MOB_OR_IMPL(ch)) {
d587 2
a588 1
    if (!MOB_OR_IMPL(ch)) {
d652 2
a653 1
    if (!MOB_OR_IMPL(ch)) {
d699 2
a700 1
    if (!MOB_OR_IMPL(ch)) {
d775 2
a776 1
    if (!MOB_OR_IMPL(ch)) {
d852 2
a853 1
    if (!MOB_OR_IMPL(ch)) {
d896 2
a897 1
    if (!MOB_OR_IMPL(ch)) {
d986 2
a987 1
    if (!MOB_OR_IMPL(ch)) {
d1041 2
a1042 1
    if (!MOB_OR_IMPL(ch)) {
d1103 5
a1107 4
    if (!MOB_OR_IMPL(ch)) {
       send_to_char(HUH, ch);
       return;
    }
d1109 2
a1110 2
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
d1112 6
a1117 5
    if (ch->desc) {
      send_to_char("You've got no VNUM to return to, dummy! try 'switch'\r\n",
        ch);
      return;
    }
d1125 2
a1126 1
  else {
d1129 2
a1130 1
    else {
d1134 2
a1135 1
    if (m==NULL) {
d1142 2
a1143 1
    for (pos = 0; pos < NUM_WEARS; pos++) {
d1167 2
a1168 1
    if (keep_hp) {
d1181 1
a1181 1
    for (pos = 0; pos < NUM_WEARS; pos++) {
a1183 1
    }
d1192 15
a1206 15
    char target[MAX_INPUT_LENGTH], direction[MAX_INPUT_LENGTH];
    char field[MAX_INPUT_LENGTH], *value;
    room_data *rm;
    struct room_direction_data *exit;
    int dir, fd, to_room;

    const char *door_field[] = {
       "purge",
       "description",
       "flags",
       "key",
       "name",
       "room",
       "\n"
    };
d1209 5
a1213 4
    if (!MOB_OR_IMPL(ch)) {
       send_to_char(HUH, ch);
       return;
    }
d1215 2
a1216 2
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
d1218 3
a1220 3
    argument = two_arguments(argument, target, direction);
    value = one_argument(argument, field);
    skip_spaces(&value);
d1222 5
a1226 4
    if (!*target || !*direction || !*field) {
       mob_log(ch, "mdoor called with too few args");
       return;
    }
d1228 5
a1232 4
    if ((rm = get_room(target)) == NULL) {
       mob_log(ch, "mdoor: invalid target");
       return;
    }
d1234 5
a1238 4
    if ((dir = search_block(direction, dirs, FALSE)) == -1) {
       mob_log(ch, "mdoor: invalid direction");
       return;
    }
d1240 5
a1244 4
    if ((fd = search_block(field, door_field, FALSE)) == -1) {
       mob_log(ch, "odoor: invalid field");
       return;
    }
d1246 1
a1246 1
    exit = rm->dir_option[dir];
d1248 17
a1264 10
    /* purge exit */
    if (fd == 0) {
       if (exit) {
           if (exit->general_description)
               free(exit->general_description);
           if (exit->keyword)
               free(exit->keyword);
           free(exit);
           rm->dir_option[dir] = NULL;
       }
a1265 6

    else {
       if (!exit) {
           CREATE(exit, struct room_direction_data, 1);
           rm->dir_option[dir] = exit; 
       }
d1267 27
a1293 27
       switch (fd) {
       case 1:  /* description */
           if (exit->general_description)
               free(exit->general_description);
           CREATE(exit->general_description, char, strlen(value) + 3);
           strcpy(exit->general_description, value);
           strcat(exit->general_description, "\r\n");
           break;
       case 2:  /* flags       */
           exit->exit_info = (sh_int)asciiflag_conv(value);
           break;
       case 3:  /* key         */
           exit->key = atoi(value);
           break;
       case 4:  /* name        */
           if (exit->keyword)
               free(exit->keyword);
           CREATE(exit->keyword, char, strlen(value) + 1);
           strcpy(exit->keyword, value);
           break;
       case 5:  /* room        */
           if ((to_room = real_room(atoi(value))) != NOWHERE)
               exit->to_room = to_room;
           else
               mob_log(ch, "mdoor: invalid door target");
           break;
       }
d1295 1
@


1.16
log
@Artus> Now warning free :o)
@
text
@d51 1
d909 2
a910 2
    char_data *victim;
    char arg[MAX_INPUT_LENGTH];
d912 5
a916 4
    if (!MOB_OR_IMPL(ch)) {
       send_to_char(HUH, ch);
       return;
    }
d918 2
a919 2
    if (AFF_FLAGGED(ch, AFF_CHARM))
       return;
d921 2
a922 2
    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
       return;
d924 1
a924 1
    one_argument(argument, arg);
d926 5
a930 5
    if (!*arg) {
       mob_log(ch, "mhunt called with no argument");
       return;
    }
  
d932 1
a932 1
    if (FIGHTING(ch)) return;
d934 7
a940 10
    if (*arg == UID_CHAR) {
      if (!(victim = get_char(arg))) {
        sprintf(buf, "mhunt: victim (%s) does not exist", arg);
       mob_log(ch, buf);
       return;
      }
    } else if (!(victim = get_char_vis(ch, arg, FIND_CHAR_WORLD))) {
        sprintf(buf, "mhunt: victim (%s) does not exist", arg);
       mob_log(ch, buf);
       return;
d942 6
a947 3
    HUNTING(ch) = victim;
  

d1141 1
a1141 1
    HUNTING(&tmpmob) = HUNTING(ch);
@


1.15
log
@Artus> Added mzoneecho (%zoneecho%)
@
text
@d136 2
a137 1
  if (vict = get_char(name))
@


1.14
log
@Artus> Minor change to mrestore.
@
text
@a299 1

d377 28
@


1.13
log
@Artus> Fixed reversed LR_FAIL in mteleport.
@
text
@d586 2
@


1.12
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d673 1
a673 1
	   if (!LR_FAIL(vict, LVL_IS_GOD)) {
@


1.11
log
@Artus>
act.informative.c: Fixed bug where examining a container was always listng the
                   objects in the first container matched.
                   Gold rush finishing is now only displayed within the same
		   world.
act.movement.c   : Environmental damage is now passed through damage().
act.offensive.c  : Throw() now calls damage().
act.other.c      : When you fail to create a torch, it hurts.
dg_mobcmd.c      : mdamage() now calls damage().
dg_objcmd.c      : odamage() now calls damage().
dg_wldcmd.c      : wdamage() now calls damage().
fight.c          : Changed damage() to allow a NULL ch.
interpreter.c    : Falling because fly has worn off now calls damage().
limits.c         : No waterbreathe underwater now calls damage().
magic.c          : Added handle_fireball() for fire breathing, fireball, type
                   stuff..
                   Random chance of objs in inventory/open containers burning
                   up :o)
spec_assign.c    : Removed some unused/wasted assigns: corridor_guard,
                   receiptionist, virus, bacteria.
spec_procs.c     : Removed some unused/wasted procs. Changed lots of tali's
                   indenting.
                   Fixed gaping hole in deadlyblade proc.
                   Replaced GET_HIT(vict) -= with damage(ch, vict...
spell_parser.c   : Added awake and can_see checks to magic fail = mob attacks.
@
text
@d138 1
a138 1
    if (GET_LEVEL(vict)>=LVL_ANGEL) 
d673 1
a673 1
           if (GET_LEVEL(vict)<LVL_ANGEL) {
d698 1
a698 1
      if (GET_LEVEL(vict) < LVL_ANGEL) 
d746 1
a746 1
                   GET_LEVEL(vch)<LVL_ANGEL) {
d748 1
a748 1
               } else if ((GET_LEVEL(vch) >= LVL_ANGEL) && (vch->desc)) {
d774 1
a774 1
       if (GET_LEVEL(victim)<LVL_ANGEL)
@


1.10
log
@Artus> Intermittent build.
act.informative.c: Affect/Timers now display something when no affects/timers
                   are present.
                   Sense curse now senses objects inside containers.
act.movement.c   : Optimised the aggravate stuff a little.
act.offensive.c  : Logging death by pit trap.
act.other.c      : Logging death by suicide.
                   Superman now sets affects rather than actual stats, for STR
                   and CON (CON bonus is +1, STR is 21 - GET_REAL_STR
                   Logging death by arrow.
clan.c           : Removed aggravate_check() function, no longer used.
db.c             : Now initialising character specials.
dg_mobcmd.c      : Logging death by mdamage.
dg_objcmd.c      : Logging death by odamage.
dg_wldcmd.c      : Logging death by wdamage.
fight.c          : New optional msg paramater to die(), for if the death was
                   not caused by a character.
                   Deaths are now logged to info channel.
handler.c        : Modified ability affect function to permit more than one
                   affect modifier per special. (Required for superman)
spec_procs.c     : Logging death by pit trap, archers and room blast.
spells.h         : Added SPELL_SUPERMAN for special affect modifiers.
utils.h          : Updated die() prototype to match changes in fight.c.
@
text
@d145 3
a147 1
      GET_HIT(vict) -= dam;
d179 1
d185 1
a185 1
	 }
@


1.9
log
@Artus> Moving stuff across to live.

act.informative.c:
  Info on it's own will now display the info file. Use me or self to see your
own info.
  Score and Exp now both show gained and remaining exp.
  Gold value is now to a max of 30000. (60000 in lvl 40+ zones, 120 in 70+)
  Gold rushes no longer occur in !GOLDRUSH zones, city sectors, etc.

act.other.c:
  Mana retained on remort is now floored at 100 instead of 50.
  Added elitist bonus for chars who play past the earliest remort point(s).

act.wizard.c:
  Gold rush events are now only advertised within the world they occur.

genolc.h:
  Added special #defines for different OLC levels whether running live or test.
  (Noted by compiling with -DPRIMAL_LIVE)

interpreter.c:
  Aliases will now be saved automatically, when added or remoed.
  Added elitist_modifier() to modifier calculation.
  Replaced Huh?!? with HUH.

limits.c:
  NPC corpses are no longer emptied before they are purged. Too much clutter.

spells.c:
  Reduced the amount of weight applied by create water to 1/3 of what it was.

comm.c:       Added send_to_not_zone_world()
db.c:         Added elitist_modifier() to modifier calculation.
dg_mobcmd.c:  Replaced Huh?!? with the define, HUH.
dg_scripts.h: Changed version string so it will fit on one line :o)
fight.c:      Eq should no longer be damaged when a hit fails.
handler.c:    Now, when the sleep spell wears of an NPC, it will wake up.
structs.h:    Added HUH define.
utils.c:      Added elitist_modifier() calculation.
utils.h:      Added elitist_modifier() prototype.
@
text
@d181 1
a181 1
	   mudlog(buf2, BRF, 0, TRUE);
d183 1
a183 1
	 die(vict, NULL);
@


1.8
log
@Artus> Added mrestore.
@
text
@d88 1
a88 1
       send_to_char("Huh?!?\r\n", ch);
d197 1
a197 1
       send_to_char("Huh?!?\r\n", ch);
d256 1
a256 1
       send_to_char("Huh?!?\r\n", ch);
d306 1
a306 1
       send_to_char( "Huh?!?\r\n", ch );
d345 1
a345 1
       send_to_char( "Huh?!?\r\n", ch );
d382 1
a382 1
       send_to_char( "Huh?!?\r\n", ch );
d412 1
a412 1
       send_to_char("Huh?!?\r\n", ch);
d468 1
a468 1
       send_to_char("Huh?!?\r\n", ch);
d534 1
a534 1
       send_to_char("Huh?!?\r\n", ch);
d567 1
a567 1
    send_to_char("Huh?!?\r\n", ch);
d596 1
a596 1
       send_to_char("Huh?!?\r\n", ch);
d642 1
a642 1
       send_to_char("Huh?!?\r\n", ch);
d717 1
a717 1
       send_to_char("Huh?!?\r\n", ch);
d793 1
a793 1
       send_to_char("Huh?!?\r\n", ch);
d836 1
a836 1
       send_to_char("Huh?!?\r\n", ch);
d879 1
a879 1
       send_to_char("Huh?!?\r\n", ch);
d924 1
a924 1
       send_to_char("Huh?!?\r\n", ch);
d978 1
a978 1
       send_to_char("Huh?!?\r\n", ch);
d1039 1
a1039 1
       send_to_char("Huh?!?\r\n", ch);
d1139 1
a1139 1
       send_to_char("Huh?!?\r\n", ch);
@


1.7
log
@Artus> Mostly just cosmetic changes, mostly for underwater stuff..
       Added some more stuff to dg_scripts:

       %actor.affected(aff_bit)% - Is actor affected by whatever.
       %self.people(countpc)%    - (Rooms): Count players.
       %self.people(countnpc)%   - (Rooms): Count npcs.
       %self.people(countall)%   - (Rooms): Count chars.
       %firstchar.<room_vnum>%   - First character in room <vnum>

       Possibly a bugfix to one of the forest specials that was attacking you
       if you were affected by poison.
@
text
@d124 1
a124 1
  struct char_data *vict;
d136 1
a136 1
  if ((vict = get_char(name))) 
d560 27
@


1.6
log
@Artus> Breakin now requires mount skill, and is tested vs it.
       Remort ability list changed some more, also remort ability parser.
       DGScript Force/Teleport commands now tell >=LVL_ANGEL what they were
       trying to do..
       MultiWeapon is once more required for dual wield.
       Lowered exp gained whilst grouping by about 30%.
@
text
@d506 1
a506 1
	 if (!GET_CORPSEID(obj) == 0)
@


1.5
log
@Artus>
act.informative.c: Added Sense Wounds.
constants.c      : Added Sense Wounds.
db.c             : Fixed spell effectiveness.
dg_mobcmd.c      : mpurge will no longer purge player corpses.
dg_objcmd.c      : opurge will no longer purge player corpses.
dg_wldcmd.c      : wpurge will no longer purge player corpses.
fight.c          : Added Sense Wounds.
magic.c          : Added Sense Wounds.
spell_parser.c   : Added Sense Wounds.. Trialling changes do damage
                   done by headbutt, flytackle, piledrive.
spells.h         : Added Sense Wounds.
structs.h        : Added Sense Wounds.
@
text
@d646 5
a650 1
           }
d668 8
a675 3
      if (GET_LEVEL(vict) < LVL_ANGEL) {
       char_from_room(vict);
       char_to_room(vict, target);
d718 5
a722 1
               }
d745 7
a751 1
           command_interpreter(victim, argument);
@


1.4
log
@Artus> Added !KILL flag for mobs... Things like gamina, postmaster, etc, can
       have this set, which should make it pretty damn impossible for them to
       die..
       Modified more stuff for dark ritual and vampires.. Have added a switch
       statement to affect_remove, which should be a good central place to
       handle triggers on affect removal.. Mainly to reset mana/move/hit to
       make sure they're not higher than max values when removing werewolf/
       vampire.
@
text
@d504 3
a506 1
       if ((obj = get_obj_vis(ch, arg))) {
d508 2
@


1.3
log
@
Modified: DM

Changed: (This is a group checkin)
- many many bug fixes
@
text
@d120 13
a132 4
ACMD(do_mdamage) {
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
    int dam = 0;
    struct char_data *vict;
d134 1
a134 1
    two_arguments(argument, name, amount);
d136 6
a141 3
    if (!*name || !*amount || !isdigit(*amount)) {
       mob_log(ch, "mdamage: bad syntax");
       return;
d143 37
a179 40

    dam = atoi(amount);

    if ((vict = get_char(name))) {
       if (GET_LEVEL(vict)>=LVL_ANGEL) {
           send_to_char("Being the cool immortal you are, you sidestep a trap, obviously placed to kill you.\r\n", vict);
           return;
       }
       GET_HIT(vict) -= dam;
       update_pos(vict);
       switch (GET_POS(vict)) {
       case POS_MORTALLYW:
           act("$n is mortally wounded, and will die soon, if not aided.", TRUE, vict, 0, 0, TO_ROOM);
           send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", vict);
           break;
       case POS_INCAP:
           act("$n is incapacitated and will slowly die, if not aided.", TRUE, vict, 0, 0, TO_ROOM);
           send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", vict);
           break;
       case POS_STUNNED:
           act("$n is stunned, but will probably regain consciousness again.", TRUE, vict, 0, 0, TO_ROOM);
           send_to_char("You're stunned, but will probably regain consciousness again.\r\n", vict);
           break;
       case POS_DEAD:
           act("$n is dead!  R.I.P.", FALSE, vict, 0, 0, TO_ROOM);
           send_to_char("You are dead!  Sorry...\r\n", vict);
           break;

       default:                        /* >= POSITION SLEEPING */
           if (dam > (GET_MAX_HIT(vict) >> 2))
               act("That really did HURT!", FALSE, vict, 0, 0, TO_CHAR);
           if (GET_HIT(vict) < (GET_MAX_HIT(vict) >> 2)) {
               sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
                       CCRED(vict, C_SPR), CCNRM(vict, C_SPR));
               send_to_char(buf2, vict);
                   }
       }
       if (GET_POS(vict) == POS_DEAD) {
           if (!IS_NPC(vict)) {
               sprintf(buf2, "%s killed by %s mdamage at %s", GET_NAME(vict), 
d181 7
a187 7
               mudlog(buf2, BRF, 0, TRUE);
           }
           die(vict, NULL);
       }
    }
    else
       mob_log(ch, "mdamage: target not found");
d191 1
a191 1
ACMD(do_mkill)
@


1.2
log
@Modified (un)equip_chars..
@
text
@d41 1
d120 61
d630 1
a630 1
           if (GET_LEVEL(vict)<LVL_IMMORT) {
d650 2
a651 1
      if (GET_LEVEL(vict)<LVL_IMMORT) {
d694 1
a694 1
                   GET_LEVEL(vch)<LVL_IMMORT) {
d718 1
a718 1
       if (GET_LEVEL(victim)<LVL_IMMORT)
@


1.1
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d203 1
a203 1
           unequip_char(ch, pos);
d219 1
a219 1
           unequip_char(ch, pos);
d952 1
a952 1
        obj[pos] = unequip_char(ch, pos);
d989 1
a989 1
        equip_char(ch, obj[pos], pos);
@

