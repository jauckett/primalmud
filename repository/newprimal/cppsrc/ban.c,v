head	1.12;
access;
symbols
	A3_0_59:1.3
	LATEST:1.3
	A3_0_1:1.3;
locks; strict;
comment	@ * @;


1.12
date	2004.06.12.09.36.00;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.06.02.23.29;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.06.12.27.24;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.24.00.14.49;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.12.11.00.13;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.10.10.48.30;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.14.06.10.18;	author primal;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.12.04.59.16;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.24.03.43.50;	author artus;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.14.03.55.10;	author talisman;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.13.00.59.18;	author primal;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.57;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Artus> Fixed ban code.
@
text
@/* ************************************************************************
*   File: ban.c                                         Part of CircleMUD *
*  Usage: banning/unbanning/checking sites and player names               *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h> 
#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"

struct ban_list_element *ban_list = NULL;
extern struct descriptor_data *descriptor_list;

/* local functions */
void load_banned(void);
int isbanned(char *hostname);
int isipbanned(struct in_addr *inaddr, const int nameserver_is_slow);
int parse_ip(const char *addr, struct in_addr *inaddr);
void _write_one_node(FILE * fp, struct ban_list_element * node);
void write_ban_list(void);
ACMD(do_ban);
ACMD(do_unban);
void Read_Invalid_List(void);

const char *ban_types[] =
{
  "no",
  "new",
  "select",
  "all",
  "ERROR"
};


void load_banned(void)
{
  FILE *fl;
  int i, date;
  char site_name[BANNED_SITE_LENGTH + 1], ban_type[100];
  char name[MAX_NAME_LENGTH + 1];
  struct ban_list_element *next_node;
  struct in_addr addy;

  ban_list = 0;

  if (!(fl = fopen(BAN_FILE, "r")))
  {
    if (errno != ENOENT)
      basic_mud_log("SYSERR: Unable to open banfile '%s': %s", BAN_FILE, strerror(errno));
    else
      basic_mud_log("   Ban file '%s' doesn't exist.", BAN_FILE);
    return;
  }
  while (fscanf(fl, " %s %s %d %s ", ban_type, site_name, &date, name) == 4)
  {
    CREATE(next_node, struct ban_list_element, 1);
    strncpy(next_node->site, site_name, BANNED_SITE_LENGTH);
    next_node->site[BANNED_SITE_LENGTH] = '\0';
    if (parse_ip(site_name, &addy) == 0)
      basic_mud_log("SYSERR: Banned site [%s] failed parse_ip()", site_name);
    strncpy(next_node->name, name, MAX_NAME_LENGTH);
    next_node->s_addr = addy.s_addr;
    next_node->name[MAX_NAME_LENGTH] = '\0';
    next_node->date = date;

    for (i = BAN_NOT; i <= BAN_ALL; i++)
      if (!strcmp(ban_type, ban_types[i]))
	next_node->type = i;

    next_node->next = ban_list;
    ban_list = next_node;
  }

  fclose(fl);
}

// DM - check ips, not hostnames
int isipbanned(struct in_addr in, const int nameserver_is_slow) 
{
  int i = BAN_NOT;
  for (struct ban_list_element *b = ban_list; b; b = b->next)
    if ((b->s_addr & 0xff000000) == 0)
    {
      if ((in.s_addr & 0x00ffffff) == b->s_addr)
	i = MAX(i, b->type);
    } else if (in.s_addr == b->s_addr)
      i = MAX(i, b->type);
  return i;
}	
		
int isbanned(char *hostname)
{
  int i;
  struct ban_list_element *banned_node;
  char *nextchar;

  if (!hostname || !*hostname)
    return (0);

  i = 0;
  for (nextchar = hostname; *nextchar; nextchar++)
    *nextchar = LOWER(*nextchar);

  for (banned_node = ban_list; banned_node; banned_node = banned_node->next)
    if (strstr(hostname, banned_node->site))	/* if hostname is a substring */
      i = MAX(i, banned_node->type);

  return (i);
}


void _write_one_node(FILE * fp, struct ban_list_element * node)
{
  if (node)
  {
    _write_one_node(fp, node->next);
    fprintf(fp, "%s %s %ld %s\n", ban_types[node->type],
	    node->site, (long) node->date, node->name);
  }
}



void write_ban_list(void)
{
  FILE *fl;

  if (!(fl = fopen(BAN_FILE, "w")))
  {
    perror("SYSERR: Unable to open '" BAN_FILE "' for writing");
    return;
  }
  _write_one_node(fl, ban_list);/* recursively write from end to start */
  fclose(fl);
  return;
}


ACMD(do_ban)
{
  char flag[MAX_INPUT_LENGTH], site[MAX_INPUT_LENGTH],
	format[MAX_INPUT_LENGTH], *nextchar, *timestr;
  int i;
  struct ban_list_element *ban_node;
  struct in_addr addy;
#ifdef NO_LOCALTIME
  struct tm lt;
#endif

  *buf = '\0';

  if (!*argument)
  {
    if (!ban_list)
    {
      send_to_char("No sites are banned.\r\n", ch);
      return;
    }
    strcpy(format, "%-25.25s  %-8.8s  %-10.10s  %-16.16s\r\n");
    sprintf(buf, format,
	    "Banned Site Name",
	    "Ban Type",
	    "Banned On",
	    "Banned By");
    send_to_char(buf, ch);
    sprintf(buf, format,
	    "---------------------------------",
	    "---------------------------------",
	    "---------------------------------",
	    "---------------------------------");
    send_to_char(buf, ch);

    for (ban_node = ban_list; ban_node; ban_node = ban_node->next) {
      if (ban_node->date) 
      {
#ifndef NO_LOCALTIME
	timestr = asctime(localtime(&(ban_node->date)));
#else
	if (jk_localtime(&lt, ban_node->date))
	  strcpy(site, "Error");
	else 
	  timestr = asctime(&lt);
	*(timestr + 10) = 0;
#endif
	strcpy(site, timestr);
      } else {
	strcpy(site, "Unknown");
      }
      sprintf(buf, format, ban_node->site, ban_types[ban_node->type], site,
	      ban_node->name);
      send_to_char(buf, ch);
    }
    return;
  }
  two_arguments(argument, flag, site);
  if (!*site || !*flag)
  {
    send_to_char("Usage: ban {all | select | new} site_name\r\n", ch);
    return;
  }
  if (!(!str_cmp(flag, "select") || 
	!str_cmp(flag, "all") || 
	!str_cmp(flag, "new"))) {
    send_to_char("Flag must be ALL, SELECT, or NEW.\r\n", ch);
    return;
  }
  if (parse_ip(site, &addy) == 0)
  {
    send_to_char("That is not a valid IP address.\r\n", ch);
    return;
  }
  for (ban_node = ban_list; ban_node; ban_node = ban_node->next)
  {
    if (!str_cmp(ban_node->site, site) || (addy.s_addr == ban_node->s_addr))
    {
      send_to_char("That site has already been banned -- unban it to change the ban type.\r\n", ch);
      return;
    }
  }

  CREATE(ban_node, struct ban_list_element, 1);
  strncpy(ban_node->site, site, BANNED_SITE_LENGTH);
  for (nextchar = ban_node->site; *nextchar; nextchar++)
    *nextchar = LOWER(*nextchar);
  ban_node->site[BANNED_SITE_LENGTH] = '\0';
  ban_node->s_addr = addy.s_addr;
  strncpy(ban_node->name, GET_NAME(ch), MAX_NAME_LENGTH);
  ban_node->name[MAX_NAME_LENGTH] = '\0';
  ban_node->date = time(0);

  for (i = BAN_NEW; i <= BAN_ALL; i++)
    if (!str_cmp(flag, ban_types[i]))
      ban_node->type = i;

  ban_node->next = ban_list;
  ban_list = ban_node;

  sprintf(buf, "%s has banned %s for %s players.", GET_NAME(ch), site,
	  ban_types[ban_node->type]);
  mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
  send_to_char("Site banned.\r\n", ch);
  write_ban_list();
}


ACMD(do_unban)
{
  char site[MAX_INPUT_LENGTH];
  struct ban_list_element *ban_node, *temp;
  int found = 0;

  one_argument(argument, site);
  if (!*site) {
    send_to_char("A site to unban might help.\r\n", ch);
    return;
  }
  ban_node = ban_list;
  while (ban_node && !found)
  {
    if (!str_cmp(ban_node->site, site))
      found = 1;
    else
      ban_node = ban_node->next;
  }

  if (!found)
  {
    send_to_char("That site is not currently banned.\r\n", ch);
    return;
  }
  REMOVE_FROM_LIST(ban_node, ban_list, next);
  send_to_char("Site unbanned.\r\n", ch);
  sprintf(buf, "%s removed the %s-player ban on %s.",
	  GET_NAME(ch), ban_types[ban_node->type], ban_node->site);
  mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);

  free(ban_node);
  write_ban_list();
}


/**************************************************************************
 *  Code to check for invalid names (i.e., profanity, etc.)		  *
 *  Written by Sharon P. Goza						  *
 **************************************************************************/

#define MAX_INVALID_NAMES	200

char *invalid_list[MAX_INVALID_NAMES];
int num_invalid = 0;

int Valid_Name(char *newname, bool desc_check)
{
  int i;
  struct descriptor_data *dt;
  char tempname[MAX_INPUT_LENGTH];

  /*
   * Make sure someone isn't trying to create this same name.  We want to
   * do a 'str_cmp' so people can't do 'Bob' and 'BoB'.  The creating login
   * will not have a character name yet and other people sitting at the
   * prompt won't have characters yet.
   */
  if (desc_check) 
    for (dt = descriptor_list; dt; dt = dt->next)
      if (dt->character && GET_NAME(dt->character) && !str_cmp(GET_NAME(dt->character), newname))
	switch (STATE(dt))
	{
	  case CON_EXDESC:
	  case CON_MEDIT:
	  case CON_OEDIT:
	  case CON_REDIT:
	  case CON_SEDIT:
	  case CON_TEDIT:
	  case CON_ZEDIT:
	  case CON_REPORT_ADD:
	  case CON_REPORT_EDIT:
	  case CON_TRIGEDIT:
	    // Do we need to do anything here?..
	  case CON_DELCNF1:
	  case CON_DELCNF2:
	  case CON_RMOTD:
	  case CON_MENU:
	  case CON_PLAYING:
	    return (1);
	  default: 
	    return (0);
	}

  /* return valid if list doesn't exist */
  if (!invalid_list || num_invalid < 1)
    return (1);

  /* change to lowercase */
  strcpy(tempname, newname);
  for (i = 0; tempname[i]; i++)
    tempname[i] = LOWER(tempname[i]);

  /* Does the desired name contain a string in the invalid list? */
  for (i = 0; i < num_invalid; i++)
    if (strstr(tempname, invalid_list[i]))
      return (0);

  return (1);
}


void Read_Invalid_List(void)
{
  FILE *fp;
  char temp[256];

  if (!(fp = fopen(XNAME_FILE, "r")))
  {
    perror("SYSERR: Unable to open '" XNAME_FILE "' for reading");
    return;
  }

  num_invalid = 0;
  while (get_line(fp, temp) && num_invalid < MAX_INVALID_NAMES)
    invalid_list[num_invalid++] = str_dup(temp);

  if (num_invalid >= MAX_INVALID_NAMES)
  {
    basic_mud_log("SYSERR: Too many invalid names; change MAX_INVALID_NAMES in ban.c");
    exit(1);
  }

  fclose(fp);
}
@


1.11
log
@Artus> Now warning free :o)
@
text
@d39 2
a40 1
const char *ban_types[] = {
d56 1
d60 3
a62 2
  if (!(fl = fopen(BAN_FILE, "r"))) {
    if (errno != ENOENT) {
d64 1
a64 1
    } else
d68 2
a69 1
  while (fscanf(fl, " %s %s %d %s ", ban_type, site_name, &date, name) == 4) {
d73 2
d76 1
d94 9
a102 8

  //parse_ip("127.0.0.1",&temp);

  //if (temp.s_addr == in.s_addr) {
  //  return BAN_ALL;
  //} else {
    return 0;
  //}  
d128 2
a129 1
  if (node) {
d142 2
a143 1
  if (!(fl = fopen(BAN_FILE, "w"))) {
d159 1
d166 4
a169 2
  if (!*argument) {
    if (!ban_list) {
d198 1
a199 1
#endif
d210 2
a211 1
  if (!*site || !*flag) {
d215 3
a217 1
  if (!(!str_cmp(flag, "select") || !str_cmp(flag, "all") || !str_cmp(flag, "new"))) {
d221 9
a229 2
  for (ban_node = ban_list; ban_node; ban_node = ban_node->next) {
    if (!str_cmp(ban_node->site, site)) {
d240 1
d272 2
a273 1
  while (ban_node && !found) {
d280 2
a281 1
  if (!found) {
d367 2
a368 1
  if (!(fp = fopen(XNAME_FILE, "r"))) {
d377 2
a378 1
  if (num_invalid >= MAX_INVALID_NAMES) {
@


1.10
log
@Artus> Fixed bug that prevented users logging in over themselves after
       connection had crapped out in olc / menu / motd / reports.
       Hopefully fixed bug that was causing eq not to save, sometimes.
@
text
@a86 1
  struct in_addr temp;
@


1.9
log
@Artus> Changed remort, in particular, list remort abilities to char.. Also,
       spellsword was incorrectly being listed as a possible path for a
       warrior.

       Replaced #ifdef USE_LOCALTIME with #ifndef NO_LOCALTIME..

       Added define NOTELL_SOUNDPROOF .. Define this to stop people telling
       to/from soundproof rooms.

       Removed extraneous level checking from do_wear.. This is handled
       better by perform_wear.
@
text
@d293 1
a293 1
  if (desc_check) {
d296 22
a317 2
        return (STATE(dt) == CON_PLAYING);
  }
@


1.8
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@d150 1
a150 1
#ifndef USE_LOCALTIME
d178 1
a178 1
#ifdef USE_LOCALTIME
@


1.7
log
@Artus> Localtime fix.
@
text
@d60 1
a60 1
      log("SYSERR: Unable to open banfile '%s': %s", BAN_FILE, strerror(errno));
d62 1
a62 1
      log("   Ban file '%s' doesn't exist.", BAN_FILE);
d332 1
a332 1
    log("SYSERR: Too many invalid names; change MAX_INVALID_NAMES in ban.c");
@


1.6
log
@
Modified: DM

Changed:
- Don't ask (large group checkin) - lots of bug fixes mainly.
- Use cvs diff if you really wanna see the changes.
@
text
@d150 3
d176 3
a178 1
      if (ban_node->date) {
d180 5
d187 2
a188 1
      } else
d190 1
@


1.5
log
@*** empty log message ***
@
text
@d269 1
a269 1
int Valid_Name(char *newname)
d281 5
a285 3
  for (dt = descriptor_list; dt; dt = dt->next)
    if (dt->character && GET_NAME(dt->character) && !str_cmp(GET_NAME(dt->character), newname))
      return (STATE(dt) == CON_PLAYING);
@


1.4
log
@Modified: DM

Removed:
- debug log lines
@
text
@d91 3
a93 3
  if (temp.s_addr == in.s_addr) {
    return BAN_ALL;
  } else {
d95 1
a95 1
  }  
@


1.3
log
@took out that damnable parse_ip("127..blahblah");
@
text
@a90 3
  log("connect from %s", inet_ntoa(in));
  log("banned from %s", inet_ntoa(temp));

a91 1
    log("Ban: Banned");
a93 1
    log("Ban: Not Banned");
a95 1
	
@


1.2
log
@
Added:
- olc stuff - sectors, zone flags

Changed:
- Heaps of little fixes ....
@
text
@d89 1
a89 1
  parse_ip("127.0.0.1",&temp);
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d11 3
d31 2
d84 9
d94 10
@

