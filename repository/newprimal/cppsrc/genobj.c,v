head	1.13;
access;
symbols
	A3_0_59:1.4
	LATEST:1.4
	A3_0_1:1.4;
locks; strict;
comment	@ * @;


1.13
date	2004.11.24.05.49.49;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.27.02.10.58;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.28.10.07.05;	author john;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.12.11.00.13;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.27.22.33.15;	author primal;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.15.03.29.53;	author primal;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.12.01.46.35;	author artus;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.11.14.00.50;	author artus;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.02.04.34.48;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.17.13.33.19;	author primal;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.22.09.22.35;	author talisman;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.14.00.16.39;	author primal;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.58;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Artus> Added extract_all routine.
@
text
@/************************************************************************
 * Generic OLC Library - Objects / genobj.c			v1.0	*
 * Original author: Levork						*
 * Copyright 1996 by Harvey Gilpin					*
 * Copyright 1997-1999 by George Greer (greerga@@circlemud.org)		*
 ************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "utils.h"
#include "db.h"
#include "boards.h"
#include "shop.h"
#include "genolc.h"
#include "genobj.h"
#include "genzon.h"
#include "dg_olc.h"

static int copy_object_main(struct obj_data *to, struct obj_data *from, int free_object);

extern struct obj_data *obj_proto;
extern struct obj_data *object_list;
extern struct index_data *obj_index;
extern struct zone_data *zone_table;
extern struct board_info_type board_info[];
extern struct shop_data *shop_index;
extern zone_rnum top_of_zone_table;
extern obj_rnum top_of_objt;
extern int top_shop;

obj_rnum add_object(struct obj_data *newobj, obj_vnum ovnum, zone_vnum vznum)
{
  int found = NOTHING;
  zone_rnum rznum = real_zone_by_thing(ovnum);

  /*
   * Write object to internal tables.
   */
  if ((newobj->item_number = real_object(ovnum)) != NOTHING) {
    copy_object(&obj_proto[newobj->item_number], newobj);
    update_objects(&obj_proto[newobj->item_number]);
    add_to_save_list(zone_table[rznum].number, SL_OBJ);
    return newobj->item_number;
  }

  found = insert_object(newobj, ovnum, vznum);
  adjust_objects(found);
  add_to_save_list(zone_table[rznum].number, SL_OBJ);
  return found;
}

/* ------------------------------------------------------------------------------------------------------------------------------ */

/*
 * Fix all existing objects to have these values.
 * We need to run through each and every object currently in the
 * game to see which ones are pointing to this prototype.
 * if object is pointing to this prototype, then we need to replace it
 * with the new one.
 */
int update_objects(struct obj_data *refobj)
{
  struct obj_data *obj, swap;
  int count = 0;

  for (obj = object_list; obj; obj = obj->next) {
    if (obj->item_number != refobj->item_number)
      continue;

    count++;

    /* Update the existing object but save a copy for private information. */
    swap = *obj;
    *obj = *refobj;

    /* Copy game-time dependent variables over. */
    obj->in_room = swap.in_room;
    obj->carried_by = swap.carried_by;
    obj->worn_by = swap.worn_by;
    obj->worn_on = swap.worn_on;
    obj->in_obj = swap.in_obj;
    obj->contains = swap.contains;
    obj->next_content = swap.next_content;
    obj->next = swap.next;
  }

  return count;
}

/* ------------------------------------------------------------------------------------------------------------------------------ */

/*
 * Adjust the internal values of other objects as if something was inserted at the given array index.
 * Might also be useful to make 'holes' in the array for some reason.
 */
int adjust_objects(obj_rnum refpt)
{
  int shop, i, zone, cmd_no;
  struct obj_data *obj;

  if (refpt < 0 || refpt >= top_of_objt)
    return refpt;

  /*
   * Renumber live objects.
   */
  for (obj = object_list; obj; obj = obj->next)
    GET_OBJ_RNUM(obj) += (GET_OBJ_RNUM(obj) >= refpt);

  /*
   * Renumber zone table.
   */
  for (zone = 0; zone <= top_of_zone_table; zone++) {
    for (cmd_no = 0; ZCMD(zone, cmd_no).command != 'S'; cmd_no++) {
      switch (ZCMD(zone, cmd_no).command) {
      case 'P':
        ZCMD(zone, cmd_no).arg3 += (ZCMD(zone, cmd_no).arg3 >= refpt);
         /*
          * No break here - drop into next case.
          */
      case 'O':
      case 'G':
      case 'E':
        ZCMD(zone, cmd_no).arg1 += (ZCMD(zone, cmd_no).arg1 >= refpt);
        break;
      case 'R':
        ZCMD(zone, cmd_no).arg2 += (ZCMD(zone, cmd_no).arg2 >= refpt);
        break;
      }
    }
  }

  /*
   * Renumber notice boards.
   */
  for (i = 0; i < NUM_OF_BOARDS; i++)
    BOARD_RNUM(i) += (BOARD_RNUM(i) >= refpt);

  /*
   * Renumber shop produce.
   */
  for (shop = 0; shop <= top_shop - top_shop_offset; shop++)
    for (i = 0; SHOP_PRODUCT(shop, i) != NOTHING; i++)
      SHOP_PRODUCT(shop, i) += (SHOP_PRODUCT(shop, i) >= refpt);

  return refpt;
}

/* ------------------------------------------------------------------------------------------------------------------------------ */

/*
 * Function handle the insertion of an object within the prototype framework.  Note that this does not adjust internal values
 * of other objects, use add_object() for that.
 */
int insert_object(struct obj_data *obj, obj_vnum ovnum, zone_vnum vznum)
{
  int i;

  top_of_objt++;
  zone_table[real_zone(vznum)].noobjs++;
  RECREATE(obj_index, struct index_data, top_of_objt + 1);
  RECREATE(obj_proto, struct obj_data, top_of_objt + 1);

  /*
   * Start counting through both tables.
   */
  for (i = top_of_objt; i > 0; i--) {
    /*
     * Check if current virtual is bigger than our virtual number.
     */
    if (ovnum > obj_index[i - 1].vnum)
      return index_object(obj, ovnum, i, vznum);

    /* Copy over the object that should be here. */
    obj_index[i] = obj_index[i - 1];
    obj_proto[i] = obj_proto[i - 1];
    obj_proto[i].item_number = i;
  }

  /* Not found, place at 0. */
  return index_object(obj, ovnum, 0, vznum);
}

/* ------------------------------------------------------------------------------------------------------------------------------ */

int index_object(struct obj_data *obj, obj_vnum ovnum, obj_rnum ornum, zone_vnum vznum)
{
  if (obj == NULL || ovnum < 0 || ornum < 0 || ornum > top_of_objt)
    return NOWHERE;

  zone_rnum rznum = real_zone(vznum);

  obj->item_number = ornum;
  obj_index[ornum].vnum = ovnum;
  obj_index[ornum].vznum = vznum; 
  obj_index[ornum].rznum = rznum; 
  obj_index[ornum].number = 0;
  obj_index[ornum].func = NULL;
  
  // DM - check if needed ... TDOD
  //new_obj_proto[robj_num].proto_script = OLC_SCRIPT(d);

  copy_object_preserve(&obj_proto[ornum], obj);
  obj_proto[ornum].in_room = NOWHERE;

  return ornum;
}

/* ------------------------------------------------------------------------------------------------------------------------------ */

int save_objects(zone_rnum zone_num)
{
  int counter, counter2, realcounter;
  FILE *fp;
  struct obj_data *obj;
  struct extra_descr_data *ex_desc;

  if (zone_num < 0 || zone_num > top_of_zone_table)
  {
    basic_mud_log("SYSERR: GenOLC: save_objects: Invalid real zone number %d. (0-%d)", zone_num, top_of_zone_table);
    return FALSE;
  }
  sprintf(buf, "%s/%d.new", OBJ_PREFIX, zone_table[zone_num].number);
  if (!(fp = fopen(buf, "w+")))
  {
    mudlog("SYSERR: OLC: Cannot open objects file!", BRF, LVL_BUILDER, TRUE);
    return FALSE;
  }
  /*
   * Start running through all objects in this zone.
   */
  for (counter=zone_table[zone_num].number*100; 
       counter <= zone_table[zone_num].top; counter++)
  {
    if ((realcounter = real_object(counter)) >= 0)
    {
      if ((obj = &obj_proto[realcounter])->action_description)
      {
        buf1[MAX_STRING_LENGTH - 1] = '\0';
	strncpy(buf1, obj->action_description, MAX_STRING_LENGTH - 1);
	strip_cr(buf1);
      } else
	*buf1 = '\0';
      fprintf(fp,
	      "#%d\n"
	      "%s~\n"
	      "%s~\n"
	      "%s~\n"
	      "%s~\n"
	      "%d %d %d %ld\n"
	      "%d %d %d %d\n"
	      "%d %d %d %d\n"
	      "L %d\n",
	      GET_OBJ_VNUM(obj),
	      (obj->name && *obj->name) ? obj->name : "undefined",
	      (obj->short_description && *obj->short_description) ? 
	        obj->short_description : "undefined",
	      (obj->description && *obj->description) ?	
	        obj->description : "undefined", buf1,
	      GET_OBJ_TYPE(obj), GET_OBJ_EXTRA(obj), GET_OBJ_WEAR(obj), 
	      GET_OBJ_PERM(obj), GET_OBJ_VAL(obj, 0), GET_OBJ_VAL(obj, 1),
	      GET_OBJ_VAL(obj, 2), GET_OBJ_VAL(obj, 3), GET_OBJ_WEIGHT(obj),
	      GET_OBJ_COST(obj), GET_OBJ_RENT(obj), GET_OBJ_LEVEL(obj),
	      GET_OBJ_LEVEL(obj));
      script_save_to_disk(fp, obj, OBJ_TRIGGER);
      /*
       * Do we have extra descriptions? 
       */
      if (obj->ex_description)
      {	/* Yes, save them too. */
	for (ex_desc = obj->ex_description; ex_desc; ex_desc = ex_desc->next)
	{
	  /*
	   * Sanity check to prevent nasty protection faults.
	   */
	  if (!ex_desc->keyword  || !ex_desc->description || 
	      !*ex_desc->keyword || !*ex_desc->description)
	  {
	    mudlog("SYSERR: OLC: oedit_save_to_disk: Corrupt ex_desc!", 
		   BRF, LVL_BUILDER, TRUE);
	    continue;
	  }
          buf1[MAX_STRING_LENGTH - 1] = '\0';
	  strncpy(buf1, ex_desc->description, MAX_STRING_LENGTH - 1);
	  strip_cr(buf1);
	  fprintf(fp, "E\n"
		      "%s~\n"
		      "%s~\n", ex_desc->keyword, buf1);
	}
      }
      /*
       * Do we have affects? 
       */
      for (counter2 = 0; counter2 < MAX_OBJ_AFFECT; counter2++)
	if (obj->affected[counter2].modifier)
	  fprintf(fp, "A\n"
		      "%d %d\n",
		  obj->affected[counter2].location,
		  obj->affected[counter2].modifier);
      /*
       * Do we have a list of products that this item can make
       */
       if (obj->products != NULL)
       {
         basic_mud_log("object %s has products list", obj->name);
         // iterate through products list and save 
         list<ObjProductClass>::iterator itrProd = obj->products->begin();
         while (obj->products->end() != itrProd);
       }

      /* 
       * Do we have a list of materials that makes this object
       */
       if (obj->materials != NULL)
       {
         basic_mud_log("object %s has materials list", obj->name);
         // iterate through materials list and save 
         list<ObjMaterialClass>::iterator itrMat = obj->materials->begin();
         while (obj->materials->end() != itrMat);
       }
    }
  }

  /*
   * Write the final line, close the file.
   */
  fprintf(fp, "$~\n");
  fclose(fp);
  sprintf(buf2, "%s/%d.obj", OBJ_PREFIX, zone_table[zone_num].number);
  remove(buf2);
  rename(buf, buf2);

  remove_from_save_list(zone_table[zone_num].number, SL_OBJ);
  return TRUE;
}

/*
 * Free all, unconditionally.
 */
void free_object_strings(struct obj_data *obj)
{
#if 0 /* Debugging, do not enable. */
  extern struct obj_data *object_list;
  struct obj_data *t;
  int i = 0;

  for (t = object_list; t; t = t->next) {
    if (t == obj) {
      i++;
      continue;
    }
    assert(obj->name != t->name);
    assert(obj->description != t->description);
    assert(obj->short_description != t->short_description);
    assert(obj->action_description != t->action_description);
    assert(obj->ex_description != t->ex_description);
  }
  assert(i <= 1);
#endif

  if (obj->name)
    free(obj->name);
  if (obj->description)
    free(obj->description);
  if (obj->short_description)
    free(obj->short_description);
  if (obj->action_description)
    free(obj->action_description);
  if (obj->ex_description)
    free_ex_descriptions(obj->ex_description);
}

/*
 * For object instances that are not the prototype.
 */
void free_object_strings_proto(struct obj_data *obj)
{
  int robj_num = GET_OBJ_RNUM(obj);

//  basic_mud_log("object: %s (%d)", obj->short_description, GET_OBJ_VNUM(obj));

  if (obj->name && obj->name != obj_proto[robj_num].name)
    free(obj->name);
  if (obj->description && obj->description != obj_proto[robj_num].description)
    free(obj->description);
  if (obj->short_description && obj->short_description != obj_proto[robj_num].short_description)
    free(obj->short_description);
  if (obj->action_description && obj->action_description != obj_proto[robj_num].action_description)
    free(obj->action_description);
  if (obj->ex_description) {
    struct extra_descr_data *thised, *plist, *next_one; /* O(horrible) */
    int ok_key, ok_desc, ok_item;
    for (thised = obj->ex_description; thised; thised = next_one) {
      next_one = thised->next;
      for (ok_item = ok_key = ok_desc = 1, plist = obj_proto[robj_num].ex_description; plist; plist = plist->next) {
        if (plist->keyword == thised->keyword)
          ok_key = 0;
        if (plist->description == thised->description)
          ok_desc = 0;
        if (plist == thised)
          ok_item = 0;
      }
      if (thised->keyword && ok_key)
        free(thised->keyword);
      if (thised->description && ok_desc)
        free(thised->description);
      if (ok_item)
        free(thised);
    }
  }
}

void copy_object_strings(struct obj_data *to, struct obj_data *from)
{
  to->name = from->name ? str_dup(from->name) : NULL;
  to->description = from->description ? str_dup(from->description) : NULL;
  to->short_description = from->short_description ? str_dup(from->short_description) : NULL;
  to->action_description = from->action_description ? str_dup(from->action_description) : NULL;

  if (from->ex_description)
    copy_ex_descriptions(&to->ex_description, from->ex_description);
  else
    to->ex_description = NULL;

}

int copy_object(struct obj_data *to, struct obj_data *from)
{
  free_object_strings(to);
  return copy_object_main(to, from, TRUE);
}

int copy_object_preserve(struct obj_data *to, struct obj_data *from)
{
  return copy_object_main(to, from, FALSE);
}

static int copy_object_main(struct obj_data *to, struct obj_data *from, int free_object)
{
  *to = *from;
  copy_object_strings(to, from);
  return TRUE;
}

void extract_object_all(obj_vnum vnum)
{
  void extract_obj(struct obj_data *obj);
  struct obj_data *next, *obj;

  for (obj = object_list; obj; obj = next)
  {
    next = obj->next;
    if (GET_OBJ_VNUM(obj) == vnum)
      extract_obj(obj);
  }
}
@


1.12
log
@Artus> Chagned mudlogs to LVL_BUILDER vs LVL_IMMORT.
@
text
@d445 13
@


1.11
log
@Continued development on manufacturing code
@
text
@d219 2
a220 1
  if (zone_num < 0 || zone_num > top_of_zone_table) {
a223 1

d225 3
a227 2
  if (!(fp = fopen(buf, "w+"))) {
    mudlog("SYSERR: OLC: Cannot open objects file!", BRF, LVL_IMMORT, TRUE);
d233 7
a239 3
  for (counter = zone_table[zone_num].number * 100; counter <= zone_table[zone_num].top; counter++) {
    if ((realcounter = real_object(counter)) >= 0) {
      if ((obj = &obj_proto[realcounter])->action_description) {
a244 1

a254 1

d257 9
a265 9
	      (obj->short_description && *obj->short_description) ? obj->short_description : "undefined",
	      (obj->description && *obj->description) ?	obj->description : "undefined",
	      buf1,
	      GET_OBJ_TYPE(obj), GET_OBJ_EXTRA(obj), GET_OBJ_WEAR(obj), GET_OBJ_PERM(obj),
	      GET_OBJ_VAL(obj, 0), GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 2), GET_OBJ_VAL(obj, 3),
	      GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj), GET_OBJ_RENT(obj), GET_OBJ_LEVEL(obj),
	      GET_OBJ_LEVEL(obj)
      );

a266 1

d270 4
a273 2
      if (obj->ex_description) {	/* Yes, save them too. */
	for (ex_desc = obj->ex_description; ex_desc; ex_desc = ex_desc->next) {
d277 5
a281 2
	  if (!ex_desc->keyword || !ex_desc->description || !*ex_desc->keyword || !*ex_desc->description) {
	    mudlog("SYSERR: OLC: oedit_save_to_disk: Corrupt ex_desc!", BRF, LVL_IMMORT, TRUE);
d288 2
a289 2
		  "%s~\n"
		  "%s~\n", ex_desc->keyword, buf1);
d298 2
a299 1
		  "%d %d\n", obj->affected[counter2].location,
d304 4
a307 3
       if (obj->products != NULL) {
          basic_mud_log("object %s has products list", obj->name);
          // iterate through products list and save 
d309 1
a309 3
         while (obj->products->end() != itrProd) {
         }
       
d315 2
a316 1
       if (obj->materials != NULL) {
d320 1
a320 2
         while (obj->materials->end() != itrMat) {
         }
@


1.10
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@d293 22
@


1.9
log
@Modified: DM

Changed:
- Detailed zone data (UNCOMPLETE!)
@
text
@d220 1
a220 1
    log("SYSERR: GenOLC: save_objects: Invalid real zone number %d. (0-%d)", zone_num, top_of_zone_table);
d352 1
a352 1
//  log("object: %s (%d)", obj->short_description, GET_OBJ_VNUM(obj));
@


1.8
log
@Modified: DM

Changed:
- added '\n' at L %d line for objs
@
text
@d161 1
d192 2
d197 1
@


1.7
log
@Modified: DM

Changed:
- fixed oedit save to correctly output our obj files (was missing L XXX)
  for levels - which has consequently fucked up all our levels on objs in zones
  saved using olc :(
@
text
@d246 1
a246 1
	      "L %d",
@


1.6
log
@Modified: DM

Changed:
- function calls to pass another attribute for the virtual zone number
@
text
@d245 2
a246 1
	      "%d %d %d %d\n",
d255 2
a256 1
	      GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj), GET_OBJ_RENT(obj), GET_OBJ_LEVEL(obj)
@


1.5
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d32 1
a32 1
obj_rnum add_object(struct obj_data *newobj, obj_vnum ovnum)
d47 1
a47 1
  found = insert_object(newobj, ovnum);
d156 1
a156 1
int insert_object(struct obj_data *obj, obj_vnum ovnum)
d172 1
a172 1
      return index_object(obj, ovnum, i);
d181 1
a181 1
  return index_object(obj, ovnum, 0);
d186 1
a186 1
int index_object(struct obj_data *obj, obj_vnum ovnum, obj_rnum ornum)
d193 1
@


1.4
log
@
Removed:
- removed "Object freed!" log
@
text
@d18 1
d195 3
d256 2
d389 1
@


1.3
log
@

Added:
- Events
-

Changed:
- Score command
-

TODO:
- Finish the base
-
@
text
@a369 1
  log("Object freed!");
@


1.2
log
@
Removed:
- Tali's log messages
@
text
@d370 1
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d339 1
a339 1
  log("object: %s (%d)", obj->short_description, GET_OBJ_VNUM(obj));
@

