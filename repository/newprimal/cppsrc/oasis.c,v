head	1.12;
access;
symbols
	A3_0_59:1.1
	LATEST:1.1
	A3_0_1:1.1;
locks; strict;
comment	@ * @;


1.12
date	2004.08.27.02.12.35;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.10.12.02.26;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.17.02.25.06;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.12.11.00.14;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.20.12.01.50;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.14.07.24.16;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.11.10.48.13;	author rod;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.27.22.33.15;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.04.08.10.54;	author primal;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.08.15.28.28;	author primal;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.02.04.34.48;	author primal;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.59;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Artus> Changed a couple of LVL_IMMORTs to LVL_BUILDERs
@
text
@/************************************************************************
 * OasisOLC - General / oasis.c					v2.0	*
 * Original author: Levork						*
 * Copyright 1996 by Harvey Gilpin					*
 * Copyright 1997-1999 by George Greer (greerga@@circlemud.org)		*
 ************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "interpreter.h"
#include "comm.h"
#include "db.h"
#include "shop.h"
#include "genolc.h"
#include "genmob.h"
#include "genshp.h"
#include "genzon.h"
#include "genwld.h"
#include "genobj.h"
#include "oasis.h"
#include "screen.h"
#include "dg_olc.h"
#include "constants.h"

const char *nrm, *grn, *cyn, *yel;

/*
 * External data structures.
 */
extern struct obj_data *obj_proto;
extern struct char_data *mob_proto;
extern struct room_data *world;
extern zone_rnum top_of_zone_table;
extern struct zone_data *zone_table;
extern struct descriptor_data *descriptor_list;
extern struct index_data *obj_index;	/* index table for object file	 */
extern struct obj_data *obj_proto;	/* prototypes for objs		 */
extern struct index_data *mob_index;	/* index table for mobile file	 */
extern obj_rnum top_of_objt;	/* top of object index table	 */
extern mob_rnum top_of_mobt;	/* top of mobile index table	 */

/*
 * Internal data structures.
 */
struct olc_scmd_info_t {
  const char *text;
  int con_type;
} olc_scmd_info[] = {
  { "room",	CON_REDIT },
  { "object",	CON_OEDIT },
  { "zone",	CON_ZEDIT },
  { "mobile",	CON_MEDIT },
  { "shop",	CON_SEDIT },
  { "trigger",  CON_TRIGEDIT},
  { "\n",	-1	  }
};

/* -------------------------------------------------------------------------- */

/*
 * Only player characters should be using OLC anyway.
 */
void clear_screen(struct descriptor_data *d)
{
  if (PRF_FLAGGED(d->character, PRF_CLS))
    send_to_char("[H[J", d->character);
}

/* -------------------------------------------------------------------------- */

/*
 * Exported ACMD do_oasis function.
 *
 * This function is the OLC interface.  It deals with all the 
 * generic OLC stuff, then passes control to the sub-olc sections.
 */
ACMD(do_oasis)
{
  int number = -1, save = 0, real_num;
  struct descriptor_data *d;
  // No screwing around as a mobile.
  if (IS_NPC(ch))
    return;
  
  if ((GET_OLC_ZONE(ch) == 0) && LR_FAIL(ch, LVL_IMPL))
  {
    send_to_char("You do not have a zone assigned to you.\r\n", ch);
    return;
  }

  /*
   * The command to see what needs to be saved, typically 'olc'.
   */
  if (subcmd == SCMD_OLC_SAVEINFO)
  {
    do_show_save_list(ch);
    return;
  }

  /* 
   * Don't allow olc'ing while fighting. -- Artus> 20031014 
   */
  if (FIGHTING(ch))
  {
    send_to_char("No no no.. Stop fighting first.\r\n", ch);
    return;
  }

  /*
   * Parse any arguments.
   */
  two_arguments(argument, buf1, buf2);
  if (!*buf1)
  {		/* No argument given. */
    switch (subcmd)
    {
      case SCMD_OASIS_ZEDIT:
      case SCMD_OASIS_REDIT:
	number = GET_ROOM_VNUM(IN_ROOM(ch));
	break;
      case SCMD_OASIS_TRIGEDIT:
      case SCMD_OASIS_OEDIT:
      case SCMD_OASIS_MEDIT:
      case SCMD_OASIS_SEDIT:
	sprintf(buf, "Specify a %s VNUM to edit.\r\n",
	        olc_scmd_info[subcmd].text);
	send_to_char(buf, ch);
	return;
    }
  } else if (!isdigit(*buf1)) {
    if (str_cmp("save", buf1) == 0) 
    {
      save = TRUE;
      if ((number = (*buf2 ? atoi(buf2) : 
	            (GET_OLC_ZONE(ch) ? GET_OLC_ZONE(ch) : -1)) * 100) < 0) 
      {
	send_to_char("Save which zone?\r\n", ch);
	return;
      }
    } else if (!str_cmp("new", buf1) && (subcmd == SCMD_OASIS_ZEDIT) && 
	       !LR_FAIL(ch, LVL_IMPL)) {
      if ((*buf2) && (number = atoi(buf2)) >= 0)
	zedit_new_zone(ch, number);
      else
	send_to_char("Specify a new zone number.\r\n", ch);
      return;
    } else if ((str_cmp("sect", buf1) == 0) && (subcmd == SCMD_OASIS_ZEDIT) &&
	       ((GET_OLC_ZONE(ch) == zone_table[world[IN_ROOM(ch)].zone].number)
		|| !LR_FAIL(ch, LVL_IMPL))) {
      if (!(*buf2))
	number = -1;
      else
	number = atoi(buf2);
      zedit_sect_all(ch, number);
      return;
    } else {
      send_to_char("Yikes!  Stop that, someone will get hurt!\r\n", ch);
      return;
    }
  }

  /*
   * If a numeric argument was given (like a room number), get it.
   */
  if (number == -1)
    number = atoi(buf1);

  /*
   * Check that whatever it is isn't already being edited.
   */
  for (d = descriptor_list; d; d = d->next)
    if (STATE(d) == olc_scmd_info[subcmd].con_type)
      if (d->olc && OLC_NUM(d) == number)
      {
	sprintf(buf, "That %s is currently being edited by %s.\r\n", olc_scmd_info[subcmd].text, PERS(d->character, ch));
	send_to_char(buf, ch);
	return;
      }
  d = ch->desc;
 
  /*
   * Give descriptor an OLC structure.
   */
  if (d->olc)
  {
    mudlog("SYSERR: do_oasis: Player already had olc structure.", 
	   BRF, LVL_BUILDER, TRUE);
    free(d->olc);
  }
  CREATE(d->olc, struct oasis_olc_data, 1);

  /*
   * Find the zone.
   */

  // DM: DEBUG INFO
  //sprintf(buf, "number = %d, real_zone_by_thing(number) = %d", number,
  //    real_zone_by_thing(number));
  //mudlog(buf, NRM, LVL_GOD, TRUE);
  
  if ((OLC_ZNUM(d) = real_zone_by_thing(number)) == -1)
  {
    send_to_char("Sorry, there is no zone for that number!\r\n", ch);
    free(d->olc);
    d->olc = NULL;
    return;
  }

  /*
   * Everyone but IMPLs can only edit zones they have been assigned.
   * DM: allow full access for chars with olc zone number 0
   * Artus> Coz primr keeps crashing it by pasting lots.. <IMPL now get a 
   *        wait_state.
   */
  if (LR_FAIL(ch, LVL_IMPL))
  {
    if ((GET_OLC_ZONE(ch) != 0) && 
	(zone_table[OLC_ZNUM(d)].number != GET_OLC_ZONE(ch)))
    {
      send_to_char("You do not have permission to edit this zone.\r\n", ch);
      free(d->olc);
      d->olc = NULL;
      return;
    }
    GET_WAIT_STATE(ch) = PULSE_VIOLENCE;
  }

  if (save)
  {
    const char *type = NULL;
 
    if (subcmd >= 0 && subcmd <= (int)(sizeof(olc_scmd_info) / sizeof(struct olc_scmd_info_t) - 1))
      type = olc_scmd_info[subcmd].text;
    else
    {
      send_to_char("Oops, I forgot what you wanted to save.\r\n", ch);
      return;
    }
    sprintf(buf, "Saving all %ss in zone %d.\r\n", type,
	    zone_table[OLC_ZNUM(d)].number);
    send_to_char(buf, ch);
    sprintf(buf, "OLC: %s saves %s info for zone %d.",
	    GET_NAME(ch), type, zone_table[OLC_ZNUM(d)].number);
    mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE);
    switch (subcmd)
    {
      case SCMD_OASIS_REDIT: save_rooms(OLC_ZNUM(d));   break;
      case SCMD_OASIS_ZEDIT: save_zone(OLC_ZNUM(d));    break;
      case SCMD_OASIS_OEDIT: save_objects(OLC_ZNUM(d)); break;
      case SCMD_OASIS_MEDIT: save_mobiles(OLC_ZNUM(d)); break;
      case SCMD_OASIS_SEDIT: save_shops(OLC_ZNUM(d));   break;
    }
    free(d->olc);
    d->olc = NULL;
    return;
  }

  OLC_NUM(d) = number;
  /*
   * Steal player's descriptor and start up subcommands.
   */
  switch (subcmd)
  {
    case SCMD_OASIS_TRIGEDIT:
      if ((real_num = real_trigger(number)) >= 0)
	trigedit_setup_existing(d, real_num);
      else
	trigedit_setup_new(d);
      STATE(d) = CON_TRIGEDIT;
      break;
    case SCMD_OASIS_REDIT:
      if ((real_num = real_room(number)) >= 0)
	redit_setup_existing(d, real_num);
      else
	redit_setup_new(d);
      STATE(d) = CON_REDIT;
      break;
    case SCMD_OASIS_ZEDIT:
      if ((real_num = real_room(number)) < 0)
      {
	send_to_char("That room does not exist.\r\n", ch);
	free(d->olc);
	d->olc = NULL;
	return;
      }
      zedit_setup(d, real_num);
      STATE(d) = CON_ZEDIT;
      break;
    case SCMD_OASIS_MEDIT:
      if ((real_num = real_mobile(number)) < 0)
	medit_setup_new(d);
      else
	medit_setup_existing(d, real_num);
      STATE(d) = CON_MEDIT;
      break;
    case SCMD_OASIS_OEDIT:
      if ((number == 1351) || (number == 1350))
      { // Artus> Only allow these to be changed offline.
	send_to_char("Cannot edit map/atlas with OLC.\r\n", ch);
	free(d->olc);
	d->olc = NULL;
	return;
      }
      if ((real_num = real_object(number)) >= 0)
	oedit_setup_existing(d, real_num);
      else
	oedit_setup_new(d);
      STATE(d) = CON_OEDIT;
      break;
    case SCMD_OASIS_SEDIT:
      if ((real_num = real_shop(number)) >= 0)
	sedit_setup_existing(d, real_num);
      else
	sedit_setup_new(d);
      STATE(d) = CON_SEDIT;
      break;
  }
  act("$n starts using OLC.", TRUE, d->character, 0, 0, TO_ROOM);
  SET_BIT(PLR_FLAGS(ch), PLR_WRITING);
}

/*------------------------------------------------------------*\
 Exported utilities 
\*------------------------------------------------------------*/

/*
 * Set the colour string pointers for that which this char will
 * see at color level NRM.  Changing the entries here will change 
 * the colour scheme throughout the OLC.
 */
void get_char_colors(struct char_data *ch)
{
  nrm = CCNRM(ch, C_NRM);
  grn = CCGRN(ch, C_NRM);
  cyn = CCCYN(ch, C_NRM);
  yel = CCYEL(ch, C_NRM);
}

/*
 * This procedure frees up the strings and/or the structures
 * attatched to a descriptor, sets all flags back to how they
 * should be.
 */
void cleanup_olc(struct descriptor_data *d, byte cleanup_type)
{
  /*
   * Clean up WHAT?
   */
  if (d->olc == NULL)
    return;

  /*
   * Check for a room. free_room doesn't perform
   * sanity checks, we must be careful here.
   */
  if (OLC_ROOM(d))
  {
    switch (cleanup_type)
    {
      case CLEANUP_ALL:
	free_room(OLC_ROOM(d));
	break;
      case CLEANUP_STRUCTS:
	free(OLC_ROOM(d));
	break;
      default: /* The caller has screwed up. */
	basic_mud_log("SYSERR: cleanup_olc: Unknown type!");
	break;
    }
  }

  /*
   * Check for an existing object in the OLC.  The strings
   * aren't part of the prototype any longer.  They get added
   * with str_dup().
   */
  if (OLC_OBJ(d))
  {
    free_object_strings(OLC_OBJ(d));
    free(OLC_OBJ(d));
  }

  /*
   * Check for a mob.  free_mobile() makes sure strings are not in
   * the prototype.
   */
  if (OLC_MOB(d))
    free_mobile(OLC_MOB(d));

  /*
   * Check for a zone.  cleanup_type is irrelevant here, free() everything.
   */
  if (OLC_ZONE(d))
  {
    free(OLC_ZONE(d)->name);
    free(OLC_ZONE(d)->cmd);
    free(OLC_ZONE(d));
  }

  /*
   * Check for a shop.  free_shop doesn't perform sanity checks, we must
   * be careful here.
   */
  if (OLC_SHOP(d))
  {
    switch (cleanup_type)
    {
      case CLEANUP_ALL:
	free_shop(OLC_SHOP(d));
	break;
      case CLEANUP_STRUCTS:
	free(OLC_SHOP(d));
	break;
      default:
	/* The caller has screwed up but we already griped above. */
	break;
    }
  }

  /*
   * Restore descriptor playing status.
   */
  if (d->character)
  {
    REMOVE_BIT(PLR_FLAGS(d->character), PLR_WRITING);
    STATE(d) = CON_PLAYING;
    act("$n stops using OLC.", TRUE, d->character, NULL, NULL, TO_ROOM);
  }

  free(d->olc);
  d->olc = NULL;
}

int get_type(char *str, int type)
{
  int i;

  switch(type)
  {
    case LIST_OBJ:
      for (i = 0; i < NUM_ITEM_TYPES; i++)
        if (is_abbrev(str, item_types[i]))
          return (i);
      break;
    case LIST_MOB:
      for (i = 0; i < NUM_NPC_CLASSES; i++)
        if (is_abbrev(str, npc_class_types[i]))
          return (i);
  }
  return (NOTHING);
}

ACMD(do_oasislist)
{
  char *ousage = "&1usage: &4olist [from_vnum to_vnum obj_type]&n\r\n"; 
  char *musage = "&1usage: &4mlist [from_vnum to_vnum mob_class]&n\r\n"; 
  char *rusage = "&1usage: &4rlist [from_vnum to_vnum]&n\r\n"; 
  half_chop(argument, buf, buf1);
  int from = 0, to = obj_proto[top_of_objt].item_number; 
  int type = NOTHING, i, nr, found = 0;

  if (!*buf)
  {
    switch (subcmd)
    {
      case LIST_OBJ:
        send_to_char(ousage, ch);
        break;
      case LIST_MOB:
        send_to_char(musage, ch);
        break;
      case LIST_ROOM:
        send_to_char(rusage, ch);
        break;
    }
    return;
  } else {
    // First arg digit - from
    if (isdigit(buf[0]))
    {
      from = atoi(buf);
      to = from;
      half_chop(buf1, buf, buf1);
      // second argument
      if (*buf)
      {
        // second argument digit - to
        if (isdigit(buf[0]))
	{
          to = atoi(buf); 
          half_chop(buf1, buf, buf1);

          // third argument - object type 
          if (*buf)
            type = get_type(buf, subcmd);
        // second argument - object type
        } else {
          type = get_type(buf, subcmd);
        } 
      }
    // first argument - object type
    } else {
      type = get_type(buf, subcmd);
    }
  }

  // Now do some quick checking
  if (to < from)
  {
    send_to_char("to_vnum must be less than from_vnum.\r\n", ch);
    return;
  }

  buf[0] = '\0';
  switch (subcmd)
  {
    case LIST_OBJ:
      for (nr = 0; nr <= top_of_objt; nr++)
        if ((obj_index[nr].vnum >= from && obj_index[nr].vnum <= to) &&
            (type == NOTHING || obj_proto[nr].obj_flags.type_flag == type))
	{ 
	  sprintf(buf2, "%3d. &8[%5d]&n &5%s&n\r\n", ++found,
		  obj_index[nr].vnum, obj_proto[nr].short_description);
	  strncat(buf, buf2, strlen(buf2));
	}
      break;
    case LIST_MOB:
      for (nr = 0; nr <= top_of_mobt; nr++)
        if ((mob_index[nr].vnum >= from && mob_index[nr].vnum <= to) &&
            (type == NOTHING || mob_proto[nr].player.chclass == type))
	{
	  sprintf(buf2, "%3d. &8[%5d]&n &6%s&n\r\n", ++found,
		  mob_index[nr].vnum, mob_proto[nr].player.short_descr);
	  strncat(buf, buf2, strlen(buf2));
	}
      break;
    case LIST_ROOM:
      for (i = 0; i < top_of_world; i++)
        if (world[i].number >= from && world[i].number <= to)
	{
          sprintf(buf2, "%3d. &8[%5d] %s&n\r\n", ++found, world[i].number, 
                          world[i].name);
          strncat(buf, buf2, strlen(buf2));
        }
      break;
    default:
      break;
  }
  page_string(ch->desc, buf, TRUE);
}
@


1.11
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d84 1
a84 4

  /*
   * No screwing around as a mobile.
   */
d97 2
a98 1
  if (subcmd == SCMD_OLC_SAVEINFO) {
d116 16
a131 13
  if (!*buf1) {		/* No argument given. */
    switch (subcmd) {
    case SCMD_OASIS_ZEDIT:
    case SCMD_OASIS_REDIT:
      number = GET_ROOM_VNUM(IN_ROOM(ch));
      break;
    case SCMD_OASIS_TRIGEDIT:
    case SCMD_OASIS_OEDIT:
    case SCMD_OASIS_MEDIT:
    case SCMD_OASIS_SEDIT:
      sprintf(buf, "Specify a %s VNUM to edit.\r\n", olc_scmd_info[subcmd].text);
      send_to_char(buf, ch);
      return;
d137 2
a138 1
      if ((number = (*buf2 ? atoi(buf2) : (GET_OLC_ZONE(ch) ? GET_OLC_ZONE(ch) : -1)) * 100) < 0 ) 
d150 3
a152 2
    } else if ((str_cmp("sect", buf1) == 0) && (subcmd == SCMD_OASIS_ZEDIT) && ((GET_OLC_ZONE(ch) == zone_table[world[IN_ROOM(ch)].zone].number) || !LR_FAIL(ch, LVL_IMPL)))
    {
d176 2
a177 1
      if (d->olc && OLC_NUM(d) == number) {
d187 4
a190 2
  if (d->olc) {
    mudlog("SYSERR: do_oasis: Player already had olc structure.", BRF, LVL_IMMORT, TRUE);
d204 2
a205 1
  if ((OLC_ZNUM(d) = real_zone_by_thing(number)) == -1) {
d220 3
a222 1
    if (GET_OLC_ZONE(ch) != 0 && (zone_table[OLC_ZNUM(d)].number != GET_OLC_ZONE(ch))) {
d231 2
a232 1
  if (save) {
d237 2
a238 1
    else {
d242 2
a243 1
    sprintf(buf, "Saving all %ss in zone %d.\r\n", type, zone_table[OLC_ZNUM(d)].number);
d245 2
a246 1
    sprintf(buf, "OLC: %s saves %s info for zone %d.", GET_NAME(ch), type, zone_table[OLC_ZNUM(d)].number);
d248 4
a251 4

    switch (subcmd) {
      case SCMD_OASIS_REDIT: save_rooms(OLC_ZNUM(d)); break;
      case SCMD_OASIS_ZEDIT: save_zone(OLC_ZNUM(d)); break;
d254 1
a254 1
      case SCMD_OASIS_SEDIT: save_shops(OLC_ZNUM(d)); break;
a261 1

d265 55
a319 55
  switch (subcmd) {
  case SCMD_OASIS_TRIGEDIT:
    if ((real_num = real_trigger(number)) >= 0)
      trigedit_setup_existing(d, real_num);
    else
      trigedit_setup_new(d);
    STATE(d) = CON_TRIGEDIT;
    break;
  case SCMD_OASIS_REDIT:
    if ((real_num = real_room(number)) >= 0)
      redit_setup_existing(d, real_num);
    else
      redit_setup_new(d);
    STATE(d) = CON_REDIT;
    break;
  case SCMD_OASIS_ZEDIT:
    if ((real_num = real_room(number)) < 0) {
      send_to_char("That room does not exist.\r\n", ch);
      free(d->olc);
      d->olc = NULL;
      return;
    }
    zedit_setup(d, real_num);
    STATE(d) = CON_ZEDIT;
    break;
  case SCMD_OASIS_MEDIT:
    if ((real_num = real_mobile(number)) < 0)
      medit_setup_new(d);
    else
      medit_setup_existing(d, real_num);
    STATE(d) = CON_MEDIT;
    break;
  case SCMD_OASIS_OEDIT:
    if ((number == 1351) || (number == 1350))
    { // Artus> Only allow these to be changed offline.
      send_to_char("Cannot edit map/atlas with OLC.\r\n", ch);
      free(d->olc);
      d->olc = NULL;
      return;
    }
    if ((real_num = real_object(number)) >= 0)
    {
      oedit_setup_existing(d, real_num);
    } else {
      oedit_setup_new(d);
    }
    STATE(d) = CON_OEDIT;
    break;
  case SCMD_OASIS_SEDIT:
    if ((real_num = real_shop(number)) >= 0)
      sedit_setup_existing(d, real_num);
    else
      sedit_setup_new(d);
    STATE(d) = CON_SEDIT;
    break;
d359 13
a371 11
  if (OLC_ROOM(d)) {
    switch (cleanup_type) {
    case CLEANUP_ALL:
      free_room(OLC_ROOM(d));
      break;
    case CLEANUP_STRUCTS:
      free(OLC_ROOM(d));
      break;
    default: /* The caller has screwed up. */
      basic_mud_log("SYSERR: cleanup_olc: Unknown type!");
      break;
d380 2
a381 1
  if (OLC_OBJ(d)) {
d396 2
a397 1
  if (OLC_ZONE(d)) {
d407 13
a419 11
  if (OLC_SHOP(d)) {
    switch (cleanup_type) {
    case CLEANUP_ALL:
      free_shop(OLC_SHOP(d));
      break;
    case CLEANUP_STRUCTS:
      free(OLC_SHOP(d));
      break;
    default:
      /* The caller has screwed up but we already griped above. */
      break;
d426 2
a427 1
  if (d->character) {
d437 2
a438 1
int get_type(char *str, int type) {
d441 2
a442 1
  switch(type) {
d444 2
a445 2
      for (i = 0; i < NUM_ITEM_TYPES; i++) {
        if (is_abbrev(str, item_types[i])) {
a446 2
        } 
      } 
a447 1

d449 2
a450 2
      for (i = 0; i < NUM_NPC_CLASSES; i++) {
        if (is_abbrev(str, npc_class_types[i])) {
a451 2
        }
      }
d465 4
a468 2
  if (!*buf) {
    switch (subcmd) {
d482 2
a483 1
    if (isdigit(buf[0])) {
a485 1

d488 2
a489 1
      if (*buf) {
d491 2
a492 1
        if (isdigit(buf[0])) {
d497 1
a497 1
          if (*buf) {
a498 1
          }
d511 2
a512 1
  if (to < from) {
d518 2
a519 1
  switch (subcmd) {
d521 8
a528 9
      for (nr = 0; nr <= top_of_objt; nr++) {
        if (obj_index[nr].vnum >= from && obj_index[nr].vnum <= to) {
          if (type == NOTHING || obj_proto[nr].obj_flags.type_flag == type) { 
            sprintf(buf2, "%3d. &8[%5d]&n &5%s&n\r\n", ++found,
                    obj_index[nr].vnum, obj_proto[nr].short_description);
            strncat(buf, buf2, strlen(buf2));
          }
        }
      }
d531 8
a538 9
      for (nr = 0; nr <= top_of_mobt; nr++) {
        if (mob_index[nr].vnum >= from && mob_index[nr].vnum <= to) {
          if (type == NOTHING || mob_proto[nr].player.chclass == type) {
            sprintf(buf2, "%3d. &8[%5d]&n &6%s&n\r\n", ++found,
                        mob_index[nr].vnum, mob_proto[nr].player.short_descr);
            strncat(buf, buf2, strlen(buf2));
          }
        }
      }
a539 1

d541 3
a543 2
      for (i = 0; i < top_of_world; i++) {
        if (world[i].number >= from && world[i].number <= to) {
a547 1
      }
a548 1

@


1.10
log
@Artus> Mostly just cosmetic changes, mostly for underwater stuff..
       Added some more stuff to dg_scripts:

       %actor.affected(aff_bit)% - Is actor affected by whatever.
       %self.people(countpc)%    - (Rooms): Count players.
       %self.people(countnpc)%   - (Rooms): Count npcs.
       %self.people(countall)%   - (Rooms): Count chars.
       %firstchar.<room_vnum>%   - First character in room <vnum>

       Possibly a bugfix to one of the forest specials that was attacking you
       if you were affected by poison.
@
text
@d91 1
a91 1
  if ((GET_LEVEL(ch) < LVL_IMPL) && (GET_OLC_ZONE(ch) == 0))
d133 2
a134 1
    if (str_cmp("save", buf1) == 0) {
d136 2
a137 1
      if ((number = (*buf2 ? atoi(buf2) : (GET_OLC_ZONE(ch) ? GET_OLC_ZONE(ch) : -1)) * 100) < 0 ) {
d141 3
a143 2
    } else if (subcmd == SCMD_OASIS_ZEDIT && GET_LEVEL(ch) >= LVL_IMPL) {
      if (str_cmp("new", buf1) == 0 && *buf2 && (number = atoi(buf2)) >= 0)
d148 8
d211 1
a211 1
  if (GET_LEVEL(ch) < LVL_IMPL)
@


1.9
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@d197 2
d200 9
a208 5
  if (GET_OLC_ZONE(ch) != 0 && (zone_table[OLC_ZNUM(d)].number != GET_OLC_ZONE(ch) && GET_LEVEL(ch) < LVL_IMPL)) {
    send_to_char("You do not have permission to edit this zone.\r\n", ch);
    free(d->olc);
    d->olc = NULL;
    return;
d431 3
a433 3
  char *ousage = "&1usage: &4olist [from_vnum to_vnum obj_type]&n"; 
  char *musage = "&1usage: &4mlist [from_vnum to_vnum mob_class]&n"; 
  char *rusage = "&1usage: &4rlist [from_vnum to_vnum]&n"; 
@


1.8
log
@Artus> A3_0_315
@
text
@d339 1
a339 1
      log("SYSERR: cleanup_olc: Unknown type!");
@


1.7
log
@Artus>
Adrenaline : (Potion Quaffing): 6 per fight Round instead of 5.
             (Flying Tackle)  : 2 fight rounds vs 3.
Balance    : QEQ no longer gets written to the log file when unbalanced.
Colour     : &f is no longer flash, &@@ is. Keep it quiet(tm).
Corpse File: Flush()ing after write().
Double Kick: Now calls apply_spell_skill_abil()
Echo       : No longer sends text to mobs calling it.
Fighting   : Is only possible if STATE = CON_PLAYING
Glance     : Fixed erroneous dex check.
OLC        : No longer possible while fighting.
           : LVL_IMPL+ (150+) can now edit mob levels up to 120.
Pit Trap   : Now logs deaths.
             No longer says "theoretically" on creation.
Report File: Flush()ing after write().
Spell/Skill: Now allows up to NUM_CLASSES class lines in primal_spskls
             (Used to only allow up to 10)
@
text
@d91 6
d269 7
d277 1
d279 1
a279 1
    else
d281 1
@


1.6
log
@
Modified: DM

Changed:
- removed debug info
@
text
@d99 9
@


1.5
log
@Modified: DM

Changed:
- Detailed zone data (UNCOMPLETE!)
@
text
@d168 3
a170 3
  sprintf(buf, "number = %d, real_zone_by_thing(number) = %d", number,
      real_zone_by_thing(number));
  mudlog(buf, NRM, LVL_GOD, TRUE);
@


1.4
log
@
Added:
- Full access for OLCers with OLC value 0
@
text
@d166 6
@


1.3
log
@
Added:
- do_oasislist - medit/oedit/redit
@
text
@d175 1
d177 1
a177 1
  if (zone_table[OLC_ZNUM(d)].number != GET_OLC_ZONE(ch) && GET_LEVEL(ch) < LVL_IMPL) {
@


1.2
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d26 1
d39 5
d368 120
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d25 1
d51 1
d103 1
d209 7
@

