head	1.16;
access;
symbols
	A3_0_59:1.3
	LATEST:1.3
	A3_0_1:1.3;
locks; strict;
comment	@// @;


1.16
date	2004.08.27.02.13.00;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.15.02.41.54;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.06.02.23.30;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.10.12.02.26;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.24.00.14.49;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.12.22.50.32;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.12.11.00.14;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.14.07.24.16;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.20.08.19.31;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.18.14.48.57;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.26.06.49.04;	author primal;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.11.10.48.48;	author rod;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.11.04.58.09;	author primal;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.22.22.21.09;	author primal;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.22.22.15.55;	author primal;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.20.16.36.11;	author primal;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Artus> Changed a couple of LVL_IMMORTs to LVL_ISNOT_GODs
@
text
@/*
 * Reporting system - by DM
 *        
 * Quick background on expected usage and lifecycle of a report:
 * Initially when a report is created, the state is set to OPEN. When the
 * responsible person looks at the report, they should edit it and change the
 * state to ASSESSED (so the reporter knows the report has been looked at).
 * The responsible person should then fix/respond to the problem and change
 * the state to FEEDBACK. The reporter then verifies the fix/responce and
 * edits the report changing the state to CLOSED. Obvious exceptions apply to
 * a more complicated report, but the state principals as mentioned above
 * should be used consistantly as described.
 *
 * Every time that a report is edited, notification is given to the involved
 * parties (all people that have made a change to the initial report). This
 * notification is in the form of email if possible, and mudmail.
 *
 * Basic idea is to replace the existing bug/idea/typo and add todo stuff.
 * Reports are read from a random access file at boot time, and converted to
 * Report objects contained within a list. The reports stored to file with
 * state DELETED are ignored when converting to objects at boot time.
 *
 * As far as player usage goes, the following restrictions apply on report
 * usage:
 *
 * command      list/print                      edit/delete
 * -------
 * BUG          <  GOD - owned reports          <  GRGOD - owned reports
 *              >= GOD - all reports            >= GRGOD - all reports
 *
 * IDEA         <  ANGEL - owned reports        <  GRGOD - owned reports
 *              >= ANGEL - all reports          >= GRGOD - all reports
 *
 * TYPO         <  IMMORT - owned reports       <  GOD - owned reports
 *              >= IMMORT - all reports         >= GOD - all reports
 *
 * TODO         <  ANGEL - owned reports        <  GRGOD - owned reports
 *              >= ANGEL - all reports          >= GRGOD - all reports
 *
 * Additionally, only GRGOD+ can add TODO reports, and the following opetions
 * in add and edit states apply:
 * 
 * delete - < limit (owned) - deletion is only allowed if state is CLOSED 
 *          (The record will be kept in file with state DELETED)
 *
 * edit   - < limit (owned) - change of type is not allowed, 
 *    ORIGINAL THOUGHT - state change is restricted only to FEEDBACK -> CLOSED
 *    BUT NAH, DONT BOTHER .....
 *
 * add    - for BUG give bug type options only, for others (TYPO/IDEA/TODO)
 *          onlu display the the given type
 *
 * Well thats it for now I guess.... Hope it kicks arse? ;p 
 */

#include <list>
#include <string.h>
#include <fstream>
#include <iostream>
#include <stdlib.h>
#include <time.h>
#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "db.h"
#include "handler.h"
#include "interpreter.h"
#include "reports.h"
#include "comm.h"
#include "improved-edit.h"
#include "genolc.h"
#include "mail.h"

extern ReportList *reportList;
extern ReleaseInfo release;
extern struct descriptor_data *descriptor_list;
extern struct room_data *world;
extern void do_odd_write(struct descriptor_data *d, ubyte wtype, int maxlen);

void report_string_cleanup(struct descriptor_data *d, int terminator)
{
  if (terminator == STRINGADD_ABORT)
  {
    SEND_TO_Q("Description aborted.\r\n\r\n", d);
  } else {
    REPORT_MODIFIED(d) = 1;
    if (*d->str)
      REPORT(d)->setLongDescription(*d->str);
    else
      REPORT(d)->setLongDescription("");
  }
  switch (STATE(d))
  {
    case CON_REPORT_ADD:  reportList->dispAddMenu(d);  break;
    case CON_REPORT_EDIT: reportList->dispEditMenu(d); break;
  }
}

ACMD(do_reporting)
{
  int number;
  char arg1[MAX_INPUT_LENGTH], rest[MAX_INPUT_LENGTH];
  char usage[MAX_INPUT_LENGTH];

  sprintf(usage, "&1Usage: &4%s [  'add'\r" 
          "\n             | 'edit' <number> \r"
	  "\n             | 'delete' <number>\r"
	  "\n             | 'list' ['self' | <state> | <player>]\r"
	  "\n             | 'print' <number> ]&n\r\n",
	  cmd_info[cmd].command);

  half_chop(argument, arg1, rest);

  // DM - a new one "listreports" same as report list - but for all types
  if (subcmd == REPORT_MODE_LISTREPORT)
  {
    reportList->listReports(ch->desc, subcmd, arg1);
    return;
  }
  if (subcmd == REPORT_MODE_PRINTREPORT)
  {
    number = atoi(arg1);
    reportList->printReport(ch->desc, number, subcmd);
    return;
  }
  if (!*arg1)
  {
    send_to_char(usage, ch);
    return;
  }
  // report add - create a blank report, set states and report pointer then
  // display the add menu
  if (is_abbrev(arg1, "add"))
  {
    if (GET_LEVEL(ch) < LVL_GRGOD && subcmd == REPORT_MODE_TODO)
    {
      send_to_char("Sorry, you are unable to add a &4todo&n report.\r\n", ch);
      return;
    }
    Report *newReport = new Report();
    switch (subcmd)
    {
      case REPORT_MODE_BUG:  newReport->setType(REPORT_TYPE_BUGCRASH); break;
      case REPORT_MODE_IDEA: newReport->setType(REPORT_TYPE_IDEA);     break;
      case REPORT_MODE_TYPO: newReport->setType(REPORT_TYPE_TYPO);     break;
      case REPORT_MODE_TODO: newReport->setType(REPORT_TYPE_TODO);     break;
    }
    newReport->setReporterId(GET_IDNUM(ch));
    newReport->setPlayerId(GET_IDNUM(ch));
    newReport->setOrgTime(time(0));
    newReport->setOrgRoom(GET_ROOM_VNUM(ch->in_room));
    newReport->setRelease(release);
    act("$n begins adding a report.", TRUE, ch, NULL, NULL, TO_ROOM);
    STATE(ch->desc) = CON_REPORT_ADD;
    REPORT(ch->desc) = (Report *) newReport;
    REPORT_MODE(ch->desc) = subcmd;
    SET_BIT(PLR_FLAGS(ch), PLR_REPORTING);
    reportList->dispAddMenu(ch->desc);
    // report edit - show menu
  } else if (is_abbrev(arg1, "edit")) {
    half_chop(rest, arg1, rest);
    number = atoi(arg1);
    // need to create a copy of existing ...
    // then when we save, we copy details and free the temp ...
    // copyReport makes a copy of the existing report and sets the report
    // pointer of the descriptor. It also checks to see that no-one is editing
    // that report.
    if (!reportList->copyReport(ch->desc, number, subcmd))
      return;
    act("$n begins editing a report.", TRUE, ch, NULL, NULL, TO_ROOM);
    SET_BIT(PLR_FLAGS(ch), PLR_REPORTING);
    STATE(ch->desc) = CON_REPORT_EDIT;
    reportList->dispEditMenu(ch->desc);
    // report delete <number>
  } else if (is_abbrev(arg1, "delete")) {
    half_chop(rest, arg1, rest);
    number = atoi(arg1);
    reportList->removeReport(ch->desc, number, subcmd);
    // report list [filter] 
  } else if (is_abbrev(arg1, "list")) {
    half_chop(rest, arg1, rest);
    reportList->listReports(ch->desc, subcmd, arg1);
    // report print <number>
  } else if (is_abbrev(arg1, "print")) {
    half_chop(rest, arg1, rest);
    number = atoi(arg1);
    reportList->printReport(ch->desc, number, subcmd);
  } else {
    sprintf(buf, usage, cmd_info[cmd].command);
    send_to_char(buf, ch);
    return;
  }
}

void
ReportList::dispAddMenu(struct descriptor_data *d)
{
  char dateString[25], typeString[20], stateString[20];
  time_t dispTime = REPORT(d)->getOrgTime();
#ifdef NO_LOCALTIME
  struct tm lt;
#endif

  REPORT_STATE(d) = REPORT_STATE_MENU;
#ifndef NO_LOCALTIME
  strncpy(dateString, (char *) asctime(localtime(&dispTime)), 25);
#else
  jk_localtime(&lt, dispTime);
  strncpy(dateString, (char *) asctime(&lt), 25);
#endif
  dateString[24] = '\0';
  sprinttype(REPORT(d)->getState(), report_states, stateString);
  sprinttype(REPORT(d)->getType(), report_types, typeString);
  sprintf(buf, "\r\n-- Report Number: [&cUNASSIGNED&n] Reporter: [&7%s&n]"
	       " Room: [&8%d&n]\r\n"
	       "-- Date: [&g%s&n] Revision: [&c%d.%d.%d&n] State: [&4%s&n]\r\n"
	       "&g1&n) S-Desc : &0%s\r\n"
	       "&g2&n) L-Desc : %s\r\n",
	  get_name_by_id(REPORT(d)->getReporterId()),
	  (int) REPORT(d)->getOrgRoom(), dateString, release.getMajor(),
	  release.getBranch(), release.getMinor(), stateString,
	  REPORT(d)->getShortDescription(), REPORT(d)->getLongDescription());
  if (!REPORT(d)->isRestricted(d, REPORT_MODE(d)))
    sprintf(buf+strlen(buf), "&g3&n) State  : &c%s\r\n", stateString);
  if (REPORT_MODE(d) == REPORT_MODE_BUG || 
      !REPORT(d)->isRestricted(d, REPORT_MODE(d)))
    sprintf(buf+strlen(buf), "&g4&n) Type   : &c%s\r\n", typeString);
  if (!REPORT(d)->isRestricted(d, REPORT_MODE(d)))
    sprintf(buf+strlen(buf), "&g5&n) Player : &7%s&n\r\n", 
            get_name_by_id(REPORT(d)->getPlayerId()));
  strcat(buf, "&gQ&n) Quit\r\n" "&nEnter Choice : ");

  SEND_TO_Q(buf, d);
}

void
ReportList::dispEditMenu(struct descriptor_data *d)
{
  char
    dateString[25], typeString[20], stateString[20];
  time_t dispTime = REPORT(d)->getOrgTime();
#ifdef NO_LOCALTIME
  struct tm lt;
#endif

  REPORT_STATE(d) = REPORT_STATE_MENU;
#ifndef NO_LOCALTIME
  strncpy(dateString, (char *) asctime(localtime(&dispTime)), 25);
#else
  jk_localtime(&lt, dispTime);
  strncpy(dateString, (char *) asctime(&lt), 25);
#endif
  dateString[24] = '\0';
  sprinttype(REPORT(d)->getState(), report_states, stateString);
  sprinttype(REPORT(d)->getType(), report_types, typeString);
  sprintf(buf, "\r\n-- Report Number: [&g%d&n] Reporter: [&7%s&n]"
	       " Room: [&8%d&n]\r\n"
	       "-- Date: [&g%s&n] Revision: [&c%d.%d.%d&n]\r\n"
	       "&g1&n) S-Desc : &0%s\r\n"
	       "&g2&n) L-Desc : %s\r\n",
	  REPORT(d)->getReportNum(), get_name_by_id(REPORT(d)->getReporterId()),
	  (int) REPORT(d)->getOrgRoom(), dateString,
	  REPORT(d)->getOrgRelease().getMajor(),
	  REPORT(d)->getOrgRelease().getBranch(),
	  REPORT(d)->getOrgRelease().getMinor(),
	  REPORT(d)->getShortDescription(), REPORT(d)->getLongDescription());
  // allow player to change the type in bug mode, or if they do not have edit
  // restrictions imposed. 
  if (REPORT_MODE(d) == REPORT_MODE_BUG || 
      !REPORT(d)->isRestricted(d, REPORT_MODE(d)))
  {
    sprintf(buf+strlen(buf), "&g3&n) State  : &c%s\r\n" 
		             "&g4&n) Type   : &c%s\r\n",
            stateString, typeString);
    if (!REPORT(d)->isRestricted(d, REPORT_MODE(d)))
      sprintf(buf+strlen(buf), "&g5&n) Player : &7%s&n\r\n", 
	      get_name_by_id(REPORT(d)->getPlayerId()));
  } else
    sprintf(buf+strlen(buf), "&g3&n) State  : &c%s\r\n", stateString);

  sprintf(buf, "%s" "&gQ&n) Quit\r\n" "&nEnter Choice : ", buf);

  SEND_TO_Q(buf, d);
}

// Returns whether or not the char has restrictions imposed on editing/adding
// ie. The char is editing/adding this report, but unless they meet the level
// requirements, they are restricted in what they can edit. 
bool Report::isRestricted(struct descriptor_data *d, int mode)
{
  switch (mode)
  {
    case REPORT_MODE_TODO:
    case REPORT_MODE_IDEA:
    case REPORT_MODE_BUG:
      if (GET_LEVEL(d->character) >= LVL_GRGOD)
	return (FALSE);
      break;
    case REPORT_MODE_TYPO:
      if (GET_LEVEL(d->character) >= LVL_GOD)
	return (FALSE);
      break;
  }
  return (TRUE);
}

// Returns whether or not the char can list/print the given report
bool Report::isViewable(struct descriptor_data *d)
{
  switch (getReportType())
  {
    case REPORT_MODE_IDEA:
    case REPORT_MODE_TODO:
      if ((GET_LEVEL(d->character) < LVL_ANGEL) &&
	  (GET_IDNUM(d->character) != getPlayerId()) &&
          (GET_IDNUM(d->character) != getReporterId()))
	return (FALSE);
      return (TRUE);
    case REPORT_MODE_TYPO:
      if ((GET_LEVEL(d->character) < LVL_ISNOT_GOD) &&
          (GET_IDNUM(d->character) != getPlayerId()) &&
	  (GET_IDNUM(d->character) != getReporterId()))
	return (FALSE);
      return (TRUE);
    case REPORT_MODE_BUG:
      if ((GET_LEVEL(d->character) < LVL_GOD) &&
	  (GET_IDNUM(d->character) != getPlayerId()) &&
	  (GET_IDNUM(d->character) != getReporterId()))
	return (FALSE);
      return (TRUE);
  }
  return (FALSE);
}

// Returns whether the char can edit/delete the given report
bool Report::isEditable(struct descriptor_data * d, int mode)
{
  switch (mode)
  {
    // Bug/Idea/Todo Mode - restricted to owner, LVL_GRGOD
    case REPORT_MODE_BUG:
    case REPORT_MODE_IDEA:
    case REPORT_MODE_TODO:
      if ((GET_LEVEL(d->character) < LVL_GRGOD) &&
	  (GET_IDNUM(d->character) != getPlayerId()))
	return (FALSE);
      return (TRUE);

    // Typo Mode - restricted to owner, LVL_GOD
    case REPORT_MODE_TYPO:
      if ((GET_LEVEL(d->character) < LVL_GOD) &&
	  (GET_IDNUM(d->character) != getPlayerId()))
	return (FALSE);
      return (TRUE);
  }
  return (FALSE);
}

void
report_parse(struct descriptor_data *d, char *arg)
{
  int option;
  long playerId = 0;

  switch (REPORT_STATE(d)) {

    case REPORT_STATE_MENU:

    switch (*arg) {
      case 'q':
      case 'Q':
      if (REPORT_MODIFIED(d)) {
	SEND_TO_Q("Do you wish to save changes? : ", d);
	REPORT_STATE(d) = REPORT_STATE_CONFIRM;
      } else {
	delete(Report *) REPORT(d);
	REPORT(d) = NULL;
	act("$n cancels adding a report.",
	    TRUE, d->character, NULL, NULL, TO_ROOM);
	REMOVE_BIT(PLR_FLAGS(d->character), PLR_REPORTING);
	STATE(d) = CON_PLAYING;
      }
      return;

      case '1':
      REPORT_STATE(d) = REPORT_STATE_SHORTDESC;
      SEND_TO_Q("Enter short description : ", d);
      return;

      case '2':
      REPORT_STATE(d) = REPORT_STATE_LONGDESC;
      SEND_TO_Q("\r\n", d);
      send_editor_help(d);
      SEND_TO_Q("Enter details:\r\n\r\n", d);
      do_odd_write(d, PWT_REPORT_LONGDESC, REPORT_LONGDESC_LENGTH);
      return;

      case '3':
      if (STATE(d) == CON_REPORT_EDIT ||
                !REPORT(d)->isRestricted(d, REPORT_MODE(d))) {
	reportList->dispStateMenu(d);
      } else {
	if (STATE(d) == CON_REPORT_ADD) {
	  reportList->dispAddMenu(d);
	} else {
	  reportList->dispEditMenu(d);
	}
      }
      return;

      case '4':
      if (!REPORT(d)->isRestricted(d, REPORT_MODE(d)) || 
                REPORT_MODE(d) == REPORT_MODE_BUG) {
	reportList->dispTypeMenu(d);
      } else {
	if (STATE(d) == CON_REPORT_ADD) {
	  reportList->dispAddMenu(d);
	} else {
	  reportList->dispEditMenu(d);
	}
      }
      return;

      // 5) playerid
      case '5':
      if (!REPORT(d)->isRestricted(d, REPORT_MODE(d))) {
	SEND_TO_Q("Enter player name : ", d);
	REPORT_STATE(d) = REPORT_STATE_PLAYER;
      } else {
	reportList->dispEditMenu(d);
      }
      return;

      default:
      if (STATE(d) == CON_REPORT_ADD) {
	reportList->dispAddMenu(d);
      } else {
	reportList->dispEditMenu(d);
      }
      break;
    }
    break;

    case REPORT_STATE_PLAYER:
      // search by player name
      playerId = get_id_by_name(arg);
      if (playerId == -1) {
	SEND_TO_Q("Character not found, try again : ", d);
	return;
      }
      REPORT_MODIFIED(d) = 1;
      REPORT(d)->setPlayerId(playerId);

      if (STATE(d) == CON_REPORT_ADD) {
        reportList->dispAddMenu(d);
      } else {
        reportList->dispEditMenu(d);
      }
      return;

    case REPORT_STATE_TYPE:
    option = atoi(arg);

    if (REPORT(d)->isRestricted(d, REPORT_MODE(d))) {
      if (option < (NUM_REPORT_TYPES - NUM_BUG_TYPES + 1) ||
	  option > NUM_REPORT_TYPES) {
	SEND_TO_Q("Invalid choice, try again : ", d);
	return;
      } 
    } else if (option < 1 || option > NUM_REPORT_TYPES) {
      SEND_TO_Q("Invalid choice, try again : ", d);
      return;
    }
    REPORT(d)->setType(option - 1);
    REPORT_MODIFIED(d) = 1;
    if (STATE(d) == CON_REPORT_ADD) {
      reportList->dispAddMenu(d);
    } else {
      reportList->dispEditMenu(d);
    }
    break;

    case REPORT_STATE_STATE:
    option = atoi(arg);
    if (option < 1 || option > NUM_REPORT_STATES) {
      SEND_TO_Q("Invalid choice, try again : ", d);
      return;
    } else {
      REPORT(d)->setState(option - 1);
      REPORT_MODIFIED(d) = 1;
      if (STATE(d) == CON_REPORT_ADD) {
	reportList->dispAddMenu(d);
      } else {
	reportList->dispEditMenu(d);
      }
    }
    break;

    case REPORT_STATE_SHORTDESC:
    if (!genolc_checkstring(d, arg))
      break;
    REPORT(d)->setShortDescription(arg);
    REPORT_MODIFIED(d) = 1;
    if (STATE(d) == CON_REPORT_ADD) {
      reportList->dispAddMenu(d);
    } else {
      reportList->dispEditMenu(d);
    }
    break;

    case REPORT_STATE_LONGDESC:
    if (!genolc_checkstring(d, arg))
      break;
    REPORT(d)->setLongDescription(arg);
    REPORT_MODIFIED(d) = 1;
    if (STATE(d) == CON_REPORT_ADD) {
      reportList->dispAddMenu(d);
    } else {
      reportList->dispEditMenu(d);
    }
    break;

    case REPORT_STATE_CHANGEDESC:
      if (!genolc_checkstring(d, arg))
        break;
      REPORT(d)->setChangeDescription(arg);
      reportList->setReport(d);
      delete(Report *) REPORT(d);
      REPORT(d) = NULL;
      REMOVE_BIT(PLR_FLAGS(d->character), PLR_REPORTING);
      STATE(d) = CON_PLAYING;
      break;

    // Handle any add/edit differences
    case REPORT_STATE_CONFIRM:
    switch (*arg) {
      // First we must check if we are editing - if so, then prompt for change
      // description ...
      case 'y':
      case 'Y':
      if (STATE(d) == CON_REPORT_EDIT) {
	SEND_TO_Q("Enter change description : ", d);
	REPORT_STATE(d) = REPORT_STATE_CHANGEDESC;
	return;
      }
      reportList->setReport(d);
      break;

      case 'n':
      case 'N':
      act("$n cancels reporting.", TRUE, d->character, NULL, NULL, TO_ROOM);
      break;

      default:
      SEND_TO_Q("Invalid choice!\r\n", d);
      SEND_TO_Q("Do you wish to save changes? : ", d);
      return;
    }
    delete(Report *) REPORT(d);
    REPORT(d) = NULL;
    REMOVE_BIT(PLR_FLAGS(d->character), PLR_REPORTING);
    STATE(d) = CON_PLAYING;
    break;

    default:
    mudlog("SYSERR: REPORT: Reached default case in report_parse",
	   BRF, MAX(GET_LEVEL(d->character), GET_INVIS_LEV(d->character)),
	   TRUE);
    SEND_TO_Q("Opps...\r\n", d);
    break;
  }
}

void ReportList::setReport(struct descriptor_data *d)
{
  int reportNum = reportList->addReport(d, REPORT(d));

  if (reportNum <= 0) {
    return;
  }

  getReportModeName(REPORT(d)->getReportType(), buf2);

  if (STATE(d) == CON_REPORT_ADD) {
    sprintf(buf, "REPORT: %s added %s report number %d",
	    GET_NAME(d->character), buf2, reportNum); 
  } else {
    sprintf(buf, "REPORT: %s edited %s report number %d",
	    GET_NAME(d->character), buf2, reportNum);
  }

  mudlog(buf, NRM,
	 MAX(GET_LEVEL(d->character), GET_INVIS_LEV(d->character)), TRUE);

  act("$n finishes reporting.", TRUE, d->character, NULL, NULL, TO_ROOM);

  // email/mudmail ppl ....
  reportList->notify(reportNum);
}

void
ReportList::dispTypeMenu(struct descriptor_data *d)
{
  int
    counter, columns = 0, begin = 1, end = NUM_REPORT_TYPES;

  // Only display bug types if restricted, otherwise display all
  if (REPORT(d)->isRestricted(d, REPORT_MODE(d))) {
    begin = NUM_REPORT_TYPES - NUM_BUG_TYPES + 1;
    end = NUM_REPORT_TYPES;
  }

  sprintf(buf, "\r\nReport Types:\r\n");
  for (counter = begin; counter <= end; counter++) {
    sprintf(buf, "%s &g%2d&n) &c%-20.20s %s", buf, counter,
	    report_types[counter - 1], !(++columns % 2) ? "\r\n" : "");
  }
  if ((columns % 2) > 0) {
    sprintf(buf, "%s\r\n", buf);
  }
  sprintf(buf, "%s&nEnter report type : ", buf);
  REPORT_STATE(d) = REPORT_STATE_TYPE;
  page_string(d, buf, TRUE);
}

void
ReportList::dispStateMenu(struct descriptor_data *d)
{
  int
    counter, columns = 0;

  sprintf(buf, "\r\nState Types:\r\n");
  for (counter = 1; counter <= NUM_REPORT_STATES; counter++) {
    sprintf(buf, "%s &g%2d&n) &c%-20.20s %s", buf, counter,
	    report_states[counter - 1], !(++columns % 2) ? "\r\n" : "");
  }
  if ((columns % 2) > 0) {
    sprintf(buf, "%s\r\n", buf);
  }
  sprintf(buf, "%s&nEnter report state : ", buf);

  // We only have the ability to change the state in edit...
  REPORT_STATE(d) = REPORT_STATE_STATE;
  page_string(d, buf, TRUE);
}


// REPORTLIST
// list related functions
int
ReportList::addReport(struct descriptor_data *d, Report * report)
{
  // 2 cases: a new report reportNum will be 0 (when adding a new report)
  //   and the other - when editing, will already have a report number.

  // Edit case
  if (report->getReportNum()) {
    list < Report >::iterator liter;	// iterator for looping over list elements
    for (liter = reports.begin(); liter != reports.end(); liter++) {

      if (report->getReportNum() == liter->getReportNum()) {

        ReportChange reportChange = ReportChange(++topChangeNum, 
                                           report->getReportNum(),
				           GET_IDNUM(d->character),
				           liter->getState(), 
                                           report->getState(),
				           liter->getType(), 
                                           report->getType(),
				           time(0), 
                                           release,
				           report->getChangeDescription());

/*
	// found it - add the change report and copy editable data
	liter->addChange(ReportChange(++topChangeNum, report->getReportNum(),
				      GET_IDNUM(d->character),
				      liter->getState(), report->getState(),
				      liter->getType(), report->getType(),
				      time(0), release,
				      report->getChangeDescription()));
*/
        liter->addChange(reportChange);

        liter->setPlayerId(report->getPlayerId());
	liter->setState(report->getState());
	liter->setType(report->getType());
	liter->setShortDescription(report->getShortDescription());
	liter->setLongDescription(report->getLongDescription());
        writeReport(liter->toFileElem());
        writeChange(reportChange.toFileElem());

	return (liter->getReportNum());
      }
    }

    // Add case
  } else {

    report->setReportNum(++topReportNum);
    reports.push_back(Report(report->getPlayerId(),
	  		     report->getReporterId(),
			     report->getReportNum(), report->getState(),
			     report->getType(), report->getShortDescription(),
			     report->getLongDescription(),
			     report->getOrgRoom(), report->getOrgTime(),
			     report->getOrgRelease()));

    writeReport(report->toFileElem());

    return (report->getReportNum());
  }
  return (-1);
}

bool
ReportList::removeReport(struct descriptor_data * d, int number, int mode)
{
  list < Report >::iterator liter;	// iterator for looping over list elements

  for (liter = reports.begin(); liter != reports.end(); liter++) {
    if (liter->getReportNum() == number) {

      if (liter->getReportType() != mode)
	continue;

      // Check delete restrictions - if its restricted, then state has to be
      // closed
      if (liter->isEditable(d, mode)) {
	if (liter->isRestricted(d, mode) && 
                  liter->getState() != REPORT_STATE_CLOSED) {
	  SEND_TO_Q("You do not have access to delete this report.\r\n", d);
	  return (FALSE);
	}
        // Change state to deleted and save so its not loaded to list next time
        liter->setState(REPORT_STATE_DELETED);
        writeReport(liter->toFileElem());

        // Remove from list
	reports.erase(liter);
	
        sprintf(buf, "REPORT: %s deleted report number %d",
	        GET_NAME(d->character), liter->getReportNum());
        mudlog(buf, NRM,
	     MAX(GET_LEVEL(d->character), GET_INVIS_LEV(d->character)), TRUE);

	return (TRUE);
      } else {
	SEND_TO_Q("You do not have access to delete this report.\r\n", d);
	return (FALSE);
      }
    }
  }
  getNotFoundMesg(mode, buf);
  SEND_TO_Q(buf, d);
  return (FALSE);
}

// printing functions
void
ReportList::listReports(struct descriptor_data *d, int mode, char *arg)
{
  int i = 0, state = -1;
  long playerId = -1;
  bool onlySelf = FALSE;
  list < Report >::iterator liter;  // iterator for looping over list elements

  basic_mud_log("ReportList::listReports: arg = '%s', mode = %d", (*arg) ? arg : "", mode);
  if (*arg) {
    // states
    state = search_block_case_insens(arg, report_states, FALSE);
    if (state == -1) {
      // players reports
      if (!str_cmp(arg, "self")) {
        onlySelf = TRUE;
      // player name
      } else {
        playerId = get_id_by_name(arg);
      }
    }
  }
  buf[0] = '\0';
  for (liter = reports.begin(); liter != reports.end(); liter++) {
    if ((mode != REPORT_MODE_LISTREPORT) && liter->getReportType() != mode)
      continue;

    if (liter->isViewable(d)) {

      // only players reports 
      if ((onlySelf == TRUE) && liter->getPlayerId() != GET_IDNUM(d->character))
        continue;
      // of certain state
      if ((state > -1) && liter->getState() != state)
        continue;
      // characters name
      if ((playerId != -1) && liter->getPlayerId() != playerId)
        continue;
      liter->printBriefDescription(d, buf1);
      sprintf(buf, "%s%s", buf, buf1);
      i++;
    }
  }
  if (i == 0) {
    getNoneExistMesg(mode, buf);
    SEND_TO_Q(buf, d);
  } else {
    sprintf(buf, "%s\r\n%d Reports listed.\r\n", buf, i);
    page_string(d, buf, TRUE);
  }
}

bool
ReportList::printReport(struct descriptor_data *d, int number, int mode)
{

  list < Report >::iterator liter;	// iterator for looping ober list elements

  if (number < 1 || number > getTopReportNum()) {
    getOutOfRangeMesg(mode, buf);
    SEND_TO_Q(buf, d);
    return (FALSE);
  }

  for (liter = reports.begin(); liter != reports.end(); liter++) {
    if (liter->getReportNum() == number) {

      // only look at reports of this type (REPORT_MODE_xxx)
      if (mode != REPORT_MODE_PRINTREPORT && liter->getReportType() != mode)
	continue;

      // Check if player is able to view the report
      if (liter->isViewable(d)) {
	liter->printDetails(d, buf);
	page_string(d, buf, TRUE);
	return (TRUE);
      } else {
	getRestrictedMesg(mode, buf);
	SEND_TO_Q(buf, d);
	return (FALSE);
      }
    }
  }

  getNotFoundMesg(mode, buf);
  SEND_TO_Q(buf, d);
  return (FALSE);
}

bool
ReportList::copyReport(struct descriptor_data * d, int number, int mode)
{
  struct descriptor_data *dsc;

  if (number <= 0 || number > getTopReportNum()) {
    getOutOfRangeMesg(mode, buf);
    SEND_TO_Q(buf, d);
    return (FALSE);
  }

  list < Report >::iterator liter;	// iterator for looping over list elements
  for (liter = reports.begin(); liter != reports.end(); liter++) {

    if (liter->getReportType() != mode)
      continue;

    if (liter->getReportNum() == number) {

      if (!liter->isEditable(d, mode)) {
	getRestrictedMesg(mode, buf);
	SEND_TO_Q(buf, d);
	return (FALSE);
      }
      // found report - now check to see that no other descriptors are editing
      // this report ...
      for (dsc = descriptor_list; dsc; dsc = dsc->next) {
	if (REPORT(dsc) && REPORT(dsc)->getReportNum() == number) {
	  SEND_TO_Q("Report currently being edited.", d);
	  return (FALSE);
	}
      }

      // Now make a copy and set report pointer on descriptor 
      Report *
	newReport = new Report(liter->getPlayerId(),
	    		       liter->getReporterId(),
			       liter->getReportNum(), liter->getState(),
			       liter->getType(),
			       liter->getShortDescription(),
			       liter->getLongDescription(),
			       liter->getOrgRoom(), liter->getOrgTime(),
			       liter->getOrgRelease());

      REPORT(d) = (Report *) newReport;
      REPORT_MODE(d) = mode;
      return (TRUE);
    }
  }

  getNotFoundMesg(mode, buf);
  SEND_TO_Q(buf, d);
  return (FALSE);
}


void
Report::mailChanges() {
  list < long > sendTo; 
  list < long >::iterator sliter;
  list < ReportChange >::iterator cliter;
  bool found = FALSE;

  // New report (no changes)
  // notify responsible player if it is not the reporter
  if (changes.begin() == changes.end()) 
    if (getPlayerId() != getReporterId())
      sendTo.push_back(getPlayerId()); 
  
  // Report Changes
  // 
  // Construct a list of playerIDs whom should receive notification
  for (cliter = changes.begin(); cliter != changes.end(); cliter++) 
  {
    found = FALSE;
    // First add reporter to sendTo list.
    if (sendTo.begin() == sendTo.end()) 
      sendTo.push_back(getReporterId()); 
    else
    {
      // Check to see player id doesn't already exist.
      for (sliter = sendTo.begin(); sliter != sendTo.end(); sliter++) 
        if ((*sliter) == cliter->getPlayerId())
          found = TRUE;
      if (!found)
	sendTo.push_back(cliter->getPlayerId()); 
    } 
  }
  
  if (sendTo.begin() == sendTo.end())
    return; 

  cliter = changes.end();
  cliter--;

  getReportModeName(getReportType(), buf2);

  if (changes.begin() == changes.end()) 
    sprintf(buf, "&0Report Added by &7%s&n\r\n"
                 "&0Short Description:&n %s\r\n"
                 "&0Long Description:&n \r\n%s\r\n\r\n"
                 "For full details type &4%s print %d&n\r\n",
	    get_name_by_id(getReporterId()),
	    getShortDescription(), getLongDescription(), buf2, getReportNum());
  else
    sprintf(buf, "&0Report Change by &7%s&n\r\n"
                 "&0Change Description:&n %s\r\n\r\n"
                 "For full details type &4%s print %d&n\r\n",
	    get_name_by_id(cliter->getPlayerId()),
	    cliter->getChangeDescription(), buf2, getReportNum());

  found = FALSE;
  // Now mail the info out
  for (sliter = sendTo.begin(); sliter != sendTo.end(); sliter++) 
  {
    //basic_mud_log("Sending mail to player id %ld", (*sliter));
    if ((*sliter) == getPlayerId())
      found = TRUE;
    store_mail((*sliter), MAIL_FROM_REPORT, buf);
  }

  if (!found)
    store_mail(getPlayerId(), MAIL_FROM_REPORT, buf);
}

void
ReportList::notify(int number) {

  list < Report >::iterator liter;

  for (liter = reports.begin(); liter != reports.end(); liter++) {
    if (liter->getReportNum() == number) {

      if (liter->getReportNum() == number) {
        liter->mailChanges(); 
      }
    }
  }
}

// file related functions

void ReportList::loadFile()
{
  struct report_file_elem report;
  struct reportchange_file_elem reportchange;

  inReportFile.open(REPORTS_FILE, std::ios::in);
  if (!inReportFile) {
    basic_mud_log("SYSERR: could not open reports file %s.", REPORTS_FILE);
    return;
  }

  inReportFile.read((char *)&report, sizeof(report));

  while (!inReportFile.eof()) {
    topReportNum++; 

    // skip adding deleted report to list ...
    if (report.state != REPORT_STATE_DELETED) {
      addReport(report);
    }

    inReportFile.read((char *)&report, sizeof(report));
  }
  inReportFile.close();

  inChangeFile.open(RCHANGES_FILE, std::ios::in);
  if (!inChangeFile) {
    basic_mud_log("SYSERR: could not open report changes file %s.", RCHANGES_FILE);
    return;
  }

  inChangeFile.read((char *)&reportchange, sizeof(reportchange));

  while (!inChangeFile.eof()) {
    topChangeNum++;
    addChange(reportchange);
    inChangeFile.read((char *)&reportchange, sizeof(reportchange));
  }
  inChangeFile.close();
  basic_mud_log("  Loaded %d reports and %d reportchanges", topReportNum, topChangeNum);
}

void ReportList::addReport(struct report_file_elem report)
{
  ReleaseInfo release = ReleaseInfo(report.relMajor, report.relBranch, 
                                    report.relMinor, "", report.relCvsUpToDate, "UNUSED");

  reports.push_back(Report(report.playerId, report.reporterId, report.reportNum,
			   report.state, report.type, report.shortDescription, 
                           report.longDescription, report.orgRoom, 
                           report.orgTime, release));
}

// Converts and adds the report change from file struct to reports list.
// At this stage we have the assumption that all the reports have been added to
// the list.
void ReportList::addChange(struct reportchange_file_elem reportchange)
{
  ReleaseInfo release = ReleaseInfo(reportchange.relMajor,
                                    reportchange.relBranch, 
                                    reportchange.relMinor, "", 
                                    reportchange.relCvsUpToDate,
				    "UNUSED");

  // First find the report is the report list...
  list<Report>::iterator liter;
  for (liter = reports.begin(); liter != reports.end(); liter++) {
    if (reportchange.reportNum == liter->getReportNum()) {
      
      liter->addChange(ReportChange(reportchange.changeNum,
                                    reportchange.reportNum,
                                    reportchange.playerId,
                                    reportchange.fromState, 
                                    reportchange.toState, 
                                    reportchange.fromType,
                                    reportchange.toType, 
                                    reportchange.changeTime, 
                                    release, 
                                    reportchange.changeDescription));
      return;
    }
  }
}

// Artus> We'll do this my way, now.
void ReportList::writeReport(struct report_file_elem report)
{
  FILE *outReportFile;

  outReportFile = fopen(REPORTS_FILE, "r+");
  if (outReportFile == NULL)
    outReportFile = fopen(REPORTS_FILE, "w+");
  if (outReportFile == NULL) {
    basic_mud_log("SYSERR: couldn't open reports file %s for writing", REPORTS_FILE);
    return;
  }
  fseek(outReportFile, (report.reportNum - 1) * sizeof(report), SEEK_SET);
  fwrite(&report, sizeof(report), 1, outReportFile);
  fflush(outReportFile);
  fclose(outReportFile);
}

void ReportList::writeChange(struct reportchange_file_elem reportchange)
{
  FILE *outChangeFile;

  outChangeFile = fopen(RCHANGES_FILE, "r+");
  if (outChangeFile == NULL)
    outChangeFile = fopen(RCHANGES_FILE, "w+");
  if (outChangeFile == NULL)
  {
    basic_mud_log("SYSERR: couldn't open report changes file %s for writing", RCHANGES_FILE);
    return;
  }
  fseek(outChangeFile, (reportchange.changeNum - 1) * sizeof(reportchange), SEEK_SET);
  fwrite(&reportchange, sizeof(reportchange), 1, outChangeFile);
  fflush(outChangeFile);
  fclose(outChangeFile);
}

void ReportList::getNoneExistMesg(int mode, char *writeto)
{
  char temp[10];
  getReportModeName(mode, temp);
  sprintf(writeto, "No &4%s&n reports available.\r\n", temp);
}

void ReportList::getOutOfRangeMesg(int mode, char *writeto)
{
  char temp[10];
  if (mode == REPORT_MODE_PRINTREPORT) {
    sprintf(writeto, "&4report&n report number out of range.\r\n"
	  "Use &4listreports&n to view available reports.\r\n");
  } else {
    getReportModeName(mode, temp);
    sprintf(writeto, "&4%s&n report number out of range.\r\n"
	  "Use &4%s list&n to view available reports.\r\n", temp, temp);
  }
}

void ReportList::getNotFoundMesg(int mode, char *writeto)
{
  char temp[10];
  if (mode == REPORT_MODE_PRINTREPORT) {
    sprintf(writeto,
	  "Report not found. Use &4listreports&n to list available reports.\r\n");
  } else {
    getReportModeName(mode, temp);
    sprintf(writeto,
	  "Report not found. Use &4%s list&n to list available reports.\r\n",
	  temp);
  }
}

void ReportList::getRestrictedMesg(int mode, char *writeto)
{
  char temp[10];
  getReportModeName(mode, temp);
  sprintf(writeto,
	  "Sorry, you don't have access to this report.\r\n"
	  "Use &4%s list&n to list available reports.\r\n", temp);
}

void getReportModeName(int mode, char *writeto)
{
  switch (mode) {
    case REPORT_MODE_BUG:
    sprintf(writeto, "bug");
    return;
    case REPORT_MODE_TODO:
    sprintf(writeto, "todo");
    return;
    case REPORT_MODE_IDEA:
    sprintf(writeto, "idea");
    return;
    case REPORT_MODE_TYPO:
    sprintf(writeto, "typo");
    return;
  }

  sprintf(writeto, "Undefined");
}

// REPORT
int
Report::getReportType()
{
  switch (getType()) {

    case REPORT_TYPE_IDEA:
    return REPORT_MODE_IDEA;

    case REPORT_TYPE_TYPO:
    return REPORT_MODE_TYPO;

    case REPORT_TYPE_TODO:
    return REPORT_MODE_TODO;

    default:
    return REPORT_MODE_BUG;
  }
}

  // list related functions
void
Report::addChange(ReportChange reportChange)
{
  changes.push_back(reportChange);
}


bool
Report::removeChange(int index)
{
  int
    i = 0;
  list < ReportChange >::iterator liter;	// iterator for looping over list elements

  for (liter = changes.begin(); liter != changes.end(); liter++) {
    if (i == index) {
      changes.erase(liter);
      return (TRUE);
    }
    i++;
  }
  return (FALSE);
}

void
Report::printDetails(struct descriptor_data *d, char *writeto)
{
  char stateString[20], typeString[20], dateString[25];
  char temp[MAX_STRING_LENGTH], temp1[MAX_STRING_LENGTH];
  time_t dispTime = getOrgTime();
#ifdef NO_LOCALTIME
  struct tm lt;
#endif

  sprinttype(getType(), report_types, typeString);
  sprinttype(getState(), report_states, stateString);
#ifndef NO_LOCALTIME
  strncpy(dateString, (char *) asctime(localtime(&dispTime)), 25);
#else
  jk_localtime(&lt, dispTime);
  strncpy(dateString, (char *) asctime(&lt), 25);
#endif
  dateString[24] = '\0';

  sprintf(writeto,
	  "Report Num: [&g%3d&n] Reported by &7%s&n on &g%s&n "
	  "Rev &c%d.%d.%d&n\r\n"
	  "Type: [&4%s&n] State: [&4%s&n] Room: [&8%d&n]\r\n"
	  "S-Desc: &0%s&n\r\n"
	  "L-Desc: %s\r\n",
	  getReportNum(), get_name_by_id(getReporterId()), dateString,
	  getOrgRelease().getMajor(), getOrgRelease().getBranch(),
	  getOrgRelease().getMinor(),
	  typeString, stateString, getOrgRoom(),
	  getShortDescription(), getLongDescription());

  temp[0] = '\0';
  list < ReportChange >::iterator liter;	// iterator for looping over list elemnts
  for (liter = changes.begin(); liter != changes.end(); liter++) {
    liter->printDetails(temp1);
    sprintf(temp, "%s%s", temp, temp1);
  }
  sprintf(writeto, "%s\r\n%s", writeto, temp);
}

void
Report::printBriefDescription(struct descriptor_data *d, char *writeto)
{
  char
    stateString[20], typeString[20];

  sprinttype(getType(), report_types, typeString);
  sprinttype(getState(), report_states, stateString);

  sprintf(writeto, "&g%3d&n) S-Desc: &0%s&n\r\n"
	  "     Type: [&4%12s&n] State: [&4%7s&n] "
	  "Rev [&c%d.%d.%d&n] By [&7%s&n] Res [&7%s&n]\r\n",
	  getReportNum(), getShortDescription(),
	  typeString, stateString,
	  getOrgRelease().getMajor(), getOrgRelease().getBranch(),
	  getOrgRelease().getMinor(), get_name_by_id(getReporterId()), get_name_by_id(getPlayerId()));
}

void
ReportChange::printDetails(char *writeto)
{
  char dateString[25], fromState[20], toState[20], fromType[20], toType[20];
  bool appendNewLine = FALSE;
  time_t dispTime = getTime();
#ifdef NO_LOCALTIME
  struct tm lt;
#endif

#ifndef NO_LOCALTIME
  strncpy(dateString, (char *) asctime(localtime(&dispTime)), 25);
#else
  jk_localtime(&lt, dispTime);
  strncpy(dateString, (char *) asctime(&lt), 25);
#endif
  dateString[24] = '\0';

  sprintf(writeto, "Change by &7%s&n on &g%s&n Rev &c%d.%d.%d&n\r\n",
	  get_name_by_id(getPlayerId()), dateString,
	  getRelease().getMajor(), getRelease().getBranch(),
	  getRelease().getMinor());

  if (getFromState() != getToState()) {
    sprinttype(getFromState(), report_states, fromState);
    sprinttype(getToState(), report_states, toState);

    sprintf(writeto, "%s  State: &4%s&n -> &4%s&n",
	    writeto, fromState, toState);
    appendNewLine = TRUE;
  }

  if (getFromType() != getToType()) {
    sprinttype(getFromType(), report_types, fromType);
    sprinttype(getToType(), report_types, toType);

    sprintf(writeto, "%s  Type: &4%s&n -> &4%s&n", writeto, fromType, toType);
    appendNewLine = TRUE;
  }

  sprintf(writeto, "%s%s  Description : &1%s&n\r\n",
	  writeto, (appendNewLine) ? "\r\n" : "", getChangeDescription());
}

struct report_file_elem Report::toFileElem()
{
  struct report_file_elem
    fileElem;

  fileElem.playerId = getPlayerId();
  fileElem.reporterId = getReporterId();
  fileElem.reportNum = getReportNum();
  fileElem.state = getState();
  fileElem.type = getType();
  fileElem.orgRoom = getOrgRoom();
  fileElem.orgTime = getOrgTime();
  fileElem.relMajor = getOrgRelease().getMajor();
  fileElem.relBranch = getOrgRelease().getBranch();
  fileElem.relMinor = getOrgRelease().getMinor();
  fileElem.relCvsUpToDate = getOrgRelease().isCvsUpToDate();
  strcpy(fileElem.shortDescription, getShortDescription());
  strcpy(fileElem.longDescription, getLongDescription());

  return fileElem;
}

struct reportchange_file_elem ReportChange::toFileElem()
{
  struct reportchange_file_elem fileElem;

  fileElem.changeNum = getChangeNum();
  fileElem.reportNum = getReportNum();
  fileElem.playerId = getPlayerId();
  fileElem.fromState = getFromState();
  fileElem.toState = getToState();
  fileElem.fromType = getFromType();
  fileElem.toType = getToType();
  fileElem.changeTime = getTime();
  fileElem.relMajor = getRelease().getMajor();
  fileElem.relBranch = getRelease().getBranch();
  fileElem.relMinor = getRelease().getMinor();
  fileElem.relCvsUpToDate = getRelease().isCvsUpToDate();
  strncpy(fileElem.changeDescription, getChangeDescription(), REPORT_SHORTDESC_LENGTH);

  return fileElem;
}

const char *
  report_states[] = {
  "OPEN",
  "ASSESSED",
  "FEEDBACK",
  "CLOSED",
  "DELETED",
  "\n"
};

const char *
  report_types[] = {
  "IDEA",
  "TYPO",
  "TODO",
  "BUG-CRASH",
  "BUG-BUILDING",
  "BUG-BALANCE",
  "BUG-OTHER",
  "\n"
};
@


1.15
log
@Artus> Now showing when a user begins editing a report.
@
text
@d84 2
a85 1
  if (terminator == STRINGADD_ABORT) {
a88 1

d94 4
a97 8

  switch (STATE(d)) {
    case CON_REPORT_ADD:
    reportList->dispAddMenu(d);
    break;
    case CON_REPORT_EDIT:
    reportList->dispEditMenu(d);
    break;
d117 2
a118 1
  if (subcmd == REPORT_MODE_LISTREPORT) {
d122 2
a123 1
  if (subcmd == REPORT_MODE_PRINTREPORT) {
d128 2
a129 2

  if (!*arg1) {
a134 1

d137 2
a138 1
    if (GET_LEVEL(ch) < LVL_GRGOD && subcmd == REPORT_MODE_TODO) {
d145 4
a148 12
      case REPORT_MODE_BUG:
	newReport->setType(REPORT_TYPE_BUGCRASH);
	break;
      case REPORT_MODE_IDEA:
	newReport->setType(REPORT_TYPE_IDEA);
	break;
      case REPORT_MODE_TYPO:
	newReport->setType(REPORT_TYPE_TYPO);
	break;
      case REPORT_MODE_TODO:
	newReport->setType(REPORT_TYPE_TODO);
	break;
a149 1

a154 1

a160 1

a164 1

a166 1

a171 1

a175 1

a179 1

a180 1

d185 1
a185 2

    // but print <number>
a188 1

a189 1

a199 1

a206 1

d216 5
a220 7

  sprintf(buf,
	  "\r\n-- Report Number: [&cUNASSIGNED&n] Reporter: [&7%s&n]"
	  " Room: [&8%d&n]\r\n"
	  "-- Date: [&g%s&n] Revision: [&c%d.%d.%d&n] State: [&4%s&n]\r\n"
	  "&g1&n) S-Desc : &0%s\r\n"
	  "&g2&n) L-Desc : %s\r\n",
d225 2
a226 5

  if (!REPORT(d)->isRestricted(d, REPORT_MODE(d))) {
    sprintf(buf, "%s" "&g3&n) State  : &c%s\r\n", buf, stateString);
  }

d228 4
a231 14
                !REPORT(d)->isRestricted(d, REPORT_MODE(d))) {
    sprintf(buf,
	    "%s"
	    "&g4&n) Type   : &c%s\r\n",
	    buf,
            typeString);
  }

  if (!REPORT(d)->isRestricted(d, REPORT_MODE(d))) {
    sprintf(buf,
            "%s"
	    "&g5&n) Player : &7%s&n\r\n", 

            buf, 
d233 1
a233 4

  }

  sprintf(buf, "%s" "&gQ&n) Quit\r\n" "&nEnter Choice : ", buf);
a240 1

a248 1

d258 5
a262 7

  sprintf(buf,
	  "\r\n-- Report Number: [&g%d&n] Reporter: [&7%s&n]"
	  " Room: [&8%d&n]\r\n"
	  "-- Date: [&g%s&n] Revision: [&c%d.%d.%d&n]\r\n"
	  "&g1&n) S-Desc : &0%s\r\n"
	  "&g2&n) L-Desc : %s\r\n",
d264 1
a264 2
	  (int) REPORT(d)->getOrgRoom(),
	  dateString,
a268 1

d272 10
a281 17
                !REPORT(d)->isRestricted(d, REPORT_MODE(d))) {
    sprintf(buf, "%s"
	    "&g3&n) State  : &c%s\r\n" 
	    "&g4&n) Type   : &c%s\r\n",
            buf, stateString, typeString);

    if (!REPORT(d)->isRestricted(d, REPORT_MODE(d))) {
      sprintf(buf, "%s"
	    "&g5&n) Player : &7%s&n\r\n", 

            buf, 
            get_name_by_id(REPORT(d)->getPlayerId()));
    }
  } else {
    sprintf(buf, "%s"
	    "&g3&n) State  : &c%s\r\n", buf, stateString);
  }
d293 2
a294 1
  switch (mode) {
d298 3
a300 4
    if (GET_LEVEL(d->character) >= LVL_GRGOD) {
      return (FALSE);
    }
    break;
d302 3
a304 4
    if (GET_LEVEL(d->character) >= LVL_GOD) {
      return (FALSE);
    }
    break;
d322 1
a322 1
      if ((GET_LEVEL(d->character) < LVL_IMMORT) &&
a341 1

@


1.14
log
@Artus> Now warning free :o)
@
text
@d138 2
a139 2
  if (is_abbrev(arg1, "add")) {

a143 1

d145 2
a146 2

    switch (subcmd) {
d148 2
a149 2
      newReport->setType(REPORT_TYPE_BUGCRASH);
      break;
d151 2
a152 2
      newReport->setType(REPORT_TYPE_IDEA);
      break;
d154 2
a155 2
      newReport->setType(REPORT_TYPE_TYPO);
      break;
d157 2
a158 2
      newReport->setType(REPORT_TYPE_TODO);
      break;
d185 1
a185 1
    if (!reportList->copyReport(ch->desc, number, subcmd)) {
a186 1
    }
d188 1
@


1.13
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d82 1
a82 2
void
report_string_cleanup(struct descriptor_data *d, int terminator)
a83 2
  bool copy = TRUE;

d109 1
a109 2
  char outofrange[MAX_INPUT_LENGTH], notfound[MAX_INPUT_LENGTH],
    usage[MAX_INPUT_LENGTH];
d369 2
a370 1
  switch (getReportType()) {
d373 3
a375 3
    if (GET_LEVEL(d->character) < LVL_ANGEL) {
      if (GET_IDNUM(d->character) != getPlayerId() &&
          GET_IDNUM(d->character) != getReporterId()) {
d377 1
a377 4
      }
    }
    return (TRUE);

d379 3
a381 3
    if (GET_LEVEL(d->character) < LVL_IMMORT) {
      if (GET_IDNUM(d->character) != getPlayerId() &&
	  GET_IDNUM(d->character) != getReporterId()) {
d383 1
a383 4
      }
    }
    return (TRUE);

d385 3
a387 3
    if (GET_LEVEL(d->character) < LVL_GOD) {
      if (GET_IDNUM(d->character) != getPlayerId() &&
	  GET_IDNUM(d->character) != getReporterId()) {
d389 1
a389 3
      }
    }
    return (TRUE);
d391 1
d397 2
a398 1
  switch (mode) {
d404 2
a405 2
    if (GET_LEVEL(d->character) < LVL_GRGOD) {
      if (GET_IDNUM(d->character) != getPlayerId()) {
d407 1
a407 3
      }
    }
    return (TRUE);
d411 2
a412 2
    if (GET_LEVEL(d->character) < LVL_GOD) {
      if (GET_IDNUM(d->character) != getPlayerId()) {
d414 1
a414 3
      }
    }
    return (TRUE);
d422 1
a422 1
  int reportNum, option;
a423 2
  char *oldtext = NULL, arg1[MAX_INPUT_LENGTH];
  char *writeto = NULL;
d912 1
a912 4
  int
    i = 0;
  struct descriptor_data *
    dsc;
a1138 1
  int i;
a1155 1
  int i;
@


1.12
log
@Artus> Changed remort, in particular, list remort abilities to char.. Also,
       spellsword was incorrectly being listed as a possible path for a
       warrior.

       Replaced #ifdef USE_LOCALTIME with #ifndef NO_LOCALTIME..

       Added define NOTELL_SOUNDPROOF .. Define this to stop people telling
       to/from soundproof rooms.

       Removed extraneous level checking from do_wear.. This is handled
       better by perform_wear.
@
text
@d1045 1
a1045 1
    store_mail((*sliter), 0, buf);
d1049 1
a1049 1
    store_mail(getPlayerId(), 0, buf);
@


1.11
log
@Artus> Fixed primal scream.
       Added sanity checking to clan_rel_inc().
       do_cast() no longer resets mana to maxmana(), fixes dark ritual and
	 vampire.
       Reports should no longer mail the same person twice.
@
text
@d230 1
a230 1
#ifndef USE_LOCALTIME
d236 1
a236 1
#ifdef USE_LOCALTIME
d292 1
a292 1
#ifndef USE_LOCALTIME
d298 1
a298 1
#ifdef USE_LOCALTIME
d1305 1
a1305 1
#ifndef USE_LOCALTIME
d1311 1
a1311 1
#ifdef USE_LOCALTIME
d1364 1
a1364 1
#ifndef USE_LOCALTIME
d1368 1
a1368 1
#ifdef USE_LOCALTIME
@


1.10
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@d987 2
a988 1
  list < ReportChange >::iterator cliter;	// iterator for looping over list elements
d992 2
a993 2
  if (changes.begin() == changes.end()) {
    if (getPlayerId() != getReporterId()) {
a994 2
    }
  }
d999 3
a1001 1
  for (cliter = changes.begin(); cliter != changes.end(); cliter++) {
d1003 1
a1003 1
    if (sendTo.begin() == sendTo.end()) {
d1005 2
a1006 1
    } else {
d1008 5
a1012 6
      for (sliter = sendTo.begin(); sliter != sendTo.end(); sliter++) {
        if ((*sliter) == cliter->getPlayerId()) {
          continue;
        }
        sendTo.push_back(cliter->getPlayerId()); 
      }
d1016 1
a1016 1
  if (sendTo.begin() == sendTo.end()) {
a1017 1
  }
d1024 1
a1024 1
  if (changes.begin() == changes.end()) {
d1029 3
a1031 6
      
        get_name_by_id(getReporterId()),
        getShortDescription(), getLongDescription(),
        buf2, getReportNum()
        );
  } else {
d1035 2
a1036 8
      
        get_name_by_id(cliter->getPlayerId()),
        cliter->getChangeDescription(),
        buf2, getReportNum()
        );
  }

  bool found = FALSE;
d1038 1
d1040 2
a1041 1
  for (sliter = sendTo.begin(); sliter != sendTo.end(); sliter++) {
d1048 1
a1048 1
  if (!found) {
a1049 1
  }
@


1.9
log
@Artus>
Adrenaline : (Potion Quaffing): 6 per fight Round instead of 5.
             (Flying Tackle)  : 2 fight rounds vs 3.
Balance    : QEQ no longer gets written to the log file when unbalanced.
Colour     : &f is no longer flash, &@@ is. Keep it quiet(tm).
Corpse File: Flush()ing after write().
Double Kick: Now calls apply_spell_skill_abil()
Echo       : No longer sends text to mobs calling it.
Fighting   : Is only possible if STATE = CON_PLAYING
Glance     : Fixed erroneous dex check.
OLC        : No longer possible while fighting.
           : LVL_IMPL+ (150+) can now edit mob levels up to 120.
Pit Trap   : Now logs deaths.
             No longer says "theoretically" on creation.
Report File: Flush()ing after write().
Spell/Skill: Now allows up to NUM_CLASSES class lines in primal_spskls
             (Used to only allow up to 10)
@
text
@d56 1
a56 1
#include <list.h>
d58 2
a59 2
#include <fstream.h>
#include <iostream.h>
a764 1

d843 1
a843 1
  log("ReportList::listReports: arg = '%s', mode = %d", (*arg) ? arg : "", mode);
d1049 1
a1049 1
    //log("Sending mail to player id %ld", (*sliter));
d1082 1
a1082 1
  inReportFile.open(REPORTS_FILE, ios::in);
d1084 1
a1084 1
    log("SYSERR: could not open reports file %s.", REPORTS_FILE);
d1102 1
a1102 1
  inChangeFile.open(RCHANGES_FILE, ios::in);
d1104 1
a1104 1
    log("SYSERR: could not open report changes file %s.", RCHANGES_FILE);
d1116 1
a1116 6

  // Now open the output streams for writing
  outReportFile.open(REPORTS_FILE, ios::ate);
  outChangeFile.open(RCHANGES_FILE, ios::ate);

  log("  Loaded %d reports and %d reportchanges", topReportNum, topChangeNum);
d1161 1
d1164 9
a1172 6
  if (!outReportFile) {
    outReportFile.open(REPORTS_FILE, ios::ate);
    if (!outReportFile) {
      log("SYSERR: couldn't open reports file %s for writing", REPORTS_FILE);
      return;
    }
d1174 4
a1177 4
  outReportFile.seekp((report.reportNum - 1) * sizeof(report));
  outReportFile.write((char *)&report, sizeof(report));
  outReportFile.flush(); /* Artus> Should stop things not being written when
			    a crash happens later.. */
d1182 10
a1191 7
  if (!outChangeFile) {
    outChangeFile.open(RCHANGES_FILE, ios::ate);
    if (!outChangeFile) {
      log("SYSERR: couldn't open report changes file %s for writing", 
          RCHANGES_FILE);
      return;
    }
d1193 4
a1196 4
  outChangeFile.seekp((reportchange.changeNum - 1) * sizeof(reportchange));
  outChangeFile.write((char *)&reportchange, sizeof(reportchange));
  outChangeFile.flush(); /* Artus> Should stop things not being written when
			    a crash happens later.. */
@


1.8
log
@Latest Versions
@
text
@d1178 2
d1194 2
@


1.7
log
@

Modified: Artus

Changed:
- localtime stuff
@
text
@d1128 1
a1128 1
                                    report.relMinor, "", report.relCvsUpToDate);
d1144 2
a1145 1
                                    reportchange.relCvsUpToDate);
@


1.6
log
@
Modified: DM

Changed: (This is a group checkin)
- many many bug fixes
@
text
@d228 1
a228 2
  char
    dateString[25], typeString[20], stateString[20];
d230 3
d236 1
d238 4
d292 3
d298 1
d300 4
d1304 6
a1309 6
  char
    stateString[20], typeString[20], dateString[25];
  char
    temp[MAX_STRING_LENGTH], temp1[MAX_STRING_LENGTH];
  time_t
    dispTime = getOrgTime();
d1313 1
d1315 4
d1363 6
a1368 6
  char
    dateString[25], fromState[20], toState[20], fromType[20], toType[20];
  bool
    appendNewLine = FALSE;
  time_t
    dispTime = getTime();
d1370 1
d1372 4
@


1.5
log
@
Modified: DM

Changed:
- finished report notification
@
text
@d5 1
a5 1
 * Initiallu when a report is created, the state is set to OPEN. When the
d115 5
a119 2
  sprintf(usage, "&1Usage: &4%s [ 'add' | 'edit' <number> | 'delete' <number>\r"
	  "\n            | 'list' <orderedby> | 'print' <number>&n\r\n",
d124 11
d166 1
d205 1
a205 1
    // report list [sortedby] 
d207 2
a208 1
    reportList->listReports(ch->desc, subcmd);
d245 1
a245 1
	  get_name_by_id(REPORT(d)->getPlayerId()),
d299 1
a299 1
	  REPORT(d)->getReportNum(), get_name_by_id(REPORT(d)->getPlayerId()),
d356 1
a356 1
bool Report::isViewable(struct descriptor_data * d, int mode)
d358 1
a358 1
  switch (mode) {
d362 2
a363 1
      if (GET_IDNUM(d->character) != getPlayerId()) {
d371 2
a372 1
      if (GET_IDNUM(d->character) != getPlayerId()) {
d380 2
a381 1
      if (GET_IDNUM(d->character) != getPlayerId()) {
d584 8
a591 1
    if (!genolc_checkstring(d, arg))
a592 7
    REPORT(d)->setChangeDescription(arg);
    reportList->setReport(d);
    delete(Report *) REPORT(d);
    REPORT(d) = NULL;
    REMOVE_BIT(PLR_FLAGS(d->character), PLR_REPORTING);
    STATE(d) = CON_PLAYING;
    break;
d642 2
d645 2
a646 2
    sprintf(buf, "REPORT: %s added report number %d",
	    GET_NAME(d->character), reportNum);
d648 2
a649 2
    sprintf(buf, "REPORT: %s edited report number %d",
	    GET_NAME(d->character), reportNum);
d763 1
d802 6
d822 1
a822 1
ReportList::listReports(struct descriptor_data *d, int mode)
d824 19
a842 4
  int
    i = 0;
  list < Report >::iterator liter;	// iterator for looping over list elements

d845 1
a845 1
    if (liter->getReportType() != mode)
d848 11
a858 1
    if (liter->isViewable(d, mode)) {
d868 1
d889 1
a889 1
      if (liter->getReportType() != mode)
d893 1
a893 1
      if (liter->isViewable(d, mode)) {
d949 1
d975 10
a984 1
  log("In mailChanges()");
d987 1
a987 1
    log("  Passing change number %d", cliter->getChangeNum());
d989 1
a989 2
        log("Added playerID %ld to notify list", cliter->getPlayerId());
        sendTo.push_back(cliter->getPlayerId()); 
d991 1
a995 1
        log("Added playerID %ld to notify list", cliter->getPlayerId());
d1010 14
a1023 3
  sprintf(buf, "&0Report Change by &7%s&n\r\n"
               "&0Change Description:&n %s\r\n\r\n"
               "For full details type &4%s print %d&n\r\n",
d1025 7
a1031 4
      get_name_by_id(cliter->getPlayerId()),
      cliter->getChangeDescription(),
      buf2, getReportNum()
      );
d1035 3
a1037 1
    log("Sending mail to player id %ld", (*sliter));
d1040 4
a1048 2
  log("In notify(int)");

d1115 2
a1116 2
  reports.push_back(Report(report.playerId, report.reportNum, report.state, 
                           report.type, report.shortDescription, 
d1188 6
a1193 2
  getReportModeName(mode, temp);
  sprintf(writeto, "&4%s&n report number out of range.\r\n"
d1195 1
d1201 6
a1206 2
  getReportModeName(mode, temp);
  sprintf(writeto,
d1209 1
d1307 1
a1307 1
	  getReportNum(), get_name_by_id(getPlayerId()), dateString,
d1333 1
a1333 1
	  "Revision [&c%d.%d.%d&n] By [&7%s&n]\r\n",
d1337 1
a1337 27
	  getOrgRelease().getMinor(), get_name_by_id(getPlayerId()));
}

// File related functions
void
Report::read()
{

}

void
Report::write()
{
}


// file realted functions
void
ReportChange::read()
{

}

void
ReportChange::write()
{

d1385 1
d1417 1
a1417 1
  strcpy(fileElem.changeDescription, getChangeDescription());
@


1.4
log
@*** empty log message ***
@
text
@d943 1
d945 5
a949 4
  sprintf(buf, "&B --- Report Change by &7%s &B---\r\n"
               "&0Report Number: &c%-10d &0Report Originator: &7%s\r\n"
               "&0Status From:   &c%-10s &0Status To: &c%-10s\r\n"
               "&0Change Description:&n\r\n  %s\r\n",
d952 2
a953 5
      getReportNum(), 
      get_name_by_id(getPlayerId()),
      report_states[cliter->getFromState()],
      report_states[cliter->getToState()],
      cliter->getChangeDescription()
d1130 1
a1130 1
void ReportList::getReportModeName(int mode, char *writeto)
@


1.3
log
@
Removed:
- debug logs
@
text
@d74 1
a621 2
  // email/mudmail ppl ....
  reportList->notify(reportNum);
d635 3
d913 51
d965 8
a972 2
ReportList::notify(int number)
{
d974 5
@


1.2
log
@
Added:
- Evolution - first working loadable/saveable reports version

TODO:
- report notification
@
text
@a415 1
	log("deleting temp report report %d", (int) d->report);
a727 1
        log("Writing report num %d", liter->getReportNum());
a728 2

        log("Writing change num %d", reportChange.getChangeNum());
a745 1
    log("Writing report num %d", report->getReportNum());
a899 2
      log("Report Edit: created temp copy of report number %d mem %d",
	  newReport->getReportNum(), (int) newReport);
a901 1
      log("Report Edit: set d->report to %d", (int) d->report);
@


1.1
log
@
Added:
- Initial version of reporting system

TODO:
- restrictions, notification, saving/loading
@
text
@d1 55
d98 1
a98 1
  case CON_REPORT_ADD:
d101 1
a101 1
  case CON_REPORT_EDIT:
a117 8
  sprintf(outofrange, "%s report number out of range, use &4%s list&n "
	  "to view report details.\r\n",
	  cmd_info[cmd].command, cmd_info[cmd].command);

  sprintf(notfound, "%s report not found, use &4%s list&n "
	  "to view report details.\r\n",
	  cmd_info[cmd].command, cmd_info[cmd].command);

d126 1
d128 6
d137 1
a137 1
    case REPORT_MODE_BUG:
d140 1
a140 1
    case REPORT_MODE_IDEA:
d143 1
a143 1
    case REPORT_MODE_TYPO:
d146 1
a146 1
    case REPORT_MODE_TODO:
d156 1
a167 4
    if (number < 1 || number > reportList->getTopReportNum()) {
      send_to_char(outofrange, ch);
      return;
    }
d174 1
a174 1
    if (!reportList->copyReport(ch->desc, number)) {
d187 1
a187 4
    if (number < 1 || number > reportList->getTopReportNum()) {
      send_to_char(outofrange, ch);
      return;
    }
a188 4
    if (!reportList->removeReport(number)) {
      send_to_char(notfound, ch);
      return;
    }
d191 1
a191 1
    reportList->printReports(ch->desc);
d198 1
a198 4
    if (number < 1 || number > reportList->getTopReportNum()) {
      send_to_char(outofrange, ch);
      return;
    }
a199 4
    if (!reportList->printReport(ch->desc, number)) {
      send_to_char(notfound, ch);
      return;
    }
d226 2
a227 5
	  "&g1&n) Type   : &c%s\r\n"
	  "&g2&n) S-Desc : &0%s\r\n"
	  "&g3&n) L-Desc : %s\r\n"
	  "&gQ&n) Quit\r\n"
	  "&nEnter Choice : ",
d230 1
a230 1
	  release.getBranch(), release.getMinor(), stateString, typeString,
d233 25
d280 2
a281 6
	  "&g1&n) State  : &c%s\r\n"
	  "&g2&n) Type   : &c%s\r\n"
	  "&g3&n) S-Desc : &0%s\r\n"
	  "&g4&n) L-Desc : %s\r\n"
	  "&gQ&n) Quit\r\n"
	  "&nEnter Choice : ",
a287 2
	  stateString,
	  typeString,
d290 23
d316 81
a401 1
  iostream argStream;
a404 2
  argStream << arg;

d407 1
a407 3
  case REPORT_STATE_MENU:
    switch (STATE(d)) {
    case CON_REPORT_ADD:
d409 1
a409 1
      switch (*arg) {
d412 13
a424 14
	if (REPORT_MODIFIED(d)) {
	  SEND_TO_Q("Do you wish to save changes? : ", d);
	  REPORT_STATE(d) = REPORT_STATE_CONFIRM;
	} else {
	  log("deleting temp report report %d", (int) d->report);
	  delete(Report *) REPORT(d);
	  REPORT(d) = NULL;
	  log("deleted");
	  act("$n cancels adding a report report.",
	      TRUE, d->character, NULL, NULL, TO_ROOM);
	  REMOVE_BIT(PLR_FLAGS(d->character), PLR_REPORTING);
	  STATE(d) = CON_PLAYING;
	}
	break;
d427 3
a429 2
	reportList->dispTypeMenu(d);
	break;
d432 6
a437 3
	SEND_TO_Q("Enter short description : ", d);
	REPORT_STATE(d) = REPORT_STATE_SHORTDESC;
	break;
d440 9
a448 10
	REPORT_STATE(d) = REPORT_STATE_LONGDESC;
	SEND_TO_Q("\r\n", d);
	send_editor_help(d);
	SEND_TO_Q("Enter details:\r\n\r\n", d);
	do_odd_write(d, PWT_REPORT_LONGDESC, REPORT_LONGDESC_LENGTH);
	break;

      default:
	reportList->dispAddMenu(d);
	break;
a450 1
      // End of Add Menu
d452 7
a458 7
    case CON_REPORT_EDIT:
      switch (*arg) {
      case 'q':
      case 'Q':
	if (REPORT_MODIFIED(d)) {
	  SEND_TO_Q("Do you wish to save changes? : ", d);
	  REPORT_STATE(d) = REPORT_STATE_CONFIRM;
d460 1
a460 7
	  log("deleting temp report report %d", (int) d->report);
	  delete(Report *) REPORT(d);
	  REPORT(d) = NULL;
	  act("$n cancels adding a report report.",
	      TRUE, d->character, NULL, NULL, TO_ROOM);
	  REMOVE_BIT(PLR_FLAGS(d->character), PLR_REPORTING);
	  STATE(d) = CON_PLAYING;
d462 2
a463 1
	break;
d465 9
a473 4
	// State
      case '1':
	reportList->dispStateMenu(d);
	break;
d475 9
a483 4
	// Type
      case '2':
	reportList->dispTypeMenu(d);
	break;
d485 9
a493 5
	// Short Description
      case '3':
	SEND_TO_Q("Enter short description : ", d);
	REPORT_STATE(d) = REPORT_STATE_SHORTDESC;
	break;
d495 4
a498 12
	// Long Description
      case '4':
	REPORT_STATE(d) = REPORT_STATE_LONGDESC;
	SEND_TO_Q("\r\n", d);
	send_editor_help(d);
	SEND_TO_Q("Enter details:\r\n\r\n", d);
	do_odd_write(d, PWT_REPORT_LONGDESC, REPORT_LONGDESC_LENGTH);
	break;

      default:
	reportList->dispEditMenu(d);
	break;
a500 2
      // End of edit menu
    }
d502 1
a502 1
  case REPORT_STATE_TYPE:
d504 8
a511 1
    if (option < 1 || option > NUM_REPORT_TYPES) {
d514 5
d520 1
a520 7
      REPORT(d)->setType(option - 1);
      REPORT_MODIFIED(d) = 1;
      if (REPORT_STATE(d) == REPORT_STATE_TYPE) {
	reportList->dispAddMenu(d);
      } else {
	reportList->dispEditMenu(d);
      }
d524 1
a524 1
  case REPORT_STATE_STATE:
d532 5
a536 1
      reportList->dispEditMenu(d);
d540 1
a540 1
  case REPORT_STATE_SHORTDESC:
d552 1
a552 1
  case REPORT_STATE_LONGDESC:
d564 1
a564 1
  case REPORT_STATE_CHANGEDESC:
d568 1
a568 1
    reportList->setReport(d, REPORT(d));
d576 1
a576 1
  case REPORT_STATE_CONFIRM:
d580 3
a582 3
    case 'y':
    case 'Y':
      if (REPORT(d)->getReportNum()) {
d587 1
a587 1
      reportList->setReport(d, REPORT(d));
d590 2
a591 2
    case 'n':
    case 'N':
d595 1
a595 1
    default:
d606 1
a606 1
  default:
d615 1
a615 2
void
ReportList::setReport(struct descriptor_data *d, Report * report)
d617 1
a617 2
  int
    reportNum = reportList->addReport(d, REPORT(d));
d620 8
a627 3
    SEND_TO_Q("Adding/Editing report failed...\r\n", d);
    log("SYSERR: Adding/Editing report %d by %s",
	REPORT(d)->getReportNum(), GET_NAME(d->character));
d629 3
d633 2
a634 2
    // email/mudmail ppl ....
    reportList->notify(reportNum);
a635 10
    if (STATE(d) == CON_REPORT_ADD) {
      sprintf(buf, "REPORT: %s added report number %d",
	      GET_NAME(d->character), reportNum);
    } else {
      sprintf(buf, "REPORT: %s edited report number %d",
	      GET_NAME(d->character), reportNum);
    }
    mudlog(buf, NRM,
	   MAX(GET_LEVEL(d->character), GET_INVIS_LEV(d->character)), TRUE);
  }
d643 7
a649 1
    counter, columns = 0;
d652 1
a652 1
  for (counter = 1; counter <= NUM_REPORT_TYPES; counter++) {
d656 1
a656 1
  if (!(columns % 2)) {
d675 1
a675 1
  if (!(columns % 2)) {
d700 13
d714 2
a715 1
	liter->addChange(ReportChange(GET_IDNUM(d->character),
d720 2
d723 1
d729 6
a742 3

    log("Adding report number %d to end of list", report->getReportNum());

d750 3
d759 1
a759 1
ReportList::removeReport(int number)
d765 23
a787 2
      reports.erase(liter);
      return (TRUE);
d790 2
d797 1
a797 1
ReportList::printReports(struct descriptor_data *d)
d805 8
a812 3
    liter->printBriefDescription(d, buf1);
    sprintf(buf, "%s%s", buf, buf1);
    i++;
d815 2
a816 1
    SEND_TO_Q("No reports exist.\r\n", d);
a821 6
void
ReportList::printReports(struct descriptor_data *d, int order)
{

}

d823 1
a823 1
ReportList::printReport(struct descriptor_data *d, int number)
d828 6
d836 15
a850 3
      liter->printDetails(d, buf);
      page_string(d, buf, TRUE);
      return (TRUE);
d854 2
d860 1
a860 1
ReportList::copyReport(struct descriptor_data * d, int number)
d867 6
d876 3
d881 5
d908 1
d914 2
a915 2
  SEND_TO_Q("Report not found, use &4TODO list&n to view report"
	    " details.\r\n", d);
d926 117
a1042 2
void
ReportList::load()
d1044 4
d1049 6
d1057 1
a1057 2
void
ReportList::save()
d1059 6
d1066 7
d1075 16
d1092 2
d1096 19
d1122 1
a1203 1

d1259 42
d1307 1
d1313 3
a1319 3
  "IDEA",
  "TYPO",
  "TODO",
@

