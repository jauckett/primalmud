head	1.39;
access;
symbols
	A3_0_59:1.7
	LATEST:1.7
	A3_0_1:1.6;
locks; strict;
comment	@ * @;


1.39
date	2004.11.24.01.38.10;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.27.01.43.58;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	2004.06.04.12.20.04;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.24.11.39.39;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.21.14.12.36;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.20.05.06.37;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.07.06.03.35;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.06.02.23.29;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.21.06.46.41;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.23.00.57.46;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.21.06.20.32;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.16.00.15.37;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.12.04.32.00;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.11.03.43.48;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.10.12.02.25;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.07.04.04.20;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.02.13.59.50;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.24.01.24.02;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.17.02.25.06;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.24.00.14.49;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.16.03.19.09;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.14.06.10.17;	author primal;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.23.05.49.06;	author primal;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.30.13.32.02;	author rod;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.03.12.55.47;	author primal;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.26.07.05.35;	author primal;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.23.11.26.22;	author primal;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.12.03.44.10;	author artus;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.11.14.09.32;	author artus;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.04.17.49.40;	author primal;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.02.04.34.44;	author primal;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.31.10.33.43;	author primal;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.26.17.15.18;	author primal;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.22.22.08.38;	author primal;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.20.23.59.40;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.28.21.12.17;	author primal;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.22.09.22.34;	author talisman;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.13.14.25.12;	author mbd;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.57;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Artus> Mostly looks like indent changes.. And a modification to determine
       whether we're moving, or fleeing.
@
text
@/* ************************************************************************
*   File: act.comm.c                                    Part of CircleMUD *
*  Usage: Player-level communication commands                             *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "constants.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "screen.h"
#include "spells.h"
#include "improved-edit.h" 
#include "dg_scripts.h"
#include "mail.h"

#define LAST_GOSSIPS_TO_SAVE 10
GossipItem last_gossips[LAST_GOSSIPS_TO_SAVE];

/* extern variables */
extern int level_can_shout;
extern int holler_move_cost;
extern struct room_data *world;
extern struct descriptor_data *descriptor_list;
extern struct char_data *character_list;
extern struct auc_data *auc_list;
extern int lot_tot;   

struct char_data *get_player_by_id(long id);
void write_auction_file();

/* local functions */
void perform_tell(struct char_data *ch, struct char_data *vict, char *arg);
int is_tell_ok(struct char_data *ch, struct char_data *vict);
void do_auc_stat(struct char_data *ch, int lot);
ACMD(do_say);
ACMD(do_gsay);
ACMD(do_tell);
ACMD(do_reply);
ACMD(do_spec_comm);
ACMD(do_write);
ACMD(do_page);
ACMD(do_gen_comm);
// ACMD(do_gen_write);
ACMD(do_qcomm);

/* modified do_say to affect speech when drunk.. - Vader */
#define DRUNKNESS    ch->player_specials->saved.conditions[DRUNK]
#define PISS_FACTOR  (25 - DRUNKNESS) * 50

ACMD(do_say)
{
  char *speech;
  unsigned int i,j;

  skip_spaces(&argument);

  if (!*argument)
    send_to_char("Yes, but WHAT do you want to say?\r\n", ch);
  else {
   speech = str_dup(argument);
/* this loop goes thru and randomly drops letters from what was said
 * depanding on how drunk the person is.. 24 is max drunk.. when someone
 * is 24 drunk they pretty much cant be understood.. - Vader
 */
   for(i = 0,j = 0; i < strlen(speech); i++) {
     if(number(1,PISS_FACTOR) > DRUNKNESS) {
       speech[j] = speech[i];
       j++;
       }
     }
     speech[j] = '\0';
	
     if(!IS_NPC(ch) && UNDERWATER(ch)){
        send_to_char("Bubbles raise from your mouth as you speak!\r\n",ch);
        act("Bubbles raise from $n's mouth as $e speaks.", TRUE, ch, 0, 0, TO_ROOM);
      }

    sprintf(buf, "&n$n says, '%s&n'", speech); 
    //act(buf, FALSE, ch, 0, 0, TO_ROOM);
    act(buf, FALSE, ch, 0, 0, TO_ROOM|DG_NO_TRIG);

    if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else {
      delete_doubledollar(argument);
      sprintf(buf, "&nYou say, '%s&n'\r\n", speech);  
      send_to_char(buf, ch);
    }
  }
  
  /* trigger check */
  speech_mtrigger(ch, argument);
  speech_wtrigger(ch, argument);
}


ACMD(do_gsay)
{
  struct char_data *k;
  struct follow_type *f;

  skip_spaces(&argument);

  if (!AFF_FLAGGED(ch, AFF_GROUP)) {
    send_to_char("But you are not the member of a group!\r\n", ch);
    return;
  }
  if (!*argument)
    send_to_char("Yes, but WHAT do you want to group-say?\r\n", ch);
  else {
    if (ch->master)
      k = ch->master;
    else
      k = ch;

   sprintf(buf, "&R$n &rtells the group, '%s&r'&n", argument);

    if (AFF_FLAGGED(k, AFF_GROUP) && (k != ch))
      act(buf, FALSE, ch, 0, k, TO_VICT | TO_SLEEP);
    for (f = k->followers; f; f = f->next)
      if (AFF_FLAGGED(f->follower, AFF_GROUP) && (f->follower != ch))
	act(buf, FALSE, ch, 0, f->follower, TO_VICT | TO_SLEEP);

    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else {
      sprintf(buf, "&rYou tell the group, '%s&r'&n\r\n", argument);   
      send_to_char(buf, ch);
    }
  }
}


void perform_tell(struct char_data *ch, struct char_data *vict, char *arg)
{
  sprintf(buf, "$n &rtells you, '%s&r'&n", arg);
  act(buf, FALSE, ch, 0, vict, TO_VICT | TO_SLEEP);

  if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
  else {
    sprintf(buf, "&rYou tell $N&r, '%s&r'&n", arg);
    act(buf, FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  }

  if (!IS_NPC(vict) && !IS_NPC(ch))
    GET_LAST_TELL(vict) = GET_IDNUM(ch);

// The above is stock circle code and the below was primal
//  GET_LAST_TELL(vict) = ch;
}

int is_tell_ok(struct char_data *ch, struct char_data *vict)
{
  if (ch == vict)
    send_to_char("You try to tell yourself something.\r\n", ch);
  else if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_NOTELL))
    send_to_char("You can't tell other people while you have notell on.\r\n", ch);
#ifdef NOTELL_SOUNDPROOF
  else if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF))
    send_to_char("The walls seem to absorb your words.\r\n", ch);
#endif
  else if (!IS_NPC(vict) && !vict->desc)        /* linkless */
    act("$E's linkless at the moment.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if (PLR_FLAGGED(vict, PLR_WRITING))
    act("$E's writing a message right now; try again later.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if ((!IS_NPC(vict) && PRF_FLAGGED(vict, PRF_NOTELL))
#ifdef NOTELL_SOUNDPROOF
           || ROOM_FLAGGED(vict->in_room, ROOM_SOUNDPROOF)
#endif
          )
    act("$E can't hear you.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else
    return (TRUE);

  return (FALSE);
}

/*
 * Yes, do_tell probably could be combined with whisper and ask, but
 * called frequently, and should IMHO be kept as tight as possible.
 */
ACMD(do_tell)
{
  struct char_data *vict = NULL;
  int i;
  struct char_data *generic_find_char(struct char_data *ch, char *arg, 
                                      int where);

  half_chop(argument, buf, buf2);

  if (!*buf || !*buf2)
    send_to_char("Who do you wish to tell what??\r\n", ch);
  else if (!(vict = generic_find_char(ch, buf, FIND_CHAR_WORLD)))
    send_to_char(NOPERSON, ch);
  else if (ch == vict)
    send_to_char("You try to tell yourself something.\r\n", ch);
  else if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_NOTELL))
    send_to_char("You can't tell other people while you have notell on.\r\n", ch);
  else if (!IS_NPC(vict) && !vict->desc)        /* linkless */
    act("$E's linkless at the moment.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if (IS_BUILDING(vict))
    act("$E's building right now; try again later.",
        FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if (!IS_NPC(vict) && PLR_FLAGGED(vict, PLR_WRITING | PLR_REPORTING | PLR_ODDWRITE))
    act("$E's writing a message right now; try again later.",
        FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if (!IS_NPC(vict) && PRF_FLAGGED(vict, PRF_NOTELL))
    act("$E's deaf to your tells; try again later.",
        FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if (!IS_NPC(vict) && PRF_FLAGGED(vict, PRF_AFK))
    act("$E's is marked (AFK); try again later.",
        FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_AFK))
    send_to_char("It is unfair to tell people things while marked AFK.  They can't reply!!.\r\n", ch);
  else if (GET_IGN_LVL(vict) > GET_LEVEL(ch) && !IS_NPC(ch)) {
      act("$E's ignoring you.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP );
      return;
  } else {    
    if (!IS_NPC(ch) && (LR_FAIL(ch, MAX(GET_LEVEL(vict), LVL_IS_GOD))))
      for (i=0; i < MAX_IGNORE; i++) {
        if (GET_IGNORE(vict, i) == GET_IDNUM(ch)) {       
          act("$E's ignoring you.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP );
          return;
        }
      } 
    perform_tell(ch, vict, buf2);
  }
}


ACMD(do_reply)
{
  struct char_data *tch = character_list;

  if (IS_NPC(ch))
    return;

  skip_spaces(&argument);

  if (GET_LAST_TELL(ch) == NOBODY)
    send_to_char("You have no-one to reply to!\r\n", ch);
  else if (!*argument)
    send_to_char("What is your reply?\r\n", ch);
  else {
    /*
     * Make sure the person you're replying to is still playing by searching
     * for them.  Note, now last tell is stored as player IDnum instead of
     * a pointer, which is much better because it's safer, plus will still
     * work if someone logs out and back in again.
     */
				     
    /*
     * XXX: A descriptor list based search would be faster although
     *      we could not find link dead people.  Not that they can
     *      hear tells anyway. :) -gg 2/24/98
     */
    while (tch != NULL && (IS_NPC(tch) || GET_IDNUM(tch) != GET_LAST_TELL(ch)))
      tch = tch->next;

    if (tch == NULL)
      send_to_char("They are no longer playing.\r\n", ch);
    else if (is_tell_ok(ch, tch))
      perform_tell(ch, tch, argument);
  }
}


ACMD(do_spec_comm)
{
  struct char_data *vict;
  const char *action_sing, *action_plur, *action_others;

  switch (subcmd) {
  case SCMD_WHISPER:
    action_sing = "whisper to";
    action_plur = "whispers to";
    action_others = "$n whispers something to $N.";
    break;

  case SCMD_ASK:
    action_sing = "ask";
    action_plur = "asks";
    action_others = "$n asks $N a question.";
    break;

  default:
    action_sing = "oops";
    action_plur = "oopses";
    action_others = "$n is tongue-tied trying to speak with $N.";
    break;
  }

  half_chop(argument, buf, buf2);

  if (!*buf || !*buf2) {
    sprintf(buf, "Whom do you want to %s.. and what??\r\n", action_sing);
    send_to_char(buf, ch);
  } else if (!(vict = generic_find_char(ch, buf, FIND_CHAR_ROOM)))
    send_to_char(NOPERSON, ch);
  else if (vict == ch)
    send_to_char("You can't get your mouth close enough to your ear...\r\n", ch);
  else {
    sprintf(buf, "&C$n &c%s you, '%s&c'&n", action_plur, buf2);
    act(buf, FALSE, ch, 0, vict, TO_VICT);
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else {
      sprintf(buf, "&cYou %s &C%s&c, '%s&c'&n\r\n", action_sing, GET_NAME(vict), buf2);
      send_to_char(buf, ch);
    }
    act(action_others, FALSE, ch, 0, vict, TO_NOTVICT);
  }
}



#define MAX_NOTE_LENGTH 1000	/* arbitrary */

ACMD(do_write)
{
  struct obj_data *paper, *pen = NULL;
  char *papername, *penname;

  if (IS_NPC(ch)) 
  {
    send_to_char("Your a mob, you can hardly read let alone write.\r\n", ch);
    return;
  }
    
  papername = buf1;
  penname = buf2;

  two_arguments(argument, papername, penname);

  if (!ch->desc)
    return;

  if (!*papername) 
  {		/* nothing was delivered */
    send_to_char("Write?  With what?  ON what?  What are you trying to do?!?\r\n", ch);
    return;
  }
  if (*penname) 
  {		/* there were two arguments */
    if (!(paper = generic_find_obj(ch, papername, FIND_OBJ_INV)))
    {
      sprintf(buf, "You have no %s.\r\n", papername);
      send_to_char(buf, ch);
      return;
    }
    if (!(pen = generic_find_obj(ch, penname, FIND_OBJ_INV)))
    {
      sprintf(buf, "You have no %s.\r\n", penname);
      send_to_char(buf, ch);
      return;
    }
  } else {		/* there was one arg.. let's see what we can find */
    if (!(paper = generic_find_obj(ch, papername, FIND_OBJ_INV)))
    {
      sprintf(buf, "There is no %s in your inventory.\r\n", papername);
      send_to_char(buf, ch);
      return;
    }
    if (GET_OBJ_TYPE(paper) == ITEM_PEN)	/* oops, a pen.. */
    {
      pen = paper;
      paper = NULL;
    } else if (GET_OBJ_TYPE(paper) != ITEM_NOTE) {
      send_to_char("That thing has nothing to do with writing.\r\n", ch);
      return;
    }
    /* One object was found.. now for the other one. */
    if (!GET_EQ(ch, WEAR_HOLD)) {
      sprintf(buf, "You can't write with %s %s alone.\r\n", AN(papername),
	      papername);
      send_to_char(buf, ch);
      return;
    }
    if (!CAN_SEE_OBJ(ch, GET_EQ(ch, WEAR_HOLD))) {
      send_to_char("The stuff in your hand is invisible!  Yeech!!\r\n", ch);
      return;
    }
    if (pen)
      paper = GET_EQ(ch, WEAR_HOLD);
    else
      pen = GET_EQ(ch, WEAR_HOLD);
  }


  /* ok.. now let's see what kind of stuff we've found */
  if (GET_OBJ_TYPE(pen) != ITEM_PEN)
    act("$p is no good for writing with.", FALSE, ch, pen, 0, TO_CHAR);
  else if (GET_OBJ_TYPE(paper) != ITEM_NOTE)
    act("You can't write on $p.", FALSE, ch, paper, 0, TO_CHAR);
  else {
    //char *backstr = NULL;

    /* Something on it, display it as that's in input buffer. */
    if (paper->action_description) {
      //backstr = str_dup(paper->action_description);
      send_to_char("There's something written on it already:\r\n", ch);
      //send_to_char(paper->action_description, ch);
    }
  
    /* we can write - hooray! */
    /* this is the PERFECT code example of how to set up:
     * a) the text editor with a message already loaed
     * b) the abort buffer if the player aborts the message
     */
    ch->desc->backstr = NULL;
    send_to_char("Write your note.  (/s saves /h for help)\r\n", ch);
    /* ok, here we check for a message ALREADY on the paper */
    if (paper->action_description) {
      /* we str_dup the original text to the descriptors->backstr */
      ch->desc->backstr = str_dup(paper->action_description);
      /* send to the player what was on the paper (cause this is already */
      /* loaded into the editor) */
      send_to_char(paper->action_description, ch);
    }

    act("$n begins to jot down a note.", TRUE, ch, 0, 0, TO_ROOM);
    //send_editor_help(ch->desc);
    /* assign the descriptor's->str the value of the pointer to the text */
    /* pointer so that we can reallocate as needed (hopefully that made */
    /* sense :>) */
    //string_write(ch->desc, &paper->action_description, MAX_NOTE_LENGTH, 0, backstr);
    string_write(ch->desc, &paper->action_description, MAX_NOTE_LENGTH, 0, NULL);

  }
}



ACMD(do_page)
{
  struct descriptor_data *d;
  struct char_data *vict;

  half_chop(argument, arg, buf2);

  if (IS_NPC(ch))
    send_to_char("Monsters can't page.. go away.\r\n", ch);
  else if (!*arg)
    send_to_char("Whom do you wish to page?\r\n", ch);
  else {
    sprintf(buf, "\007\007*$n* %s", buf2);
    if (!str_cmp(arg, "all")) {
      if (!LR_FAIL(ch, LVL_GOD)) {
	for (d = descriptor_list; d; d = d->next)
	  if (STATE(d) == CON_PLAYING && d->character)
	    act(buf, FALSE, ch, 0, d->character, TO_VICT);
      } else
	send_to_char("You will never be godly enough to do that!\r\n", ch);
      return;
    }
    if ((vict = generic_find_char(ch, arg, FIND_CHAR_WORLD)) != NULL) {
      act(buf, FALSE, ch, 0, vict, TO_VICT);
      if (PRF_FLAGGED(ch, PRF_NOREPEAT))
	send_to_char(OK, ch);
      else
	act(buf, FALSE, ch, 0, vict, TO_CHAR);
    } else
      send_to_char("There is no such person in the game!\r\n", ch);
  }
}

void show_last_gossips(struct char_data *ch)
{
  int nCount = 0;
  sprintf(buf2, "&BThe last &M%d&B gossips were:\r\n&n", 
	  LAST_GOSSIPS_TO_SAVE);
  send_to_char(buf2, ch);
  for (int i = 0; i < LAST_GOSSIPS_TO_SAVE; i++)
  {
    last_gossips[i].getGossip(ch, buf2);
    if (strcmp(buf2, "") == 0)
      continue;
    send_to_char(buf2, ch);
    nCount++;
  }
  if (nCount == 0)
    send_to_char("   Nothing has been said.\r\n", ch);
}

void log_gossip(struct char_data *ch, char *gossip)
{
  // move the gossips up one
  for (int i = 1; i < LAST_GOSSIPS_TO_SAVE; i++)
    last_gossips[i - 1].copyGossip(last_gossips[i]);
  last_gossips[LAST_GOSSIPS_TO_SAVE - 1].setGossip(ch, gossip);
}

/**********************************************************************
 * generalized communication func, originally by Fred C. Merkel (Torg) *
  *********************************************************************/

ACMD(do_gen_comm)
{
  struct descriptor_data *i;
  struct char_data *realch;
  char color_on[24];
  char s[800];/* zap */       
  char *speech;
  unsigned int l,j,ignore; 

  /* Array of flags which must _not_ be set in order for comm to be heard */
  int channels[] = {
    0,
    PRF_DEAF,
    PRF_NOGOSS,
    PRF_NOAUCT,
    PRF_NOGRATZ,
    EXT_NONEWBIE
  };

  /*
   * com_msgs: [0] Message if you can't perform the action because of noshout
   *           [1] name of the action
   *           [2] message if you're not on the channel
   *           [3] a color string.
   */
  const char *com_msgs[][4] = {
    {"You cannot holler!!\r\n",
      "&yholler",
      "",
    KYEL},

    {"You cannot shout!!\r\n",
      "&yshout",
      "Turn off your noshout flag first!\r\n",
    KYEL},

    {"You cannot gossip!!\r\n",
      "&ygossip",
      "You aren't even on the channel!\r\n",
    KYEL},

    {"You cannot auction!!\r\n",
      "auction",
      "You aren't even on the channel!\r\n",
    KMAG},

    {"You cannot congratulate!\r\n",
      "&gcongrat",
      "You aren't even on the channel!\r\n",
    KGRN},

    {"You cannot use the newbie channel!\r\n",
      "&cnewbie",
      "You aren't even on the channel!\r\n",
    KCYN}//,
 
  };

  /* changed so mobs can shout and holler in spec procs - Vader */
  if (!ch->desc && subcmd != SCMD_SHOUT && subcmd != SCMD_HOLLER)
    return;  

/*  if (PLR_FLAGGED(ch, PLR_NOSHOUT)) {
    send_to_char(com_msgs[subcmd][0], ch);
    return;
  }
  -- Replaced with PUN_FLAGGED.... -- ARTUS
*/
 
  if (!IS_NPC(ch))
  {
    if (PUN_FLAGGED(ch, PUN_MUTE)) { /* ARTUS - Punishment Replace NOSHOUT */
      send_to_char(com_msgs[subcmd][0], ch);
      if (ch->player_specials->saved.phours[PUN_MUTE] < 0)
	sprintf(buf, "This must be removed by an immortal, you must have been bad.\r\n");
      else
	sprintf(buf, "This will be removed in %dhrs.\r\n", ch->player_specials->saved.phours[PUN_MUTE]);
      send_to_char(buf, ch);
      return;
    }

    if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF))
    {
      send_to_char("The walls seem to absorb your words.\r\n", ch);
      return;
    }
    /* level_can_shout defined in config.c */
    if ((subcmd != SCMD_NEWBIE) && LR_FAIL_MAX(ch, level_can_shout))
    {
      sprintf(buf1, "You must be at least level %d before you can %s.\r\n",
	      level_can_shout, com_msgs[subcmd][1]);
      send_to_char(buf1, ch);
      return;
    }
    /* make sure the char is on the channel */
    if (PRF_FLAGGED(ch, channels[subcmd]) && subcmd <= SCMD_GRATZ)
    {
      send_to_char(com_msgs[subcmd][2], ch);
      return;
    }
  }
  /* skip leading spaces */
  skip_spaces(&argument);

  /* make sure that there is something there to say! */
  if (!*argument)
  {
    sprintf(buf1, "Yes, %s, fine, %s we must, but WHAT???\r\n",
	    com_msgs[subcmd][1], com_msgs[subcmd][1]);
    send_to_char(buf1, ch);
    return;
  }

  // log newbie channel
  // if (subcmd == SCMD_NEWBIE)
  //   do_gen_write(ch,argument,0,SCMD_NEWBIE); 

  if ((subcmd == SCMD_HOLLER) && !IS_NPC(ch))
  {
    if (GET_MOVE(ch) < holler_move_cost)
    {
      send_to_char("You're too exhausted to holler.\r\n", ch);
      return;
    } else
      GET_MOVE(ch) -= holler_move_cost;
  }

  if (scan_buffer_for_xword(argument))
  {
    sprintf(s,"WATCHLOG SWEAR: %s %ss, '%s'", ch->player.name,com_msgs[subcmd][1], argument);
    mudlog(s,NRM,LVL_IMPL,TRUE);
    send_to_char("Please dont swear on the open channels.&n\r\n",ch);
    return ;
  }

  speech = str_dup(argument);
 
  if(strcmp(speech, "last") == 0 && subcmd == SCMD_GOSSIP)
  {
    show_last_gossips(ch);
    return;
  }

/* this loop goes thru and randomly drops letters from what was said
 * depanding on how drunk the person is.. 24 is max drunk.. when someone
 * is 24 drunk they pretty much cant be understood.. - Vader
 */
  for(l = 0,j = 0; l < strlen(speech); l++)
    if(number(1,PISS_FACTOR) > DRUNKNESS)
    {
      speech[j] = speech[l];
      j++;
    }

  /* set up the color on code */
  strcpy(color_on, com_msgs[subcmd][3]);

  /* first, set up strings to be given to the communicator */
  if (!IS_NPC(ch) &&PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
  else {
    // was C_CMP - DM
    if (COLOR_LEV(ch) >= C_NRM)
     sprintf(buf1, "%sYou %s, '%s&n%s'&n", color_on, com_msgs[subcmd][1],
              speech, color_on);
    else
      sprintf(buf1, "You %s, '%s&n'", com_msgs[subcmd][1], speech);
    act(buf1, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP);
  }

  if (subcmd == SCMD_GOSSIP)
    log_gossip(ch, speech);

  // The actual gos..
  sprintf(buf, "$n %ss, '%s'", com_msgs[subcmd][1], argument);


  /* now send all the strings out */
  for (i = descriptor_list; i; i = i->next) {
    realch = (i->original) ? i->original : i->character;
    // ARTUS - Bug fixed (gen_comms not being sent to chars..
    //     if (STATE(i) == CON_PLAYING && realch && i != realch->desc && 
    if (STATE(i) == CON_PLAYING && realch && i != ch->desc &&
       ((!PRF_FLAGGED(realch, channels[subcmd]) && subcmd <= SCMD_GRATZ )||
       (!EXT_FLAGGED(realch, channels[subcmd]) && subcmd >= SCMD_NEWBIE ))&&
        !PLR_FLAGGED(realch, PLR_WRITING) &&
        !ROOM_FLAGGED(i->character->in_room, ROOM_SOUNDPROOF)) {

      // Ignore all communication
      ignore = FALSE;
      if (!IS_NPC(ch))
        for (j=0; j < MAX_IGNORE; j++)
	{
          if (GET_IGNORE(i->character,j) == GET_IDNUM(ch) && GET_IGNORE_ALL(i->character,j))
            ignore = TRUE;
        }

      if (ignore)
        continue;

      if (subcmd == SCMD_SHOUT &&
	  ((world[ch->in_room].zone != world[i->character->in_room].zone) ||
	   !AWAKE(i->character)))
	continue;


      if (COLOR_LEV(i->character) >= C_NRM)
        sprintf(buf, "%s$n %ss, '%s&n%s'&n", color_on, com_msgs[subcmd][1], speech, color_on);
      else
        sprintf(buf, "$n %ss, '%s'&n", com_msgs[subcmd][1], speech);

       act(buf, TRUE, ch, 0, i->character, TO_VICT | TO_SLEEP);

//      if (COLOR_LEV(i->character) >= C_NRM)
//	send_to_char(color_on, i->character);
//     if (COLOR_LEV(i->character) >= C_NRM)
//	send_to_char(KNRM, i->character);
    }
  }
}

/* Artus> It would be nice to use this shit again at some point. */
int scan_buffer_for_xword(char* buf)
{
  char tmpword[MAX_INPUT_LENGTH+65];
  unsigned int i;
  int count = -1;
  for (i=0;i<=strlen(buf);i++)
  {
    count++;
    tmpword[count]=buf[i];
    if (tmpword[count]==' ' || tmpword[i]=='\n' || i==strlen(buf))
    {
      tmpword[count]='\0';
      count = -1;
      if (!Valid_Name(tmpword, FALSE))
        return 1;
    }
  }
  return 0;
} 

/* =================== Auction Routines -- Artus =================== */

// Artus> Show help syntax.
void show_auction_help(struct char_data *ch, int subcmd)
{
  switch (subcmd)
  {
    case AUC_BID:
      send_to_char("Syntax: Auction Bid <item #> <amount>\r\n"
	           "  Bid <amount> on auctioned item <item #>\r\n", ch);
      break;
    case AUC_PURGE:
      send_to_char("Syntax: Auction Purge <item #>\r\n"
	           "  Removes <item #> from the auction list.\r\n", ch);
      break;
    case AUC_SELL:
      send_to_char("Syntax: Auction Sell <item> <starting bid>\r\n"
	           "  Sells <item> for a minimum total of <starting bid>\r\n", ch);
      break;
    case AUC_STAT:
      sprintf(buf, "Syntax: Auction Stat <item #>\r\n"
	           "  Displays some statistics of auction <item #>\r\n"
		   "  This service is charged at %d coins.\r\n", 
		   AUC_STAT_COST);
      send_to_char(buf, ch);
      break;
    case AUC_NONE:
    default:
      send_to_char("Auction bid <item #> <amount>\r\n"
		   "Auction cancel\r\n"
		   "Auction list\r\n"
		   "Auction sell <item> <starting bid>\r\n"
		   "Auction sold\r\n"
		   "Auction stat <item #>\r\n", ch);
      if (LR_FAIL(ch, LVL_GRGOD))
	break;
	send_to_char("Auction purge <item #>\r\n", ch);
  }
  return;
}

// Send an auction email to player.
void auction_mail_to(struct auc_data *lot, int target, int subcmd)
{
  char mailstr[MAX_STRING_LENGTH] = "";
  char *tmp_name = NULL;
  struct char_data *tch = NULL;

  // If they're online they'll see the message.
  if ((tch = get_player_by_id(target)) && 
      !ROOM_FLAGGED(IN_ROOM(tch), ROOM_SOUNDPROOF))
    return;

  switch (subcmd)
  {
    case AUC_SOLD:
      sprintf(mailstr, 
  "Congratuations, &7%s&n, you have won the auction of item #%d.\r\n\r\n"
  "  Item Name  : &5%s&n\r\n"
  "  Your Bid   : &Y%ld&n\r\n"
  "  Seller Name; &7%s&n\r\n\r\n"
  "This item has been automatically placed into your inventory, and the\r\n"
  "gold automatically deducted from your account.\r\n",
	lot->buyername, lot->idnum, lot->obj->short_description, lot->offer,
	lot->sellername);
      break;
    case AUC_BID:
      if (target == lot->buyerid)
      {
	tmp_name = get_name_by_id(target);
	if (!(tmp_name))
	  return;
	sprintf(mailstr,
  "Dear &7%s&n,\r\n\r\n"
  "While you were away, the auction you were bidding on received a\r\n"
  "bid higher than your previous bid. The details are as follows:\r\n\r\n"
  "  Item Number: &y%d&n\r\n"
  "  Item Name  : &5%s&n\r\n"
  "  New Bid    : &Y%ld&n\r\n"
  "  New Bidder : &7%s&n\r\n\r\n"
  "Good luck with your future bidding!\r\n",
          tmp_name, lot->idnum, lot->obj->short_description, lot->offer,
	  lot->buyername);
      } else {
        sprintf(mailstr,
  "Dear &7%s&n,\r\n\r\n"
  "While you were away, the auction you are hosting received a new bid.\r\n"
  "The details are as follows:\r\n\r\n"
  "  New Bid   : &Y%ld&n\r\n"
  "  New Bidder: &7%s&n\r\n\r\n"
  "Mmmmmmmmm... Coin.\r\n",
          lot->sellername, lot->offer, lot->buyername);
      }
      break;
    case AUC_CANCEL:
      sprintf(mailstr,
  "Dear &7%s&n,\r\n\r\n"
  "While you were away, the auction you were bidding on was cancelled by\r\n"
  "the seller. The details are as follows:\r\n\r\n"
  "  Seller Name: &7%s&n\r\n"
  "  Item Number: &y%d&n\r\n"
  "  Item Name  : &5%s&n\r\n\r\n"
  "Go kick their butt! :o)\r\n",
              lot->buyername, lot->sellername, lot->idnum, 
	      lot->obj->short_description);
      break;
    case AUC_PURGE:
      sprintf(mailstr,
  "Dear &y%s&n,\r\n\r\n"
  "While you were away, the auction you were %s was purged, probably\r\n"
  "%s idle, or the auction was deemed unfit for the system.\r\n"
  "The details are as follows:\r\n\r\n"
  "  Item Number: &y%d&n\r\n"
  "  Item Name  : &5%s&n\r\n"
  "  Seller Name: &7%s&n\r\n\r\n"
  "Better luck next time!\r\n", 
          (target == lot->buyerid) ? lot->buyername : lot->sellername,
	  (target == lot->buyerid) ? "bidding on" : "hosting",
	  (target == lot->buyerid) ? "the seller was" : "you were",
	  lot->idnum, lot->obj->short_description, lot->sellername);
      break;
    default:
      sprintf(buf, "SYSERR: Unknown subcommand passed to auction_mail_to: %d.",
	      subcmd);
      mudlog(buf, NRM, LVL_IMPL, TRUE);
  }
  store_mail(target, MAIL_FROM_AUCTION, mailstr);
}

// Find an auction based on the auction number.
struct auc_data *find_auction_by_id(int target)
{
  struct auc_data *lot;
  for (lot = auc_list; lot; lot = lot->next)
    if (lot->idnum == target)
      return lot;
  return NULL;
}

// Find an auction based on the seller idnum.
struct auc_data *find_auction_by_seller(int target)
{
  struct auc_data *lot;
  for (lot = auc_list; lot; lot = lot->next)
    if (lot->sellerid == target)
      return lot;
  return NULL;
}

// Give the offered amount to the target.
void auction_offer_to(struct auc_data *lot, int target)
{
  struct char_file_u tmp_store;
  struct char_data *ch;
  extern FILE *player_fl;
  int player_i = 0;

  if (target < 1)
    return;
  ch = get_player_by_id(target);
  if (ch)
  {
    GET_BANK_GOLD(ch) += lot->offer;
    return;
  }
  player_i = load_char(get_name_by_id(target), &tmp_store);
  if (player_i < 0)
  {
    sprintf(buf, "SYSERR: load_char failed in auction_offer_to. [%s/%d/%d]", 
	    get_name_by_id(target), target, player_i);
    mudlog(buf, NRM, LVL_IMPL, TRUE);
    return;
  }
  // They logged off.. Load them from file.
  CREATE(ch, struct char_data, 1);
  clear_char(ch);
  store_to_char(&tmp_store, ch);
  char_to_room(ch, 0);
  GET_BANK_GOLD(ch) += lot->offer;
  char_to_store(ch, &tmp_store);
  fseek(player_fl, (player_i) *sizeof(struct char_file_u), SEEK_SET);
  fwrite(&tmp_store, sizeof(struct char_file_u), 1, player_fl);
  fflush(player_fl);
  free(ch);
}

// Give the item to the target.
void auction_item_to(struct auc_data *lot, int target)
{
  struct char_file_u tmp_store;
  struct char_data *ch;
  char filename[50];
  FILE *fd;
  struct rent_info rent;
  struct tmp_elem {
    struct obj_file_elem obj;
    struct tmp_elem *next;
  };
  struct tmp_elem *ele_index=NULL, *prev=NULL, *ele=NULL;
  void Obj_to_file_elem(struct obj_data *obj, struct obj_file_elem *target,
                        int location);
  
  if (target < 1)
    return;
  if ((ch = get_player_by_id(target)))
  {
    obj_from_room(lot->obj);
    obj_to_char(lot->obj, ch, __FILE__, __LINE__);
    return;
  }
  if (load_char(get_name_by_id(target), &tmp_store) < 0)
  {
    obj_from_room(lot->obj);
    extract_obj(lot->obj);
    return;       
  }
  // They logged off.. Load them from file.
  CREATE(ch, struct char_data, 1);
  clear_char(ch);
  store_to_char(&tmp_store, ch);
  obj_from_room(lot->obj);
  char_to_room(ch, 0);
  // Don't worry about it if they're deleted.
  if (!PLR_FLAGGED(ch, PLR_DELETED) &&
      get_filename(GET_NAME(ch), filename, CRASH_FILE) &&
      (fd = fopen(filename, "rb")))
  {
    fread(&rent, sizeof(struct rent_info), 1, fd);
    while (!feof(fd))
    {
      CREATE(ele, struct tmp_elem, 1);
      fread(&ele->obj, sizeof(struct obj_file_elem), 1, fd);
      if (ferror(fd))
	break;
      ele->next = NULL;
      if (feof(fd))
	break;
      if (prev)
	prev->next = ele;
      else
	ele_index = ele;
      prev = ele;
    }
    Obj_to_file_elem(lot->obj, &ele->obj, 0);
    if (prev)
      prev->next = ele;
    else
      ele_index = ele;
    fclose(fd);
    fd = fopen(filename, "wb");
    fwrite(&rent, sizeof(struct rent_info), 1, fd);
    ele = ele_index;
    while (ele)
    {
      struct tmp_elem *next_ele;
      next_ele = ele->next;
      fwrite(&ele->obj, sizeof(struct obj_file_elem), 1, fd);
      free(ele);
      ele = next_ele;
    }
    fclose(fd);
  }
  extract_obj(lot->obj);
  extract_char(ch);
}

// Delete an auction.
void auction_delete(struct auc_data *lot, int subcmd)
{
  struct auc_data *temp; // Needed for REMOVE_FROM_LIST

  switch (subcmd)
  {
    case AUC_CANCEL:
    case AUC_PURGE:
      auction_offer_to(lot, lot->buyerid);
      auction_item_to(lot, lot->sellerid);
      break;
    case AUC_SOLD:
      auction_offer_to(lot, lot->sellerid);
      auction_item_to(lot, lot->buyerid);
      break;
    default:
      sprintf(buf, "SYSERR: Unknown subcommand [%d] passed to auction_delete().", subcmd);
      mudlog(buf, NRM, LVL_IMPL, TRUE);
  }
  REMOVE_FROM_LIST(lot, auc_list, next);
  lot->obj = NULL;
  free(lot);
  write_auction_file();
}

// Send a message to all on the mud.
void auction_spam(struct auc_data *lot, struct char_data *ch, int subcmd)
{
  switch (subcmd)
  {
    case AUC_BID:
      sprintf(buf1, "&m[Auction]: $n has bid &Y%ld&m on Item #&y%d&m!&n",
	      lot->offer, lot->idnum);
      break;
    case AUC_SELL:
      sprintf(buf1, "&m[Auction]: $n is selling $p for %ld (Item #%d.)&n", lot->offer, lot->idnum);
      break;
    case AUC_CANCEL:
      strcpy(buf1, "&m[Auction]: $n has cancelled the sale of $p.&n");
      break;
    case AUC_PURGE:
      sprintf(buf1, "&m[Auction]: Auction #&y%d&m has been purged.&n",lot->idnum);
      break;
    case AUC_SOLD:
      sprintf(buf1, "&m[Auction]: $n has sold $p to %s for %ld.&n", lot->buyername, lot->offer);
      break;
    default:
      sprintf(buf1, "SYSERR: Unknown subcmd [%d] in auction_spam().", subcmd);
      mudlog(buf1, NRM, LVL_IMPL, TRUE);
      return;
  }
  for (struct descriptor_data *d = descriptor_list; d; d = d->next)
  {
    if ((STATE(d) != CON_PLAYING) || !(d->character) || IS_NPC(d->character) || 
	(PRF_FLAGGED(d->character, PRF_NOAUCT)))
      continue;
    act(buf1, FALSE, ch, lot->obj, d->character, TO_VICT);
  }
}

// Bid on an auction.
void auction_bid(struct char_data *ch, char *argument)
{
  int amount, min_amt;
  unsigned int item, was_buying = 0;
  struct auc_data *lot;

  skip_spaces(&argument);
  if (!*argument)
  {
    show_auction_help(ch, AUC_BID);
    return;
  }
  argument = one_argument(argument, arg);
  skip_spaces(&argument);

  if ((!*arg) || !is_number(arg) || !is_number(argument))
  {
    show_auction_help(ch, AUC_BID);
    return;
  }
  amount = atoi(argument);
  if (amount < 1) 
  {
    send_to_char("You can't have it for free!\r\n", ch);
    return;
  }
  item = atoi(arg);
  if (!(lot = find_auction_by_id(item)))
  {
    send_to_char("That auction is a figment of your imagination.\r\n", ch);
    return;
  }
  if (lot->sellerid == GET_IDNUM(ch))
  {
    send_to_char("You can't bid on your own auction!\r\n", ch);
    return;
  }
  if (lot->buyerid == GET_IDNUM(ch))
  {
    send_to_char("But you're already the high bidder!\r\n", ch);
    return;
  }
  if (lot->buyerid == 0) 
    min_amt = lot->offer;
  else
    min_amt = MAX(10, lot->offer + (int)(lot->offer/100));
  if (amount < min_amt)
  {
    sprintf(buf, "The minimum amount you can offer is %d.\r\n", min_amt);
    send_to_char(buf, ch);
    return;
  }
  if (GET_BANK_GOLD(ch) < amount)
  {
    send_to_char("You don't have that much gold in the bank!\r\n", ch);
    return;
  }
  auction_offer_to(lot, lot->buyerid);
  was_buying = lot->buyerid;
  lot->buyerid = GET_IDNUM(ch);
  GET_BANK_GOLD(ch) -= amount;
  lot->offer = amount;
  memset(lot->buyername, '\0', MAX_NAME_LENGTH+1);
  strncpy(lot->buyername, GET_NAME(ch), MAX_NAME_LENGTH);
  auction_mail_to(lot, was_buying, AUC_BID);
  auction_mail_to(lot, lot->sellerid, AUC_BID);
  write_auction_file();
  auction_spam(lot, ch, AUC_BID);
}

// Cancel an auction.
void auction_cancel(struct char_data *ch)
{
  struct auc_data *lot;
  if (!(lot = find_auction_by_seller(GET_IDNUM(ch))))
  {
    send_to_char("But you aren't auctioning anything!\r\n", ch);
    return;
  }
  auction_spam(lot, ch, AUC_CANCEL);
  auction_mail_to(lot, lot->buyerid, AUC_CANCEL);
  auction_delete(lot, AUC_CANCEL);
}

// Create an auction record.
void auction_create(struct char_data *ch, struct obj_data *obj, int amount)
{
  struct auc_data *lot, *last=NULL, *next=NULL;
  int idnum = 1;
  
  if ((!ch) || (!obj) || (amount < 1))
    return;

  // Deterimne the auction's idnum.
  for (struct auc_data *k = auc_list; k; k = k->next)
  {
    if (idnum == k->idnum)
    {
      next = k->next;
      idnum++;
    } else {
      next = k;
      break;
    }
    last = k;
  }
  CREATE(lot, struct auc_data, 1);
  lot->idnum = idnum;
  memset(lot->sellername, '\0', MAX_NAME_LENGTH+1);
  memset(lot->buyername, '\0', MAX_NAME_LENGTH+1);
  strncpy(lot->sellername, GET_NAME(ch), MAX_NAME_LENGTH+1);
  strncpy(lot->buyername, "noone", MAX_NAME_LENGTH+1);
  lot->sellerid = GET_IDNUM(ch);
  lot->buyerid = 0;
  lot->obj = obj;
  if (next)
    lot->next = next;
  else 
    lot->next = NULL;
  lot->offer = amount;
  if (!(last))
    auc_list = lot;
  else
    last->next = lot;
  obj_from_char(obj);
  obj_to_room(obj, real_room(AUC_ROOM));
  auction_spam(lot, ch, AUC_SELL);
  write_auction_file();
}

// Sell an Item.
void auction_sell(struct char_data *ch, char *argument)
{
  int amount = 0, auc_count = 0;
  struct obj_data *obj = NULL;
  skip_spaces(&argument);
  if (!*argument)
  {
    show_auction_help(ch, AUC_SELL);
    return;
  }
  argument = one_argument(argument, arg);
  skip_spaces(&argument);
  if (!*argument || !*arg || !is_number(argument))
  {
    show_auction_help(ch, AUC_SELL);
    return;
  }
  if (find_auction_by_seller(GET_IDNUM(ch)))
  {
    send_to_char("You can only have one auction at a time!\r\n", ch);
    return;
  }
  amount = atoi(argument);
  if (!(obj = generic_find_obj(ch, arg, FIND_OBJ_INV)))
  {
    sprintf(buf, "You don't have a %s.\r\n", arg);
    send_to_char(buf, ch);
    return;
  }
  if (OBJ_FLAGGED(obj, ITEM_QEQ))
  {
    send_to_char("You can't auction quest items!\r\n", ch);
    return;
  }
  if (obj->item_number == NOTHING) // Artus> Corpses, Mail, etc..
  {
    send_to_char("You can't auction that!\r\n", ch);
    return;
  }
  if (GET_OBJ_TYPE(obj) == ITEM_REWARD)
  {
    send_to_char("You can't auction rewards!\r\n", ch);
    return;
  }
  if (OBJ_FLAGGED(obj, ITEM_NODROP))
  {
    send_to_char("You can't auction something that is cursed!\r\n", ch);
    return;
  }
  if ((GET_OBJ_TYPE(obj) == ITEM_CONTAINER) && (obj->contains != NULL))
  {
    send_to_char("Empty it first!\r\n", ch);
    return;
  }
  if (OBJ_RIDDEN(obj))
  {
    send_to_char("Get off it first!\r\n", ch);
    return;
  }
  if (amount < (int)(GET_OBJ_COST(obj) / 2))
  {
    send_to_char("You can't just give it away!\r\n", ch);
    return;
  }
  for (struct auc_data *k = auc_list; k; k = k->next)
    auc_count++;
  if (auc_count >= AUC_LIMIT)
  {
    send_to_char("There are already too many auctions running, please ask someone to cancel one.\r\n", ch);
    return;
  }
  auction_create(ch, obj, amount);
}

// List auctions.
void auction_list(struct char_data *ch)
{
  struct char_data *seller;
  if (!(auc_list))
  {
    send_to_char("There is currently nothing up for auction.\r\n", ch);
    return;
  }
  send_to_char("&MCurrent Auctions:&n\r\n\r\n", ch);
  for (struct auc_data *lot = auc_list; lot; lot = lot->next)
  {
    sprintf(buf, "&mItem #&y%d&m: &5%s&m currently selling for &Y%ld\r\n"
	         "&m  Auctioned by &7%s&m; Current Bidder: &7%s&n\r\n",
	    lot->idnum, lot->obj->short_description, lot->offer,
	    ((seller = get_player_by_id(lot->sellerid)) ? (CAN_SEE(ch, seller) ? GET_NAME(seller) : "&rsomeone") : lot->sellername), lot->buyername);
    send_to_char(buf, ch);
  }
}

// Purge an auction.
void auction_purge(struct char_data *ch, char *argument)
{
  struct auc_data *lot;
  int idnum;

  if (LR_FAIL(ch, LVL_GRGOD))
  {
    show_auction_help(ch, AUC_NONE);
    return;
  }
  skip_spaces(&argument);
  if ((!*argument) || !is_number(argument))
  {
    show_auction_help(ch, AUC_PURGE);
    return;
  }
  idnum = atoi(argument);
  if (!(lot = find_auction_by_id(idnum)))
  {
    send_to_char("That auction does not exist.\r\n", ch);
    return;
  }
  auction_spam(lot, ch, AUC_PURGE);
  auction_mail_to(lot, lot->sellerid, AUC_PURGE);
  auction_mail_to(lot, lot->buyerid, AUC_PURGE);
  auction_delete(lot, AUC_PURGE);
}

// Sold the auctioned item.
void auction_sold(struct char_data *ch)
{
  struct auc_data *lot;

  if (!(lot = find_auction_by_seller(GET_IDNUM(ch))))
  {
    send_to_char("But you're not auctioning anything!\r\n", ch);
    return;
  }
  if (lot->buyerid < 1)
  {
    send_to_char("But noone has bid on it. You should use Auction Cancel.\r\n", ch);
    return;
  }
  auction_spam(lot, ch, AUC_SOLD);
  auction_mail_to(lot, lot->buyerid, AUC_SOLD);
  auction_delete(lot, AUC_SOLD);
}

// Stat an auction.
void auction_stat(struct char_data *ch, char *argument)
{
  void identify_obj_to_char(struct char_data *ch, struct obj_data *obj);
  struct auc_data *lot;
  int item;

  skip_spaces(&argument);
  if ((!*argument) || !is_number(argument))
  {
    show_auction_help(ch, AUC_STAT);
    return;
  }
  if (GET_GOLD(ch) < AUC_STAT_COST)
  {
    sprintf(buf, "Statting an auction costs &Y%d&n coins, which you do not have!&\r\n", AUC_STAT_COST);
    send_to_char(buf, ch);
    return;
  }
  item = atoi(argument);
  if (item < 1) 
  {
    show_auction_help(ch, AUC_STAT);
    return;
  }
  if (!(lot = find_auction_by_id(item)))
  {
    send_to_char("That auction is a figment of your imagination.\r\n", ch);
    return;
  }
  if (lot->sellerid == GET_IDNUM(ch))
  {
    send_to_char("Perhaps you should buy a scroll of identify :o)\r\n", ch);
    return;
  }
  if (!(lot->obj))
  {
    send_to_char("This auction is screwed up.. Perhaps you should ask an imm to purge it.\r\n", ch);
    sprintf(buf, "SYSERR: Auction item seems to have disappeared! (Item %d)",
	    lot->idnum);
    mudlog(buf, NRM, LVL_IMPL, TRUE);
    return;
  }
  if (!MORT_CAN_SEE_OBJ(ch, lot->obj))
  {
    send_to_char("You can't see it!\r\n", ch);
    return;
  }
  GET_GOLD(ch) -= AUC_STAT_COST;
  identify_obj_to_char(ch, lot->obj);
}

// Artus> This had to be rewritten.
ACMD(do_auction)
{
  subcmd = AUC_NONE;
  argument = one_argument(argument, arg);
  if (IS_NPC(ch))
  {
    send_to_char("Not in this lifetime!\r\n", ch);
    return;
  }
  if (PRF_FLAGGED(ch, PRF_NOAUCT))
  {
    send_to_char("You aren't even on that channel!\r\n", ch);
    return;
  }
  if (!*arg)
  {
    show_auction_help(ch, AUC_NONE);
    return;
  }
  if (is_abbrev(arg, "sell"))
    auction_sell(ch, argument);
  else if (is_abbrev(arg, "bid"))
    auction_bid(ch, argument);
  else if (is_abbrev(arg, "cancel"))
    auction_cancel(ch);
  else if (is_abbrev(arg, "list"))
    auction_list(ch);
  else if (is_abbrev(arg, "stat"))
    auction_stat(ch, argument);
  else if (is_abbrev(arg, "sold"))
    auction_sold(ch);
  else if (!LR_FAIL(ch, LVL_GRGOD) && is_abbrev(arg, "purge"))
    auction_purge(ch, argument);
  else 
    show_auction_help(ch, AUC_NONE);
  return;
}

//////////////////////////////////////
// Class definition for GossipItem
void GossipItem::getGossip(struct char_data *forChar, char *gossip)
{
   bool bSomeone = FALSE;

   if (nInvisSpecific != 0)	// gossiper was invis to id at time
   {
     if (GET_ID(forChar) == nInvisSpecific)
	bSomeone = TRUE;
   }
  
   if (nInvisLevel != 0)
   {
     if (GET_LEVEL(forChar) < nInvisLevel)
	bSomeone = TRUE;
   }

   if (nInvisSingle != 0)
   {
	if (GET_LEVEL(forChar) == nInvisSingle)
	   bSomeone = TRUE;
   }

   if (bStandardInvis == TRUE && !IS_AFFECTED(forChar, AFF_DETECT_INVIS))
	bSomeone = TRUE;

   // See if there's no gossip yet
   if (strcmp(cGossip, "") == 0 ||
       strcmp(cGossip, " ") == 0 ||
       strcmp(cGossip, "\0") == 0)
   {
        strcpy(gossip, "");
	return;
   }
   // Put together the gossip message
   if (bSomeone)
      strcpy(gossip, "Someone");
   else
      strcpy(gossip, cGossiper);

   strcat(gossip, " gossiped, '");
   strcat(gossip, cGossip);
   strcat(gossip, "'\r\n\0");

}

void GossipItem::setGossip(struct char_data *ch, char *gossip)
{
    // Reset the variables
    nInvisSingle = nInvisLevel = nInvisSpecific = 0;
    bStandardInvis = FALSE;

    if (GET_INVIS_TYPE(ch) == INVIS_SPECIFIC)
	nInvisSpecific = GET_INVIS_LEV(ch);
    if (GET_INVIS_TYPE(ch) == INVIS_SINGLE)
	nInvisSingle = GET_INVIS_LEV(ch);
    if (GET_INVIS_TYPE(ch) == INVIS_NORMAL)
	nInvisLevel = GET_INVIS_LEV(ch);

    if (IS_AFFECTED(ch, AFF_INVISIBLE))
	bStandardInvis = TRUE;

    strcpy(cGossip, gossip);
    strcpy(cGossiper, GET_NAME(ch));
}

void GossipItem::copyGossip(GossipItem target)
{
	nInvisSpecific = target.nInvisSpecific;
	nInvisSingle = target.nInvisSingle;
	nInvisLevel = target.nInvisLevel;
	bStandardInvis = target.bStandardInvis;

	strcpy(cGossip, target.cGossip);
	strcpy(cGossiper, target.cGossiper);
}

////////  end GossipItem ////////////
@


1.38
log
@Artus> Newbie command no longer calls do_gen_write().
@
text
@d482 14
a495 19
   int nCount = 0;

   sprintf(buf2, "&BThe last &M%d&B gossips were:\r\n&n", 
	LAST_GOSSIPS_TO_SAVE);
   send_to_char(buf2, ch);

   for (int i = 0; i < LAST_GOSSIPS_TO_SAVE; i++)
   {
   	last_gossips[i].getGossip(ch, buf2);
	if (strcmp(buf2, "") == 0)
		continue;

	send_to_char(buf2, ch);
	nCount++;
   }

   if (nCount == 0)
	send_to_char("   Nothing has been said.\r\n", ch);

d500 4
a503 7
   // move the gossips up one
   for (int i = 1; i < LAST_GOSSIPS_TO_SAVE; i++)
   {
	last_gossips[i - 1].copyGossip(last_gossips[i]);
   }

   last_gossips[LAST_GOSSIPS_TO_SAVE - 1].setGossip(ch, gossip);
d731 1
@


1.37
log
@Artus> Required changes for new find_xxx functions.
@
text
@d55 1
a55 1
ACMD(do_gen_write);
d599 2
a600 1
    if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF)) {
d632 2
a633 2
  if (subcmd == SCMD_NEWBIE)
    do_gen_write(ch,argument,0,SCMD_NEWBIE); 
@


1.36
log
@Artus> Moved all the quest event stuff to quest.[ch].
       Added trivia quest type.
@
text
@d199 2
d206 1
a206 1
  else if (!(vict = get_char_vis(ch, buf, FIND_CHAR_WORLD)))
d311 1
a311 1
  } else if (!(vict = get_char_vis(ch, buf, FIND_CHAR_ROOM)))
d358 2
a359 1
    if (!(paper = get_obj_in_list_vis(ch, papername, ch->carrying))) {
d364 2
a365 1
    if (!(pen = get_obj_in_list_vis(ch, penname, ch->carrying))) {
d371 2
a372 1
    if (!(paper = get_obj_in_list_vis(ch, papername, ch->carrying))) {
d377 2
a378 1
    if (GET_OBJ_TYPE(paper) == ITEM_PEN) {	/* oops, a pen.. */
d469 1
a469 1
    if ((vict = get_char_vis(ch, arg, FIND_CHAR_WORLD)) != NULL) {
d1240 1
a1240 1
  if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying)))
@


1.35
log
@Artus> Cleanup.
@
text
@a731 40

ACMD(do_qcomm)
{
  struct descriptor_data *i;

  if (!PRF_FLAGGED(ch, PRF_QUEST))
  {
    send_to_char("You aren't even part of the quest!\r\n", ch);
    return;
  }
  skip_spaces(&argument);

  if (!*argument) {
    sprintf(buf, "%s?  Yes, fine, %s we must, but WHAT??\r\n", CMD_NAME,
	    CMD_NAME);
    CAP(buf);
    send_to_char(buf, ch);
  } else {
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else {
      if (subcmd == SCMD_QSAY)
        sprintf(buf, "You quest-say, '%s&n'", argument); 
      else
	strcpy(buf, argument);
      act(buf, FALSE, ch, 0, argument, TO_CHAR);
    }

    if (subcmd == SCMD_QSAY)
      sprintf(buf, "&C$n&n quest-says, '%s&n'", argument); 
    else
      strcpy(buf, argument);

    for (i = descriptor_list; i; i = i->next)
      if (STATE(i) == CON_PLAYING && i != ch->desc &&
	  PRF_FLAGGED(i->character, PRF_QUEST))
	act(buf, 0, ch, 0, i->character, TO_VICT | TO_SLEEP);
  }
}

@


1.34
log
@Artus> count=-1 -> count = -1
@
text
@d737 2
a738 1
  if (!PRF_FLAGGED(ch, PRF_QUEST)) {
@


1.33
log
@Artus> Now including auction # in sell message.
@
text
@d775 1
a775 1
  int count=-1;
d783 1
a783 1
      count=-1;
@


1.32
log
@Artus> Now warning free :o)
@
text
@d1093 1
a1093 1
      sprintf(buf1, "&m[Auction]: $n is selling $p for %ld.&n", lot->offer);
@


1.31
log
@Artus> Can no longer auction corpses, mail, etc.
@
text
@d65 1
a65 1
  int i,j;
d519 1
a519 1
  int l,j,ignore; 
d774 2
a775 1
  int i,count=-1;
d850 1
a850 1
  "  Your Bid   : &Y%d&n\r\n"
d869 1
a869 1
  "  New Bid    : &Y%d&n\r\n"
d879 1
a879 1
  "  New Bid   : &Y%d&n\r\n"
d950 2
a951 1
  if ((ch = get_player_by_id(target)))
d956 2
a957 1
  if (player_i = load_char(get_name_by_id(target), &tmp_store) < 0)
a982 1
  int dummy=0;
a1060 3
  struct char_file_u tmp_store;
  struct char_data *buyer;
  struct char_data *seller;
d1089 1
a1089 1
      sprintf(buf1, "&m[Auction]: $n has bid &Y%d&m on Item #&y%d&m!&n",
d1093 1
a1093 1
      sprintf(buf1, "&m[Auction]: $n is selling $p for %d.&n", lot->offer);
d1102 1
a1102 1
      sprintf(buf1, "&m[Auction]: $n has sold $p to %s for %d.&n", lot->buyername, lot->offer);
d1121 2
a1122 4
  unsigned int item; 
  unsigned int amount;
  unsigned int min_amt;
  unsigned int was_buying = 0;
a1192 1
  struct char_data *buyer;
d1336 1
a1336 1
    sprintf(buf, "&mItem #&y%d&m: &5%s&m currently selling for &Y%d\r\n"
a1347 1
  struct char_data *seller;
@


1.30
log
@Artus> Added syslog message on load char fail.
@
text
@d1223 1
a1223 3
    }
    else
    {
d1288 5
@


1.29
log
@Artus> Putting buyername in where selling name to the buyer, instead of
       sellername.. Doh!

       Should now write returned gold to file properly when cancelling/purging
       an auction bid on by offline players, or the player is outbid while
       offline.
@
text
@d955 6
a960 1
    return;       
@


1.28
log
@Artus> Fixed a couple of errors in auction amounts.
@
text
@d889 1
d893 2
a894 1
          lot->sellername, lot->idnum, lot->obj->short_description);
d944 3
d954 1
a954 1
  if (load_char(get_name_by_id(target), &tmp_store) < 0)
d962 5
a966 1
  extract_char(ch);
@


1.27
log
@Artus> Cleaned up.
@
text
@d1153 1
a1153 1
    min_amt = MAX(10, lot->offer + (int)(lot->offer*1.05));
d1156 1
a1156 1
    sprintf(buf, "The minimum amount you can offer is %d.\r\n", ch);
@


1.26
log
@Artus> Added some !IS_NPC() checking.
@
text
@d883 1
d893 1
@


1.25
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d581 11
a591 9
  if (PUN_FLAGGED(ch, PUN_MUTE)) { /* ARTUS - Punishment Replace NOSHOUT */
    send_to_char(com_msgs[subcmd][0], ch);
    if (ch->player_specials->saved.phours[PUN_MUTE] < 0)
      sprintf(buf, "This must be removed by an immortal, you must have been bad.\r\n");
    else
      sprintf(buf, "This will be removed in %dhrs.\r\n", ch->player_specials->saved.phours[PUN_MUTE]);
    send_to_char(buf, ch);
    return;
  }
d593 18
a610 17
  if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF)) {
    send_to_char("The walls seem to absorb your words.\r\n", ch);
    return;
  }
  /* level_can_shout defined in config.c */
  if ((subcmd != SCMD_NEWBIE) && LR_FAIL_MAX(ch, level_can_shout))
  {
    sprintf(buf1, "You must be at least level %d before you can %s.\r\n",
	    level_can_shout, com_msgs[subcmd][1]);
    send_to_char(buf1, ch);
    return;
  }
  /* make sure the char is on the channel */
  if (!IS_NPC(ch) && PRF_FLAGGED(ch, channels[subcmd]) && subcmd <= SCMD_GRATZ)
  {
    send_to_char(com_msgs[subcmd][2], ch);
    return;
d616 2
a617 1
  if (!*argument) {
d625 1
a625 1
  if (subcmd == SCMD_NEWBIE) {
a626 1
  }
d628 4
a631 2
  if (subcmd == SCMD_HOLLER) {
    if (GET_MOVE(ch) < holler_move_cost) {
d646 1
a646 1
    speech = str_dup(argument);
d648 5
a652 5
    if(strcmp(speech, "last") == 0 && subcmd == SCMD_GOSSIP)
    {
	show_last_gossips(ch);
	return;
    }
d658 6
a663 6
    for(l = 0,j = 0; l < strlen(speech); l++) {
      if(number(1,PISS_FACTOR) > DRUNKNESS) {
        speech[j] = speech[l];
        j++;
        }
      }                
d682 1
a682 3
  {
     log_gossip(ch, speech);
  }
d702 2
a703 1
        for (j=0; j < MAX_IGNORE; j++) {
@


1.24
log
@Artus> Intermittent build. Fixing auctions.
@
text
@d26 1
d37 1
a37 1
extern struct auction_lot avail_lots[MAX_LOTS];
d41 1
d230 1
a230 1
    if (!IS_NPC(ch))
d455 1
a455 1
      if (GET_LEVEL(ch) > LVL_GOD) {
d596 2
a597 1
  if ((subcmd != SCMD_NEWBIE) && GET_LEVEL(ch) < level_can_shout) {
d604 2
a605 1
  if (!IS_NPC(ch) && PRF_FLAGGED(ch, channels[subcmd]) && subcmd <= SCMD_GRATZ ) {
d786 4
a789 1
void do_auc_stat(struct char_data *ch, int lot)
d791 9
a799 50
  struct obj_data *obj;
  long offer;
 
  extern char *spells[];
 
  offer = avail_lots[lot].offer;
  obj = avail_lots[lot].obj;
 
  if (COLOR_LEV(ch) >= C_NRM)
                        send_to_char(KMAG, ch);
 
  sprintf(buf, "\r\nItem %d\r\n", lot+1);
  sprintf(buf, "%sSeller: %s\tBuyer: %s\tPrice: %ld\r\n", buf,avail_lots[lot].sellername, 
	avail_lots[lot].buyername,offer);
  send_to_char ( buf,ch);
 
  sprintf(buf, "Object '%s', Item type: ", obj->short_description);
    sprinttype(GET_OBJ_TYPE(obj), item_types, buf2);
    strcat(buf, buf2);
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
 
    if (obj->obj_flags.bitvector) {
      send_to_char("Item will give you following abilities:  ", ch);
      sprintbit(obj->obj_flags.bitvector, affected_bits, buf);
      strcat(buf, "\r\n");  
     send_to_char(buf, ch);
    }
    send_to_char("Item is: ", ch);
    sprintbit(GET_OBJ_EXTRA(obj), extra_bits, buf);
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
 
    sprintf(buf, "Weight: %d, Value: %d, Rent: %d\r\n",
            GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj), GET_OBJ_RENT(obj));
    send_to_char(buf, ch);
 
    switch (GET_OBJ_TYPE(obj)) {
    case ITEM_SCROLL:
    case ITEM_POTION:
      sprintf(buf, "This %s casts: ", item_types[(int) GET_OBJ_TYPE(obj)]);
 
      if (GET_OBJ_VAL(obj, 1) >= 1) 
        sprintf(buf, "%s %s", buf, skill_name(GET_OBJ_VAL(obj, 1)));
      if (GET_OBJ_VAL(obj, 2) >= 1)
        sprintf(buf, "%s %s", buf, skill_name(GET_OBJ_VAL(obj, 2)));
      if (GET_OBJ_VAL(obj, 3) >= 1)
        sprintf(buf, "%s %s", buf, skill_name(GET_OBJ_VAL(obj, 3)));
      sprintf(buf, "%s\r\n", buf);
      send_to_char(buf, ch);
d801 3
a803 8
    case ITEM_WAND:
    case ITEM_STAFF:
      sprintf(buf, "This %s casts: ", item_types[(int) GET_OBJ_TYPE(obj)]);
      sprintf(buf, "%s %s\r\n", buf, skill_name(GET_OBJ_VAL(obj, 3)));
      sprintf(buf, "%sIt has %d maximum charge%s and %d remaining.\r\n", buf,
              GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 1) == 1 ? "" : "s",
              GET_OBJ_VAL(obj, 2));
      send_to_char(buf, ch);
d805 5
a809 9
    case ITEM_WEAPON:
      sprintf(buf, "Damage Dice is '%dD%d'", GET_OBJ_VAL(obj, 1),
              GET_OBJ_VAL(obj, 2));
      sprintf(buf, "%s for an average per-round damage of %.1f.\r\n", buf,
              (((GET_OBJ_VAL(obj, 2) + 1) / 2.0) * GET_OBJ_VAL(obj, 1)));
     send_to_char(buf, ch);  
     break;
    case ITEM_ARMOR:
      sprintf(buf, "AC-apply is %d\r\n", GET_OBJ_VAL(obj, 0));
d812 14
a825 6
    }
 
  if (COLOR_LEV(ch) >= C_NRM)
    send_to_char(KNRM, ch);
 
}     
d827 2
a828 1
void auction_refund(long refund, int id)
d830 8
a837 2
   struct char_data *buyer;
   struct char_file_u tmp_store;
d839 71
a909 7
   if ((buyer = get_player_by_id(id)) != NULL)
   {
	// They're online, just refund to bank
	GET_BANK_GOLD(buyer) += refund;
	send_to_char("You have been outbid, and your money refunded.\r\n", buyer);
	return;
   }
d911 9
a919 10
   // Load file, they've pissed off
   if (load_char(get_name_by_id(id), &tmp_store) < 0)
	return;       

   CREATE(buyer, struct char_data, 1);
   clear_char(buyer);
   store_to_char(&tmp_store, buyer);
   char_to_room(buyer, 0);
   GET_BANK_GOLD(buyer) += refund;
   extract_char(buyer);
d921 8
a928 1
   return;
d931 2
a932 3
/* TODO: Time limit the duration of lots up for sale, in case
         sellers quit the game. */
ACMD(do_auction)
d934 5
a938 10
  int lot;
  struct descriptor_data *i;
  long amount, offer;
  struct obj_data *obj;
  struct char_data *buyer;
 
  argument = one_argument(argument, arg);
 
  // Geez Hal, at least give us some help so we know how to USE your code! - Tal
  if (!*arg) 
d940 1
a940 6
    send_to_char("&m-Auction &M<item> <price>\r\n"
	         "&m-Auction &Mstat <item #>\r\n"
		 "&m-Auction <item #> <price>\r\n"
		 "&m-Auction &Mlist\r\n"
		 "-&mAuction &Mcancel\r\n"
		 "&m-Auction &Msold&n\r\n", ch);
d943 10
d954 20
a973 1
  if (strcmp(arg, "list") == 0)
d975 2
a976 1
    show_lots(ch);
d979 16
a994 3

// auction <item number> <bid amount> 
  if (is_number(arg)) 
d996 2
a997 3
    lot = atoi(arg);
 
    if (lot > MAX_LOTS) 
d999 23
a1021 5
      send_to_char("That is an invalid item.\r\n",ch);
      return;
    } 
 
    if (lot > lot_tot || lot > MAX_LOTS || lot < 0) 
d1023 5
a1027 2
      send_to_char("That is an invalid item.\r\n",ch);
      return;
d1029 13
d1043 20
a1062 1
    lot--;
d1064 24
a1087 12
    if (avail_lots[lot].sellerid == GET_IDNUM(ch)) 
    {
      send_to_char("You can't bid on your own item.\r\n",ch);
      return; 
    }
 
    argument = one_argument(argument, arg);
 
    if (is_number(arg))
      offer = atoi(arg);
    else {
      send_to_char("You need to make an offer.\r\n",ch);
d1089 9
a1097 18
    }
 
    if (offer <= avail_lots[lot].offer) 
    {
      sprintf(buf, "Your bid needs to be higher then the current bid of %ld.\r\n", avail_lots[lot].offer);
      send_to_char(buf,ch);
      return;
    }
 
    if (offer > GET_BANK_GOLD(ch)) 
    {
      sprintf(buf,"You need more gold!\r\n");
      send_to_char(buf,ch);
      return;
    }
 
    // Take their gold, we'll give it back if they get outbid - Tal
    GET_BANK_GOLD(ch) -= offer;
d1099 8
a1106 1
    auction_refund(avail_lots[lot].offer, avail_lots[lot].buyerid);
d1108 8
a1115 3
    avail_lots[lot].offer = offer;
    avail_lots[lot].buyerid = GET_IDNUM(ch);
    strcpy(avail_lots[lot].buyername, GET_NAME(ch));
d1117 32
a1148 4
    subcmd = SCMD_BID;

// auction STAT <item number>
  } else if (!strcmp("stat", arg)) 
d1150 2
a1151 22
    argument = one_argument(argument, arg);
 
    if (is_number(arg))
      lot = atoi(arg);
    else {
      send_to_char("Need a item number.\r\n",ch);
      return;
    }
 
    if (lot > MAX_LOTS || lot > lot_tot || lot < 1) 
    {
      send_to_char("That is an invalid item number.\r\n",ch);
      return;
    }
 
    if (GET_IDNUM(ch) == avail_lots[lot-1].sellerid) 
    {
      send_to_char("You cant see the stats on your own item. Go buy a an identify scroll!\r\n", ch );
      return;
    }
 
    do_auc_stat(ch, lot-1);
d1153 2
a1154 3
// auction CANCEL
  } 
  if (!strcmp("cancel", arg)) 
d1156 15
a1170 41
    lot = check_seller(ch);
    if (lot > -1) 
    {
      remove_lot(lot);
      obj_to_char(avail_lots[lot].obj, ch, __FILE__, __LINE__);
      auction_refund(avail_lots[lot].offer, avail_lots[lot].buyerid);
      subcmd = SCMD_CANCEL;
    } else {
      send_to_char("You're not selling anything!\r\n", ch);
      return;
    }
// auction SOLD
  } else if (!str_cmp("sold", arg)) {
    lot = check_seller(ch);  
 
    if (lot > -1)
    {
      if (avail_lots[lot].buyerid == 0)
      {
        send_to_char("No-one has offered you a price.\r\n",ch);
        return;
      }
      // Is the buyer still online?	
      if ((buyer = get_player_by_id(avail_lots[lot].buyerid)) == NULL)
      {
         //  Player has welched on the deal
         obj = avail_lots[lot].obj;
	 obj_to_char(obj, ch, __FILE__, __LINE__);	// Give back to owner
	 subcmd = SCMD_WELCH;
      } else { // Still online, deal normally
        offer = avail_lots[lot].offer;
        obj = avail_lots[lot].obj;
        obj_to_char(obj, buyer, __FILE__, __LINE__);
        GET_GOLD(ch) += offer;
        remove_lot(lot);
        subcmd = SCMD_SOLD;
      } 
    } else {
      send_to_char("Your not selling anything!\r\n", ch);
      return;
    }
d1172 14
a1185 12
// auction <item name> <item price>
  } else {
    if (check_seller(ch) != -1 && lot_tot != 0) {
      send_to_char("One item per person.\r\n",ch);
      return;
    } 
 
    if (lot_tot >= MAX_LOTS) {
      sprintf(buf, "Only %d lots at once.\r\n", MAX_LOTS);
      send_to_char ( buf,ch);
      return;
    }
d1187 8
a1194 23
    if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
      sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
      send_to_char(buf, ch);
      return;
    } else {
      argument = one_argument(argument, arg);
      if (is_number(arg))
        amount = atoi(arg);
      else {
        send_to_char("A starting price is needed.\r\n",ch);
        return;
      }
    }
 
    if (amount <= 0) {
      send_to_char ( "The price has to be positive.\r\n",ch);
      return;
    }
 
    if (amount > MAX_PRICE) {
      send_to_char("Be reasonable!\r\n",ch);
      return;
    }
d1196 4
a1199 1
    if (amount < (int)(GET_OBJ_COST(obj) / 2))
d1201 2
a1202 2
	send_to_char("You can't just GIVE it away!\r\n", ch);
	return;
d1204 1
a1204 3
 
    // Artus> Forbid Reward Auctioning. [Cheat Prevention]
    if (GET_OBJ_TYPE(obj) == ITEM_REWARD)
d1206 2
a1207 2
      send_to_char("You can't auction that!\r\n", ch);
      return;
d1209 25
d1235 69
a1303 6
    // Artus> Forbid QEQ Auctioning.
    if (OBJ_FLAGGED(obj, ITEM_QEQ))
    {
      send_to_char("You can't sell quest equipment!\r\n", ch);
      return;
    }
d1305 19
a1323 6
    // Artus> Forbid Cursed Item Auctioning. [Cheat Prevention]
    if (OBJ_FLAGGED(obj, ITEM_NODROP))
    {
      send_to_char("Yeech! It's cursed! You can't auction that!\r\n", ch);
      return;
    }
d1325 6
a1330 6
    // Artus> Containers Must be Empty! [Cheat Prevention]
    if ((GET_OBJ_TYPE(obj) == ITEM_CONTAINER) && (obj->contains))
    {
      send_to_char("You'll need to empty it, first.\r\n", ch);
      return;
    }
d1332 16
a1347 9
    if (OBJ_RIDDEN(obj))
    {
	send_to_char("You can't auction something you're riding!\r\n", ch);
	return;
    }

    obj_from_char(obj);
    lot_tot = add_lot(obj, ch, amount);
    subcmd = SCMD_NEW;
d1349 5
a1353 5
 
  switch(subcmd) {
    case SCMD_NEW:
      sprintf(buf, "[Auction] $n: %ld for %s.",  amount, obj->short_description );
      break;
d1355 4
a1358 3
    case SCMD_CANCEL:
      sprintf(buf, "[Auction] $n: The sale of %s has been canceled.",  avail_lots[lot].obj->short_description);
      break;
d1360 14
a1373 3
    case SCMD_BID:
      sprintf ( buf,"[Auction] $n: %ld for item %d: %s.", offer, lot+1, avail_lots[lot].obj->short_description);
      break;
d1375 6
a1380 4
    case SCMD_SOLD:
      sprintf ( buf,"[Auction] $n: Item %d: %s sold to %s for %ld.",  lot+1, obj->short_description, 
		avail_lots[lot].buyername, offer);
      break;
d1382 27
a1408 5
    case SCMD_WELCH:
      sprintf ( buf,"[Auction] $n: %s welched on %s, forfeiting their offer.", 
		avail_lots[lot].buyername, obj->short_description );
      remove_lot(lot);
      break;
d1410 7
a1416 11
 
  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
  else {
    if (COLOR_LEV(ch) >= C_NRM)
      send_to_char(KMAG, ch);
 
    act(buf, FALSE, ch, 0, ch, TO_VICT | TO_SLEEP);
 
    if (COLOR_LEV(ch) >= C_NRM)
      send_to_char(KNRM, ch);
d1418 1
a1418 2
 
  for (i = descriptor_list; i; i = i->next) 
d1420 6
a1425 7
    if (STATE(i) == CON_PLAYING && i != ch->desc && i->character &&
        !PRF_FLAGGED(i->character, PRF_NOAUCT) &&   
        !PLR_FLAGGED(i->character, PLR_WRITING) &&
        !ROOM_FLAGGED(i->character->in_room, ROOM_SOUNDPROOF))
    {
      if (COLOR_LEV(i->character) >= C_NRM)
        send_to_char(KMAG, i->character);
d1427 19
a1445 5
      act(buf, FALSE, ch, 0, i->character, TO_VICT | TO_SLEEP);

      if (COLOR_LEV(i->character) >= C_NRM)
        send_to_char(KNRM, i->character);
    }
d1447 18
a1464 1
}           
@


1.23
log
@Artus> Fixed: Crash in listen, Missing CRLF on gsay, Scan fail message.
@
text
@d902 8
a909 2
  if (!*arg) {
    send_to_char("&m-Auction &M<item> <price>\r\n&m-Auction &Mstat <item #>\r\n&m-Auction <item #> <price>\r\n&m-Auction &Mlist\r\n-&mAuction &Mcancel\r\n&m-Auction &Msold&n\r\n", ch);
d915 3
a917 3
	show_lots(ch);
	return;
   }
d920 2
a921 1
  if (is_number(arg)) {
d924 2
a925 1
    if (lot > MAX_LOTS) {
d930 2
a931 1
    if (lot > lot_tot || lot > MAX_LOTS || lot < 0) {
d938 2
a939 1
    if (avail_lots[lot].sellerid == GET_IDNUM(ch)) {
d953 2
a954 1
    if (offer <= avail_lots[lot].offer) {
d960 2
a961 1
    if (offer > GET_BANK_GOLD(ch)) {
d979 2
a980 1
  } else if (!strcmp("stat", arg)) {
d990 2
a991 1
    if (lot > MAX_LOTS || lot > lot_tot || lot < 1) {
d996 2
a997 1
    if (GET_IDNUM(ch) == avail_lots[lot-1].sellerid) {
a1003 1

d1005 3
a1007 1
  } else if (!strcmp("cancel", arg)) {
d1009 2
a1010 2
 
    if (lot > -1) {
a1018 1

d1023 4
a1026 2
    if (lot > -1) {
      if (avail_lots[lot].buyerid == 0) {
a1029 1

d1037 1
a1037 3
      }
      else  // Still online, deal normally
      { 
d1169 2
a1170 1
  for (i = descriptor_list; i; i = i->next) {
@


1.22
log
@Artus> No more auctioning cursed/quest/reward items. Containers must be empty.
@
text
@d137 1
a137 1
      sprintf(buf, "&rYou tell the group, '%s&r'&n", argument);   
@


1.21
log
@Artus> Mostly just cosmetic changes, mostly for underwater stuff..
       Added some more stuff to dg_scripts:

       %actor.affected(aff_bit)% - Is actor affected by whatever.
       %self.people(countpc)%    - (Rooms): Count players.
       %self.people(countnpc)%   - (Rooms): Count npcs.
       %self.people(countall)%   - (Rooms): Count chars.
       %firstchar.<room_vnum>%   - First character in room <vnum>

       Possibly a bugfix to one of the forest specials that was attacking you
       if you were affected by poison.
@
text
@d1079 30
a1108 2
   if (OBJ_RIDDEN(obj))
   {
d1111 1
a1111 1
   }
@


1.20
log
@Artus> Changed remort, in particular, list remort abilities to char.. Also,
       spellsword was incorrectly being listed as a possible path for a
       warrior.

       Replaced #ifdef USE_LOCALTIME with #ifndef NO_LOCALTIME..

       Added define NOTELL_SOUNDPROOF .. Define this to stop people telling
       to/from soundproof rooms.

       Removed extraneous level checking from do_wear.. This is handled
       better by perform_wear.
@
text
@d83 1
a83 1
     if(!IS_NPC(ch) && ((BASE_SECT(world[ch->in_room].sector_type) == SECT_UNDERWATER))){
@


1.19
log
@Artus>
Trap Obj is now VNUM 25599 aka TRAP_OBJ
Modified board code to handle clan boards.
Reduced number of clans to 8 (was 32).
Added a few new clan defines.. GET_CLAN_REL(us, them); CLAN_AT_PEACE(us, them),
  CLAN_AT_WAR(us, them); CLAN_ALLIED(us, them);...
Fixed up the clan destroy routine.
Set slowns to default on.
Remove loop for assigning clan mobs, replaced with sequential assigns.
@
text
@d169 1
d172 1
d177 5
a181 1
  else if ((!IS_NPC(vict) && PRF_FLAGGED(vict, PRF_NOTELL)) || ROOM_FLAGGED(vict->in_room, ROOM_SOUNDPROOF))
@


1.18
log
@
Modified: DM

Changed:
- Don't ask (large group checkin) - lots of bug fixes mainly.
- Use cvs diff if you really wanna see the changes.
@
text
@d327 2
a328 1
  if (IS_NPC(ch)) {
d341 2
a342 1
  if (!*papername) {		/* nothing was delivered */
d346 2
a347 1
  if (*penname) {		/* there were two arguments */
@


1.17
log
@
Modified: DM

Changed:
- fixed colours for channels
@
text
@d766 1
a766 1
      if (!Valid_Name(tmpword))
@


1.16
log
@
Modified: DM

Changed:
- coloured hard tells
@
text
@d528 1
a528 1
      "holler",
d533 1
a533 1
      "shout",
d538 1
a538 1
      "gossip",
d548 1
a548 1
      "congrat",
d553 1
a553 1
      "newbie",
@


1.15
log
@*** empty log message ***
@
text
@d146 1
a146 1
  sprintf(buf, "&R$n &rtells you, '%s&r'&n", arg);
d152 1
a152 1
    sprintf(buf, "&rYou tell &R$N&r, '%s&r'&n", arg);
@


1.14
log
@Artus - Changes to do_gen_comm, removed clan stuff and fixed a bug..
@
text
@d27 3
d463 33
d629 7
d663 6
a668 1
 // ???
d671 1
d699 1
d705 1
a705 1
      act(buf, TRUE, ch, 0, i->character, TO_VICT | TO_SLEEP);
d1134 80
@


1.13
log
@*** empty log message ***
@
text
@d481 1
a481 3
    EXT_NONEWBIE,
//    EXT_NOCTALK, 
    0
a520 5
/*    {"You cannot use clan talk!\r\n",
      "clan talk",
      "You aren't even on the channel!\r\n",
    KWHT}
    -- ARTUS: Old clan stuff.  */
a583 8
  /* check that there not in a clan if using clan talk 
  if ( subcmd == SCMD_CTALK && GET_CLAN_NUM(ch) == -1 )
  {
   send_to_char("Your not even in a clan.\n\r" , ch);
   return;
  } -- ARTUS: Old clan stuff.
  */

d626 6
a631 4
    if (STATE(i) == CON_PLAYING && i != realch->desc && /*i->character*/ realch &&
       ((!PRF_FLAGGED(/*i->character*/realch, channels[subcmd]) && subcmd <= SCMD_GRATZ )||
       (!EXT_FLAGGED(/*i->character*/realch, channels[subcmd]) && subcmd >= SCMD_NEWBIE ))&&
        !PLR_FLAGGED(/*i->character*/realch, PLR_WRITING) &&
a633 5
//	!PRF_FLAGGED(i->character, channels[subcmd]) &&
//	!PLR_FLAGGED(i->character, PLR_WRITING) &&
//	!ROOM_FLAGGED(i->character->in_room, ROOM_SOUNDPROOF)) {


d655 1
a655 1
      act(buf, FALSE, ch, 0, i->character, TO_VICT | TO_SLEEP);
@


1.12
log
@Modified: DM

Changed:
- help for auction (removed bid)
@
text
@d1038 6
@


1.11
log
@Modified: Artus - Clan/Punishment/PK
@
text
@d862 1
a862 1
    send_to_char("&m-Auction &M<item> <price>\r\n&m-Auction &Mstat <item #>\r\n&m-Auction &Mbid <item #> <price>\r\n&m-Auction &Mlist\r\n-&mAuction &Mcancel\r\n&m-Auction &Msold&n\r\n", ch);
@


1.10
log
@
Added:
- check so mobs cannot write.
@
text
@d482 1
a482 1
    EXT_NOCTALK, 
d521 1
a521 1
    KCYN},
d523 1
a523 1
    {"You cannot use clan talk!\r\n",
d527 1
d534 1
a534 1
  if (PLR_FLAGGED(ch, PLR_NOSHOUT)) {
d538 13
d591 1
a591 1
  /* check that there not in a clan if using clan talk */
d596 2
a597 1
  }
a667 4
      /* stops others from hearing the clan channels */
      if (subcmd == SCMD_CTALK && (GET_LEVEL(realch) < LVL_GOD) && (GET_CLAN_NUM(i->character) != GET_CLAN_NUM(ch)))
        continue;

d956 1
@


1.9
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d324 5
@


1.8
log
@
Added:
- switched mob checks, do_gen_comm checks on NPC's
@
text
@d25 1
d86 2
a87 1
    act(buf, FALSE, ch, 0, 0, TO_ROOM);
d97 4
d384 1
a384 1
    char *backstr = NULL;
d388 1
a388 1
      backstr = str_dup(paper->action_description);
d390 1
a390 1
      send_to_char(paper->action_description, ch);
d394 15
d410 7
a416 2
    send_editor_help(ch->desc);
    string_write(ch->desc, &paper->action_description, MAX_NOTE_LENGTH, 0, backstr);
d939 1
a939 1
      obj_to_char(avail_lots[lot].obj, ch);
d961 1
a961 1
	 obj_to_char(obj, ch);	// Give back to owner
d968 1
a968 1
        obj_to_char(obj, buyer);
@


1.7
log
@
Added:
- Missing '\r\n' in do_say
@
text
@d191 1
a191 1
  else if (PRF_FLAGGED(ch, PRF_NOTELL))
d198 1
a198 1
  else if (PLR_FLAGGED(vict, PLR_WRITING | PLR_REPORTING | PLR_ODDWRITE))
d201 2
a202 2
  else if (PRF_FLAGGED(vict, PRF_NOTELL))
        act("$E's deaf to your tells; try again later.",
d204 2
a205 2
  else if (PRF_FLAGGED(vict, PRF_AFK))
        act("$E's is marked (AFK); try again later.",
d207 1
a207 1
  else if (PRF_FLAGGED(ch, PRF_AFK))
d215 1
a215 1
        if (GET_IGNORE(vict, i) == GET_IDNUM(ch) && !IS_NPC(ch)) {       
d437 1
d594 5
a598 4
    if (STATE(i) == CON_PLAYING && i != ch->desc && i->character &&
       ((!PRF_FLAGGED(i->character, channels[subcmd]) && subcmd <= SCMD_GRATZ )||
       (!EXT_FLAGGED(i->character, channels[subcmd]) && subcmd >= SCMD_NEWBIE ))&&
        !PLR_FLAGGED(i->character, PLR_WRITING) &&
d623 1
a623 1
      if (subcmd == SCMD_CTALK && (GET_LEVEL(ch) < LVL_GOD) && (GET_CLAN_NUM(i->character) != GET_CLAN_NUM(ch)))
@


1.6
log
@
Added:
- IS_BUILDING(ch) check in do_tell
@
text
@d91 1
a91 1
      sprintf(buf, "&nYou say, '%s&n'", speech);  
@


1.5
log
@
Added:
- reporting and odd write check in do_tell
@
text
@d195 3
@


1.4
log
@
Added:
- newbie logging
- random hint channel

Changed:
- Rewrote the ignore code, ignore char all/tells, ignore level all/tells
@
text
@d195 1
a195 1
  else if (PLR_FLAGGED(vict, PLR_WRITING))
@


1.3
log
@

Added:
- Events
-

Changed:
- Score command
-

TODO:
- Finish the base
-
@
text
@d49 1
d181 1
a203 6
  else if ( ( GET_IGN1(vict) == GET_IDNUM(ch) ||
             GET_IGN2(vict) == GET_IDNUM(ch) ||
             GET_IGN3(vict) == GET_IDNUM(ch) ||
             GET_IGN_LEVEL(vict) >= GET_LEVEL(ch)) &&
             !IS_NPC(ch) )
            act("$E's ignoring you.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP );
d206 11
a216 1
  else
d218 1
d437 1
a437 1
  int l,j; 
d528 6
d553 1
a553 1
    send_to_char("&nPlease dont swear on the open channels.\r\n",ch);
d600 12
d618 1
a618 1
       if (subcmd == SCMD_CTALK && (GET_LEVEL(ch) < LVL_GOD) && (GET_CLAN_NUM(i->character) != GET_CLAN_NUM(ch)))
d621 1
a621 1
     if (COLOR_LEV(i->character) >= C_NRM)
@


1.2
log
@
Added:
- Some initial colour coding for mobs and objects

Changed:
- Various inclusions from the existing primal base ...
- Including Sector fixes, clan guards, listing items

TODO:
- Fix colours for mobs/objects - A player comes up as a mob colour
@
text
@d35 2
a671 1
  char buyer[30];
a678 5
  if ( avail_lots[lot].buyer == NULL )
          strcpy ( buyer, "no one");
  else
          strcpy ( buyer, avail_lots[lot].buyer->player.name);
 
d683 2
a684 1
  sprintf(buf, "%sSeller: %s\tBuyer: %s\tPrice: %ld\r\n", buf,avail_lots[lot].seller->player.name, buyer, offer);
d749 29
d788 1
d790 1
a790 1
    show_lots(ch);
d794 6
d816 1
a816 1
    if (avail_lots[lot].seller == ch) {
d836 2
a837 2
    if (offer > GET_GOLD(ch)) {
      sprintf(buf,"Your need more gold!\r\n");
d842 5
d848 2
a849 1
    avail_lots[lot].buyer = ch;
d869 2
a870 2
    if (ch == avail_lots[lot-1].seller) {
      send_to_char("You cant see the stats on your own item. Go buy a an identify scroll, you cheap bastard!\r\n", ch );
d886 1
a886 1
      send_to_char("Your not selling anything!\r\n", ch);
d895 1
a895 1
      if (!(buyer = avail_lots[lot].buyer)) {
d898 1
a898 1
      };
d900 12
a911 6
      offer = avail_lots[lot].offer;
      obj = avail_lots[lot].obj;
 
      if (GET_GOLD(buyer) < offer) {
        subcmd = SCMD_WELCH;
      } else {
a912 1
        GET_GOLD(buyer) -= offer;
d958 6
d972 1
a972 1
      sprintf(buf, "[Auction] $n: %ld for a %s.",  amount, obj->short_description );
d984 2
a985 1
      sprintf ( buf,"[Auction] $n: Item %d: %s sold to %s for %ld.",  lot+1, obj->short_description, buyer->player.name, offer);
d989 3
a991 1
      sprintf ( buf,"[Auction] $n: %s welched on the deal.", buyer->player.name );
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@a51 1
#define BASE_SECT(n) ((n) & 0x000f)  
@

