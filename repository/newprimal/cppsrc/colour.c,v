head	1.13;
access;
symbols
	A3_0_59:1.2
	LATEST:1.2
	A3_0_1:1.2;
locks; strict;
comment	@ * @;


1.13
date	2004.08.27.01.47.03;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.06.02.23.30;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.25.05.37.15;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.14.07.24.16;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.14.06.10.18;	author primal;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.30.13.59.34;	author rod;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.30.13.41.57;	author rod;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.25.12.08.45;	author rod;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.16.13.30.20;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.15.04.21.09;	author rod;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.31.10.33.05;	author primal;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.13.00.59.18;	author primal;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.57;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Artus> Added (then removed) strdispmax() function.
@
text
@/* ************************************************************************
*   File: colour.c                                      Part of CircleMUD *
*  Usage: interprets inline colour codes                                  *
*  Name: Easy Colour v2.2                                                 *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*  Modifications Copyright Trevor Man 1997                                *
*  Based on the Easy Color patch by mud@@proimages.proimages.com           *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "db.h"
#include "utils.h"
#include "comm.h"
#include "constants.h"
#include "colour.h"

const char *COLOURLIST[] = {CNRM, CRED, CGRN, CYEL, CBLU, CMAG, CCYN, CWHT,
			    BRED, BGRN, BYEL, BBLU, BMAG, BCYN, BWHT,
			    BKRED, BKGRN, BKYEL, BKBLU, BKMAG, BKCYN, BKWHT,
			    CAMP, CSLH, BKBLK, CBLK, CFSH, CRVS, CUDL, BBLK };

int isnum(char s)
{
  return( (s>='0') && (s<='9') );
}

/*
 * Returns the index position in the string txt at which the first displayable
 * character to the screen exists. (Skips over colour codes)
 */
int first_disp_char(const char *txt)
{
  int k = 0;

  for (int j = strlen(txt); j > 1 && k < j; k++) {
    // C = colour code | 'n'
    // (&C)& - only worry if starting with a colour code ...
    if (txt[k] == '&') {
      // (&C)&C
      if (k + 1 < j && (is_colour(NULL, txt[k+1], FALSE) || txt[k+1] == 'n')) {
        k++;
      // (&C)& - reached end of string 
      } else if (k + 1 >= j) {
        return k;
      // (&C)&[&|\]	
      } else if (txt[k+1] == '&' || txt[k+1] == '\\') {
        return k+1;
      } 
    } else {
      return k;
    }
  }
  return k;
}

#if 0
// returns string, truncated to maxlen display characters.
char *strdispmax(char *source, char *dest, int maxlen)
{
  int i = 0, displen = 0;
  bool spec_code = FALSE;
  if (maxlen <= 0)
    return (strcpy(dest, ""));
  if ((int)strlen(input) < maxlen)
    return (strcpy(dest, source));
  strcpy(dest, input);
  for (; (displen <= maxlen); i++)
  {
    /* If end of string, return the number of displayed characters */
    if (dest[i] == '\0')
      return (dest);
    /* Check for the begining of an ANSI color code block. */
    else if (dest[i] == '\x1B')
      spec_code = TRUE;
    /* Check for the end of an ANSI color code block. */
    else if (dest[i] == 'm' && spec_code)
      spec_code = FALSE;
    /* Check for everything else. */
    else if (!spec_code)
    {
      if ((dest[i] == '&') && (dest[i+1] != '\0'))
      {
        if (dest("nmbBcCgGkKmMrRwWyYaA0123456789@@[]|", dest[i+1]) != NULL)
	{
	  i++;
	  continue;
	} else if (dest[i+1] == '&' || dest[i+1] == '\\') {
          displen++;
	  i++;
	  continue;
	}
      }
      displen++;
    }
  }
  dest[i+1] = '\0';
  return dest;
}
#endif

// returns the number of characters which will be displayed of the string on 
// the screen (taking the colour codes out) ...
int strdisplen(const char *string)
{
  int number = 0, i = 0;
  char str[MAX_STRING_LENGTH];
  bool spec_code = FALSE;

  if (string == NULL)
    return 0;
  strcpy(str, string);
  for (;; i++)
  {
    /* If end of string, return the number of displayed characters */
    if (str[i] == '\0')
      return (number);
    /* Check for the begining of an ANSI color code block. */
    else if (str[i] == '\x1B' && !spec_code)
      spec_code = TRUE;
    /* Check for the end of an ANSI color code block. */
    else if (str[i] == 'm' && spec_code)
      spec_code = FALSE;
    /* Check for everything else. */
    else if (!spec_code)
    {
      // DM - easy colour codes
      // '&'
      if ((str[i+1] != '\0') && str[i] == '&')
      {
	// "&<colour code>", "&<number code>"
	// (is_colour returns 0 for n)
        if (str[i+1] == 'n' || is_colour(NULL, str[i+1], FALSE))
	{
	  i++;
	  continue;
	// "&&", "&\"
	} else if (str[i+1] == '&' || str[i+1] == '\\') {
          number++;
	  i++;
	  continue;
	}
      }
      /* Carriage return without newline puts us in column one. */
      // reset number as previous test is written over?
      if ((str[i] == '\r') && (str[i+1] != '\n'))
      {
	number = 0;
        continue;
      }
      if (str[i] == '\n' || str[i] == '\r')
        continue;
      number++;
    }
  }
}


/* The is_colour function is used in a variety of ways: 
* The first is to check whether or not code is a number or letter code 
*	(colour_code_only == FALSE, ch == NULL)
*	Used: when paging (checking)
* The second is to check whether or not code is a letter only code
*	(colour_only_code == TRUE, ch == NULL) 
*	Used: when setting colours (choosing)
* The third is to return the value for the colour code 
*	(colour_code_only == FALSE, ch != NULL)
*	Used: proc_color (outputting)
*/
 
int is_colour(struct char_data *ch, char code, bool colour_code_only)
{
  switch (code)
  {
    /* Normal colours */
    //  case  'k': return 25; break;	/* Black */
    case  'r': return 1;	break;	/* Red */
    case  'g': return 2;	break;	/* Green */
    case  'y': return 3;	break;	/* Yellow */
    case  'b': return 4;	break;	/* Blue */
    case  'm': return 5;	break;	/* Magenta */
    case  'c': return 6;	break;	/* Cyan */
    case  'w': return 7;	break;	/* White */

    /* Bold colours */
    case  'K': return 29; break;  /* Bold black (Just for completeness) */
    case  'R': return 8;	break;	/* Bold red */
    case  'G': return 9;	break;	/* Bold green */
    case  'Y': return 10;	break;	/* Bold yellow */
    case  'B': return 11;	break;	/* Bold blue */
    case  'M': return 12;	break;	/* Bold magenta */
    case  'C': return 13;	break;	/* Bold cyan */
    case  'W': return 14;	break;	/* Bold white */
    
    /* Special codes */
    case  'n': return 0;	break;	/* Normal */
    case  'f': return -1;       break;  /* Artus> Was: Flash */
    case  '@@': return 26;       break;  /* Artus> New Flash. */
    case  'v': return 27;       break;	/* Reverse video */
    case  'u': return 28;       break;	/* Underline (Only for mono screens) */

    case CPREV_CODE: 
      if (!colour_code_only && ch == NULL) return TRUE;
      if (ch == NULL) return FALSE;
      if (GET_PREV_COLOUR(ch) >= 0 && GET_PREV_COLOUR(ch) < MAX_COLORS)
	return GET_PREV_COLOUR(ch); 
      else
	return 0; // CNRM
      break;

    case CMARK_PLACE: 
      if (!colour_code_only && ch == NULL) return TRUE;
      if (ch == NULL) return 0;
      if (GET_MARK_COLOUR(ch) >= 0 && GET_MARK_COLOUR(ch) < MAX_COLORS)
	return GET_MARK_COLOUR(ch); 
      else
	return 0; // CNRM 
      break;

    case CMARK_CODE: 
      if (!colour_code_only && ch == NULL) return TRUE;
      if (ch == NULL) return 0;
      if (GET_LAST_COLOUR(ch) >= 0 && GET_LAST_COLOUR(ch) < MAX_COLORS)
	return GET_LAST_COLOUR(ch); 
      else
	return 0; // CNRM 
      break;


    default:   
      // Checking to see if it is a code - return TRUE or FALSE
      if (!colour_code_only && ch == NULL)
      {
	switch(code)
	{
	  case '0': 
	  case '1':
	  case '2':
	  case '3':
	  case '4':
	  case '5':
	  case '6':
	  case '7':
	  case '8':
	  case '9':
	    return TRUE;
    
	  break;
	  default:
	    return -1;
	  break;
	}
      }
      // Outputting - return the colour value
      if (!colour_code_only && ch)
      {
	switch (code)
	{
	  case  '0': return GET_COLOUR(ch,0);	break;	
	  case  '1': return GET_COLOUR(ch,1);	break;	
	  case  '2': return GET_COLOUR(ch,2);	break;	
	  case  '3': return GET_COLOUR(ch,3);	break;	
	  case  '4': return GET_COLOUR(ch,4);	break;	
	  case  '5': return GET_COLOUR(ch,5);	break;	
	  case  '6': return GET_COLOUR(ch,6);	break;	
	  case  '7': return GET_COLOUR(ch,7);	break;	
	  case  '8': return GET_COLOUR(ch,8);	break;	
	  case  '9': return GET_COLOUR(ch,9);	break;	
	  /* Misc characters */
	  case  '&': return 22;	break;	/* The & character */
	  case '\\': return 23;	break;	/* The \ character */
	  default:   return 0;		break;
	}
      } 
      break;
  }
  return -1;
}

void proc_color(char *inbuf, struct char_data *ch, int colour, int insize)
{
  register int j = 0, p = 0;
  int k, max, c = 0;
  char out_buf[32768];
  struct char_data *realch;
  bool prev_code, mark_code, mark_place;

  realch = (ch->desc->original) ? ch->desc->original : ch;

  if (inbuf[0] == '\0')
    return;

  while (inbuf[j] != '\0') {
    prev_code = FALSE;
    mark_code = FALSE;
    mark_place = FALSE;
    if ((inbuf[j]=='\\') && (inbuf[j+1]=='c')
        && isnum(inbuf[j + 2]) && isnum(inbuf[j + 3])) {
      c = (inbuf[j + 2] - '0')*10 + inbuf[j + 3]-'0';
      j += 4;
    } else if ((inbuf[j] == '&') && !(is_colour(realch, inbuf[j + 1], FALSE) == -1)) {
      c = is_colour(realch, inbuf[j + 1], FALSE);
      if (inbuf[j + 1] == CPREV_CODE) {
        prev_code = TRUE;
      } else if (inbuf[j + 1] == CMARK_CODE) {
        mark_code = TRUE;
	GET_MARK_COLOUR(ch) = GET_LAST_COLOUR(ch);
      } else if (inbuf[j + 1] == CMARK_PLACE) {
        mark_place = TRUE;
      }
      GET_PREV_COLOUR(ch) = GET_LAST_COLOUR(ch);
      GET_LAST_COLOUR(ch) = c;
      j += 2;
    } else {
      out_buf[p] = inbuf[j];
      j++;
      p++;
      continue;
    }
    if (c > MAX_COLORS)
      c = 0;
    max = strlen(COLOURLIST[c]);
    int maxt = strlen(COLOURLIST[0]);
    if (colour || max == 1 && !mark_code) {
      // Add equivilant of a &n before &| or &]
      if (prev_code || mark_place) {
        for (k = 0; k < maxt; k++) {
          out_buf[p] = COLOURLIST[0][k];
	  p++;
        }
      }
      for (k = 0; k < max; k++) {
        out_buf[p] = COLOURLIST[c][k];
	p++;
      }
    }
  }

  out_buf[p] = '\0';

  // Artus> Made strncpy, and setting last char to null..
  strncpy(inbuf, out_buf, insize-1);
  inbuf[insize] = '\0';
}

void set_default_colour(struct char_data *ch, int i)
{
  if (i < 0 || i > 9) {
    send_to_char("Some nuff-nuff coder didn't check your colour number.\r\n",ch);
    return;
  } else {
    GET_COLOUR(ch,i) = default_colour_codes[i];
  }
}
 
void set_colour(struct char_data *ch, int i, int colour_code)
{
  if ((i < 0 || i > 9) || (colour_code < 0 || colour_code > MAX_COLORS)) {
    send_to_char("Some nuff-nuff coder didn't check your colour code.\r\n",ch);
    return;
  } else {
    GET_COLOUR(ch,i) = colour_code;
  }
} 
@


1.12
log
@Artus> Now warning free :o)
@
text
@d61 45
d108 2
a109 1
int strdisplen(const char *string) {
a115 1

d117 2
a118 3

  for (;; i++) {

d120 1
a120 1
    if (str[i] == '\0') {
a121 2
    }

a124 1

a127 1

d129 2
a130 2
    else if (!spec_code) {

a131 1
      
d133 2
a134 2
      if ((str[i+1] != '\0') && str[i] == '&') {

d137 2
a138 1
        if (str[i+1] == 'n' || is_colour(NULL, str[i+1], FALSE)) {
a147 1
	  	
d150 2
a151 1
      if ((str[i] == '\r') && (str[i+1] != '\n')) {
a154 1

a156 1

d177 80
a256 78
  switch (code) {
  /* Normal colours */
//  case  'k': return 25; break;	/* Black */
  case  'r': return 1;	break;	/* Red */
  case  'g': return 2;	break;	/* Green */
  case  'y': return 3;	break;	/* Yellow */
  case  'b': return 4;	break;	/* Blue */
  case  'm': return 5;	break;	/* Magenta */
  case  'c': return 6;	break;	/* Cyan */
  case  'w': return 7;	break;	/* White */

  /* Bold colours */
  case  'K': return 29; break;  /* Bold black (Just for completeness) */
  case  'R': return 8;	break;	/* Bold red */
  case  'G': return 9;	break;	/* Bold green */
  case  'Y': return 10;	break;	/* Bold yellow */
  case  'B': return 11;	break;	/* Bold blue */
  case  'M': return 12;	break;	/* Bold magenta */
  case  'C': return 13;	break;	/* Bold cyan */
  case  'W': return 14;	break;	/* Bold white */
  
  /* Special codes */
  case  'n': return 0;	break;	/* Normal */
  case  'f': return -1; break;  /* Artus> Was: Flash */
  case  '@@': return 26; break;  /* Artus> New Flash. */
  case  'v': return 27; break;	/* Reverse video */
  case  'u': return 28; break;	/* Underline (Only for mono screens) */

  case CPREV_CODE: 
    if (!colour_code_only && ch == NULL) return TRUE;
    if (ch == NULL) return FALSE;
    if (GET_PREV_COLOUR(ch) >= 0 && GET_PREV_COLOUR(ch) < MAX_COLORS)
      return GET_PREV_COLOUR(ch); 
    else
      return 0; // CNRM
    break;

  case CMARK_PLACE: 
    if (!colour_code_only && ch == NULL) return TRUE;
    if (ch == NULL) return 0;
    if (GET_MARK_COLOUR(ch) >= 0 && GET_MARK_COLOUR(ch) < MAX_COLORS)
      return GET_MARK_COLOUR(ch); 
    else
      return 0; // CNRM 
    break;

  case CMARK_CODE: 
    if (!colour_code_only && ch == NULL) return TRUE;
    if (ch == NULL) return 0;
    if (GET_LAST_COLOUR(ch) >= 0 && GET_LAST_COLOUR(ch) < MAX_COLORS)
      return GET_LAST_COLOUR(ch); 
    else
      return 0; // CNRM 
    break;


  default:   

    // Checking to see if it is a code - return TRUE or FALSE
    if (!colour_code_only && ch == NULL) {
      switch(code) {
        case '0': 
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
	case '9':
          return TRUE;
  
        break;

        default:
          return -1;
        break;
d258 22
a279 25
    }

    // Outputting - return the colour value
    if (!colour_code_only && ch) {
      switch (code) {
        case  '0': return GET_COLOUR(ch,0);	break;	
        case  '1': return GET_COLOUR(ch,1);	break;	
        case  '2': return GET_COLOUR(ch,2);	break;	
        case  '3': return GET_COLOUR(ch,3);	break;	
        case  '4': return GET_COLOUR(ch,4);	break;	
        case  '5': return GET_COLOUR(ch,5);	break;	
        case  '6': return GET_COLOUR(ch,6);	break;	
        case  '7': return GET_COLOUR(ch,7);	break;	
        case  '8': return GET_COLOUR(ch,8);	break;	
        case  '9': return GET_COLOUR(ch,9);	break;	

        /* Misc characters */
        case  '&': return 22;	break;	/* The & character */
        case '\\': return 23;	break;	/* The \ character */

        default:   return 0;		break;
      }
    } 
  break;

@


1.11
log
@Artus> Imms no longer affected by hot/cold/etc.
       Debug no longer available to mortals, can be set though.
       Fixed buffer overflow in proc_color.
       Stops processing get_from_container when arms full.
       Changed the way remort abilities are listed.
@
text
@d276 1
a276 1
        mark_place == TRUE;
@


1.10
log
@Artus>
Adrenaline : (Potion Quaffing): 6 per fight Round instead of 5.
             (Flying Tackle)  : 2 fight rounds vs 3.
Balance    : QEQ no longer gets written to the log file when unbalanced.
Colour     : &f is no longer flash, &@@ is. Keep it quiet(tm).
Corpse File: Flush()ing after write().
Double Kick: Now calls apply_spell_skill_abil()
Echo       : No longer sends text to mobs calling it.
Fighting   : Is only possible if STATE = CON_PLAYING
Glance     : Fixed erroneous dex check.
OLC        : No longer possible while fighting.
           : LVL_IMPL+ (150+) can now edit mob levels up to 120.
Pit Trap   : Now logs deaths.
             No longer says "theoretically" on creation.
Report File: Flush()ing after write().
Spell/Skill: Now allows up to NUM_CLASSES class lines in primal_spskls
             (Used to only allow up to 10)
@
text
@d247 1
a247 1
void proc_color(char *inbuf, struct char_data *ch, int colour)
d308 3
a310 1
  strcpy(inbuf, out_buf);
@


1.9
log
@
Modified: DM

Changed:
- Don't ask (large group checkin) - lots of bug fixes mainly.
- Use cvs diff if you really wanna see the changes.
@
text
@d162 2
a163 1
  case  'f': return 26;	break;	/* Flash */
@


1.8
log
@
Modified: DM

Added:
- sanity checks
@
text
@d166 3
a168 1
  case CPREV_CODE: return GET_PREV_COLOUR(ch); break;
d176 2
d185 2
d252 1
a252 1
  bool prev_code, mark_code;
d262 1
d274 3
a276 1
      } 
d291 2
a292 2
      // Add equivilant of a &n before &}
      if (prev_code) {
@


1.7
log
@
Modified: DM

Added:
- first_disp_char() function which returns the index position
  of the first character in a string which will be displayed to the screen
  (called atm from CAP()) ...
- LAST and PREV "&|", MARK "&[", "&]" colour codes, see documentation in
  file for further info - not sure if the documentation is very good though
@
text
@d167 20
a186 2
  case CMARK_PLACE: return GET_MARK_COLOUR(ch); break;
  case CMARK_CODE: return GET_LAST_COLOUR(ch); break;
@


1.6
log
@
Modified: DM

Added:
- NULL string check for argument passed to strdisplen
@
text
@d32 29
d166 4
d190 1
a190 1
          return FALSE;
d198 1
a198 1
        case  '0': return GET_COLOUR(ch,0);	break; 	
d213 1
a213 1
        default:   return 0;			break;
d228 1
d236 2
d244 8
d262 9
a270 1
    if (colour || max == 1)
d275 1
d295 1
a295 1
  if ((i < 0 || i > 9) || (colour_code < 0 || colour_code > 30)) {
@


1.5
log
@

Modified: DM

Changed:
- str char pointer to char array in strdisplen to fix free() crash
@
text
@d39 3
@


1.4
log
@
Modified: DM

Changed:
- finished fixing up score?
- added strdisplen function (colour.c)
- paging fix up
@
text
@d35 2
a36 3
  int number = 0;
  char *str;
  char **str_start;
d39 1
a39 2
  str = str_dup(string);
  *str_start = str;
d41 1
a41 1
  for (;; str++) {
d44 1
a44 3
    if (*str == '\0') {
      str = *str_start;
      free(str);
d49 1
a49 1
    else if (*str == '\x1B' && !spec_code)
d53 1
a53 1
    else if (*str == 'm' && spec_code)
d62 1
a62 2
      if ((*(str+1) != '\0') && *str == '&') {
	      log("strdisplen: *str == '&'");
d66 2
a67 2
        if (*(str+1) == 'n' || is_colour(NULL, *(str+1), FALSE)) {
	  *str++;
d70 1
a70 1
	} else if (*(str+1) == '&' || *(str+1) == '\\') {
d72 1
a72 1
	  *str++;
d79 1
a79 1
      if ((*str == '\r') && (*(str+1) != '\n')) {
d84 1
a84 1
      if (*str == '\n' || *str == '\r')
@


1.3
log
@
Added:
- switched mob checks
@
text
@d32 66
@


1.2
log
@
Added:
- olc stuff - sectors, zone flags

Changed:
- Heaps of little fixes ....
@
text
@d130 3
d142 2
a143 2
    } else if ((inbuf[j] == '&') && !(is_colour(ch, inbuf[j + 1], FALSE) == -1)) {
      c = is_colour(ch, inbuf[j + 1], FALSE);
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d48 1
a48 1
  case  'k': return 25; break;	/* Black */
d166 1
a166 2
    send_to_char("Some nuff-nuff coder didn't check your colour
number.\r\n",ch);
@

