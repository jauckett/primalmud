head	1.72;
access;
symbols
	A3_0_59:1.7
	LATEST:1.7
	A3_0_1:1.7;
locks; strict;
comment	@ * @;


1.72
date	2004.11.24.05.48.30;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	2004.11.24.01.38.10;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	2004.08.27.01.44.31;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	2004.07.15.02.41.08;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	2004.06.08.12.30.33;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	2004.06.05.14.43.18;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	2004.06.04.12.22.03;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	2004.06.03.02.50.09;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	2004.05.25.04.10.51;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	2004.05.15.22.38.54;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	2004.05.07.06.08.37;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	2004.05.06.02.23.29;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	2004.05.02.08.22.01;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	2004.05.01.13.39.00;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	2004.04.30.00.47.43;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	2004.04.29.07.55.40;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	2004.04.21.07.00.10;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	2004.03.11.00.23.41;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.01.03.30.27;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	2004.02.23.02.59.40;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	2004.01.31.09.05.14;	author john;	state Exp;
branches;
next	1.51;

1.51
date	2004.01.31.08.42.17;	author john;	state Exp;
branches;
next	1.50;

1.50
date	2004.01.27.09.47.51;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.23.11.53.16;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	2004.01.21.06.21.59;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.16.00.48.14;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	2004.01.11.20.28.44;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	2004.01.10.14.08.02;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	2004.01.10.12.02.25;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	2004.01.06.04.32.50;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	2004.01.04.10.35.00;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.17.02.25.06;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.09.05.42.45;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	2003.11.27.06.16.00;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	2003.11.25.05.37.15;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	2003.11.17.12.36.24;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	2003.11.14.06.25.13;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.12.11.00.13;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.08.11.58.22;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	2003.11.06.06.06.32;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	2003.11.06.03.47.15;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.05.12.17.13;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.03.17.01.11;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.29.12.23.11;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.14.06.10.18;	author primal;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.23.05.51.31;	author primal;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.07.01.05.33;	author karma;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.27.12.46.56;	author rod;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.01.02.27.34;	author rod;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.30.11.43.08;	author primal;	state Exp;
branches;
next	1.22;

1.22
date	2001.10.30.11.23.29;	author rod;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.12.05.15.56;	author primal;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.12.04.58.34;	author primal;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.12.01.43.10;	author artus;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.12.10.37.02;	author artus;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.09.03.43.11;	author artus;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.03.05.17.37;	author artus;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.02.00.28.23;	author primal;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.26.07.16.45;	author primal;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.23.11.26.22;	author primal;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.05.11.59.35;	author rod;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.11.14.17.43;	author artus;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.09.09.22.54;	author primal;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.04.08.22.34;	author primal;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.02.04.34.44;	author primal;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.20.23.54.39;	author primal;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.13.00.59.17;	author primal;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.14.00.15.43;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.03.07.22.12;	author mbd;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.12.29.15;	author talisman;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.13.14.25.12;	author mbd;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.57;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.72
log
@Artus> Gateways can now become tollways by setting objval 3.
@
text
@/* ************************************************************************
*   File: act.movement.c                                Part of CircleMUD *
*  Usage: movement commands, door handling, & sleep/rest/etc state        *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "house.h"
#include "constants.h"
#include "dg_scripts.h"

/* external vars  */
extern struct room_data *world;
extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct index_data *obj_index;
extern struct zone_data *zone_table;

int check_environment_effect(struct char_data *ch);

/* external functs */
void add_follower(struct char_data *ch, struct char_data *leader);
int special(struct char_data *ch, int cmd, char *arg);
void death_cry(struct char_data *ch);
int find_eq_pos(struct char_data * ch, struct obj_data * obj, char *arg);
void ch_trigger_trap(struct char_data *ch, struct obj_data *obj);
int Escape(struct char_data *ch);
int pun_aggro_check (struct char_data *ch);

/* local functions */
int has_boat(struct char_data *ch);
int find_door(struct char_data *ch, const char *type, char *dir, const char *cmdname, bool dispMessages);
int has_key(struct char_data *ch, obj_vnum key);
void do_doorcmd(struct char_data *ch, struct obj_data *obj, int door, int scmd);
int ok_pick(struct char_data *ch, obj_vnum keynum, int pickproof, int scmd);
ACMD(do_escape);
ACMD(do_gen_door);
ACMD(do_enter);
ACMD(do_leave);
ACMD(do_stand);
ACMD(do_sit);
ACMD(do_rest);
ACMD(do_sleep);
ACMD(do_wake);
ACMD(do_follow);
ACMD(do_violent_skill);
ACMD(do_recall);

void EscapeAll(struct char_data *escaper, struct char_data *master, int room)
{
  struct follow_type *tmp;
  int escapecount = 0;

  for(tmp = master->followers; tmp; tmp = tmp->next)
  {
    if (tmp->follower == escaper) // leave self for last
      continue;
    if (tmp->follower->in_room != escaper->in_room)
      continue;
    act("$n manages to find $s way out, and your group escapes.\r\n", FALSE,
	escaper, 0, tmp->follower, TO_VICT);
    char_from_room(tmp->follower);
    char_to_room(tmp->follower, room);
    act("$n has arrives, looking hurried.", FALSE, tmp->follower, 0, 0, TO_ROOM);
    look_at_room(tmp->follower, 0);
    escapecount++;
  }
  // Now move the master
  if (master != escaper)
  {
    act("$n manages to find $s way out, and your group escapes.\r\n", FALSE,
	escaper, 0, master, TO_VICT);
    char_from_room(master);
    char_to_room(master, room);
    act("$n has arrives, looking hurried.", FALSE, master, 0, 0, TO_ROOM);
    look_at_room(master, 0);
    escapecount++;
  }
  // At this stage, the escaper is the only one left, whether master or not
  act("$n leads $s group to safety.", FALSE, escaper, 0, 0, TO_ROOM);
  if (escapecount)
    act("You manage to find your way out, and your group escapes with you.\r\n",
	FALSE, escaper, 0, 0, TO_CHAR);
  else
    act("You manage to find your way out, but none of your group were nearby to follow.\r\n",
	  FALSE, escaper, 0, 0, TO_CHAR);
  char_from_room(escaper);
  char_to_room(escaper, room);
  act("$n has arrives, looking hurried.", FALSE, escaper, 0, 0, TO_ROOM);
  look_at_room(escaper, 0);
}

ACMD(do_recall)
{
  room_rnum room_num;
  extern int world_start_room[NUM_WORLDS];

  if (GET_LEVEL(ch) > LVL_NEWBIE)
  {
    send_to_char("Perhaps it's time you bought a scroll of recall.\r\n", ch);
    return;
  }
  if (ENTRY_ROOM(ch, get_world(ch->in_room)) != -1)
    room_num = real_room(ENTRY_ROOM(ch, get_world(ch->in_room)));
  else
    room_num = real_room(world_start_room[get_world(ch->in_room)]);

  if (PRF_FLAGGED(ch, PRF_MORTALK))
    REMOVE_BIT(PRF_FLAGS(ch), PRF_MORTALK);

  if (room_num <= 0)
  {
    sprintf(buf,"SYSERR: Recall: %s entry room for %d invalid",
            GET_NAME(ch), get_world(ch->in_room));
    mudlog(buf, BRF, LVL_GOD, TRUE);
    return;
  }
  act("$n disappears.", TRUE, ch, 0, 0, TO_ROOM);
  char_from_room(ch);
  char_to_room(ch, room_num);
  act("$n appears in the middle of the room.", TRUE, ch, 0, 0, TO_ROOM);
  look_at_room(ch, 0);
  entry_memory_mtrigger(ch);
  greet_mtrigger(ch, -1);
  greet_memory_mtrigger(ch);
}

ACMD(do_escape)
{
  int room;

  if (IS_NPC(ch))
  {
    send_to_char("Nup, you're stuck as an NPC forever!\r\n", ch);
    return;
  }
  if (!IS_SET(GET_SPECIALS(ch), SPECIAL_ESCAPE))
  {
    send_to_char("You try to escape the drudgery of your life.\r\n", ch);
    act("$n goes into denial.", FALSE, ch, 0, 0, TO_ROOM);
    return;
  }
  if ((BASE_SECT(ch->in_room) != SECT_INSIDE) && 
      !ROOM_FLAGGED(ch->in_room, ROOM_INDOORS))
  {
    send_to_char("You're already outside!\r\n", ch);
    return;
  }

  if ((room = Escape(ch)) != NOWHERE)
  {
    // Check if they're groupped
    if (AFF_FLAGGED(ch, AFF_GROUP))
    {
      if (ch->master) 
	EscapeAll(ch, ch->master, room);
      else
	EscapeAll(ch, ch, room);
    } else {
      act("You manage to find your way out, and escape your surroundings.\r\n",
	  FALSE, ch, 0, 0, TO_CHAR);
      char_from_room(ch);
      char_to_room(ch, room);
      act("$n arrives looking hurried.\r\n", FALSE, ch, 0, 0, TO_ROOM);
      look_at_room(ch, 0);
    }
  } else 
    send_to_char("You try to remember your way back out, and escape, but are unable to.\r\n", ch);
}

/* returns 1 if ch is allowed in zone */
int allowed_zone(struct char_data * ch, int flag, bool show)
{
  int reqlvl = 0;

  if (!LR_FAIL(ch, LVL_IMPL))
    return 1;
 
  /* check if the room we're going to is level restricted */
  if ((IS_SET(flag, ZN_NEWBIE) && GET_LEVEL(ch) > LVL_NEWBIE))
  {
    send_to_char("You are too high a level to enter this zone!",ch);
    return 0;
  }

  if (flag & 0xffffc == 0) // No zone LR.
    return 1;

  if (IS_SET(flag, ZN_LR_IMP))
    reqlvl = LVL_IMPL;
  else if (IS_SET(flag, ZN_LR_IMM))
    reqlvl = LVL_ANGEL;
  else if (IS_SET(flag, ZN_LR_ET))
    reqlvl = LVL_ETRNL1;
  else if (IS_SET(flag, ZN_LR_95))
    reqlvl = 95;
  else if (IS_SET(flag, ZN_LR_90))
    reqlvl = 90;
  else if (IS_SET(flag, ZN_LR_85))
    reqlvl = 85;
  else if (IS_SET(flag, ZN_LR_80))
    reqlvl = 80;
  else if (IS_SET(flag, ZN_LR_75))
    reqlvl = 75;
  else if (IS_SET(flag, ZN_LR_70))
    reqlvl = 70;
  else if (IS_SET(flag, ZN_LR_65))
    reqlvl = 65;
  else if (IS_SET(flag, ZN_LR_60))
    reqlvl = 60;
  else if (IS_SET(flag, ZN_LR_55))
    reqlvl = 55;
  else if (IS_SET(flag, ZN_LR_50))
    reqlvl = 50;
  else if (IS_SET(flag, ZN_LR_45))
    reqlvl = 45;
  else if (IS_SET(flag, ZN_LR_40))
    reqlvl = 40;
  else if (IS_SET(flag, ZN_LR_35))
    reqlvl = 35;
  else if (IS_SET(flag, ZN_LR_30))
    reqlvl = 30;
  else if (IS_SET(flag, ZN_LR_25))
    reqlvl = 25;
  else if (IS_SET(flag, ZN_LR_20))
    reqlvl = 20;
  else if (IS_SET(flag, ZN_LR_15))
    reqlvl = 15;
  else if (IS_SET(flag, ZN_LR_10))
    reqlvl = 10;
  else if (IS_SET(flag, ZN_LR_5))
    reqlvl = 5;

  if (!LR_FAIL(ch, reqlvl)) // Base check.
    return 1;

  if ((GET_CLASS(ch) > CLASS_WARRIOR) && (reqlvl <= GET_MAX_LVL(ch)))
  {
    if (GET_CLASS(ch) == CLASS_MASTER)
      reqlvl -= 20;
    else
      reqlvl -= 10;
    if (!LR_FAIL(ch, reqlvl))
      return 1;
  }

  if (show)
    send_to_char("An overwhelming fear stops you from going any further.\r\n", ch);
  return 0;
} 

/* returns 1 if ch is allowed in room */
int allowed_room(struct char_data * ch, int flag, bool show)
{
  if (!LR_FAIL(ch, LVL_IMPL))
    return TRUE;

  if (IS_NPC(ch) && (!ch->master) && IS_SET(flag, ROOM_NOMOB))
  {
    if (show)
      send_to_char("I think you should leave that room to the players.\r\n",ch);
    return FALSE;
  }

  if ((IS_SET(flag, ROOM_NEWBIE) && GET_LEVEL(ch) > LVL_NEWBIE))
  {
    if (show)
      send_to_char("You are too high a level to enter this zone!",ch);
    return FALSE;
  }
  if ((IS_SET(flag, ROOM_LR_ET) && LR_FAIL_MAX(ch, LVL_ETRNL1)) ||
      (IS_SET(flag, ROOM_LR_IMM) && LR_FAIL(ch, LVL_CHAMP))     ||
      (IS_SET(flag, ROOM_LR_ANG) && LR_FAIL(ch, LVL_ANGEL))     ||
      (IS_SET(flag, ROOM_LR_GOD) && LR_FAIL(ch, LVL_GOD))       ||
      (IS_SET(flag, ROOM_LR_IMP))) // Artus> IMPL is checked already.
  {
    if (show)
      send_to_char("An overwhelming fear stops you from going any further.\r\n",ch);
    return FALSE;
  }
  return TRUE;
} 

/* simple function to determine if char can walk on water */
int has_boat(struct char_data *ch)
{
  struct obj_data *obj;
  int i;
/*
  if (ROOM_IDENTITY(ch->in_room) == DEAD_SEA)
    return (1);
*/

  if (AFF_FLAGGED(ch, AFF_WATERWALK))
    return TRUE;
  if (AFF_FLAGGED(ch, AFF_WATERBREATHE))
    return TRUE;
  if (AFF_FLAGGED(ch, AFF_FLY))
    return TRUE;
  if (!LR_FAIL(ch, LVL_IMPL))
    return TRUE;
  /* non-wearable boats in inventory will do it */
  for (obj = ch->carrying; obj; obj = obj->next_content)
    if (GET_OBJ_TYPE(obj) == ITEM_BOAT && (find_eq_pos(ch, obj, NULL) < 0))
      return TRUE;

  /* and any boat you're wearing will do it too */
  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i) && GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_BOAT)
      return TRUE;

  /* Check for the type of mount they have, to see whether they can walk on water */
  if (MOUNTING(ch)) 
  {
    i = GET_CLASS(MOUNTING(ch));
    if (i == CLASS_AQUATIC || i == CLASS_DRAGON)
      return TRUE;
  }

  return FALSE;
}

/* Artus> Generic movement check. */
int char_can_enter(struct char_data *ch, struct room_data *room, bool show)
{
  if (!(ch && room))
  {
    if (show)
      send_to_char("Maybe that's not such a great idea...\r\n", ch);
    return FALSE;
  }

  // Whatever. I do what I want.
  if (!LR_FAIL(ch, LVL_IMPL))
    return TRUE;
  // Zone Allowed
  if (!allowed_zone(ch, zone_table[room->zone].zflag, show))
    return FALSE;
  // Room Allowed.
  if (!allowed_room(ch, room->room_flags, show))
    return FALSE;

  // A mount? 
  if (IS_NPC(ch) && MOUNTING(ch))
    return FALSE;

  // if this room or the one we're going to needs a boat, check for one
  if (((BASE_SECT(world[ch->in_room].sector_type) == SECT_WATER_NOSWIM) ||
       (BASE_SECT(room->sector_type) == SECT_WATER_NOSWIM)) && 
      (!has_boat(ch)))
  {
    if (show)
      send_to_char("You need a boat to go there.\r\n", ch);
    return FALSE;
  }
 
  // check if the room we're going to is a fly room - Vader 
  if (!IS_AFFECTED(ch,AFF_FLY) && 
      ((BASE_SECT(world[ch->in_room].sector_type) == SECT_FLYING) ||
       (BASE_SECT(room->sector_type) == SECT_FLYING))) 
  {
    if (show)
      send_to_char("You need to be able to fly to go there.\r\n",ch);
    return FALSE;
  }

  // Artus> Houses.
  if (ROOM_FLAGGED(ch->in_room, ROOM_ATRIUM))
  {
    if (!House_can_enter(ch, room->number))
    {
      send_to_char("That's private property -- no trespassing!\r\n", ch);
      return (0);
    }
    if (MOUNTING(ch))
    {
      send_to_char("You cannot go there while mounted!\r\n", ch);
      return (0);
    }
  }

  if (!IS_NPC(ch) && (!LR_FAIL(ch, LVL_IS_GOD)) &&
      !IS_AFFECTED(ch,AFF_WATERBREATHE) &&
      ((UNDERWATER(ch)) ||
       (BASE_SECT(room->sector_type) == SECT_UNDERWATER)))
  {
    send_to_char("You take a deep breath of water.  OUCH!\r\n",ch);
    send_to_char("Your chest protests terrebly causing great pain. \r\n", ch);
    act("$n suddenly turns a deep blue color holding $s throat.", 
	FALSE, ch, 0, 0, TO_ROOM);
    // GET_HIT(ch)-= GET_LEVEL(ch)*5;
    damage(NULL, ch, GET_LEVEL(ch)*5, TYPE_UNDEFINED, FALSE);
    if (GET_HIT(ch) <0) 
    {
      send_to_char("Your life flashes before your eyes.  You have Drowned.  RIP!", ch);
      act("$n suddenly turns a deep blue color holding $s throat.", 
	  FALSE, ch, 0, 0, TO_ROOM);
      act("$n has drowned. RIP!.", FALSE, ch, 0, 0, TO_ROOM);
      if (MOUNTING(ch)) 
      {
        send_to_char("Your mount suffers as it dies.\r\n", ch);
	death_cry(MOUNTING(ch));
        raw_kill(MOUNTING(ch), NULL);
      }
      death_cry(ch);
      die(ch,NULL,"drowning");
    }
    return FALSE;
  }
  return TRUE;
}

void special_item_mount_message(struct char_data *ch) 
{
  struct obj_data *mount = MOUNTING_OBJ(ch);
  char temp[MAX_STRING_LENGTH];

  if (!mount)
    return;

  /* Place specific item messages here */

  // else
  sprintf(temp, "$n, mounted on %s, has arrived.", mount->short_description);
  act(temp, FALSE, ch, mount, 0, TO_ROOM);
}
  

/* do_simple_move assumes
 *    1. That there is no master and no followers.
 *    2. That the direction exists.
 *
 *   Returns :
 *   1 : If succes.
 *   0 : If fail
 */

/* JA some data for reversing directions */
static int DIR_REVERSE[6] = {2, 3, 0, 1, 5, 4};
static char *SECT_ATMOSPHERE_ARRIVE[7]  = {"", "", "", "", "", "", ""};
static char *SECT_TEMPERATURE_ARRIVE[7] = {"", "", "", "", "", "", ""};
static char *SECT_GRAVITY_ARRIVE[7]     = {"", "", "", "", "", "", ""};
static char *SECT_ENVIRON_ARRIVE[7]     = {"", "", "", "$n is moving backwards.", "", "", ""};
static char *SECT_ATMOSPHERE_LEAVE[7]   = {"", "", "", "", "", "", ""};
static char *SECT_TEMPERATURE_LEAVE[7]  = {"", "", "", "", "", "", ""};
static char *SECT_GRAVITY_LEAVE[7]      = {"", "", "", "", "", "", ""};
static char *SECT_ENVIRON_LEAVE[7]      = {"", "", "", "$n leaves back to front.", "", "", ""};

static void do_environ_leave_message(struct char_data *ch, int dir)
{
  int sect_type;
  sect_type =  world[ch->in_room].sector_type & 0xfff0;
  sprintf(buf2, SECT_ATMOSPHERE_LEAVE[ATMOSPHERE(sect_type)], dirs[dir]);
  act(buf2, TRUE, ch, 0, 0, TO_ROOM);
  sprintf(buf2, SECT_TEMPERATURE_LEAVE[TEMPERATURE(sect_type)], dirs[dir]);
  act(buf2, TRUE, ch, 0, 0, TO_ROOM);
  sprintf(buf2, SECT_GRAVITY_LEAVE[GRAVITY(sect_type)], dirs[dir]);
  act(buf2, TRUE, ch, 0, 0, TO_ROOM);
  sprintf(buf2, SECT_ENVIRON_LEAVE[ENVIRON(sect_type)], dirs[dir]);
  act(buf2, TRUE, ch, 0, 0, TO_ROOM);
}

static void do_environ_arrive_message(struct char_data *ch, int dir)
{
  int sect_type;
  sect_type =  world[ch->in_room].sector_type & 0xfff0;
  sprintf(buf2, SECT_ATMOSPHERE_ARRIVE[ATMOSPHERE(sect_type)], dirs[dir]);
  act(buf2, TRUE, ch, 0, 0, TO_ROOM);
  sprintf(buf2, SECT_TEMPERATURE_ARRIVE[TEMPERATURE(sect_type)], dirs[dir]);
  act(buf2, TRUE, ch, 0, 0, TO_ROOM);
  sprintf(buf2, SECT_GRAVITY_ARRIVE[GRAVITY(sect_type)], dirs[dir]);
  act(buf2, TRUE, ch, 0, 0, TO_ROOM);
  sprintf(buf2, SECT_ENVIRON_ARRIVE[ENVIRON(sect_type)], dirs[dir]);
  act(buf2, TRUE, ch, 0, 0, TO_ROOM);
}

int do_simple_move(struct char_data *ch, int dir, int need_specials_check,
                   int subcmd, bool show)
{
  room_rnum was_in;
  int need_movement;

  /*
   * Check for special routines (North is 1 in command list, but 0 here) Note
   * -- only check if following; this avoids 'double spec-proc' bug
   */
  if (need_specials_check && special(ch, dir + 1, "")) /* XXX: Evaluate NULL */
    return (0);

  // charmead?
  if (AFF_FLAGGED(ch, AFF_CHARM) && (ch->master) && 
      (ch->in_room == ch->master->in_room))
  {
    send_to_char("The thought of leaving your master makes you weep.\r\n", ch);
    act("$n bursts into tears.", FALSE, ch, 0, 0, TO_ROOM);
    return (0);
  }

  if (!char_can_enter(ch, &world[EXIT(ch,dir)->to_room], TRUE))
    return 0;

  /* if flying movement is only 1 */
  if (BASE_SECT(world[EXIT(ch,dir)->to_room].sector_type) == SECT_UNDERWATER)
    need_movement = 10;
  else if (BASE_SECT(world[EXIT(ch,dir)->to_room].sector_type) == SECT_WATER_NOSWIM)
    need_movement = 5;
  else if (IS_AFFECTED(ch,AFF_FLY))
    need_movement = 1;
  else if (MOUNTING(ch) || MOUNTING_OBJ(ch))  // Mounts go anywhere for 1 move
    need_movement = 1;
  else
  /* move points needed is avg. move loss for src and destination sect type */
    need_movement = (movement_loss[BASE_SECT(world[ch->in_room].sector_type)] + movement_loss[BASE_SECT(world[world[ch->in_room].dir_option[dir]->to_room].sector_type)]) >> 1;

  if (!IS_NPC(ch) && need_movement > 1 && GET_SKILL(ch, SKILL_MOUNTAINEER) && 
     (BASE_SECT(world[EXIT(ch,dir)->to_room].sector_type) == SECT_MOUNTAIN ||
      BASE_SECT(world[EXIT(ch,dir)->to_room].sector_type) == SECT_HILLS))
    if (number(1, 101) < GET_SKILL(ch, SKILL_MOUNTAINEER))
      need_movement = 2;
  if (GET_MOVE(ch) < need_movement && !IS_NPC(ch))
  {
     if (need_specials_check && ch->master)
       send_to_char("You are too exhausted to follow.\r\n", ch);
     else
       send_to_char("You are too exhausted.\r\n", ch);
     return (0);
  }
  // Tunnels -- Artus> Modified to allow groups to pass through.
  if (ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_TUNNEL) && !IS_NPC(ch) &&
      num_pc_in_room(&(world[EXIT(ch, dir)->to_room])) >= 1)
  {
    if (!(ch->master && AFF_FLAGGED(ch, AFF_GROUP) &&
	  (IN_ROOM(ch->master) == EXIT(ch, dir)->to_room)))
    {
      send_to_char("There isn't enough room there for more than one person!\r\n", ch);
      return (0);
    }
  }
  /* Mortals and low level gods cannot enter greater god rooms. */
  if (ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_GODROOM) &&
	!LR_FAIL(ch, LVL_GRGOD))
  {
    send_to_char("You aren't godly enough to use that room!\r\n", ch);
    return (0);
  }

  /* Now we know we're allow to go into the room. */

  // Just incase ...
  if (char_affected_by_timer(ch, TIMER_MEDITATE))
    timer_from_char(ch, TIMER_MEDITATE);
  if (char_affected_by_timer(ch, TIMER_HEAL_TRANCE))
    timer_from_char(ch, TIMER_HEAL_TRANCE);
  
  if (!IS_NPC(ch) && LR_FAIL(ch, LVL_IMMORT))
    GET_MOVE(ch) -= need_movement;

  if (AFF_FLAGGED(ch, AFF_SNEAK) && (subcmd == SCMD_MOVE) &&
      (IS_NPC(ch) || !PRF_FLAGGED(ch, PRF_TAG)))
    show = false;

  if (show)
  {
    if (!MOUNTING(ch) || !MOUNTING_OBJ(ch))
      sprintf(buf2, "$n leaves %s.", dirs[dir]);
    if (MOUNTING(ch))
      sprintf(buf2, "$n, mounted on $N, leaves %s.", dirs[dir]);
    if (MOUNTING_OBJ(ch))
     sprintf(buf2, "$n, mounted on %s, leaves %s.", MOUNTING_OBJ(ch)->short_description,dirs[dir]);
    if (MOUNTING(ch))
      act(buf2, TRUE, ch, 0, MOUNTING(ch), TO_ROOM);
    else
      act(buf2, TRUE, ch, 0, 0, TO_ROOM);
    do_environ_leave_message(ch, dir);
    if (ROOM_FLAGGED(ch->in_room, ROOM_BACKWARD))
    {
      sprintf(buf2, "$n is leaves back to front!");
      act(buf2, TRUE, ch, 0, 0, TO_ROOM);
    }
  }

  /* see if an entry trigger disallows the move */
  if (!entry_mtrigger(ch))
    return 0;
  if (!enter_wtrigger(&world[EXIT(ch, dir)->to_room], ch, dir))
    return 0;

  was_in = ch->in_room;
  char_from_room(ch);
  char_to_room(ch, world[was_in].dir_option[dir]->to_room);

  if (show)
  {
    if (MOUNTING(ch))
      act("$n, mounted on $N, has arrived.",
	  TRUE, ch, 0, MOUNTING(ch), TO_ROOM);
    else if (MOUNTING_OBJ(ch))
      special_item_mount_message(ch);
    else
      act("$n has arrived.", TRUE, ch, 0, 0, TO_ROOM);
    do_environ_arrive_message(ch, dir);
    if (ROOM_FLAGGED(ch->in_room, ROOM_BACKWARD))
    { 
      sprintf(buf2, "$n is moving backwards!");
      act(buf2, TRUE, ch, 0, 0, TO_ROOM);
    }
  }
  if (ch->desc != NULL)
    look_at_room(ch, 0);
  if (check_environment_effect(ch))
  {
    if (MOUNTING(ch))
    {
      send_to_char("Your mount screams in agony as it dies.\r\n", ch);
      death_cry(MOUNTING(ch));
      raw_kill(MOUNTING(ch), NULL);
    }
    return 1;
  }

  // Backwards..
  if (ROOM_FLAGGED(ch->in_room, ROOM_BACKWARD))
    send_to_char("Everything here is moving backwards!\r\n", ch);

  if (ROOM_FLAGGED(ch->in_room, ROOM_DEATH) && LR_FAIL(ch, LVL_IMMORT))
  {
    log_death_trap(ch, DT_DEATH);
    if (MOUNTING(ch))
    {
      send_to_char("Your mount screams in agony as it dies.\r\n", ch);
      death_cry(MOUNTING(ch));
      raw_kill(MOUNTING(ch), NULL);
    }
    // DM - corpses need to be made ...
    death_cry(ch);
    char_from_room(ch);
    char_to_room(ch, was_in);
    // Artus> Make corpse here.. (WAS extract_char(ch))
    raw_kill(ch, NULL);
    return (0);
  }
  
  entry_memory_mtrigger(ch);
  if (!greet_mtrigger(ch, dir))
  {
    char_from_room(ch);
    char_to_room(ch, was_in);
    look_at_room(ch, 0);
  } else
    greet_memory_mtrigger(ch);
  return (1);
}

/* Artus - Post movement checks to be added in here. *
 * Called from perform_move().. Should be OK.        */
void post_move_checks(struct char_data *ch)
{
//  extern struct index_data *mob_index;	/* For aggravate check. */
  struct char_data *i;
  bool aggro_attack(struct char_data *ch, struct char_data *vict, int type);
  SPECIAL(shop_keeper); // For aggravate check.

  // ARTUS - Someone seems to have forgotten to put aggro checks in...
  // DM - fixed - problems for death traps when ch->in_room == NOWHERE (-1)
  // DM - fixed - added IS_GHOST and CAN_SEE checks on "ch is player" and gave 
  //              hit() the correct args ... (i and ch were around wrong way)
  if (IN_ROOM(ch) == NOWHERE)
    return;
  if (IS_NPC(ch))
  {
    for (i = world[IN_ROOM(ch)].people; i; i = i->next_in_room)
    {
      if ((i == ch) || !CAN_SEE(ch, i))
	continue;
      if (IS_NPC(i))
      {
	// If we're a helper, and they're fighting, get in on the action.
	if (MOB_FLAGGED(ch, MOB_HELPER) && FIGHTING(i) &&
	    aggro_attack(ch, i, AGGRA_HELPER))
	  return;
	continue;
      }
      // i is a PC.
      if (MOB_FLAGGED(ch, MOB_AGGRESSIVE) && 
	  aggro_attack(ch, i, AGGRA_AGGRESSIVE))
	return;
      else if (MOB_FLAGGED(ch, MOB_AGGR_EVIL) && IS_EVIL(i) &&
	  aggro_attack(ch, i, AGGRA_AGGR_EVIL))
	return;
      else if (MOB_FLAGGED(ch, MOB_AGGR_GOOD) && IS_GOOD(i) &&
	  aggro_attack(ch, i, AGGRA_AGGR_GOOD))
	return;
      // Aggravate punishment.
      if (PUN_FLAGGED(i, PUN_AGGRAVATE) && aggro_attack(ch, i, AGGRA_PUNISH))
	return;
    }
    return;
  } // End of NPC Movement Checks.
  // ch is a player.
  if (IS_GHOST(ch) || PRF_FLAGGED(ch, PRF_NOHASSLE))
    return;

  for (i = world[IN_ROOM(ch)].people; i; i = i->next_in_room)
  {
    // Basic checks. (i == ch check made not needed with !IS_NPC check)
    if (!IS_NPC(i) || FIGHTING(i) || (GET_POS(i) <= POS_SLEEPING) ||
	!CAN_SEE(ch, i))
      continue;
    if (MOB_FLAGGED(i, MOB_AGGRESSIVE) && aggro_attack(i, ch, AGGRA_AGGRESSIVE))
      return;
    else if (MOB_FLAGGED(i, MOB_AGGR_EVIL) && IS_EVIL(ch) &&
	     aggro_attack(i, ch, AGGRA_AGGR_EVIL))
      return;
    else if (MOB_FLAGGED(i, MOB_AGGR_GOOD) && IS_GOOD(ch) &&
	     aggro_attack(i, ch, AGGRA_AGGR_GOOD))
      return;
    if (PUN_FLAGGED(ch, PUN_AGGRAVATE) && aggro_attack(i, ch, AGGRA_PUNISH))
      return;
  } /* Room/Char List */
}

int perform_move(struct char_data *ch, int aDir, int need_specials_check)
{
  room_rnum was_in;
  struct follow_type *k, *next;
  int this_skill=0, best_skill=0, percent=0, prob=0;
  struct char_data *best_char = NULL;
  bool death_room = FALSE;
  int dir = aDir;
  
  /* JA for backwards rooms */
//  if (ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_BACKWARD))  r
//  sprintf(buf2, "checking sect flag : %d\n", world[ch->in_room].sector_type);
//  sprintf(buf2, "checking sect flag : %d\n", world[ch->in_room].sector_type);

 
//  send_to_char(buf2, ch);
//  sprintf(buf2, "checking room flag : %d\n", world[ch->in_room].room_flags );
//  send_to_char(buf2, ch);
  if (ROOM_FLAGGED(ch->in_room, ROOM_BACKWARD))
  {
    assert(aDir>=0 && aDir<=5);
    dir = DIR_REVERSE[aDir];
//    send_to_char("Everything here is moving backwards.\n\r", ch);
  }

//  int sect_type = world[ch->in_room].sector_type & 0xfff0;
//  if (ENVIRON(sect_type) == SECT_BACKWARD) {
//    assert(aDir>=0 && aDir<=5);
//    dir = DIR_REVERSE[aDir];
//  }

  if (IS_AFFECTED(ch, AFF_PARALYZED))
  {
    send_to_char("PANIC! Your legs refuse to move!!\r\n", ch);
    return(0);
  }

  if (ch == NULL || dir < 0 || dir >= NUM_OF_DIRS || FIGHTING(ch))
    return (0);
  if (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE)
  {
    send_to_char("Alas, you cannot go that way...\r\n", ch);
    return (0);
  }
  if (EXIT_FLAGGED(EXIT(ch, dir), EX_CLOSED))
  {
    if (EXIT(ch, dir)->keyword)
    {
      sprintf(buf2, "The %s seems to be closed.\r\n", fname(EXIT(ch, dir)->keyword));
      send_to_char(buf2, ch);
      return (0);
    }
    send_to_char("It seems to be closed.\r\n", ch);
    return (0);
  }
  // DM - check for SKILL_DETECT_DEATH
  if (!IS_NPC(ch) && is_death_room(EXIT(ch, dir)->to_room))
    death_room = TRUE;
    // Single char movement
  if (!ch->followers)
  {
    if (!IS_NPC(ch) && (is_death_room(EXIT(ch, dir)->to_room)))
    {
      if ((prob=GET_SKILL(ch, SKILL_DETECT_DEATH)) > 0)
      { 
	percent = number(1, 101);     /* 101% is a complete failure */
	if (percent <= prob)
	{
	  send_to_char("You sense that moving in that direction will lead to your death.\r\n",ch);
	  apply_spell_skill_abil(ch, SKILL_DETECT_DEATH);
	  return 0; 
	} 
      }
    }
    if (do_simple_move(ch, dir, need_specials_check) == 1)
    {
      post_move_checks(ch);
      return 1;
    } 
    return 0;
  }

  // Group Movement
  was_in = ch->in_room;

  if (!do_simple_move(ch, dir, need_specials_check))
    return (0);

  if (death_room)
  {
    // Find the char with the best SKILL_DETECT_DEATH
    for (k = ch->followers; k; k = next)
    {
      next = k->next;
      if (!IS_NPC(k->follower) && (k->follower->in_room == was_in))
      {
	this_skill = GET_SKILL(k->follower, SKILL_DETECT_DEATH);
	if (this_skill > best_skill)
	{
	  best_skill = this_skill;
	  best_char = k->follower;
	}
      }
    }

    if (best_skill > 0)
    {
      percent = number(1, 101);     /* 101% is a complete failure */
      prob = GET_SKILL(ch, SKILL_DETECT_DEATH);

      if (percent <= prob)
      {
	for (k = ch->followers; k; k = next)
	{
	  next = k->next;
	  if (k->follower->in_room == was_in)
	  {
	    if (k->follower == best_char)
	      send_to_char("You sense that moving in that direction will lead to your death.\r\n",ch);
	    else
	      act("$N senses moving in that direction will lead to the group's demise.\r\n", FALSE, best_char, 0, ch, TO_CHAR);
	  }
	}
	apply_spell_skill_abil(ch, SKILL_DETECT_DEATH);
	return (0); 
      }
    } 
  }

  for (k = ch->followers; k; k = next)
  {
    next = k->next;
    if ((k->follower->in_room == was_in) &&
	(GET_POS(k->follower) >= POS_STANDING))
    {
      act("You follow $N.\r\n", FALSE, k->follower, 0, ch, TO_CHAR);
      perform_move(k->follower, dir, 1);
    }
  }
  return (1);
}

ACMD(do_move)
{
  if (IS_AFFECTED(ch, AFF_PARALYZED))
  {
    send_to_char("You cannot move you are paralyzed.\r\n", ch);
    return;
  }
  /*
   * This is basically a mapping of cmd numbers to perform_move indices.
   * It cannot be done in perform_move because perform_move is called
   * by other functions which do not require the remapping.
   */
  if (perform_move(ch, subcmd - 1, 0) == 0) 
    return;
}


int find_door(struct char_data *ch, const char *type, char *dir, const char *cmdname, bool dispMessages)
{
  int door;
  if (*dir)
  {			/* a direction was specified */
    if ((door = search_block(dir, dirs, FALSE)) == -1)
    {	/* Partial Match */
      if (dispMessages)
        send_to_char("That's not a direction.\r\n", ch);
      return (-1);
    }
    if (EXIT(ch, door))
    {	/* Braces added according to indent. -gg */
      if (EXIT(ch, door)->keyword)
      {
	if (isname(type, EXIT(ch, door)->keyword))
	  return (door);
	else
	{
          if (dispMessages)
	  {
	    sprintf(buf2, "I see no %s there.\r\n", type);
	    send_to_char(buf2, ch);
          }
	  return (-1);
        }
      } else
	return (door);
    } else {
      if (dispMessages)
      {
        sprintf(buf2, "I really don't see how you can %s anything there.\r\n", 
		cmdname);
        send_to_char(buf2, ch);
      }
      return (-1);
    }
  } else {			/* try to locate the keyword */
    if (!*type)
    {
      if (dispMessages)
      {
        sprintf(buf2, "What is it you want to %s?\r\n", cmdname);
        send_to_char(buf2, ch);
      }
      return (-1);
    }
    for (door = 0; door < NUM_OF_DIRS; door++)
      if ((EXIT(ch, door)) && (EXIT(ch, door)->keyword) &&
	  (isname(type, EXIT(ch, door)->keyword)))
	return (door);
    if (dispMessages)
    {
      sprintf(buf2, "There doesn't seem to be %s %s here.\r\n", AN(type), type);
      send_to_char(buf2, ch);
    }
    return (-1);
  }
}

#define SKELETON_KEY_VNUM	4523
int has_key(struct char_data *ch, obj_vnum key)
{
  struct obj_data *o;

  for (o = ch->carrying; o; o = o->next_content)
  {
    if (GET_OBJ_VNUM(o) == key)
      return (1);
    if (GET_OBJ_VNUM(o) == SKELETON_KEY_VNUM)
    {
      for (int i = 0; i < MAX_QUEST_ITEMS; i++)
	if (GET_QUEST_ITEM(ch,i) == SKELETON_KEY_VNUM)
	  return (1);
      return (0);
    }
  }

  if (GET_EQ(ch, WEAR_HOLD))
    if (GET_OBJ_VNUM(GET_EQ(ch, WEAR_HOLD)) == key)
      return (1);

  return (0);
}



#define NEED_OPEN	(1 << 0)
#define NEED_CLOSED	(1 << 1)
#define NEED_UNLOCKED	(1 << 2)
#define NEED_LOCKED	(1 << 3)

const char *cmd_door[] =
{
  "open",
  "close",
  "unlock",
  "lock",
  "pick"
};

const int flags_door[] =
{
  NEED_CLOSED | NEED_UNLOCKED,
  NEED_OPEN,
  NEED_CLOSED | NEED_LOCKED,
  NEED_CLOSED | NEED_UNLOCKED,
  NEED_CLOSED | NEED_LOCKED
};


#define EXITN(room, door)		(world[room].dir_option[door])
#define OPEN_DOOR(room, obj, door)	((obj) ?\
		(TOGGLE_BIT(GET_OBJ_VAL(obj, 1), CONT_CLOSED)) :\
		(TOGGLE_BIT(EXITN(room, door)->exit_info, EX_CLOSED)))
#define LOCK_DOOR(room, obj, door)	((obj) ?\
		(TOGGLE_BIT(GET_OBJ_VAL(obj, 1), CONT_LOCKED)) :\
		(TOGGLE_BIT(EXITN(room, door)->exit_info, EX_LOCKED)))

void do_doorcmd(struct char_data *ch, struct obj_data *obj, int door, int scmd)
{
  int other_room = 0;
  struct room_direction_data *back = 0;

  // a broken container - must be fixed before you can peform use it 
  if ((obj) && (GET_OBJ_DAMAGE(obj) == 0))
  {
    send_to_char("Nope, its broken. Perhaps you should fix it!\r\n", ch);
    return;
  }
  
  // TODO: check that no other skills are passed in
  if (scmd == SKILL_PICK_LOCK)
    sprintf(buf, "$n %ss ", cmd_door[SCMD_PICK]);
  else
    sprintf(buf, "$n %ss ", cmd_door[scmd]);

  if ((!obj && ((other_room = EXIT(ch, door)->to_room) != NOWHERE)) &&
      ((back = world[other_room].dir_option[rev_dir[door]]) != NULL) &&
      (back->to_room != ch->in_room))
    back = 0;

  switch (scmd)
  {
    case SCMD_OPEN:
    case SCMD_CLOSE:
      OPEN_DOOR(ch->in_room, obj, door);
      if (back)
	OPEN_DOOR(other_room, obj, rev_dir[door]);
      send_to_char(OK, ch);
      break;
    case SCMD_UNLOCK:
    case SCMD_LOCK:
      LOCK_DOOR(ch->in_room, obj, door);
      if (back)
	LOCK_DOOR(other_room, obj, rev_dir[door]);
      send_to_char("*Click*\r\n", ch);
      break;
    case /*SCMD_PICK*/SKILL_PICK_LOCK:
      LOCK_DOOR(ch->in_room, obj, door);
      if (back)
	LOCK_DOOR(other_room, obj, rev_dir[door]);
      send_to_char("The lock quickly yields to your skills.\r\n", ch);
      strcpy(buf, "$n skillfully picks the lock on ");
      break;
  }
  /* Notify the room */
  sprintf(buf2, "%s%s.", ((obj) ? "" : "the "),
          (obj) ? "$p" : (EXIT(ch, door)->keyword ? "$F" : "door"));
  strncat(buf, buf2, strlen(buf2));
  //sprintf(buf + strlen(buf), "%s%s.", ((obj) ? "" : "the "), (obj) ? "$p" :
	//  (EXIT(ch, door)->keyword ? "$F" : "door"));
  if (!(obj) || (obj->in_room != NOWHERE))
    act(buf, FALSE, ch, obj, obj ? 0 : EXIT(ch, door)->keyword, TO_ROOM);

  /* Notify the other room */
  if ((scmd == SCMD_OPEN || scmd == SCMD_CLOSE) && back)
  {
    sprintf(buf, "The %s is %s%s from the other side.",
	    (back->keyword ? fname(back->keyword) : "door"), cmd_door[scmd],
	    (scmd == SCMD_CLOSE) ? "d" : "ed");
    if (world[EXIT(ch, door)->to_room].people)
    {
      act(buf, FALSE, world[EXIT(ch, door)->to_room].people, 0, 0, TO_ROOM);
      act(buf, FALSE, world[EXIT(ch, door)->to_room].people, 0, 0, TO_CHAR);
    }
  }
}

int ok_pick(struct char_data *ch, obj_vnum keynum, int pickproof, int scmd)
{
  int percent;

  percent = number(1, 101);
  if (scmd == SKILL_PICK_LOCK/*SCMD_PICK*/)
  {
    if (keynum < 0)
      send_to_char("Odd - you can't seem to find a keyhole.\r\n", ch);
    else if (pickproof)
      send_to_char("It resists your attempts to pick it.\r\n", ch);
    else if (percent > GET_SKILL(ch, SKILL_PICK_LOCK))
      send_to_char("You failed to pick the lock.\r\n", ch);
    else
    {
      apply_spell_skill_abil(ch, scmd);
      return (1);
    }
    return (0);
  }
  return (1);
}

#define DOOR_IS_OPENABLE(ch, obj, door)	((obj) ? \
			((GET_OBJ_TYPE(obj) == ITEM_CONTAINER) && \
			OBJVAL_FLAGGED(obj, CONT_CLOSEABLE)) :\
			(EXIT_FLAGGED(EXIT(ch, door), EX_ISDOOR)))
#define DOOR_IS_OPEN(ch, obj, door)	((obj) ? \
			(!OBJVAL_FLAGGED(obj, CONT_CLOSED)) :\
			(!EXIT_FLAGGED(EXIT(ch, door), EX_CLOSED)))
#define DOOR_IS_UNLOCKED(ch, obj, door)	((obj) ? \
			(!OBJVAL_FLAGGED(obj, CONT_LOCKED)) :\
			(!EXIT_FLAGGED(EXIT(ch, door), EX_LOCKED)))
#define DOOR_IS_PICKPROOF(ch, obj, door) ((obj) ? \
			(OBJVAL_FLAGGED(obj, CONT_PICKPROOF)) : \
			(EXIT_FLAGGED(EXIT(ch, door), EX_PICKPROOF)))

#define DOOR_IS_CLOSED(ch, obj, door)	(!(DOOR_IS_OPEN(ch, obj, door)))
#define DOOR_IS_LOCKED(ch, obj, door)	(!(DOOR_IS_UNLOCKED(ch, obj, door)))
#define DOOR_KEY(ch, obj, door)		((obj) ? (GET_OBJ_VAL(obj, 2)) : \
					(EXIT(ch, door)->key))
#define DOOR_LOCK(ch, obj, door)	((obj) ? (GET_OBJ_VAL(obj, 1)) : \
					(EXIT(ch, door)->exit_info))
ACMD(do_gen_door)
{
  int door = -1, chance = 0;
  obj_vnum keynum;
  char type[MAX_INPUT_LENGTH], dir[MAX_INPUT_LENGTH];
  struct obj_data *obj = NULL;
  struct char_data *victim = NULL;
  int cmdindex = subcmd;

  if (cmdindex == SKILL_PICK_LOCK)
    cmdindex = SCMD_PICK;
  
  skip_spaces(&argument);
  if (!*argument)
  {
    sprintf(buf, "%s what?\r\n", cmd_door[cmdindex]);
    send_to_char(CAP(buf), ch);
    return;
  }
  two_arguments(argument, type, dir);
  // DM - switched these two checks, first we'll look for a door, and then an
  // object: to get over problem of trying to open doors when you have a piece
  // of equipment with the same name as the door alias.
  if ((door = find_door(ch, type, dir, cmd_door[cmdindex], FALSE)) < 0)
    generic_find(type, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &victim, &obj);
  // We failed to find a door or an object - give the door messages
  if (!obj)
    find_door(ch, type, dir, cmd_door[cmdindex], TRUE);

  //if (!generic_find(type, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &victim, &obj))
  //  door = find_door(ch, type, dir, cmd_door[cmdindex]);

  // TODO: Tali: is this the inteded functionality for traps on objects, ie. 
  // at this stage all you know is that the arg given matched an obj ... DM
  
  // Do some trap checking
  if ((obj) && (GET_OBJ_TYPE(obj) == ITEM_TRAP))
  {
    if (IS_THIEF(ch))
      chance = 15;
    else if (IS_MAGIC_USER(ch))
      chance = 5;
    else
      chance = 2;
    if (number(1, chance) == chance) 
      ch_trigger_trap(ch, obj);
    else
      send_to_char("Strange, it won't budge.\r\n", ch);
    return;
  }
  if ((obj) || (door >= 0))
  {
    keynum = DOOR_KEY(ch, obj, door);
    if (!(DOOR_IS_OPENABLE(ch, obj, door)))
      act("You can't $F that!", FALSE, ch, 0, cmd_door[cmdindex], TO_CHAR);
    else if (!DOOR_IS_OPEN(ch, obj, door) &&
	     IS_SET(flags_door[cmdindex], NEED_OPEN))
      send_to_char("But it's already closed!\r\n", ch);
    else if (!DOOR_IS_CLOSED(ch, obj, door) &&
	     IS_SET(flags_door[cmdindex], NEED_CLOSED))
      send_to_char("But it's currently open!\r\n", ch);
    else if (!(DOOR_IS_LOCKED(ch, obj, door)) &&
	     IS_SET(flags_door[cmdindex], NEED_LOCKED))
      send_to_char("Oh.. it wasn't locked, after all..\r\n", ch);
    else if (!(DOOR_IS_UNLOCKED(ch, obj, door)) &&
	     IS_SET(flags_door[cmdindex], NEED_UNLOCKED))
      send_to_char("It seems to be locked.\r\n", ch);
    else if (!has_key(ch, keynum) && LR_FAIL(ch, LVL_GOD) &&
	     ((subcmd == SCMD_LOCK) || (subcmd == SCMD_UNLOCK)))
      send_to_char("You don't seem to have the proper key.\r\n", ch);
    else if (ok_pick(ch, keynum, DOOR_IS_PICKPROOF(ch, obj, door), subcmd))
      do_doorcmd(ch, obj, door, subcmd);
  }
  return;
}

ACMD(do_enter)
{
  int door;

  one_argument(argument, buf);
  if (*buf)
  {			/* an argument was supplied, search for door
			 * keyword */
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door) && (EXIT(ch, door)->keyword) &&
	  !str_cmp(EXIT(ch, door)->keyword, buf))
      {
	perform_move(ch, door, 1);
	return;
      }
    sprintf(buf2, "There is no %s here.\r\n", buf);
    send_to_char(buf2, ch);
  } else if (ROOM_FLAGGED(ch->in_room, ROOM_INDOORS))
    send_to_char("You are already indoors.\r\n", ch);
  else
  {
    /* try to locate an entrance */
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door) && (EXIT(ch, door)->to_room != NOWHERE) &&
	  !EXIT_FLAGGED(EXIT(ch, door), EX_CLOSED) &&
	  ROOM_FLAGGED(EXIT(ch, door)->to_room, ROOM_INDOORS))
      {
	perform_move(ch, door, 1);
	return;
      }
    send_to_char("You can't seem to find anything to enter.\r\n", ch);
  }
}

ACMD(do_leave)
{
  int door;

  if (OUTSIDE(ch))
    send_to_char("You are outside.. where do you want to go?\r\n", ch);
  else
  {
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door) && (EXIT(ch, door)->to_room != NOWHERE) &&
	  !EXIT_FLAGGED(EXIT(ch, door), EX_CLOSED) &&
	  !ROOM_FLAGGED(EXIT(ch, door)->to_room, ROOM_INDOORS))
      {
	perform_move(ch, door, 1);
	return;
      }
    send_to_char("I see no obvious exits to the outside.\r\n", ch);
  }
}

ACMD(do_stand)
{
  // DM - meditate, cant stand whilst meditating
  if (!IS_NPC(ch) && (char_affected_by_timer(ch, TIMER_MEDITATE) || char_affected_by_timer(ch, TIMER_HEAL_TRANCE))) 
  {
    send_to_char("Stop mucking around and get back to meditating.\r\n", ch);
    return;
  }
  
  switch (GET_POS(ch))
  {
    case POS_STANDING:
      send_to_char("You are already standing.\r\n", ch);
      break;
    case POS_SITTING:
      send_to_char("You stand up.\r\n", ch);
      act("$n clambers to $s feet.", TRUE, ch, 0, 0, TO_ROOM);
      /* Will be sitting after a successful bash and may still be fighting. */
      GET_POS(ch) = FIGHTING(ch) ? POS_FIGHTING : POS_STANDING;
      break;
    case POS_RESTING:
      send_to_char("You stop resting, and stand up.\r\n", ch);
      act("$n stops resting, and clambers on $s feet.", TRUE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_STANDING;
      break;
    case POS_SLEEPING:
      send_to_char("You have to wake up first!\r\n", ch);
      break;
    case POS_FIGHTING:
      send_to_char("Do you not consider fighting as standing?\r\n", ch);
      break;
    default:
      send_to_char("You stop floating around, and put your feet on the ground.\r\n", ch);
      act("$n stops floating around, and puts $s feet on the ground.",
	  TRUE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_STANDING;
      break;
  }
}


ACMD(do_sit)
{
  switch (GET_POS(ch))
  {
    case POS_STANDING:
      send_to_char("You sit down.\r\n", ch);
      act("$n sits down.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_SITTING;
      break;
    case POS_SITTING:
      send_to_char("You're sitting already.\r\n", ch);
      break;
    case POS_RESTING:
      send_to_char("You stop resting, and sit up.\r\n", ch);
      act("$n stops resting.", TRUE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_SITTING;
      break;
    case POS_SLEEPING:
      send_to_char("You have to wake up first.\r\n", ch);
      break;
    case POS_FIGHTING:
      send_to_char("Sit down while fighting? Are you MAD?\r\n", ch);
      break;
    default:
      send_to_char("You stop floating around, and sit down.\r\n", ch);
      act("$n stops floating around, and sits down.", TRUE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_SITTING;
      break;
  }
}

ACMD(do_rest)
{
  if (MOUNTING(ch))
  {
    send_to_char("You cannot rest while mounted.\r\n", ch);
    return;
  }
  // DM - meditate, cant stand whilst meditating
  if (!IS_NPC(ch) && (char_affected_by_timer(ch, TIMER_MEDITATE) ||
	              char_affected_by_timer(ch, TIMER_HEAL_TRANCE))) 
  {
    send_to_char("Stop mucking around and get back to meditating.\r\n", ch);
    return;
  }
  switch (GET_POS(ch))
  {
    case POS_STANDING:
      send_to_char("You sit down and rest your tired bones.\r\n", ch);
      act("$n sits down and rests.", TRUE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_RESTING;
      break;
    case POS_SITTING:
      send_to_char("You rest your tired bones.\r\n", ch);
      act("$n rests.", TRUE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_RESTING;
      break;
    case POS_RESTING:
      send_to_char("You are already resting.\r\n", ch);
      break;
    case POS_SLEEPING:
      send_to_char("You have to wake up first.\r\n", ch);
      break;
    case POS_FIGHTING:
      send_to_char("Rest while fighting?  Are you MAD?\r\n", ch);
      break;
    default:
      send_to_char("You stop floating around, and stop to rest your tired bones.\r\n", ch);
      act("$n stops floating around, and rests.", FALSE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_SITTING;
      break;
  }
}


ACMD(do_sleep)
{
  // DM - meditate, cant stand whilst meditating
  if (!IS_NPC(ch) && (char_affected_by_timer(ch, TIMER_MEDITATE) ||
	              char_affected_by_timer(ch, TIMER_HEAL_TRANCE))) 
  {
    send_to_char("Stop mucking around and get back to meditating.\r\n", ch);
    return;
  }
  if (MOUNTING(ch))
  {
    send_to_char("You cannot sleep while mounted.\r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_NOSLEEP))
  {
    send_to_char("You can't possibly go to sleep here!\r\n", ch);
    return;
  }
  switch (GET_POS(ch))
  {
    case POS_STANDING:
    case POS_SITTING:
    case POS_RESTING:
      send_to_char("You go to sleep.\r\n", ch);
      act("$n lies down and falls asleep.", TRUE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_SLEEPING;
      break;
    case POS_SLEEPING:
      send_to_char("You are already sound asleep.\r\n", ch);
      break;
    case POS_FIGHTING:
      send_to_char("Sleep while fighting?  Are you MAD?\r\n", ch);
      break;
    default:
      send_to_char("You stop floating around, and lie down to sleep.\r\n", ch);
      act("$n stops floating around, and lie down to sleep.",
	  TRUE, ch, 0, 0, TO_ROOM);
      GET_POS(ch) = POS_SLEEPING;
      break;
  }
}

ACMD(do_wake)
{
  struct char_data *vict;
  int self = 0;

  one_argument(argument, arg);
  if (*arg)
  {
    if (GET_POS(ch) == POS_SLEEPING)
      send_to_char("Maybe you should wake yourself up first.\r\n", ch);
    else if ((vict = generic_find_char(ch, arg, FIND_CHAR_ROOM)) == NULL)
      send_to_char(NOPERSON, ch);
    else if (vict == ch)
      self = 1;
    else if (AWAKE(vict))
      act("$E is already awake.", FALSE, ch, 0, vict, TO_CHAR);
    else if (AFF_FLAGGED(vict, AFF_SLEEP))
      act("You can't wake $M up!", FALSE, ch, 0, vict, TO_CHAR);
    else if (GET_POS(vict) < POS_SLEEPING)
      act("$E's in pretty bad shape!", FALSE, ch, 0, vict, TO_CHAR);
    else
    {
      act("You wake $M up.", FALSE, ch, 0, vict, TO_CHAR);
      act("You are awakened by $n.", FALSE, ch, 0, vict, TO_VICT | TO_SLEEP);
      GET_POS(vict) = POS_STANDING;
    }
    if (!self)
      return;
  }
  if (AFF_FLAGGED(ch, AFF_SLEEP))
    send_to_char("You can't wake up!\r\n", ch);
  else if (GET_POS(ch) > POS_SLEEPING)
    send_to_char("You are already awake...\r\n", ch);
  else
  {
    send_to_char("You awaken, and stand up.\r\n", ch);
    act("$n awakens.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_STANDING;
  }
}

ACMD(do_follow)
{
  struct char_data *leader;

  one_argument(argument, buf);

  if (*buf)
  {
    if (!(leader = generic_find_char(ch, buf, FIND_CHAR_ROOM)))
    {
      send_to_char(NOPERSON, ch);
      return;
    }
  } else {
    send_to_char("Whom do you wish to follow?\r\n", ch);
    return;
  }

  if (ch->master == leader)
  {
    act("You are already following $M.", FALSE, ch, 0, leader, TO_CHAR);
    return;
  }
  if (AFF_FLAGGED(ch, AFF_CHARM) && (ch->master))
  {
    act("But you only feel like following $N!",
	FALSE, ch, 0, ch->master, TO_CHAR);
  } else {			/* Not Charmed follow person */
    if (leader == ch)
    {
      if (!ch->master)
      {
	send_to_char("You are already following yourself.\r\n", ch);
	return;
      }
      stop_follower(ch);
    } else {
      if (circle_follow(ch, leader))
      {
	send_to_char("Sorry, but following in loops is not allowed.\r\n", ch);
	return;
      }
      if (ch->master)
	stop_follower(ch);
      REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
      add_follower(ch, leader);
    }
  }
}

// Generic vampire check.
int check_vampire(struct char_data *ch)
{
  extern struct weather_data weather_info;

  if (IS_NPC(ch) || !PRF_FLAGGED(ch, PRF_VAMPIRE))
    return(0);
  if (LR_FAIL(ch, LVL_IS_GOD) || GET_DEBUG(ch))
    return(0);
  if ((weather_info.sunlight == SUN_DARK) || !OUTSIDE(ch))
    return(0);
  for (int i = 0; i < NUM_WEARS; i++)
  {
    if (!(GET_EQ(ch, i)))
      continue;
    switch (GET_OBJ_TYPE(GET_EQ(ch, i)))
    {
      case ITEM_HEATRES:
      case ITEM_HEATPROOF:
      case ITEM_STASIS:
	return(0);
    }
  }
  send_to_char("The sun burns your skin!\r\n", ch);
  act("Smoke rises from $n's skin!",FALSE,ch,0,0,TO_ROOM);
  damage(NULL, ch, MAX(GET_HIT(ch)-GET_LEVEL(ch)/2, 0), TYPE_UNDEFINED, FALSE);
  if (GET_HIT(ch) <= 0)
  {
    send_to_char("The sun burns you to death!\r\n",ch);
    act("The sun causes $n to burst into flames!", TRUE, ch, 0, 0, TO_ROOM);
    if (MOUNTING(ch))
    {
      send_to_char("Your vampiric mount dies with you.\r\n", ch);
      die(MOUNTING(ch), NULL, "sunlight");
    }
    death_cry(ch);
    die(ch,NULL,"sunlight");
    send_to_outdoor("The scream of a burning vampire echoes throughout the land...\r\n");
    return(1);
  }
  return(0);
}

// Artus> Called by check_environment_effect.
int check_env_atmosphere(struct char_data *ch, int atmos)
{
  int i, dam, modifier = 1;

#ifndef IGNORE_DEBUG
  if (GET_DEBUG(ch)) 
  {
    sprintf(buf, "DBG: Atmosphere = %d\r\n", atmos);
    send_to_char(buf, ch);
  }
#endif

  switch (atmos)
  {
    case SECT_THIN: ////////////////////////////////////// Thin
      sprintf(buf, "The %s here is very thin.\r\n", (UNDERWATER(ch)) ? "water" : "air");
      send_to_char(buf, ch);
      for (i = 0; i < NUM_WEARS; i++)
      {
	if (!GET_EQ(ch, i))
	  continue;
	switch (GET_OBJ_TYPE(GET_EQ(ch, i)))
	{
	  case ITEM_RESPIRATE:
	  case ITEM_BREATHER:
	  case ITEM_VACSUIT:
	  case ITEM_ENVIRON:
	    return(0);
	}
      }
      send_to_char("You are gasping for breath!\n\r", ch);
      dam = (int)(MIN(GET_HIT(ch), GET_LEVEL(ch)) / modifier);
      damage(NULL, ch, dam, TYPE_UNDEFINED, FALSE);
      if (GET_HIT(ch) <= 0)
      {
	GET_POS(ch) = POS_STUNNED;
	act("$n falls down gasping for breath an goes into a coma.\n\r", TRUE, ch, 0, 0, TO_ROOM);
      }
      return (0);
    case SECT_UNBREATHABLE: ////////////////////////////// Unbreathable
      sprintf(buf, "The %s here is unbreathable.\r\n", (UNDERWATER(ch)) ? "water" : "air");
      send_to_char(buf, ch);
      for (i = 0; i < NUM_WEARS; i++)
      {
	if (!(GET_EQ(ch, i)))
	  continue;
	switch (GET_OBJ_TYPE(GET_EQ(ch, i)))
	{
	  case ITEM_RESPIRATE:
	    modifier++;
	    break;
	  case ITEM_BREATHER:
	  case ITEM_VACSUIT:
	  case ITEM_ENVIRON:
	    return(0);
	}
      }
      send_to_char("You can't breath, you are asphyxiating!\n\r", ch);
      damage(NULL, ch, MIN(GET_HIT(ch), GET_LEVEL(ch)*3), TYPE_UNDEFINED,
	     FALSE);
      if (GET_HIT(ch) < 0)
      {
	send_to_char("You suffocate to death!\n\r", ch);
	act("$n falls down gasping for breath and dies.", TRUE, ch, 0, 0, TO_ROOM); 
	death_cry(ch);
	die(ch,NULL,"unbreathable air");
	return(1);
      }
      return(0);
    case SECT_VACUUM: //////////////////////////////////// Vacuum
      send_to_char("You are in a vacuum.\n\r", ch);
      for (i = 0; i < NUM_WEARS; i++)
      {
	if (!GET_EQ(ch, i))
	  continue;
	switch (GET_OBJ_TYPE(GET_EQ(ch, i)))
	{
	  case ITEM_VACSUIT:
	  case ITEM_ENVIRON:
	    return (0);
	}
      }
      send_to_char("You walk into a total vacuum, and your whole body explodes!\n\r", ch);
      act("$n enters a total vacuum and explodes, covering you with blood and gutsi!\n\r", TRUE, ch, 0, 0, TO_ROOM);
      death_cry(ch);
      die(ch, NULL, "vacuum");
      return(1);
    case SECT_CORROSIVE: ///////////////////////////////// Corrosive
      sprintf(buf, "The %s here is thick with toxic chemicals.\r\n", (UNDERWATER(ch)) ? "water" : "air");
      send_to_char(buf, ch);
      for (i = 0; i < NUM_WEARS; i++)
      {
	if (!(GET_EQ(ch, i)))
	  continue;
	switch GET_OBJ_TYPE(GET_EQ(ch, i))
	{
	  case ITEM_VACSUIT:
	    modifier++;
	  case ITEM_BREATHER:
	    modifier++;
	  case ITEM_RESPIRATE:
	    modifier++;
	    break;
	  case ITEM_ENVIRON:
	    return(0);
	}
      }
      sprintf(buf, "The chemicals in the %s burn your lungs.\r\n", (UNDERWATER(ch)) ? "water" : "air");
      send_to_char(buf, ch);
      //GET_HIT(ch) -= 135;
      dam = (int)(GET_LEVEL(ch) * 5 / modifier);
      damage(NULL, ch, dam, TYPE_UNDEFINED, FALSE);
      if (GET_HIT(ch) < 0)
      {
	send_to_char("You fall down coughing up blood and die.\n\r", ch);
	act("$n falls down coughing up blood and gasping for breath, then dies!\n\r", TRUE, ch, 0, 0, TO_ROOM);
	death_cry(ch);
	die(ch,NULL,"corrosion");
	return(1); 
      }
      return(0);
  }
  return (0);
}

// Called by check_environment_effect
int check_env_temperature(struct char_data *ch, int temperature)
{
  int i, modifier=1, dam;

#ifndef IGNORE_DEBUG
  if (GET_DEBUG(ch))
  {
    sprintf(buf, "DBG: Temperature = %d\r\n", temperature);
    send_to_char(buf, ch);
  }
#endif

  switch(temperature)
  {
    case SECT_HOT: /////////////////////////////////////// Hot
      send_to_char("It is much hotter here than you are used to.\n\r", ch);
      for (i = 0; i < NUM_WEARS; i++)
      {
	if (!GET_EQ(ch, i))
	  continue;
	switch (GET_OBJ_TYPE(GET_EQ(ch, i)))
	{
	  case ITEM_HEATRES:
	  case ITEM_HEATPROOF:
	  case ITEM_STASIS:
	    return (0);
	}
      }
      send_to_char("The heat is really affecting you!\n\r", ch);
      //GET_HIT(ch) = MAX(GET_HIT(ch) - GET_LEVEL(ch), 0);
      dam = MIN(GET_HIT(ch), GET_LEVEL(ch));
      damage(NULL, ch, dam, TYPE_UNDEFINED, FALSE);
      if (GET_HIT(ch) <= 0)
      {
        GET_POS(ch) = POS_STUNNED;
        act("$n falls down from heat exhaustion!", TRUE, ch, 0, 0, TO_ROOM);
      }
      return (0);
    case SECT_SCORCH: //////////////////////////////////// Scorch
      send_to_char("Its almost hot enough to melt lead here.\n\r", ch);
      for (i = 0; i < NUM_WEARS; i++)
      {
	if (!GET_EQ(ch, i))
	  continue;
	switch (GET_OBJ_TYPE(GET_EQ(ch, i)))
	{
	  case ITEM_HEATRES:
	    modifier++;
	    break;
	  case ITEM_HEATPROOF:
	  case ITEM_STASIS:
	    return (0);
	}
      }
      dam = (int)((MIN(GET_HIT(ch), GET_LEVEL(ch)*2))/modifier);
      send_to_char("Your skin is smouldering and blistering!\n\r", ch);
      damage(NULL, ch, dam, TYPE_UNDEFINED, FALSE);
      if (GET_HIT(ch) <= 0)
      {
	send_to_char("Your whole body is reduced to a blistered mess, you fall down dead!\n\r", ch);
	act("$n falls down dead in a smouldering heap!", TRUE, ch, 0, 0, TO_ROOM);
	death_cry(ch);
	die(ch,NULL,"scorching");
	return(1);
      }
      return(0);
    case SECT_INCINERATE: //////////////////////////////// Incinerate
      send_to_char("You estimate that it is well over 3000 degrees here.\n\r", ch);
      send_to_char("Your skin catches fire! You are burnt to a cinder\n\r", ch);
      act("$n spontaneously combusts and is reduced to a charred mess on the ground!\n\r", TRUE, ch, 0, 0, TO_ROOM);
      death_cry(ch);
      log_death_trap(ch, DT_INCINERATE);
      raw_kill(ch, NULL);
      return(1);
    case SECT_COLD: ////////////////////////////////////// Cold
      send_to_char("Its much colder here than you are used to.\n\r", ch);
      for (i = 0; i < NUM_WEARS; i++)
      {
	if (!GET_EQ(ch, i))
	  continue;
	switch (GET_OBJ_TYPE(GET_EQ(ch, i)))
	{
	  case ITEM_COLD:
	  case ITEM_SUBZERO:
	  case ITEM_STASIS:
	    return (0);
	}
      }
      send_to_char("You shiver uncontrollably from the cold!\n\r", ch);
      dam = MIN(GET_HIT(ch), GET_LEVEL(ch));
      damage(NULL, ch, dam, TYPE_UNDEFINED, FALSE);
      if (GET_HIT(ch) <= 0)
      {
	send_to_char("You fall down unconcious from hyperthermia!\n\r", ch);
	GET_POS(ch) = POS_STUNNED;
	act("$n falls down in a coma from hyperthermia!",
	    TRUE, ch, 0, 0, TO_ROOM);
      }
      return(0);
    case SECT_FREEZING: ////////////////////////////////// Freezing
      sprintf(buf, "The %s here is freezing.\r\n",
	      (UNDERWATER(ch)) ? "water" : "air");
      send_to_char(buf, ch);
      for (i = 0; i < NUM_WEARS; i++)
      {
	if (!GET_EQ(ch, i))
	  continue;
	switch (GET_OBJ_TYPE(GET_EQ(ch, i)))
	{
	  case ITEM_COLD:
	    modifier++;
	    break;
	  case ITEM_SUBZERO:
	  case ITEM_STASIS:
	    return (0);
	}
      }
      send_to_char("You are suffering from severe frostbite!\n\r", ch);
      dam = (int)(MIN(GET_HIT(ch), (GET_LEVEL(ch)*2))/modifier);
      damage(NULL, ch, dam, TYPE_UNDEFINED, 0);
      if (GET_HIT(ch) <= 0)
      {
	send_to_char("You fall down dead from frostbite!\n\r", ch);
	act("$n falls down dead from frostbite and hyperthermia!", TRUE, ch, 0, 0, TO_ROOM);
	death_cry(ch);
	die(ch,NULL,"freezing cold");
	return(1);
      }
      break;   
    case SECT_ABSZERO: /////////////////////////////////// Absolute Zero
      send_to_char("It dosn't get much colder than this... absolute zero!\n\r",
	           ch);
      send_to_char("Your body is frozen rock hard and shatters into many pieces!\n\r", ch);
      act("$n is frozen solid, tries to move and shatters into thousands of pieces!\n\r", TRUE, ch, 0, 0, TO_ROOM);
      death_cry(ch);
      die(ch,NULL,"absolute zero");
      return(1);
      break;  
  }
  return(0);
}

// Called by check_environment_effect
int check_env_gravity(struct char_data *ch, int gravity)
{
  int i, modifier=1, dam;

#ifndef IGNORE_DEBUG
  if (GET_DEBUG(ch))
  {
    sprintf(buf, "DBG: Gravity = %d\r\n", gravity);
    send_to_char(buf, ch);
  }
#endif

  switch (gravity)
  {
    case SECT_DOUBLEGRAV: //////////////////////////////// Doublegrav
      send_to_char("You feel much heavier than you are used to.\r\n", ch);
      for (i = 0; i < NUM_WEARS; i++)
      {
	if (!GET_EQ(ch, i))
	  continue;
	switch (GET_OBJ_TYPE(GET_EQ(ch, i)))
	{
	  case ITEM_GRAV1:
	  case ITEM_GRAV3:
	    return(0);
	}
      }
      send_to_char("The extra weight sends pain right through your legs!\r\n",
	           ch);
      dam = MIN(GET_HIT(ch), GET_LEVEL(ch));
      damage(NULL, ch, dam, TYPE_UNDEFINED, 0);
      if (GET_HIT(ch) <= 0)
      {
	send_to_char("Your legs can no longer sustrain your weight.\r\n", ch);
	act("$n falls to the floor, $s legs collapsing beneath $m.", TRUE, ch,
	    0, 0, TO_ROOM);
	GET_POS(ch) = POS_STUNNED;
      }
      return(0);
    case SECT_TRIPLEGRAV: //////////////////////////////// Triplegrav
      for (i = 0; i < NUM_WEARS; i++)
      {
	if (!GET_EQ(ch, i))
	  continue;
	send_to_char("You feel like you weigh a tonne!\r\n", ch);
	switch (GET_OBJ_TYPE(GET_EQ(ch, i)))
	{
	  case ITEM_GRAV1:
	    modifier++;
	    break;
	  case ITEM_GRAV3:
	    return(0);
	}
      }
      send_to_char("Your legs spasm with the pain of the extra weight you feel here.\r\n", ch);
      dam = (int)(MIN(GET_HIT(ch), GET_LEVEL(ch)*3)/modifier);
      damage(NULL, ch, dam, TYPE_UNDEFINED, 0);
      if (GET_HIT(ch) <= 0)
      {
	send_to_char("You are crushed to a pulp!\r\n", ch);
	act("$n is crushed to a pulp by the extremely strong gravity, here.",
	    TRUE, ch, 0, 0, TO_ROOM);
	death_cry(ch);
	die(ch, NULL, "gravity");
	return(1);
      }
      return (0);
    case SECT_CRUSH: ///////////////////////////////////// Crush
      send_to_char("You must be very near to a singularity, the gravity is approaching infinity.\r\nYour body cannot take it anymore!\r\n", ch);
      act("$n is crushed to a single molecule!", TRUE, ch, 0, 0, TO_ROOM);
      death_cry(ch);
      die(ch,NULL,"gravity");
      return(1);
  }
  return 0;
}


#define MAX_DISPAIR_MESSAGES 3
char *DISPAIR_CHAR_MESSAGES[MAX_DISPAIR_MESSAGES] = {
  "This place is getting you down a bit.",
  "This place is quite depressing.",
  "This place is making you suicidal."
};

// Artus> Used by check_environment_effect
int check_env_environ(struct char_data *ch, int environ)
{
  int i, dam;
  struct affected_type *af, *next_af;

#ifndef IGNORE_DEBUG
  if (GET_DEBUG(ch))
  {
    sprintf(buf, "DBG: Environ = %d\r\n", environ);
    send_to_char(buf, ch);
  }
#endif

  switch(environ)
  {
    case SECT_RAD1: ////////////////////////////////////// Radiation
      send_to_char("If you had a geiger counter it would be off the scale.\r\n", ch);
      for (i = 0; i < NUM_WEARS; i++)
      {
	if (!GET_EQ(ch, i))
	  continue;
	switch (GET_OBJ_TYPE(GET_EQ(ch, i)))
	{
	  case ITEM_RAD1PROOF:
	  case ITEM_STASIS:
	    return(0);
	}
      }
      send_to_char("You feel decidedly sick in the stomach. The radiation is really affecting you.\r\n", ch);
      dam = MIN(GET_HIT(ch), GET_LEVEL(ch));
      damage(NULL, ch, dam, TYPE_UNDEFINED, FALSE);
      if (GET_HIT(ch) <= 0)
      {
        act("$n passes out from radiation poisining!\r\n", TRUE, ch, 0, 0, TO_ROOM);
        send_to_char("You pass out from radiation poisoining!\r\n",ch);
        GET_POS(ch) = POS_STUNNED;
      }
      return(0);
    case SECT_DISPELL: /////////////////////////////////// Dispell
      dam = 0;
      /* Artus> This will bork at abilities.
      while (ch->affected)
        affect_remove(ch, ch->affected); */
      for (af = ch->affected; af; af=next_af)
      {
        next_af = af->next;
	/* Don't remove abilities.. */
	if ((af->duration != CLASS_ABILITY) && (af->duration != CLASS_ITEM))
	{
	  affect_remove(ch, af);
	  dam++;
	}
      }
      // Artus> So we don't keep repeating this message :o)
      if (dam > 0)
	send_to_char("Your body shivers as a flash of bright light strips you of all spells!!!\r\n", ch);
      break;
    case SECT_DISPAIR1 :
    case SECT_DISPAIR2 :
    case SECT_DISPAIR3 :

      int depression = environ - 2; // gives a value 1 to 3

      // send a message to the char
      sprintf(buf2, "You are depressed by %d points\nSect type is %d\n", depression, BASE_SECT(world[ch->in_room].sector_type));
      send_to_char(buf2, ch);
      GET_MOVE(ch) -= 1+(depression * depression)/2;
      if (GET_MOVE(ch) < 0) {
        GET_MOVE(ch) = 0;
      }
      GET_MANA(ch) -= 1+(depression * depression);
      if (GET_MANA(ch) < 0) {
        GET_MANA(ch) = 0;
        // suicide
	  send_to_char("You can't take it any more, you commit suicide!\n\r", ch);
	  act("$n commits suicide and dies.", TRUE, ch, 0, 0, TO_ROOM); 
	  raw_kill(ch,NULL);
	  return(1);
      }
                                                                                                    
      break;

      return(0);
  }
  return(0);
}

// Check environment of one specific char.
int check_environment_effect(struct char_data *ch)
{
  int sect_type;
/* JA new sector flags for different worlds */

  if (IS_NPC(ch)) 
    return(0);
  sect_type = world[ch->in_room].sector_type & 0xfff0;
  if (!LR_FAIL(ch, LVL_IS_GOD)) // Artus> Changed from IMPL.
  {
#ifndef IGNORE_DEBUG
    if (GET_DEBUG(ch))
    {
      sprintf(buf, "DBG: Sect_Type: %d\r\n", sect_type);
      send_to_char(buf, ch);
    } else
#endif
      return(0);
  }
  
  if (check_env_atmosphere(ch, ATMOSPHERE(sect_type)))
    return 1;
  if (check_env_temperature(ch, TEMPERATURE(sect_type)))
    return 1;
  if (check_env_gravity(ch, GRAVITY(sect_type)))
    return 1;
  if (check_env_environ(ch, ENVIRON(sect_type)))
    return 1;

  if (check_vampire(ch))
    return 1;

  return(0);
  // This has all been replaced by the above.
#if 0 // check_atmosphere
  switch(ATMOSPHERE(sect_type))
  {
    case SECT_THIN: 
      sprintf(buf, "The %s here is very thin.\r\n", (UNDERWATER(ch)) ? "water" : "air");
      send_to_char(buf, ch);
      if (is_wearing(ch, ITEM_RESPIRATE))
        break;
      else if (is_wearing(ch, ITEM_BREATHER))
	break;
      else if (is_wearing(ch, ITEM_VACSUIT))
	break;
      else if (is_wearing(ch, ITEM_ENVIRON))
	break;
      else
      {
	send_to_char("You are gasping for breath!\n\r", ch);
	damage(NULL, ch, MIN(GET_HIT(ch), GET_LEVEL(ch)), TYPE_UNDEFINED, 
	       FALSE);
	// GET_HIT(ch) = MAX(GET_HIT(ch)-GET_LEVEL(ch), 0);
	if (GET_HIT(ch) <= 0)
	{
	  GET_POS(ch) = POS_STUNNED;
	  act("$n falls down gasping for breath an goes into a coma.\n\r", TRUE, ch, 0, 0, TO_ROOM);
	}
      }
      break;
    case SECT_UNBREATHABLE :
      sprintf(buf, "The %s here is unbreathable.\r\n", (UNDERWATER(ch)) ? "water" : "air");
      send_to_char(buf, ch);
      if (is_wearing(ch, ITEM_BREATHER))
        break;
      else if (is_wearing(ch, ITEM_VACSUIT))
	break;
      else if (is_wearing(ch, ITEM_ENVIRON))
	break;
      else
      {
	send_to_char("You can't breath, you are asphyxiating!\n\r", ch);
	//GET_HIT(ch) = MAX(GET_HIT(ch)-(GET_LEVEL(ch)*3), 0);
	damage(NULL, ch, MIN(GET_HIT(ch), GET_LEVEL(ch)*3), TYPE_UNDEFINED,
	       FALSE);
	if (GET_HIT(ch) < 0)
	{
	  send_to_char("You suffocate to death!\n\r", ch);
	  act("$n falls down gasping for breath and dies.", TRUE, ch, 0, 0, TO_ROOM); 
	  raw_kill(ch,NULL);
	  return(1);
	}
      }
      break;
    case SECT_VACUUM :
      send_to_char("You are in a vacuum.\n\r", ch);
      if (is_wearing(ch, ITEM_VACSUIT))
        break;
      else if (is_wearing(ch, ITEM_ENVIRON))
	break;
      else
      {
	send_to_char("You walk into a total vacuum, and your whole body explodes!\n\r", ch);
	act("$n enters a total vacuum and explodes, covering you with blood and gutsi!\n\r", TRUE, ch, 0, 0, TO_ROOM);
	raw_kill(ch,NULL);
	return(1);
      }  
      break;
    case SECT_CORROSIVE:
      sprintf(buf, "The %s here is thick with toxic chemicals.\r\n", (UNDERWATER(ch)) ? "water" : "air");
      send_to_char(buf, ch);
      if (!is_wearing(ch, ITEM_ENVIRON))
      {
	sprintf(buf, "The chemicals in the %s burn your lungs.\r\n", (UNDERWATER(ch)) ? "water" : "air");
        send_to_char(buf, ch);
        //GET_HIT(ch) -= 135;
	damage(NULL, ch, 135, TYPE_UNDEFINED, FALSE);
        if (GET_HIT(ch) < 0)
        {
          send_to_char("You fall down coughing up blood and die.\n\r", ch);
          act("$n falls down coughing up blood and gasping for breath, then dies!\n\r", TRUE, ch, 0, 0, TO_ROOM);   
          raw_kill(ch,NULL);
          return(1); 
        }
      }
      break;
    default:
      // TODO - handle this
      break;
  }
  switch(TEMPERATURE(sect_type))
  {
    case SECT_HOT :
      send_to_char("It is much hotter here than you are used to.\n\r", ch);
      if (is_wearing(ch, ITEM_HEATRES))
	break;
      else if (is_wearing(ch, ITEM_HEATPROOF))
	break;
      else if (!is_wearing(ch, ITEM_STASIS))   
      {
        send_to_char("The heat is really affecting you!\n\r", ch);
	//GET_HIT(ch) = MAX(GET_HIT(ch) - GET_LEVEL(ch), 0);
	damage(NULL, ch, MIN(GET_HIT(ch), GET_LEVEL(ch)), TYPE_UNDEFINED,
	       FALSE);
      }
      if (GET_HIT(ch) <= 0)
      {
        GET_POS(ch) = POS_STUNNED;
        act("$n falls down from heat exhaustion!", TRUE, ch, 0, 0, TO_ROOM);
      }
      break;
    case SECT_SCORCH :
      send_to_char("Its almost hot enough to melt lead here.\n\r", ch);
      if (is_wearing(ch, ITEM_HEATPROOF) || is_wearing(ch, ITEM_STASIS))   
	break;
      if (is_wearing(ch, ITEM_HEATRES))
	modifier = 2;
      send_to_char("Your skin is smouldering and blistering!\n\r", ch);
      //GET_HIT(ch) = MAX((GET_HIT(ch) - GET_LEVEL(ch)*2/modifier), 0);
      damage(NULL, ch, MIN(GET_HIT(ch), (int)(GET_LEVEL(ch)*2/modifier)),
	     TYPE_UNDEFINED, FALSE);
      if (GET_HIT(ch) <= 0)
      {
	send_to_char("Your whole body is reduced to a blistered mess, you fall down dead!\n\r", ch);
	act("$n falls down dead in a smouldering heap!", TRUE, ch, 0, 0, TO_ROOM);
	raw_kill(ch,NULL);
	return(1);
      }
      break;   
    case SECT_INCINERATE :
      send_to_char("You estimate that it is well over 3000 degrees here.\n\r", ch);
      send_to_char("Your skin catches fire! You are burnt to a cinder\n\r", ch);
      act("$n spontaneously combusts and is reduced to a charred mess on the ground!\n\r", TRUE, ch, 0, 0, TO_ROOM);
      raw_kill(ch,NULL);
      return(1);
      break;
    case SECT_COLD :
      send_to_char("Its much colder here than you are used to.\n\r", ch);
      if (is_wearing(ch, ITEM_COLD))
	break;
      else if (is_wearing(ch, ITEM_SUBZERO))
        break;
      else if (!is_wearing(ch, ITEM_STASIS))   
      {
	send_to_char("You shiver uncontrollably from the cold!\n\r", ch);
	//GET_HIT(ch) = MAX(GET_HIT(ch) - GET_LEVEL(ch), 0);
	damage(NULL, ch, MIN(GET_HIT(ch), GET_LEVEL(ch)), TYPE_UNDEFINED,
	       FALSE);
	if (GET_HIT(ch) <= 0)
	{
	  send_to_char("You fall down unconcious from hyperthermia!\n\r", ch);
	  GET_POS(ch) = POS_STUNNED;
	  act("$n falls down in a coma from hyperthermia!", TRUE, ch, 0, 0, TO_ROOM);
	}
      }
      break;
    case SECT_FREEZING :
      sprintf(buf, "The %s here is freezing.\r\n", (UNDERWATER(ch)) ? "water" : "air");
      send_to_char(buf, ch); 
      if (is_wearing(ch, ITEM_SUBZERO) || is_wearing(ch, ITEM_STASIS))   
	break;
      if (is_wearing(ch, ITEM_COLD))
	modifier = 2;
      send_to_char("You are suffering from severe frostbite!\n\r", ch);
      //GET_HIT(ch) = MAX(GET_HIT(ch) - (GET_LEVEL(ch)*2/modifier), 0);
      damage(NULL, ch, MIN(GET_HIT(ch), (int)(GET_LEVEL(ch)*2/modifier)),
	     TYPE_UNDEFINED, 0);
      if (GET_HIT(ch) <= 0)
      {
	send_to_char("You fall down dead from frostbite!\n\r", ch);
	act("$n falls down dead from frostbite and hyperthermia!", TRUE, ch, 0, 0, TO_ROOM);
	raw_kill(ch,NULL);
	return(1);
      }
      break;   
    case SECT_ABSZERO:
      send_to_char("It dosn't get much colder than this... absolute zero!\n\r", ch);
      send_to_char("Your body is frozen rock hard and shatters into many pieces!\n\r", ch);
      act("$n is frozen solid, tries to move and shatters into thousands of pieces!\n\r", TRUE, ch, 0, 0, TO_ROOM);
      raw_kill(ch,NULL);
      return(1);
      break;  
  }
  // Artus> Gravity isn't doing anything.. Lets fix that.. :o)
  if ((modifier = GRAVITY(sect_type)) > 0)
  {
    // Artus> For calculating damage in gravity.
    struct obj_data *weighing = NULL;
    int eqweight = 0;
    // First We'll Handle Crush.
    if (modifier == SECT_CRUSH)
    {
      send_to_char("You must be very near to a singularity, the gravity is approaching infinity.\r\nYour body cannot take it anymore!\r\n", ch);
      sprintf(buf, "%s killed by gravity at %s", GET_NAME(ch), world[ch->in_room].name);
      mudlog(buf, BRF, MAX(LVL_ANGEL, GET_INVIS_LEV(ch)), TRUE);
      raw_kill(ch,NULL);
      return(1);
    }

    for (int i = 0; i < NUM_WEARS; i++)
    {
      if (GET_EQ(ch, i))
      {
	if (GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_GRAV1)
	{
	  if (GRAVITY(sect_type) == SECT_DOUBLEGRAV)
	  {
	    eqweight = -1;
	    break;
	  } else
	    eqweight += (int)(GET_EQ_WEIGHT(ch, i)/2);
	  continue;
	}
	if (GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_GRAV3)
	{
	  eqweight = -2;
	  break;
	}
	eqweight += GET_EQ_WEIGHT(ch, i);
      } // Is Equipped.
    } // Check Wears.
    if (eqweight >= 0)
    {
      int maxdam = 0;
      if (modifier == SECT_DOUBLEGRAV)
      {
	send_to_char("You feel a little heavier than you are used to.\r\n", ch);
	eqweight *= 2;
	maxdam = GET_MAX_HIT(ch) / 10;
	maxdam = MAX(GET_MAX_HIT(ch) / 25, MIN(GET_MAX_HIT(ch)-1, (int)(maxdam * IS_CARRYING_W(ch) / CAN_CARRY_W(ch))));
      }
      if (modifier == SECT_TRIPLEGRAV)
      {
	send_to_char("You feel much heavier than you are used to.\r\n", ch);
	eqweight *= 3;
	maxdam = GET_MAX_HIT(ch) / 5;
	maxdam = MAX(GET_MAX_HIT(ch) / 15, MIN(GET_MAX_HIT(ch)-1, (int)(maxdam * IS_CARRYING_W(ch) / CAN_CARRY_W(ch))));
      }
      
      //GET_HIT(ch) = MAX(0,GET_HIT(ch) - number((int)(maxdam * 0.9),maxdam));
      damage(NULL, ch, MIN(GET_HIT(ch), number((int)(maxdam*0.9),maxdam)),
	     TYPE_UNDEFINED, FALSE);
      if (GET_HIT(ch) <= 0)
      {
	send_to_char("Your body can no longer support your weight.\r\n", ch);
	sprintf(buf, "$n is crushed to death by $s own %s!", 
		(eqweight == 0) ? "inventory" : "equipment");
	act(buf, TRUE, ch, 0, 0, TO_ROOM);
	sprintf(buf, "%s killed by gravity at %s", GET_NAME(ch), world[ch->in_room].name);
	mudlog(buf, BRF, MAX(LVL_ANGEL, GET_INVIS_LEV(ch)), TRUE);
	raw_kill(ch, NULL);
	return(1);
      }
    } else { // Eq found with gravity type. Send them a message anyway.
      send_to_char("Gravity hugs you a little tighter.\r\n", ch);
    }
  }

  switch(ENVIRON(sect_type))
  {
    case SECT_RAD1 :
      send_to_char("If you had a geiger counter it would be off the scale.\n\r", ch);
      if (is_wearing(ch, ITEM_RAD1PROOF))
        break;
      else if (!is_wearing(ch, ITEM_STASIS))
      {
	send_to_char("You feel decidedly sick in the stomach.  The radiation is really affecting you.\n\r", ch);
        //GET_HIT(ch) = MAX(GET_HIT(ch) - GET_LEVEL(ch), 0);
	damage(NULL, ch, MIN(GET_HIT(ch), GET_LEVEL(ch)), TYPE_UNDEFINED, 
	       FALSE);
      }
      if (GET_HIT(ch) <= 0)
      {
        act("$n passes out from radiation poisining!\n\r", TRUE, ch, 0, 0, TO_ROOM);
        send_to_char("You pass out from radiation poisoining!\n\r",ch);
        GET_POS(ch) = POS_STUNNED;
      }
      break;
    case SECT_DISPELL :
      send_to_char("Your body shivers as a flash of bright light stripps you of all spells!!!.\n\r", ch);
      while (ch->affected)
        affect_remove(ch, ch->affected);
      break;
    case SECT_DISPAIR1 :
    case SECT_DISPAIR2 :
    case SECT_DISPAIR3 :
      int depression = ENVIRON(sec_type) - 2; // gives a value 1 to 3
      // use the base sect type to remove some mana and mv
      // int depression = BASE_SECT(world[ch->in_room].sector_type) + 1;
      GET_MOVE(ch) -= 1+(depression * depression)/2;
      GET_MANA(ch) -= 1+depression * depression;
       
      // send a message to the char
      sprintf(buf2, "You are depressed by %d points\nSect type is %d\n", depression, BASE_SECT(world[ch->in_room].sector_type));
      send_to_char(buf2, ch);
      break;
  }
  return(0);
#endif
} 

// Artus> Check environment of all playing players.
void check_world_environment(void)
{
  struct descriptor_data *d;
  for (d = descriptor_list; d; d=d->next)
  {
    if (!(IS_PLAYING(d) && (d->character)))
      continue;
    check_environment_effect(d->character);
  }  
}

ACMD(do_go)
{
  /* this will be somewhat more sophisticated and allow players
     to board different obects, but for now we only new it for
     the pirate ship, so I'm just hard coding it for that */
  int invalid_level(struct char_data *ch, struct obj_data *object,
                    bool display);
  char arg1[MAX_INPUT_LENGTH];
  struct obj_data *obj;
  int was_in;
  room_rnum exitroom;

  one_argument(argument, arg1);
  if (!*arg1)
  {
    send_to_char("Go where??\n\r", ch);
    return;
  }
  if (!(obj = find_obj_list(ch, arg1, world[ch->in_room].contents)))
  {
    sprintf(buf, "You don't see %s %s here.\r\n", AN(arg1), arg1);
    send_to_char(buf, ch);
    return;
  }
  if (GET_OBJ_TYPE(obj) != ITEM_GATEWAY)
  {
    send_to_char("You can't 'go' to that!!\n\r", ch);
    return;
  }
  // Artus> Use Level Restrictions..
  if (invalid_level(ch, obj, FALSE) || IS_NPC(ch) ||
      LR_FAIL(ch, GET_OBJ_VAL(obj, 1)) || 
      ((GET_OBJ_VAL(obj, 2) > 0) && 
       (GET_OBJ_VAL(obj, 2) < GET_LEVEL(ch))))
  {
    sprintf(buf, "You cannot seem to enter %s.\r\n", OBJN(obj, ch));
    send_to_char(buf, ch);
    return;
  }
  // Artus> Tollway's.. Heh.
  if ((GET_OBJ_VAL(obj, 3) > 0) && (GET_LEVEL(ch) < LVL_IS_GOD))
  {
    if (GET_GOLD(ch) < GET_OBJ_VAL(obj, 3))
    {
      sprintf(buf, "It costs &Y%d&n to enter %s, which you can't afford.\r\n",
	      GET_OBJ_VAL(obj, 3), OBJN(obj, ch));
      send_to_char(buf, ch);
      return;
    }
  }
  if (((exitroom = real_room(GET_OBJ_VAL(obj, 0))) == NOWHERE) ||
      (exitroom > top_of_world))
  {
    sprintf(buf,"SYSERR: Portal %d: Invalid exit room (%d/%d) for %s.",
	    GET_OBJ_VNUM(obj), GET_OBJ_VAL(obj, 0), exitroom, OBJN(obj, ch));
    mudlog(buf, BRF, LVL_ANGEL, TRUE);
    send_to_char("It's broken!\r\n", ch);
    return;
  }
  // Artus> Make sure the room on the other side is safe.
  if (!char_can_enter(ch, &world[exitroom], TRUE))
    return;
  
/* this isn't right so we won't have movemment for 'go' for now
       if (GET_LEVEL(ch) < LVL_IS_GOD && !IS_NPC(ch))
        GET_MOVE(ch) -= need_movement;
*/
  if (!IS_AFFECTED(ch, AFF_SNEAK))
  {
    sprintf(buf2, "$n goes to the %s.", arg1);
    act(buf2, TRUE, ch, 0, 0, TO_ROOM); 
  }
  was_in = ch->in_room;
  char_from_room(ch);
  char_to_room(ch, real_room(GET_OBJ_VAL(obj, 0)));
  if (!IS_AFFECTED(ch, AFF_SNEAK))
    act("$n has arrived.", TRUE, ch, 0, 0, TO_ROOM);
  look_at_room(ch, 0);
  if ((GET_OBJ_VAL(obj, 3) > 0) && (GET_LEVEL(ch) < LVL_IS_GOD))
  {
    GET_GOLD(ch) -= GET_OBJ_VAL(obj, 3);
    sprintf(buf, "You notice you have &Y%d&n less coins.\r\n", 
	    GET_OBJ_VAL(obj, 3));
    send_to_char(buf, ch);
  }
}   
/* 
 * 	Code for mounts in Primal. Support for both mob and obj mount types.
 *
 *	Author: 	Jason Theofilos (Talisman)
 *	Date Started:	3rd December, 1999
 *	Last Modified: 	10th December, 1999
 *
 *	Location:	Melbourne, Australia
 * 	Language: 	C
 *
 */

/* OTHER FILES ALTERED:
	utils.h
	structs.h
	interpreter.c
	act.informative.c
	act.movement.c
	utils.c (circle_follow)
	act.offensive.c
	fight.c
	mobact.c
	db.c (mobloading)
	constants.c (flags) & (npc classes)
	handler.c
	act.wizard.c
 */


/* Breaks in (tames) a mob for riding */
ACMD(do_breakin) 
{
  struct char_data *victim;

  if (IS_NPC(ch))
    return;

  // Artus - Tali your slack again - could have made this a skill ...
  if (GET_SKILL(ch, SKILL_MOUNT) > 0) 
  {
    if (!has_stats_for_skill(ch, SKILL_MOUNT, TRUE))
      return;
  } else {
    send_to_char("You know nothing about mounting.\r\n", ch);
    return;
  }

  // Find the target
  one_argument(argument, arg);
	
  if (!*arg)
  {
    send_to_char("Just what would you like to break in?\r\n", ch);
    return;
  }	

  // Check the target is present
  if (!(victim = generic_find_char(ch, arg, FIND_CHAR_ROOM)))
  {
    send_to_char("Noone here by that name.\r\n", ch);
    return;
  }

  // Fighting?
  if (FIGHTING(ch) || FIGHTING(victim))
  {
    send_to_char("You can't do that now!\r\n", ch);
    return;
  }

  // Taming themselves?
  if (victim == ch)
  {
    send_to_char("You break yourself in, and feel quite susceptible to being "
                 "ridden.\r\n",ch);
    return;
  }

  if (MOB_FLAGGED(victim, MOB_AGGRESSIVE)) {
    act("$N is too aggressive to be broken in.", FALSE, ch, 0, victim,
        TO_CHAR);
    return;
  }

  if (AFF_FLAGGED(victim, AFF_BROKEN_IN)) {
    act("$N is already broken in.", FALSE, ch, 0, victim, TO_CHAR );
    return;
  }		
	
  // Is the mob mountable? 
  if (MOB_FLAGGED(victim, MOB_MOUNTABLE) && 
      (number(0, 101) < GET_SKILL(ch, SKILL_MOUNT))) //Artus> 101 = Failure.
  {
    /* Check for skill here */
    act("You successfully break $N in.", FALSE, ch, 0, victim, TO_CHAR);
      SET_BIT(AFF_FLAGS(victim), AFF_BROKEN_IN);
  } else {
    act("You try to break $N in, but $E does not respond well.", 
                    FALSE, ch, 0, victim, TO_CHAR);
    if (LR_FAIL(ch, LVL_IMMORT))
      do_violent_skill(victim, ch->player.name, 0, SCMD_HIT);	
  }
}

/* Performs the mounting manouevre on a mobile or appropriate object */
/* Is it just me or does all this sound a bit sus?  - Tal */
ACMD(do_mount) 
{
  int bits;
  struct char_data *found_char = NULL;
  struct obj_data *found_obj = NULL;

  if (IS_NPC(ch)) 
    return;

  one_argument(argument, arg);

  // DM - Tali your slack again - could have made this a skill ...
  if (GET_SKILL(ch, SKILL_MOUNT) > 0) 
  {
    if (!has_stats_for_skill(ch, SKILL_MOUNT, TRUE))
      return;
  } else {
    send_to_char("You know nothing about mounting.\r\n", ch);
    return;
  }

  if (!*arg)
  {
    send_to_char("Mount what?\r\n", ch);
    return;
  }

  // Check character is not already mounted
  if (MOUNTING(ch) || MOUNTING_OBJ(ch))
  {
    send_to_char("You're already mounted!\r\n", ch);
    return; 
  }

  bits = generic_find(arg, FIND_CHAR_ROOM | /* FIND_OBJ_ROOM |*/ 
                           FIND_OBJ_INV |  FIND_OBJ_EQUIP, ch, 
			   &found_char, &found_obj);

  // Character found 
  if (found_char != NULL)
  {
    // Check that the char is mountable
    if (!MOB_FLAGGED(found_char, MOB_MOUNTABLE))
    {
      send_to_char("You can't mount that!\r\n", ch);
      return;
    }	

    // Check if it's tamed
    if (!AFF_FLAGGED(found_char, AFF_BROKEN_IN))
    {
      send_to_char("This beastie's a bit too wild for you.\r\n", ch);
      act("$n hopelessly chases $N around, trying to mount $M.", 
                      FALSE, ch, 0,found_char, TO_ROOM);
      return;
    }	

    // Check that noone is riding it already
    if (MOUNTING(found_char))
    {
      act("Someone is already riding $M.", FALSE, ch, 0, found_char, TO_CHAR);
      return;
    }	

    // Mount the beast.
    act("With a flourish you mount $N.", FALSE, ch, 0, found_char,TO_CHAR);
    act("$n gracefully mounts $N.", FALSE, ch, 0, found_char, TO_ROOM);
    MOUNTING(ch) = found_char;
    MOUNTING(found_char) = ch;
    return;
  }

  // Is it an item
  if (found_obj != NULL)
  {
    // Check that the target item is mountable
    if (!OBJ_FLAGGED(found_obj, ITEM_RIDDEN))
    {
      send_to_char("You can't mount that!\r\n", ch);
      return;
    }

    // Check it is not already being ridden
    if (OBJ_RIDDEN(found_obj))
    {
      send_to_char("It is already being ridden.\r\n", ch);
      return;
    }	

    // Mount it
    sprintf(buf, "You mount %s.\r\n", found_obj->short_description);
    send_to_char(buf, ch);
    sprintf(buf, "%s mounts %s.", 
                    GET_NAME(ch),found_obj->short_description);
    act(buf, FALSE, ch, 0, 0, TO_ROOM);
    MOUNTING_OBJ(ch) = found_obj;
    OBJ_RIDDEN(found_obj) = ch;		
    return;	
  }
	
  // Nothing found
  send_to_char("Nothing here by that name.\r\n", ch);
}

ACMD(do_dismount)
{
  struct char_data *mount;
  struct obj_data *obj_mount;

  if (IS_NPC(ch)) 
    return;

  // May as well make it a social too
  if (!MOUNTING(ch) && !MOUNTING_OBJ(ch))
  {
    send_to_char("You get off your high horse.\r\n", ch);
    act("$n gets off $s high horse.", FALSE, ch, 0, 0, TO_ROOM);
    return;
  }

  // Mobile dismount
  if (MOUNTING(ch))
  {
    // Get the mount
    mount = MOUNTING(ch);
    // Get a keyword
    one_argument(mount->player.name, arg);
    // If it is not visible ...
    if (mount != generic_find_char(ch, arg, FIND_CHAR_ROOM))
    {
      send_to_char("Oh dear, you seem to have lost your ride.\r\n", ch);
      send_to_char("... you fall off your imaginary mount.\r\n", ch);
      act("$n falls off $s imaginary mount.\r\n", FALSE, ch, 0, 0, TO_ROOM);
    } else {
      // Dismount successful.
      send_to_char("You dismount.\r\n", ch);
      act("$n easily hops off $N.", FALSE, ch, 0, mount, TO_ROOM);
    } 

    // Regardless of whether the player can see it or not, dismount. 
    MOUNTING(mount) = NULL;
    MOUNTING(ch) = NULL;
    GET_POS(ch) = POS_STANDING;
    return;
  }

  // Item dismount
  if (MOUNTING_OBJ(ch))
  {
    // Get the object
    obj_mount = MOUNTING_OBJ(ch);
    // Check it's being carried or is in the room
    if (!((obj_mount != 
           find_obj_list(ch, obj_mount->name, ch->carrying)) || 
       (obj_mount != 
        find_obj_list(ch, obj_mount->name,world[ch->in_room].contents)) ||
       (obj_mount != generic_find_obj(ch, obj_mount->name, FIND_OBJ_EQUIP))))
    {
      send_to_char("Oh dear, you seem to have lost your ride.\r\n", ch);
      send_to_char("... you fall off your imaginary mount.\r\n", ch);
      act("$n falls off $s imaginary mount.\r\n", FALSE, ch, 0, 0, TO_ROOM);
    } else {
      send_to_char("You dismount.\r\n", ch);
      act("$n easily hops off $N.", FALSE, ch, obj_mount, 0, TO_ROOM);
    }

    // Dismount
    OBJ_RIDDEN(obj_mount) = NULL;
    MOUNTING_OBJ(ch) = NULL;
    GET_POS(ch) = POS_STANDING;
    return;
  }
}
@


1.71
log
@Artus> Mostly looks like indent changes.. And a modification to determine
       whether we're moving, or fleeing.
@
text
@d2377 11
a2387 1

d2416 7
@


1.70
log
@Artus> IMMORT Rooms now only require LVL_CHAMP.
@
text
@d463 2
a464 1
static void do_environ_leave_message(struct char_data *ch, int dir) {
a465 1

d476 3
a478 1
static void do_environ_arrive_message(struct char_data *ch, int dir) {
a479 1

d491 2
a492 1
int do_simple_move(struct char_data *ch, int dir, int need_specials_check)
d505 2
a506 1
  if (AFF_FLAGGED(ch, AFF_CHARM) && ch->master && ch->in_room == ch->master->in_room)
d519 1
a519 2
  else
  if (BASE_SECT(world[EXIT(ch,dir)->to_room].sector_type) == SECT_WATER_NOSWIM)
d521 1
a521 2
  else
  if (IS_AFFECTED(ch,AFF_FLY))
d523 1
a523 2
  else
  if (MOUNTING(ch) || MOUNTING_OBJ(ch))        // Mounts go anywhere for 1 move
a533 1
	
d572 5
a576 1
  if (!AFF_FLAGGED(ch, AFF_SNEAK) || (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_TAG)))
a587 1

d606 1
a606 1
  if (!AFF_FLAGGED(ch, AFF_SNEAK) || (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_TAG)))
d609 2
a610 1
      act("$n, mounted on $N, has arrived.", TRUE, ch, 0, MOUNTING(ch), TO_ROOM);
a621 1

a623 1

d663 1
a663 1
  } else {
a664 2
  }

d880 2
a881 1
  if (IS_AFFECTED(ch, AFF_PARALYZED)) {
a884 1

d898 4
a901 3

  if (*dir) {			/* a direction was specified */
    if ((door = search_block(dir, dirs, FALSE)) == -1) {	/* Partial Match */
d906 4
a909 2
    if (EXIT(ch, door)) {	/* Braces added according to indent. -gg */
      if (EXIT(ch, door)->keyword) {
d912 4
a915 2
	else {
          if (dispMessages) {
d924 2
a925 1
      if (dispMessages) {
d927 1
a927 1
                        cmdname);
d933 4
a936 2
    if (!*type) {
      if (dispMessages) {
d943 5
a947 6
      if (EXIT(ch, door))
	if (EXIT(ch, door)->keyword)
	  if (isname(type, EXIT(ch, door)->keyword))
	    return (door);

    if (dispMessages) {
a954 1

d1020 4
a1023 5
  if (obj) {
    if (GET_OBJ_DAMAGE(obj) == 0) {
      send_to_char("Nope, its broken. Perhaps you should fix it!\r\n", ch);
      return;
    }
d1027 1
a1027 1
  if (scmd == SKILL_PICK_LOCK) {
d1029 1
a1029 1
  } else {
a1030 1
  }
d1032 28
a1059 27
  if (!obj && ((other_room = EXIT(ch, door)->to_room) != NOWHERE))
    if ((back = world[other_room].dir_option[rev_dir[door]]) != NULL)
      if (back->to_room != ch->in_room)
	back = 0;

  switch (scmd) {
  case SCMD_OPEN:
  case SCMD_CLOSE:
    OPEN_DOOR(ch->in_room, obj, door);
    if (back)
      OPEN_DOOR(other_room, obj, rev_dir[door]);
    send_to_char(OK, ch);
    break;
  case SCMD_UNLOCK:
  case SCMD_LOCK:
    LOCK_DOOR(ch->in_room, obj, door);
    if (back)
      LOCK_DOOR(other_room, obj, rev_dir[door]);
    send_to_char("*Click*\r\n", ch);
    break;
  case /*SCMD_PICK*/SKILL_PICK_LOCK:
    LOCK_DOOR(ch->in_room, obj, door);
    if (back)
      LOCK_DOOR(other_room, obj, rev_dir[door]);
    send_to_char("The lock quickly yields to your skills.\r\n", ch);
    strcpy(buf, "$n skillfully picks the lock on ");
    break;
a1060 1

d1062 2
a1063 2
  sprintf(buf2, "%s%s.", ((obj) ? "" : "the "), (obj) ? "$p" :
	  (EXIT(ch, door)->keyword ? "$F" : "door"));
d1071 2
a1072 1
  if ((scmd == SCMD_OPEN || scmd == SCMD_CLOSE) && back) {
d1074 1
a1074 1
	 (back->keyword ? fname(back->keyword) : "door"), cmd_door[scmd],
d1076 2
a1077 1
    if (world[EXIT(ch, door)->to_room].people) {
a1083 1

d1089 2
a1090 2

  if (scmd == SKILL_PICK_LOCK/*SCMD_PICK*/) {
d1097 2
a1098 1
    else {
a1106 1

a1126 1

d1140 2
a1141 1
  if (!*argument) {
a1145 1

d1153 1
a1153 1
  if (!obj) {
a1154 1
  }
d1163 14
a1176 18
  if (obj) 
    if (GET_OBJ_TYPE(obj) == ITEM_TRAP)
    {
      if (IS_THIEF(ch))
        chance = 15;
      else if (IS_MAGIC_USER(ch))
        chance = 5;
      else
        chance = 2;

      if (number(1, chance) == chance) 
        ch_trigger_trap(ch, obj);
      else
        send_to_char("Strange, it won't budge.\r\n", ch);

      return;
    }

a1202 2


d1208 3
a1210 3

  if (*buf) {			/* an argument was supplied, search for door
				 * keyword */
d1212 6
a1217 6
      if (EXIT(ch, door))
	if (EXIT(ch, door)->keyword)
	  if (!str_cmp(EXIT(ch, door)->keyword, buf)) {
	    perform_move(ch, door, 1);
	    return;
	  }
d1222 2
a1223 1
  else {
d1226 7
a1232 7
      if (EXIT(ch, door))
	if (EXIT(ch, door)->to_room != NOWHERE)
	  if (!EXIT_FLAGGED(EXIT(ch, door), EX_CLOSED) &&
	      ROOM_FLAGGED(EXIT(ch, door)->to_room, ROOM_INDOORS)) {
	    perform_move(ch, door, 1);
	    return;
	  }
a1236 1

d1243 2
a1244 1
  else {
d1246 7
a1252 7
      if (EXIT(ch, door))
	if (EXIT(ch, door)->to_room != NOWHERE)
	  if (!EXIT_FLAGGED(EXIT(ch, door), EX_CLOSED) &&
	    !ROOM_FLAGGED(EXIT(ch, door)->to_room, ROOM_INDOORS)) {
	    perform_move(ch, door, 1);
	    return;
	  }
a1256 1

a1258 1

d1266 28
a1293 27
  switch (GET_POS(ch)) {
  case POS_STANDING:
    send_to_char("You are already standing.\r\n", ch);
    break;
  case POS_SITTING:
    send_to_char("You stand up.\r\n", ch);
    act("$n clambers to $s feet.", TRUE, ch, 0, 0, TO_ROOM);
    /* Will be sitting after a successful bash and may still be fighting. */
    GET_POS(ch) = FIGHTING(ch) ? POS_FIGHTING : POS_STANDING;
    break;
  case POS_RESTING:
    send_to_char("You stop resting, and stand up.\r\n", ch);
    act("$n stops resting, and clambers on $s feet.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_STANDING;
    break;
  case POS_SLEEPING:
    send_to_char("You have to wake up first!\r\n", ch);
    break;
  case POS_FIGHTING:
    send_to_char("Do you not consider fighting as standing?\r\n", ch);
    break;
  default:
    send_to_char("You stop floating around, and put your feet on the ground.\r\n", ch);
    act("$n stops floating around, and puts $s feet on the ground.",
	TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_STANDING;
    break;
d1300 26
a1325 25
  switch (GET_POS(ch)) {
  case POS_STANDING:
    send_to_char("You sit down.\r\n", ch);
    act("$n sits down.", FALSE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    break;
  case POS_SITTING:
    send_to_char("You're sitting already.\r\n", ch);
    break;
  case POS_RESTING:
    send_to_char("You stop resting, and sit up.\r\n", ch);
    act("$n stops resting.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    break;
  case POS_SLEEPING:
    send_to_char("You have to wake up first.\r\n", ch);
    break;
  case POS_FIGHTING:
    send_to_char("Sit down while fighting? Are you MAD?\r\n", ch);
    break;
  default:
    send_to_char("You stop floating around, and sit down.\r\n", ch);
    act("$n stops floating around, and sits down.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    break;
a1328 1

a1330 1

d1333 2
a1334 2
	send_to_char("You cannot rest while mounted.\r\n", ch);
	return;
d1337 2
a1338 1
  if (!IS_NPC(ch) && (char_affected_by_timer(ch, TIMER_MEDITATE) || char_affected_by_timer(ch, TIMER_HEAL_TRANCE))) 
d1376 2
a1377 1
  if (!IS_NPC(ch) && (char_affected_by_timer(ch, TIMER_MEDITATE) || char_affected_by_timer(ch, TIMER_HEAL_TRANCE))) 
a1381 1

a1386 1
 
a1391 1

a1415 1

d1422 2
a1423 1
  if (*arg) {
d1436 2
a1437 1
    else {
d1449 2
a1450 1
  else {
a1456 1

d1480 4
a1483 2
  if (AFF_FLAGGED(ch, AFF_CHARM) && (ch->master)) {
    act("But you only feel like following $N!", FALSE, ch, 0, ch->master, TO_CHAR);
d1772 2
a1773 1
	act("$n falls down in a coma from hyperthermia!", TRUE, ch, 0, 0, TO_ROOM);
d1777 2
a1778 1
      sprintf(buf, "The %s here is freezing.\r\n", (UNDERWATER(ch)) ? "water" : "air");
d1807 2
a1808 1
      send_to_char("It dosn't get much colder than this... absolute zero!\n\r", ch);
d2457 2
a2458 1
  if (!*arg) {
d2471 2
a2472 1
  if (FIGHTING(ch) || FIGHTING(victim)) {
d2478 2
a2479 1
  if (victim == ch) {
d2534 2
a2535 1
  if (!*arg) {
d2541 2
a2542 1
  if (MOUNTING(ch) || MOUNTING_OBJ(ch)) {
d2552 2
a2553 1
  if (found_char != NULL) {
d2555 2
a2556 1
    if (!MOB_FLAGGED(found_char, MOB_MOUNTABLE)) {
d2562 2
a2563 1
    if (!AFF_FLAGGED(found_char, AFF_BROKEN_IN)) {
d2571 2
a2572 1
    if (MOUNTING(found_char)) {
d2586 2
a2587 2
  if (found_obj != NULL) {

d2589 2
a2590 1
    if (!OBJ_FLAGGED(found_obj, ITEM_RIDDEN)) {
d2596 2
a2597 1
    if (OBJ_RIDDEN(found_obj)) {
@


1.69
log
@Artus> Implemented Skeleton Key.
@
text
@d129 1
a129 1
    mudlog(buf, BRF, LVL_IMMORT, TRUE);
d286 3
a288 3
      (IS_SET(flag, ROOM_LR_IMM) && LR_FAIL(ch, LVL_IMMORT)) ||
      (IS_SET(flag, ROOM_LR_ANG) && LR_FAIL(ch, LVL_ANGEL)) ||
      (IS_SET(flag, ROOM_LR_GOD) && LR_FAIL(ch, LVL_GOD)) ||
d2383 1
a2383 1
    mudlog(buf, BRF, LVL_IMMORT, TRUE);
@


1.68
log
@Artus> PRF_FLAGGED(i, PRF_NOHASSLE) => PRF_FLAGGED(ch, PRF_NOHASSLE)
       Also, moved NOHASSLE and GHOST checks outside loop.
@
text
@d950 1
d956 1
d959 8
d1133 1
a1133 1
  if (cmdindex == SKILL_PICK_LOCK) {
a1134 1
  }
d1162 2
a1163 1
    if (GET_OBJ_TYPE(obj) == ITEM_TRAP) {
d1179 2
a1180 1
  if ((obj) || (door >= 0)) {
@


1.67
log
@Artus> Just some tidying up.
@
text
@d715 3
d722 1
a722 1
	!CAN_SEE(ch, i) || IS_GHOST(ch) || PRF_FLAGGED(i, PRF_NOHASSLE))
@


1.66
log
@Artus> Required changes for new find_xxx functions.
@
text
@d63 4
a66 1
void EscapeAll(struct char_data *escaper, struct char_data *master, int room) {
d68 37
a104 41
	struct follow_type *tmp;
	int escapecount = 0;

	for(tmp = master->followers; tmp; tmp = tmp->next) {
		if (tmp->follower == escaper) // leave self for last
			continue;
		if (tmp->follower->in_room != escaper->in_room)
			continue;

	        act("$n manages to find $s way out, and your group escapes.\r\n", FALSE,
			escaper, 0, tmp->follower, TO_VICT);
		char_from_room(tmp->follower);
		char_to_room(tmp->follower, room);
		act("$n has arrives, looking hurried.", FALSE, tmp->follower, 0, 0, TO_ROOM);
		look_at_room(tmp->follower, 0);
		escapecount++;
	}		

	// Now move the master
	if (master != escaper) {
	   act("$n manages to find $s way out, and your group escapes.\r\n", FALSE,
		escaper, 0, master, TO_VICT);
           char_from_room(master);
           char_to_room(master, room);
           act("$n has arrives, looking hurried.", FALSE, master, 0, 0, TO_ROOM);
           look_at_room(master, 0);
	   escapecount++;
	}
	
	// At this stage, the escaper is the only one left, whether master or not
	act("$n leads $s group to safety.", FALSE, escaper, 0, 0, TO_ROOM);
	if (escapecount)		
	  act("You manage to find your way out, and your group escapes with you.\r\n", 
		FALSE, escaper, 0, 0, TO_CHAR);
	else
	  act("You manage to find your way out, but none of your group were nearby to follow.\r\n", 
		FALSE, escaper, 0, 0, TO_CHAR);
	char_from_room(escaper);
	char_to_room(escaper, room);
 	act("$n has arrives, looking hurried.", FALSE, escaper, 0, 0, TO_ROOM);
	look_at_room(escaper, 0);
d107 2
a108 1
ACMD(do_recall) {
d125 2
a126 1
  if (room_num <= 0) {
a131 1

a133 1

d142 3
a144 1
ACMD(do_escape) {
d146 17
a162 37
     int room;

     if (IS_NPC(ch) ) {
	send_to_char("Nup, you're stuck as an NPC forever!\r\n", ch);
	return;
     }

     if (!IS_SET(GET_SPECIALS(ch), SPECIAL_ESCAPE)) {
	send_to_char("You try to escape the drudgery of your life.\r\n", ch);
	act("$n goes into denial.", FALSE, ch, 0, 0, TO_ROOM);
	return;
     }

     if (BASE_SECT(ch->in_room)  != SECT_INSIDE  && !ROOM_FLAGGED(ch->in_room, ROOM_INDOORS)) {
	send_to_char("You're already outside!\r\n", ch);
	return;
     }

     if ( (room = Escape(ch)) != NOWHERE ) {
	// Check if they're groupped
	if (AFF_FLAGGED(ch, AFF_GROUP)) {
		if (ch->master) 
		  EscapeAll(ch, ch->master, room);
		else
		  EscapeAll(ch, ch, room);
        }
	else {
          act("You manage to find your way out, and escape your surroundings.\r\n",FALSE,
		ch, 0, 0, TO_CHAR);
	  char_from_room(ch);
	  char_to_room(ch, room);
	  act("$n arrives looking hurried.\r\n", FALSE, ch, 0, 0, TO_ROOM);
	  look_at_room(ch, 0);
	}
     }
     else 
	send_to_char("You try to remember your way back out, and escape, but are unable to.\r\n", ch);
d164 19
@


1.65
log
@Artus> Aggro changes, Debug Eqfind.
@
text
@d1418 1
a1418 1
    else if ((vict = get_char_vis(ch, arg, FIND_CHAR_ROOM)) == NULL)
d1454 4
a1457 2
  if (*buf) {
    if (!(leader = get_char_vis(ch, buf, FIND_CHAR_ROOM))) {
d1466 2
a1467 1
  if (ch->master == leader) {
d1474 4
a1477 2
    if (leader == ch) {
      if (!ch->master) {
d1483 2
a1484 1
      if (circle_follow(ch, leader)) {
d2342 1
a2342 1
  if (!(obj = get_obj_in_list_vis(ch, arg1, world[ch->in_room].contents)))
d2449 2
a2450 1
  if (!(victim = get_char_vis(ch, arg, FIND_CHAR_ROOM))) {
d2592 2
a2593 2
ACMD(do_dismount) {

a2595 1
  int tmp = 0;
d2601 2
a2602 1
  if (!MOUNTING(ch) && !MOUNTING_OBJ(ch)) {
d2609 2
a2610 1
  if (MOUNTING(ch)) {
d2616 2
a2617 1
    if (mount != get_char_vis(ch, arg, FIND_CHAR_ROOM)) {
d2635 2
a2636 1
  if (MOUNTING_OBJ(ch)) {
d2641 1
a2641 1
           get_obj_in_list_vis(ch, obj_mount->name, ch->carrying)) || 
d2643 3
a2645 4
        get_obj_in_list_vis(ch, obj_mount->name,world[ch->in_room].contents)) ||
       (obj_mount != 
        get_object_in_equip_vis(ch, obj_mount->name, ch->equipment, &tmp))) ) {

@


1.64
log
@Artus> Fixed bug that allowed you to rest whilst meditating.
@
text
@d673 3
a675 1
  extern struct index_data *mob_index;	/* For aggravate check. */
d682 3
a684 2
  for (struct char_data *i = world[ch->in_room].people; 
      i && ch->in_room != NOWHERE; i = i->next_in_room)
d686 1
a686 4
    if ((i == ch) || (FIGHTING(i)) || (GET_POS(i) <= POS_SLEEPING))
      continue;

    if (IS_NPC(ch)) 
d688 2
a690 14
        continue;
      if (!CAN_SEE(ch, i))
        continue;
      if (PUN_FLAGGED(i, PUN_AGGRAVATE)) 
      {
        act("$n senses dishonour in you, and attacks hastily.", FALSE, ch, 0, i, TO_VICT );
        hit(ch, i, TYPE_UNDEFINED);
        return;
      }
      if (!IS_GHOST(i) && !PRF_FLAGGED(i, PRF_NOHASSLE) && 
	  (MOB_FLAGGED(ch, MOB_AGGRESSIVE) ||
           (MOB_FLAGGED(ch, MOB_AGGR_EVIL) && IS_EVIL(i)) ||
           (MOB_FLAGGED(ch, MOB_AGGR_NEUTRAL) && IS_NEUTRAL(i)) ||
           (MOB_FLAGGED(ch, MOB_AGGR_GOOD) && IS_GOOD(i)))) 
d692 28
a719 9
        if (number(0, 25) <= GET_REAL_CHA(i)) 
	{
          act("$n looks at $N with an indifference.",FALSE, ch, 0, i, TO_NOTVICT);
          act("$N looks at you with an indifference.",FALSE, i, 0, ch, TO_CHAR);
        } else {
          hit(ch, i, TYPE_UNDEFINED);
          return;
        } /* CHA Check */
      } /* Aggressive Check */
d721 10
a730 33
    } /* NPC Check */

    /* ch is a player */
    if (!IS_NPC(i)) 
      continue;
    if (!CAN_SEE(i, ch))
      continue;

    // Artus> Moved aggravate punishment here.
    if (PUN_FLAGGED(ch, PUN_AGGRAVATE) && (i->in_room == ch->in_room) && (FIGHTING(i) == NULL) && (CAN_SEE(i, ch)) && (AWAKE(i)) && (mob_index[GET_MOB_RNUM(i)].func != shop_keeper) && !MOB_FLAGGED(i, MOB_NOKILL)) 
    {
      act("$n senses dishonour in you, and attacks hastily.", FALSE, i, 0, ch, TO_VICT);
      hit(i, ch, TYPE_UNDEFINED);
    }

    // Artus> Sneak.
    if (AFF_FLAGGED(ch, AFF_SNEAK) && !AFF_FLAGGED(i, AFF_SENSE_LIFE) &&
        (number(1, 101) < GET_SKILL(ch, SKILL_SNEAK)))
	continue;

    if (!IS_GHOST(ch) && !PRF_FLAGGED(ch, PRF_NOHASSLE) && 
	(MOB_FLAGGED(i, MOB_AGGRESSIVE) ||
         (MOB_FLAGGED(i, MOB_AGGR_EVIL) && IS_EVIL(ch)) ||
         (MOB_FLAGGED(i, MOB_AGGR_NEUTRAL) && IS_NEUTRAL(ch)) ||
         (MOB_FLAGGED(i, MOB_AGGR_GOOD) && IS_GOOD(ch)))) {
      if (number(0, 25) <= GET_REAL_CHA(i))
      {
        act("$n looks at $N with an indifference.",FALSE, i, 0, ch, TO_NOTVICT);
        act("$N looks at you with an indifference.",FALSE, ch, 0, i, TO_CHAR);
      } else {
        hit(i, ch, TYPE_UNDEFINED);
      } /* CHA Check */
    } /* Aggressive Check */
@


1.63
log
@Artus> Changed logic slightly, hopefully will prevent crash.
@
text
@d1338 2
a1339 1
  if (MOUNTING(ch)) {
d1343 32
a1374 25
  switch (GET_POS(ch)) {
  case POS_STANDING:
    send_to_char("You sit down and rest your tired bones.\r\n", ch);
    act("$n sits down and rests.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_RESTING;
    break;
  case POS_SITTING:
    send_to_char("You rest your tired bones.\r\n", ch);
    act("$n rests.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_RESTING;
    break;
  case POS_RESTING:
    send_to_char("You are already resting.\r\n", ch);
    break;
  case POS_SLEEPING:
    send_to_char("You have to wake up first.\r\n", ch);
    break;
  case POS_FIGHTING:
    send_to_char("Rest while fighting?  Are you MAD?\r\n", ch);
    break;
  default:
    send_to_char("You stop floating around, and stop to rest your tired bones.\r\n", ch);
    act("$n stops floating around, and rests.", FALSE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    break;
@


1.62
log
@Artus> Chagnes for object spells.
@
text
@d789 2
a790 1
  else if (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE)
d792 6
a797 2
  else if (EXIT_FLAGGED(EXIT(ch, dir), EX_CLOSED)) {
    if (EXIT(ch, dir)->keyword) {
d800 8
a807 6
    } else
      send_to_char("It seems to be closed.\r\n", ch);
  } else {
    // DM - check for SKILL_DETECT_DEATH
    if (!IS_NPC(ch) && is_death_room(EXIT(ch, dir)->to_room))
      death_room = TRUE;
d809 3
a811 1
    if (!ch->followers)
d813 9
a821 12
      if (!IS_NPC(ch) && (is_death_room(EXIT(ch, dir)->to_room)))
      {
        if ((prob=GET_SKILL(ch, SKILL_DETECT_DEATH)) > 0)
	{ 
          percent = number(1, 101);     /* 101% is a complete failure */
          if (percent <= prob)
	  {
            send_to_char("You sense that moving in that direction will lead to your death.\r\n",ch);
	    apply_spell_skill_abil(ch, SKILL_DETECT_DEATH);
            return 0; 
          } 
        }
a822 5
      if (do_simple_move(ch, dir, need_specials_check) == 1) {
        post_move_checks(ch);
        return 1;
      } 
      return 0;
d824 7
d832 2
a833 2
    // Group Movement
    was_in = ch->in_room;
d835 2
a836 2
    if (!do_simple_move(ch, dir, need_specials_check))
      return (0);
d838 4
a841 1
    if (death_room)
d843 2
a844 2
      // Find the char with the best SKILL_DETECT_DEATH
      for (k = ch->followers; k; k = next)
d846 2
a847 2
        next = k->next;
        if (!IS_NPC(k->follower) && (k->follower->in_room == was_in))
d849 3
a851 7
          this_skill = GET_SKILL(k->follower, SKILL_DETECT_DEATH);
          if (this_skill > best_skill)
	  {
            best_skill = this_skill;
            best_char = k->follower;
          }
        }
d853 1
d855 6
a860 1
      if (best_skill > 0)
d862 1
a862 4
        percent = number(1, 101);     /* 101% is a complete failure */
        prob = GET_SKILL(ch, SKILL_DETECT_DEATH);
 
        if (percent <= prob)
d864 2
a865 1
          for (k = ch->followers; k; k = next)
d867 11
a877 14
            next = k->next;
            if (k->follower->in_room == was_in)
	    {
              if (k->follower == best_char)
                send_to_char("You sense that moving in that direction will lead to your death.\r\n",ch);
              else
	        act("$N senses moving in that direction will lead to the group's demise.\r\n", FALSE, best_char, 0, ch, TO_CHAR);
            }
          }
	  apply_spell_skill_abil(ch, SKILL_DETECT_DEATH);
          return (0); 
        }
      } 
    }
d879 8
a886 7
    for (k = ch->followers; k; k = next) {
      next = k->next;
      if ((k->follower->in_room == was_in) &&
     	  (GET_POS(k->follower) >= POS_STANDING)) {
	act("You follow $N.\r\n", FALSE, k->follower, 0, ch, TO_CHAR);
	perform_move(k->follower, dir, 1);
      }
a887 1
    return (1);
d889 1
a889 1
  return (0);
@


1.61
log
@Artus> Now warning free :o)
@
text
@d1933 1
a1933 1
	if (af->duration != CLASS_ABILITY)
@


1.60
log
@Artus> Fixed logging issues.
@
text
@d493 1
a493 4
  int need_movement, has_boat = 0;
  struct obj_data *obj;
  struct char_data *tmp_ch;
  extern struct index_data *mob_index;
a672 1
  struct char_data *i;
d755 1
a755 1
  struct char_data *best_char;
a1125 1
  bool checking = TRUE;
a1976 2
  int modifier = 1; /* modifier is so half damage is done in freeze/scorch */
                    /* rooms if wearing minimal protection                 */
@


1.59
log
@Artus> Fixed slots.
       Zone level restrictions now apply the same way as item LRs.
@
text
@d576 1
a576 1
  if (!AFF_FLAGGED(ch, AFF_SNEAK) || PRF_FLAGGED(ch, PRF_TAG))
d607 1
a607 1
  if (!AFF_FLAGGED(ch, AFF_SNEAK) || PRF_FLAGGED(ch, PRF_TAG))
d692 2
a695 2
      if (IS_NPC(i))
        continue;
@


1.58
log
@Artus> Changes to fix tag.
       No more sleeping whilst meditating.
@
text
@d188 2
d199 53
a251 22
  if ((IS_SET(flag, ZN_LR_5) && LR_FAIL(ch, 5))
       ||(IS_SET(flag, ZN_LR_10) && LR_FAIL(ch, 10))
       ||(IS_SET(flag, ZN_LR_15) && LR_FAIL(ch, 15))
       ||(IS_SET(flag, ZN_LR_20) && LR_FAIL(ch, 20))
       ||(IS_SET(flag, ZN_LR_25) && LR_FAIL(ch, 25))
       ||(IS_SET(flag, ZN_LR_30) && LR_FAIL(ch, 30))
       ||(IS_SET(flag, ZN_LR_35) && LR_FAIL(ch, 35))
       ||(IS_SET(flag, ZN_LR_40) && LR_FAIL(ch, 40))
       ||(IS_SET(flag, ZN_LR_45) && LR_FAIL(ch, 45))
       ||(IS_SET(flag, ZN_LR_50) && LR_FAIL(ch, 50))
       ||(IS_SET(flag, ZN_LR_55) && LR_FAIL(ch, 55))
       ||(IS_SET(flag, ZN_LR_60) && LR_FAIL(ch, 60))
       ||(IS_SET(flag, ZN_LR_65) && LR_FAIL(ch, 65))
       ||(IS_SET(flag, ZN_LR_70) && LR_FAIL(ch, 70))
       ||(IS_SET(flag, ZN_LR_75) && LR_FAIL(ch, 75))
       ||(IS_SET(flag, ZN_LR_80) && LR_FAIL(ch, 80))
       ||(IS_SET(flag, ZN_LR_85) && LR_FAIL(ch, 85))
       ||(IS_SET(flag, ZN_LR_90) && LR_FAIL(ch, 90))
       ||(IS_SET(flag, ZN_LR_95) && LR_FAIL(ch, 95))
       ||(IS_SET(flag, ZN_LR_ET) && LR_FAIL(ch, LVL_ETRNL1))
       ||(IS_SET(flag, ZN_LR_IMM) && LR_FAIL(ch, LVL_ANGEL))
       ||(IS_SET(flag, ZN_LR_IMP))) // IMPL is checked already.
d253 6
a258 3
    if (show)
      send_to_char("An overwhelming fear stops you from going any further.\r\n", ch);
    return 0;
d260 4
a263 1
  return 1;
@


1.57
log
@Artus> Conditionals for IGNORE_DEBUG.
@
text
@d537 1
a537 1
  if (!AFF_FLAGGED(ch, AFF_SNEAK))
d568 1
a568 1
  if (!AFF_FLAGGED(ch, AFF_SNEAK))
d1331 11
a1341 3
  if (MOUNTING(ch)) {
	send_to_char("You cannot sleep while mounted.\r\n", ch);
	return;
d1349 22
a1370 20
  switch (GET_POS(ch)) {
  case POS_STANDING:
  case POS_SITTING:
  case POS_RESTING:
    send_to_char("You go to sleep.\r\n", ch);
    act("$n lies down and falls asleep.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SLEEPING;
    break;
  case POS_SLEEPING:
    send_to_char("You are already sound asleep.\r\n", ch);
    break;
  case POS_FIGHTING:
    send_to_char("Sleep while fighting?  Are you MAD?\r\n", ch);
    break;
  default:
    send_to_char("You stop floating around, and lie down to sleep.\r\n", ch);
    act("$n stops floating around, and lie down to sleep.",
	TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SLEEPING;
    break;
@


1.56
log
@Artus> Moved house check to char_can_enter.
       Cleaned up.
       Added some calls to log_death_trap().
@
text
@d1494 1
d1500 1
d1620 1
d1626 1
d1760 1
d1766 1
d1847 1
d1853 1
d1942 1
d1948 1
@


1.55
log
@Artus> Changed behaviour of tunnels. Now allow groups in, and NPCs.
@
text
@d342 15
d467 2
a468 1
  if (AFF_FLAGGED(ch, AFF_CHARM) && ch->master && ch->in_room == ch->master->in_room) {
d477 1
a477 52
/* Artus> Moved to char_can_enter()
  // zone / room restrictions? 
  if (!allowed_zone(ch,zone_table[world[EXIT(ch,dir)->to_room].zone].zflag) 
     || !allowed_room(ch, world[EXIT(ch, dir)->to_room].room_flags))
	return (0);

  // A mount? 
  if (IS_NPC(ch) && MOUNTING(ch))
    return (0);

  // if this room or the one we're going to needs a boat, check for one
  if (((BASE_SECT(world[ch->in_room].sector_type) == SECT_WATER_NOSWIM) ||
       (BASE_SECT(world[EXIT(ch, dir)->to_room].sector_type) == 
          SECT_WATER_NOSWIM)) && (!has_boat(ch)))
  {
    send_to_char("You need a boat to go there.\r\n", ch);
    return FALSE;
  }
 
  // check if the room we're going to is a fly room - Vader 
  if (!IS_AFFECTED(ch,AFF_FLY) && 
      ((BASE_SECT(world[ch->in_room].sector_type) == SECT_FLYING) ||
       (BASE_SECT(world[EXIT(ch,dir)->to_room].sector_type) == SECT_FLYING))) {
    send_to_char("You need to be able to fly to go there.\r\n",ch);
    return 0;
  }

  if (!IS_NPC(ch) && !IS_AFFECTED(ch,AFF_WATERBREATHE) &&
        ((BASE_SECT(world[ch->in_room].sector_type) == SECT_UNDERWATER) ||
        (BASE_SECT(world[EXIT(ch,dir)->to_room].sector_type) ==
        SECT_UNDERWATER))) {    
    send_to_char("You take a deep breath of water.  OUCH!\r\n",ch);
    send_to_char("Your chest protests terrebly causing great pain. \r\n", ch);
    act("$n suddenly turns a deep blue color holding $s throat.", 
        FALSE, ch, 0, 0, TO_ROOM);
    GET_HIT(ch)-= GET_LEVEL(ch)*5;
    if (GET_HIT(ch) <0) {
      send_to_char("Your life flashes before your eyes.  You have Drowned.  RIP!", ch);
      act("$n suddenly turns a deep blue color holding $s throat.", 
        FALSE, ch, 0, 0, TO_ROOM);
      act("$n has drowned. RIP!.", FALSE, ch, 0, 0, TO_ROOM);
      if (MOUNTING(ch)) {
        send_to_char("Your mount suffers as it dies.\r\n", ch);
        raw_kill(MOUNTING(ch), NULL);
      }
      raw_kill(ch,NULL);
    }
    return 0;
  }    
*/

/* if flying movement is only 1 */
d496 2
a497 2
	if (number(1, 101) < GET_SKILL(ch, SKILL_MOUNTAINEER))
		need_movement = 2;
d499 2
a500 2
   if (GET_MOVE(ch) < need_movement && !IS_NPC(ch))
   {
d507 1
a507 14
  if (ROOM_FLAGGED(ch->in_room, ROOM_ATRIUM))
  {
    if (!House_can_enter(ch, GET_ROOM_VNUM(EXIT(ch, dir)->to_room)))
    {
      send_to_char("That's private property -- no trespassing!\r\n", ch);
      return (0);
    }

    if (MOUNTING(ch))
    {
	send_to_char("You cannot go there while mounted!\r\n", ch);
	return (0);
    }
  }
d537 2
a538 1
  if (!AFF_FLAGGED(ch, AFF_SNEAK)) {
a544 1

d546 1
a546 1
	act(buf2, TRUE, ch, 0, MOUNTING(ch), TO_ROOM);
d548 1
a548 1
        act(buf2, TRUE, ch, 0, 0, TO_ROOM);
d551 2
a552 1
    if (ROOM_FLAGGED(ch->in_room, ROOM_BACKWARD))  { 
a556 2
  

d568 14
a581 12
  if (!AFF_FLAGGED(ch, AFF_SNEAK)) {
	if (MOUNTING(ch))
	   act("$n, mounted on $N, has arrived.", TRUE, ch, 0, MOUNTING(ch), TO_ROOM);
        else if (MOUNTING_OBJ(ch))
	   special_item_mount_message(ch);
	else
	   act("$n has arrived.", TRUE, ch, 0, 0, TO_ROOM);
      do_environ_arrive_message(ch, dir);
      if (ROOM_FLAGGED(ch->in_room, ROOM_BACKWARD))  { 
        sprintf(buf2, "$n is moving backwards!");
        act(buf2, TRUE, ch, 0, 0, TO_ROOM);
      }
d598 2
a599 1
  if (ROOM_FLAGGED(ch->in_room, ROOM_BACKWARD))  { 
a600 1
  }
d604 1
a604 1
    log_death_trap(ch);
a612 3
    sprintf(buf2, "%s killed by deathtrap at %s.", GET_NAME(ch), 
	    world[ch->in_room].name);
    mudlog(buf2, BRF, LVL_ANGEL, TRUE);
d615 2
a616 1
    extract_char(ch);
d646 2
a647 1
      i && ch->in_room != NOWHERE; i = i->next_in_room) {
d733 2
a734 1
  if (ROOM_FLAGGED(ch->in_room, ROOM_BACKWARD))  {
d746 2
a747 1
  if (IS_AFFECTED(ch, AFF_PARALYZED)) {
d763 2
a764 4

// DM - check for SKILL_DETECT_DEATH

    if (!IS_NPC(ch) && (ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_DEATH)))
a765 1

d769 1
a769 1
      if (!IS_NPC(ch) && (ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_DEATH)))
d1683 2
a1684 1
      die(ch,NULL,"inceneration");
@


1.54
log
@Artus> Charmed mobs / clones can now enter !MOB rooms.
@
text
@d534 7
a540 7
   if (GET_MOVE(ch) < need_movement && !IS_NPC(ch)) {
    if (need_specials_check && ch->master)
      send_to_char("You are too exhausted to follow.\r\n", ch);
    else
      send_to_char("You are too exhausted.\r\n", ch);

    return (0);
d542 4
a545 2
  if (ROOM_FLAGGED(ch->in_room, ROOM_ATRIUM)) {
    if (!House_can_enter(ch, GET_ROOM_VNUM(EXIT(ch, dir)->to_room))) {
d550 2
a551 1
    if (MOUNTING(ch)) {
d556 9
a564 4
  if (ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_TUNNEL) &&
      num_pc_in_room(&(world[EXIT(ch, dir)->to_room])) >= 1) {
    send_to_char("There isn't enough room there for more than one person!\r\n", ch);
    return (0);
d568 2
a569 1
	!LR_FAIL(ch, LVL_GRGOD)) {
d663 2
@


1.53
log
@Artus> Changes for Detect Deathtrap skill.
@
text
@d233 1
a233 1
  if (IS_NPC(ch) && IS_SET(flag, ROOM_NOMOB))
@


1.52
log
@commented out some debug code
@
text
@d317 1
d651 4
a654 2
    //extract_char(ch);
    die(ch, NULL, "deathtrap");
d805 6
a810 3
    if (!ch->followers) {
      if (!IS_NPC(ch) && (ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_DEATH))) {
        if ((prob=GET_SKILL(ch, SKILL_DETECT_DEATH)) > 0) { 
d812 2
a813 3
          prob = GET_SKILL(ch, SKILL_DETECT_DEATH);
 
          if (percent <= prob) {
d815 1
d833 2
a834 1
    if (death_room) {
d836 2
a837 1
      for (k = ch->followers; k; k = next) {
d839 2
a840 1
        if (!IS_NPC(k->follower) && (k->follower->in_room == was_in)) {
d842 2
a843 1
          if (this_skill > best_skill) {
d850 2
a851 1
      if (best_skill > 0) {
d855 4
a858 2
        if (percent <= prob) {
          for (k = ch->followers; k; k = next) {
d860 2
a861 1
            if (k->follower->in_room == was_in) {
d865 1
a865 1
	        act("$N senses moving in that direction will lead to the group's death.\r\n", FALSE, best_char, 0, ch, TO_CHAR);
d868 1
@


1.51
log
@Added BACKWARD roomflag
Added DISPAIR environ flag
Added code for objects which make objects
@
text
@d761 1
a761 1
  sprintf(buf2, "checking sect flag : %d\n", world[ch->in_room].sector_type);
d764 3
a766 3
  send_to_char(buf2, ch);
  sprintf(buf2, "checking room flag : %d\n", world[ch->in_room].room_flags );
  send_to_char(buf2, ch);
@


1.50
log
@Artus> Modified dispell rooms not to show you if nothing was removed. Was a
       little spammy.
@
text
@d396 39
d450 1
a450 1
  // charmed?
d587 6
d595 2
d607 12
a618 8
  if (!AFF_FLAGGED(ch, AFF_SNEAK))
  {
    if (MOUNTING(ch))
      act("$n, mounted on $N, has arrived.", TRUE, ch, 0, MOUNTING(ch), TO_ROOM);
    else if (MOUNTING_OBJ(ch))
      special_item_mount_message(ch);
    else
      act("$n has arrived.", TRUE, ch, 0, 0, TO_ROOM);
d635 4
d749 1
a749 1
int perform_move(struct char_data *ch, int dir, int need_specials_check)
d756 22
d1849 8
d1913 25
d2258 13
@


1.49
log
@Artus> Gravity fix.
@
text
@d1787 1
a1787 1
      send_to_char("If you had a geiger counter it would be off the scale.\n\r", ch);
d1799 1
a1799 1
      send_to_char("You feel decidedly sick in the stomach. The radiation is really affecting you.\n\r", ch);
d1804 2
a1805 2
        act("$n passes out from radiation poisining!\n\r", TRUE, ch, 0, 0, TO_ROOM);
        send_to_char("You pass out from radiation poisoining!\n\r",ch);
d1810 1
a1810 1
      send_to_char("Your body shivers as a flash of bright light stripps you of all spells!!!.\n\r", ch);
d1819 1
d1821 2
d1824 3
@


1.48
log
@Artus> Added NOMOB check.
@
text
@d560 8
a567 7
  if (!AFF_FLAGGED(ch, AFF_SNEAK)) {
	if (MOUNTING(ch))
	   act("$n, mounted on $N, has arrived.", TRUE, ch, 0, MOUNTING(ch), TO_ROOM);
        else if (MOUNTING_OBJ(ch))
	   special_item_mount_message(ch);
	else
	   act("$n has arrived.", TRUE, ch, 0, 0, TO_ROOM);
d575 2
a576 1
    if (MOUNTING(ch)) {
d589 3
a591 3
	send_to_char("Your mount screams in agony as it dies.\r\n", ch);
	death_cry(MOUNTING(ch));
	raw_kill(MOUNTING(ch), NULL);
a598 3
/* this next bit is to burn vampires in the day. copied from the enviro
 *  * HEAT code - Vader  ---- Artus> Moved to check_environment_effect
 *   */
d601 2
a602 1
  if (!greet_mtrigger(ch, dir)) {
d606 3
a608 1
  } else greet_memory_mtrigger(ch);
a1731 1
	return(0);
d1733 1
a1733 1
      return(1);
d1769 1
@


1.47
log
@Artus> Added check_world_environment(), checks all PLAYERS environments.
       Added check_env_atmosphere(), check_env_temperature(),
	     check_env_gravity(), check_env_environ(), check_vampire()
             -- All sub-functions to check_environment_effect.
@
text
@d233 7
@


1.46
log
@Artus> !LR_FAIL => LR_FAIL
@
text
@d354 1
d357 2
a358 1
      raw_kill(ch,NULL);
d565 2
a566 1
  if (check_environment_effect(ch)) {
d570 1
a570 1
      extract_char(MOUNTING(ch));
d582 1
a582 1
	extract_char(MOUNTING(ch));
d587 1
a587 1
    raw_kill(ch, NULL);
d591 1
a591 1
 *  * HEAT code - Vader
d593 1
a593 23
  if (!IS_NPC(ch) && (PRF_FLAGGED(ch,PRF_VAMPIRE) && !IS_SET(ROOM_FLAGS(ch->in_room),ROOM_DARK)
        && !(weather_info.sunlight == SUN_DARK || 
        weather_info.sunlight == SUN_SET) && OUTSIDE(ch))) {
    if (!is_wearing(ch, ITEM_HEATRES) && !is_wearing(ch, ITEM_HEATPROOF))
      if (!is_wearing(ch, ITEM_STASIS)) {
        send_to_char("The sun burns your skin!\r\n", ch);
        act("Smoke rises from $n's skin!",FALSE,ch,0,0,TO_ROOM);
        //GET_HIT(ch) = MAX(GET_HIT(ch) - GET_LEVEL(ch)/2, 0);
	damage(NULL, ch, MAX(GET_HIT(ch)-GET_LEVEL(ch)/2, 0), TYPE_UNDEFINED,
	       FALSE);
      }
      if (GET_HIT(ch) <= 0) {
        send_to_char("The sun burns you to death!\r\n",ch);
        act("The sun causes $n to burst into flames!", TRUE, ch, 0, 0, TO_ROOM);
        if (MOUNTING(ch)) {
          send_to_char("Your vampiric mount dies with you.\r\n", ch);
          raw_kill(MOUNTING(ch), NULL);
        }
        raw_kill(ch,NULL);
        send_to_outdoor("The scream of a burning vampire echoes throughout the land...\r\n");
      }
  }

d1383 436
d1828 1
d1830 20
a1849 1
    return(0);
d1851 3
a1853 1
  sect_type = world[ch->in_room].sector_type & 0xfff0;
d2135 1
d2138 12
@


1.45
log
@Artus> Crash bug fix, exp bug fix.
@
text
@d524 1
a524 1
  if (!IS_NPC(ch) && !LR_FAIL(ch, LVL_IMMORT))
@


1.44
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@a1736 5
  if ((IS_NPC(ch) || (GET_LEVEL(ch) < LVL_IMMORT)) &&
      ((GET_OBJ_LEVEL(obj) > GET_LEVEL(ch)) ||
       (GET_OBJ_VAL(obj, 1) > GET_LEVEL(ch)) ||
       ((GET_OBJ_VAL(obj, 2) > 0) &&
      (GET_OBJ_VAL(obj, 2) < GET_LEVEL(ch)))))
d1738 2
a1739 1
  if ((exitroom = real_room(GET_OBJ_VAL(obj, 0))) == NOWHERE)
d1741 2
a1742 2
    sprintf(buf,"SYSERR: Portal %d: Invalid exit room (%d) for %s.",
	    GET_OBJ_VNUM(obj), GET_OBJ_VAL(obj, 0), OBJN(obj, ch));
@


1.43
log
@Artus>
act.informative.c: Fixed bug where examining a container was always listng the
                   objects in the first container matched.
                   Gold rush finishing is now only displayed within the same
		   world.
act.movement.c   : Environmental damage is now passed through damage().
act.offensive.c  : Throw() now calls damage().
act.other.c      : When you fail to create a torch, it hurts.
dg_mobcmd.c      : mdamage() now calls damage().
dg_objcmd.c      : odamage() now calls damage().
dg_wldcmd.c      : wdamage() now calls damage().
fight.c          : Changed damage() to allow a NULL ch.
interpreter.c    : Falling because fly has worn off now calls damage().
limits.c         : No waterbreathe underwater now calls damage().
magic.c          : Added handle_fireball() for fire breathing, fireball, type
                   stuff..
                   Random chance of objs in inventory/open containers burning
                   up :o)
spec_assign.c    : Removed some unused/wasted assigns: corridor_guard,
                   receiptionist, virus, bacteria.
spec_procs.c     : Removed some unused/wasted procs. Changed lots of tali's
                   indenting.
                   Fixed gaping hole in deadlyblade proc.
                   Replaced GET_HIT(vict) -= with damage(ch, vict...
spell_parser.c   : Added awake and can_see checks to magic fail = mob attacks.
@
text
@d112 2
a113 1
  if (GET_LEVEL(ch) > LVL_NEWBIE) {
d117 1
a117 1
  if (ENTRY_ROOM(ch, get_world(ch->in_room)) != -1) {
d119 1
a119 1
  } else {
a120 1
  }
d188 1
a188 1
  if (GET_LEVEL(ch)>=LVL_IMPL)
d192 1
a192 1
  if ( (IS_SET(flag, ZN_NEWBIE) && GET_LEVEL(ch) > LVL_NEWBIE) )
d197 22
a218 22
  if ((IS_SET(flag, ZN_LR_5) && GET_LEVEL(ch) < 5)
       ||(IS_SET(flag, ZN_LR_10) && GET_LEVEL(ch) < 10)
       ||(IS_SET(flag, ZN_LR_15) && GET_LEVEL(ch) < 15)
       ||(IS_SET(flag, ZN_LR_20) && GET_LEVEL(ch) < 20)
       ||(IS_SET(flag, ZN_LR_25) && GET_LEVEL(ch) < 25)
       ||(IS_SET(flag, ZN_LR_30) && GET_LEVEL(ch) < 30)
       ||(IS_SET(flag, ZN_LR_35) && GET_LEVEL(ch) < 35)
       ||(IS_SET(flag, ZN_LR_40) && GET_LEVEL(ch) < 40)
       ||(IS_SET(flag, ZN_LR_45) && GET_LEVEL(ch) < 45)
       ||(IS_SET(flag, ZN_LR_50) && GET_LEVEL(ch) < 50)
       ||(IS_SET(flag, ZN_LR_55) && GET_LEVEL(ch) < 55)
       ||(IS_SET(flag, ZN_LR_60) && GET_LEVEL(ch) < 60)
       ||(IS_SET(flag, ZN_LR_65) && GET_LEVEL(ch) < 65)
       ||(IS_SET(flag, ZN_LR_70) && GET_LEVEL(ch) < 70)
       ||(IS_SET(flag, ZN_LR_75) && GET_LEVEL(ch) < 75)
       ||(IS_SET(flag, ZN_LR_80) && GET_LEVEL(ch) < 80)
       ||(IS_SET(flag, ZN_LR_85) && GET_LEVEL(ch) < 85)
       ||(IS_SET(flag, ZN_LR_90) && GET_LEVEL(ch) < 90)
       ||(IS_SET(flag, ZN_LR_95) && GET_LEVEL(ch) < 95)
       ||(IS_SET(flag, ZN_LR_ET) && GET_LEVEL(ch) < LVL_ETRNL1)
       ||(IS_SET(flag, ZN_LR_IMM) && GET_LEVEL(ch) < LVL_ANGEL)
       ||(IS_SET(flag, ZN_LR_IMP) && GET_LEVEL(ch) < LVL_IMPL) ) 
d230 1
a230 1
  if (GET_LEVEL(ch) >= LVL_IMPL)
d239 5
a243 5
  if ((IS_SET(flag, ROOM_LR_ET) && GET_LEVEL(ch) < LVL_ETRNL1) ||
      (IS_SET(flag, ROOM_LR_IMM) && GET_LEVEL(ch) < LVL_IMMORT) ||
      (IS_SET(flag, ROOM_LR_ANG) && GET_LEVEL(ch) < LVL_ANGEL) ||
      (IS_SET(flag, ROOM_LR_GOD) && GET_LEVEL(ch) < LVL_GOD) ||
      (IS_SET(flag, ROOM_LR_IMP) && GET_LEVEL(ch) < LVL_IMPL))
a261 2
  if (GET_LEVEL(ch) > LVL_IMMORT)
    return TRUE;
d268 2
d302 1
a302 1
  if (GET_LEVEL(ch) == LVL_IMPL)
d334 1
a334 1
  if (!IS_NPC(ch) && (GET_LEVEL(ch) < LVL_IS_GOD) &&
d511 1
a511 1
	GET_LEVEL(ch) < LVL_GRGOD) {
d524 1
a524 1
  if (GET_LEVEL(ch) < LVL_IMMORT && !IS_NPC(ch))
d572 2
a573 1
  if (ROOM_FLAGGED(ch->in_room, ROOM_DEATH) && GET_LEVEL(ch) < LVL_IMMORT) {
d575 2
a576 1
    if (MOUNTING(ch)) {
d1112 1
a1112 1
    else if (!has_key(ch, keynum) && (GET_LEVEL(ch) < LVL_GOD) &&
d1411 1
a1411 1
  if (GET_LEVEL(ch) >= LVL_IS_GOD) // Artus> Changed from IMPL.
d1703 2
d1728 4
a1731 5
  if ((IS_NPC(ch) || (GET_LEVEL(ch) < LVL_IMMORT)) && 
      ((GET_OBJ_LEVEL(obj) > GET_LEVEL(ch)) ||
       (GET_OBJ_VAL(obj, 1) > GET_LEVEL(ch)) ||
       ((GET_OBJ_VAL(obj, 2) > 0) &&
	(GET_OBJ_VAL(obj, 2) < GET_LEVEL(ch)))))
d1737 6
d1866 1
a1866 1
    if (GET_LEVEL(ch) < LVL_IMMORT)
@


1.42
log
@Artus> Intermittent build.
act.informative.c: Affect/Timers now display something when no affects/timers
                   are present.
                   Sense curse now senses objects inside containers.
act.movement.c   : Optimised the aggravate stuff a little.
act.offensive.c  : Logging death by pit trap.
act.other.c      : Logging death by suicide.
                   Superman now sets affects rather than actual stats, for STR
                   and CON (CON bonus is +1, STR is 21 - GET_REAL_STR
                   Logging death by arrow.
clan.c           : Removed aggravate_check() function, no longer used.
db.c             : Now initialising character specials.
dg_mobcmd.c      : Logging death by mdamage.
dg_objcmd.c      : Logging death by odamage.
dg_wldcmd.c      : Logging death by wdamage.
fight.c          : New optional msg paramater to die(), for if the death was
                   not caused by a character.
                   Deaths are now logged to info channel.
handler.c        : Modified ability affect function to permit more than one
                   affect modifier per special. (Required for superman)
spec_procs.c     : Logging death by pit trap, archers and room blast.
spells.h         : Added SPELL_SUPERMAN for special affect modifiers.
utils.h          : Updated die() prototype to match changes in fight.c.
@
text
@d343 2
a344 1
    GET_HIT(ch)-= GET_LEVEL(ch)*5;
d595 3
a597 1
        GET_HIT(ch) = MAX(GET_HIT(ch) - GET_LEVEL(ch)/2, 0);
d1429 3
a1431 1
	GET_HIT(ch) = MAX(GET_HIT(ch)-GET_LEVEL(ch), 0);
d1451 3
a1453 1
	GET_HIT(ch) = MAX(GET_HIT(ch)-(GET_LEVEL(ch)*3), 0);
d1484 2
a1485 1
        GET_HIT(ch) -= 135;
d1510 3
a1512 1
	GET_HIT(ch) = MAX(GET_HIT(ch) - GET_LEVEL(ch), 0);
d1527 3
a1529 1
      GET_HIT(ch) = MAX((GET_HIT(ch) - GET_LEVEL(ch)*2/modifier), 0);
d1554 3
a1556 1
	GET_HIT(ch) = MAX(GET_HIT(ch) - GET_LEVEL(ch), 0);
d1573 3
a1575 1
      GET_HIT(ch) = MAX(GET_HIT(ch) - (GET_LEVEL(ch)*2/modifier), 0);
d1648 3
a1650 1
      GET_HIT(ch) = MAX(0,GET_HIT(ch) - number((int)(maxdam * 0.9),maxdam));
d1676 3
a1678 1
        GET_HIT(ch) = MAX(GET_HIT(ch) - GET_LEVEL(ch), 0);
@


1.41
log
@Artus> Mostly just cosmetic changes, mostly for underwater stuff..
       Added some more stuff to dg_scripts:

       %actor.affected(aff_bit)% - Is actor affected by whatever.
       %self.people(countpc)%    - (Rooms): Count players.
       %self.people(countnpc)%   - (Rooms): Count npcs.
       %self.people(countall)%   - (Rooms): Count chars.
       %firstchar.<room_vnum>%   - First character in room <vnum>

       Possibly a bugfix to one of the forest specials that was attacking you
       if you were affected by poison.
@
text
@d623 2
a625 6
  /* ARTUS: Yeah.. It's kinda a lame way of doing it, but it's nice to the
   * resources :o) -- Makes mobs attack players with aggravate punish bits. */
  if ((!IS_NPC(ch)) && (PUN_FLAGGED(ch, PUN_AGGRAVATE)))
    if (pun_aggro_check(ch) == 1) 
      return;
  
d635 2
a636 1
    if (IS_NPC(ch)) {
d641 2
a642 1
      if (PUN_FLAGGED(i, PUN_AGGRAVATE)) {
d651 4
a654 2
           (MOB_FLAGGED(ch, MOB_AGGR_GOOD) && IS_GOOD(i)))) {
        if (number(0, 25) <= GET_REAL_CHA(i)) {
d670 13
d688 2
a689 1
      if (number(0, 25) <= GET_REAL_CHA(i)) {
@


1.40
log
@Artus>
\r\n appended to gold rush message: act.informative.c

Imms no longer affected by underwater: act.movement.c, limits.c

Changed remort some more.. New special, tracker (SPECIAL_TRACKER):
act.other.c, act.wizard.c, constants.c, graph.c, structs.h, utils.c

Object and Room triggers can now %send% <room vnum> <message>:
dg_objcmd.c, dg_wldcmd.c

%self.direction% now has a vnum subfield to return the exit room's vnum.
(Eg: %self.north(vnum)%): dg_scripts.c

%actor.hisher%, %actor.himher%, %actor.heshe% implemented: dg_scripts.c

vnum, name, can_see, can_see_me added to %actor.next_in_room%, returning char
vnum, char name, if actor can see char, and if char can see actor respectively:
dg_scripts.c

Changed "do not know that spell" to "do not know of that spell": spell_parser.c

Changed "do not of know that skill/spell" to "do not know of..": utils.c

SECT_UNDERWATER and SECT_INSIDE now checked in OUTSIDE() macro: utils.h
@
text
@d336 1
a336 1
      ((BASE_SECT(world[ch->in_room].sector_type) == SECT_UNDERWATER) ||
d504 1
a504 1
      num_pc_in_room(&(world[EXIT(ch, dir)->to_room])) > 1) {
d1385 1
a1385 1
  int sect_type; 
d1392 1
a1392 1
  if (GET_LEVEL(ch) >= LVL_IMPL)
d1398 3
a1400 2
    case SECT_THIN : 
      send_to_char("The air here is very thin.\n\r",ch);
d1421 2
a1422 1
      send_to_char("The air here is unbreathable.\n\r", ch);
d1457 2
a1458 1
      send_to_char("The are here is thick with toxic chemicals.\n\r", ch);
d1461 2
a1462 1
        send_to_char("The chemicals in the air burn your lungs.\n\r", ch);
d1538 2
a1539 1
      send_to_char("The air here is freezing.\n\r", ch); 
@


1.39
log
@Artus> Breakin now requires mount skill, and is tested vs it.
       Remort ability list changed some more, also remort ability parser.
       DGScript Force/Teleport commands now tell >=LVL_ANGEL what they were
       trying to do..
       MultiWeapon is once more required for dual wield.
       Lowered exp gained whilst grouping by about 30%.
@
text
@d334 4
a337 3
  if (!IS_NPC(ch) && !IS_AFFECTED(ch,AFF_WATERBREATHE) &&
        ((BASE_SECT(world[ch->in_room].sector_type) == SECT_UNDERWATER) ||
         (BASE_SECT(room->sector_type) == SECT_UNDERWATER))) 
@


1.38
log
@Artus> Imms no longer affected by hot/cold/etc.
       Debug no longer available to mortals, can be set though.
       Fixed buffer overflow in proc_color.
       Stops processing get_from_container when arms full.
       Changed the way remort abilities are listed.
@
text
@d1759 10
d1808 3
a1810 1
  if (MOB_FLAGGED(victim, MOB_MOUNTABLE)) {
d1836 3
a1838 2
  if (GET_SKILL(ch, SKILL_MOUNT) > 0) {
    if (!has_stats_for_skill(ch, SKILL_MOUNT, TRUE)) {
a1839 1
    }
@


1.37
log
@Artus>
---
drop_otrigger takes an extra paramater for subcmd. With drop triggers you can
now specify whether the trigger is for drop, junk, donate and put. Specify
in the argument either/combination of 'junk', 'drop', 'donate', 'put'. No
argument means any type will be triggered:

act.item.c, dg_scripts.h, dg_triggers.c, interpreter.h
---
fixed colour bleed in dc:

act.wizard.c
---
Not reapplying empty timers in char_to_store:
Not calling object triggers from char_to_store:

db.c
---
Modified hunt so that with special_elf you can track through !TRACK rooms
(Modifier for Elf has been increased from 0.02 to 0.07%):

graph.c, utils.c
---
Timers should only show remove messages when being removed because they're
wearing off (duration = 0):

handler.c
---
Not calling object triggers when auto_equipping.

objsave.c
---
#defined around love_ring specproc. What a joke. define DRAX_IS_TEH_SUXOR if
you want it back ;o)

spec_assign.c, spec_procs.c
---
@
text
@d1391 3
d1401 6
d1408 9
a1416 18
        if (is_wearing(ch, ITEM_BREATHER))
          break;
        else
          if (is_wearing(ch, ITEM_VACSUIT))
            break;
          else
            if (is_wearing(ch, ITEM_ENVIRON))
              break;
            else
            {
              send_to_char("You are gasping for breath!\n\r", ch);
              GET_HIT(ch) = MAX(GET_HIT(ch)-GET_LEVEL(ch), 0);
              if (GET_HIT(ch) <= 0)
              {
                GET_POS(ch) = POS_STUNNED;
                act("$n falls down gasping for breath an goes into a coma.\n\r", TRUE, ch, 0, 0, TO_ROOM);
              }
            }
d1422 4
d1427 11
a1437 17
        if (is_wearing(ch, ITEM_VACSUIT))
          break;
        else
          if (is_wearing(ch, ITEM_ENVIRON))
            break;
          else
          {
            send_to_char("You can't breath, you are asphyxiating!\n\r", ch);
            GET_HIT(ch) = MAX(GET_HIT(ch)-(GET_LEVEL(ch)*3), 0);
            if (GET_HIT(ch) < 0)
            {
              send_to_char("You suffocate to death!\n\r", ch);
              act("$n falls down gasping for breath and dies.", TRUE, ch, 0, 0, TO_ROOM); 
              raw_kill(ch,NULL);
              return(1);
            }
          }
d1443 2
d1446 6
a1451 9
        if (is_wearing(ch, ITEM_ENVIRON))
          break;
        else
        {
          send_to_char("You walk into a total vacuum, and your whole body explodes!\n\r", ch);
          act("$n enters a total vacuum and explodes, covering you with blood and gutsi!\n\r", TRUE, ch, 0, 0, TO_ROOM);
          raw_kill(ch,NULL);
          return(1);
        }  
d1453 1
a1453 1
    case SECT_CORROSIVE :
d1477 1
a1477 1
        break;
d1479 11
a1489 11
             break;
         else if (!is_wearing(ch, ITEM_STASIS))   
           {
             send_to_char("The heat is really affecting you!\n\r", ch);
             GET_HIT(ch) = MAX(GET_HIT(ch) - GET_LEVEL(ch), 0);
           }
           if (GET_HIT(ch) <= 0)
           {
             GET_POS(ch) = POS_STUNNED;
             act("$n falls down from heat exhaustion!", TRUE, ch, 0, 0, TO_ROOM);
           }
a1490 1

d1494 1
a1494 2
        break;

d1496 1
a1496 2
        modifier = 2;
     
d1501 3
a1503 3
        send_to_char("Your whole body is reduced to a blistered mess, you fall down dead!\n\r", ch);
        act("$n falls down dead in a smouldering heap!", TRUE, ch, 0, 0, TO_ROOM);
        raw_kill(ch,NULL);
a1506 1
      
a1513 1

d1517 2
d1520 11
a1530 13
      else if (is_wearing(ch, ITEM_SUBZERO))
             break;
         else if (!is_wearing(ch, ITEM_STASIS))   
           {
             send_to_char("You shiver uncontrollably from the cold!\n\r", ch);
             GET_HIT(ch) = MAX(GET_HIT(ch) - GET_LEVEL(ch), 0);
             if (GET_HIT(ch) <= 0)
             {
               send_to_char("You fall down unconcious from hyperthermia!\n\r", ch);
               GET_POS(ch) = POS_STUNNED;
               act("$n falls down in a coma from hyperthermia!", TRUE, ch, 0, 0, TO_ROOM);
             }
           }
a1531 1
   
d1535 1
a1535 2
        break;

d1537 1
a1537 2
        modifier = 2;
     
d1542 3
a1544 3
        send_to_char("You fall down dead from frostbite!\n\r", ch);
        act("$n falls down dead from frostbite and hyperthermia!", TRUE, ch, 0, 0, TO_ROOM);
        raw_kill(ch,NULL);
d1548 1
a1548 2

    case SECT_ABSZERO :
a1555 1

d1557 1
a1557 1
  if (((modifier = GRAVITY(sect_type)) > 0) && (GET_LEVEL(ch) < LVL_IS_GOD))
d1582 1
a1582 2
	  }
	  else
d1617 1
a1617 1
	        (eqweight == 0) ? "inventory" : "equipment");
d1635 16
a1650 11
	else if (!is_wearing(ch, ITEM_STASIS))
           {
             send_to_char("You feel decidedly sick in the stomach.  The radiation is really affecting you.\n\r", ch);
             GET_HIT(ch) = MAX(GET_HIT(ch) - GET_LEVEL(ch), 0);
           }
           if (GET_HIT(ch) <= 0)
           {
             act("$n passes out from radiation poisining!\n\r", TRUE, ch, 0, 0, TO_ROOM);
             send_to_char("You pass out from radiation poisoining!\n\r",ch);
             GET_POS(ch) = POS_STUNNED;
           }
a1651 6
     case SECT_DISPELL :
	{
		send_to_char("Your body shivers as a flash of bright light stripps you of all spells!!!.\n\r", ch);
		while (ch->affected)
    		affect_remove(ch, ch->affected);
	} break;
@


1.36
log
@Artus> Containers no longer flagged as cursed when cursed objects put inside,
       instead, we're now checking contents when we drop the container.
       Can no longer put containers inside containers.

       Healing Trance timer now displays "healing trance" rather than "timer 9"

       Now sending message when removing various timers from chars.
@
text
@d517 1
a517 1
  if (char_affected_by_timer(ch, TIMER_MEDITATE)) {
a518 1
  }
@


1.35
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@d1162 2
a1163 1
  if (!IS_NPC(ch) && (char_affected_by_timer(ch, TIMER_MEDITATE) || char_affected_by_timer(ch, TIMER_HEAL_TRANCE))) {
@


1.34
log
@Artus>>
Breakin: him/her -> he/she.
Remort: Now updates wimpy.
Show Snoop: Fixed colour bleed.
do_simple_move: Now displays failure messages.
House_boot: Now subtracts subtracts objects from obj_index.number when loading
            objs into houses.. Fixes issue where objs in houses were preventing
	    that obj from being created in the game where zone command Max: 1.
@
text
@d1579 2
a1580 1
      log("%s killed by gravity at %s", GET_NAME(ch), world[ch->in_room].name);
d1633 2
a1634 1
	log("%s killed by gravity at %s", GET_NAME(ch), world[ch->in_room].name);
@


1.33
log
@Artus> Major bugfix in char_can_enter() -- Was using room flags instead of
       zone flags..

       Also major bugfix in do_go() -- Was preventing level > 0 entering when
       level max was set to 0..

       Added sanity checking to a couple of dgscript functions which were
       passing a pointer to strcat() and not first checking whether the
       pointer was valid..
@
text
@d220 1
d222 1
a222 1
      return 0;
d230 1
a230 1
  if (GET_LEVEL(ch)>=LVL_IMPL)
d232 2
a233 1
  if ( (IS_SET(flag, ROOM_NEWBIE) && GET_LEVEL(ch) > LVL_NEWBIE) )
d407 1
a407 1
  if (!char_can_enter(ch, &world[EXIT(ch,dir)->to_room], FALSE))
d1272 5
d1765 2
a1766 2
ACMD(do_breakin) {

d1816 1
a1816 1
    act("You try to break $N in, but $M does not respond well.", 
d1825 2
a1826 2
ACMD(do_mount) {

@


1.32
log
@Artus> Changes to do_simple_move().
       Added char_can_enter() -- Tests room levels, zone levels, water/fly/etc.

       Changes to die(): Exp lost is now whichever is lesser of half earned
       exp and quater max exp. When autocorpse, instead of doubling it, we
       multiply by 1.5.

       pc killed by char now logged in die(), with lost_exp display.

       gain_exp now returns the amount of exp that was gained rather than void.
@
text
@d303 1
a303 1
  if (!allowed_zone(ch, room->room_flags, show))
a307 1
  
d1693 2
a1694 1
       (GET_OBJ_VAL(obj, 2) < GET_LEVEL(ch))))
@


1.31
log
@Artus> Sorry, Dish.. Another bastard change..

       has_stats_for_skill now takes an extra arg (bool) to determine whether
       or not to display messages.

       new routine: has_stats_for_prac.. Basically the same as
       has_stas_for_skill, without GET_SKILL(ch, i) == 0 check..

       Force is now restricted for <GRGOD.

       Score no longer displays punishment lines twice.

       New macro: IS_SKILL(skillnum) .. Used to determine whether skillnum is
                  a skill.
@
text
@d186 1
a186 1
int allowed_zone(struct char_data * ch,int flag)
d197 22
a218 22
  if ( (IS_SET(flag, ZN_LR_5) && GET_LEVEL(ch) < 5)
     ||(IS_SET(flag, ZN_LR_10) && GET_LEVEL(ch) < 10)
     ||(IS_SET(flag, ZN_LR_15) && GET_LEVEL(ch) < 15)
     ||(IS_SET(flag, ZN_LR_20) && GET_LEVEL(ch) < 20)
     ||(IS_SET(flag, ZN_LR_25) && GET_LEVEL(ch) < 25)
     ||(IS_SET(flag, ZN_LR_30) && GET_LEVEL(ch) < 30)
     ||(IS_SET(flag, ZN_LR_35) && GET_LEVEL(ch) < 35)
     ||(IS_SET(flag, ZN_LR_40) && GET_LEVEL(ch) < 40)
     ||(IS_SET(flag, ZN_LR_45) && GET_LEVEL(ch) < 45)
     ||(IS_SET(flag, ZN_LR_50) && GET_LEVEL(ch) < 50)
     ||(IS_SET(flag, ZN_LR_55) && GET_LEVEL(ch) < 55)
     ||(IS_SET(flag, ZN_LR_60) && GET_LEVEL(ch) < 60)
     ||(IS_SET(flag, ZN_LR_65) && GET_LEVEL(ch) < 65)
     ||(IS_SET(flag, ZN_LR_70) && GET_LEVEL(ch) < 70)
     ||(IS_SET(flag, ZN_LR_75) && GET_LEVEL(ch) < 75)
     ||(IS_SET(flag, ZN_LR_80) && GET_LEVEL(ch) < 80)
     ||(IS_SET(flag, ZN_LR_85) && GET_LEVEL(ch) < 85)
     ||(IS_SET(flag, ZN_LR_90) && GET_LEVEL(ch) < 90)
     ||(IS_SET(flag, ZN_LR_95) && GET_LEVEL(ch) < 95)
     ||(IS_SET(flag, ZN_LR_ET) && GET_LEVEL(ch) < LVL_ETRNL1)
     ||(IS_SET(flag, ZN_LR_IMM) && GET_LEVEL(ch) < LVL_ANGEL)
     ||(IS_SET(flag, ZN_LR_IMP) && GET_LEVEL(ch) < LVL_IMPL) ) 
d227 1
a227 1
int allowed_room(struct char_data * ch,int flag)
d230 1
a230 2
    return 1;
 
d233 9
a241 9
    send_to_char("You are too high a level to enter this zone!",ch);
    return 0;
  }

  if ( (IS_SET(flag, ROOM_LR_ET) && GET_LEVEL(ch) < LVL_ETRNL1)
      ||(IS_SET(flag, ROOM_LR_IMM) && GET_LEVEL(ch) < LVL_IMMORT)
      ||(IS_SET(flag, ROOM_LR_ANG) && GET_LEVEL(ch) < LVL_ANGEL)
      ||(IS_SET(flag, ROOM_LR_GOD) && GET_LEVEL(ch) < LVL_GOD)
      ||(IS_SET(flag, ROOM_LR_IMP) && GET_LEVEL(ch) < LVL_IMPL) )
d243 1
d245 1
a245 1
      return 0;
d247 1
a247 1
  return 1;
d261 1
a261 2
    return (1);

d263 5
a267 2
    return (1);

d271 1
a271 1
      return (1);
d276 1
a276 1
      return (1);
d279 5
a283 4
  if (MOUNTING(ch) ) {
	i = GET_CLASS(MOUNTING(ch));
	if (i == CLASS_AQUATIC || i == CLASS_DRAGON)
		return (1);
d286 1
a286 1
  return (0);
d289 43
d333 26
a358 4
void special_item_mount_message(struct char_data *ch) {
	
	struct obj_data *mount = MOUNTING_OBJ(ch);
	char temp[MAX_STRING_LENGTH];
d360 4
a363 2
	if (!mount)
		return;
d365 2
a366 1
	/* Place specific item messages here */
d368 1
a368 3
	// else
	sprintf(temp, "$n, mounted on %s, has arrived.", mount->short_description);
	act(temp, FALSE, ch, mount, 0, TO_ROOM);
d370 3
d399 1
a399 1
  /* charmed? */
d406 5
a410 1
  /* zone / room restrictions? */
d415 3
a417 4
  /* A mount? */
  if (IS_NPC(ch) && MOUNTING(ch)) {
	return (0);
  }
d419 7
a425 25
  /* if this room or the one we're going to needs a boat, check for one 
  if ((BASE_SECT(ch->in_room) == SECT_WATER_NOSWIM) ||
      (BASE_SECT(EXIT(ch, dir)->to_room) == SECT_WATER_NOSWIM)) {
    if (!has_boat(ch)) {
      send_to_char("You need a boat to go there.\r\n", ch);
      return (0);
    }
  }
  */
  /* if this room or the one we're going to needs a boat, check for one */
  if ((BASE_SECT(world[ch->in_room].sector_type) == SECT_WATER_NOSWIM) ||
      (BASE_SECT(world[EXIT(ch, dir)->to_room].sector_type) == 
      SECT_WATER_NOSWIM)) {
    if(IS_AFFECTED(ch,AFF_WATERWALK) || IS_AFFECTED(ch,AFF_FLY) || 
        IS_AFFECTED(ch,AFF_WATERBREATHE)) {
      has_boat = TRUE;
    } else {
      for (obj = ch->carrying; obj; obj = obj->next_content)
        if (GET_OBJ_TYPE(obj) == ITEM_BOAT)
          has_boat = TRUE;
        if (!has_boat) {
          send_to_char("You need a boat to go there.\r\n", ch);
          return 0;
        }
    }
d428 1
a428 1
/* check if the room we're going to is a fly room - Vader */
d430 2
a431 2
        ((BASE_SECT(world[ch->in_room].sector_type) == SECT_FLYING) ||
        (BASE_SECT(world[EXIT(ch,dir)->to_room].sector_type) == SECT_FLYING))) {
a435 1

d458 1
d645 1
a645 1
        hit(ch, i, -1); // -1 - TYPE_UNDEFINED
a1667 1
 
d1671 2
a1672 1
 
a1673 1
 
a1678 1
 
d1683 16
d1700 1
a1700 1
  else
d1702 10
a1711 7
    if (GET_OBJ_TYPE(obj) != ITEM_GATEWAY)
    {
      send_to_char("You can't 'go' to that!!\n\r", ch);
      return;
    }
    else
    {
d1716 4
a1719 14
      if (!IS_AFFECTED(ch, AFF_SNEAK))
      {
        sprintf(buf2, "$n goes to the %s.", arg1);
        act(buf2, TRUE, ch, 0, 0, TO_ROOM); 
      }
 
      was_in = ch->in_room;
      char_from_room(ch);
      char_to_room(ch, real_room(GET_OBJ_VAL(obj, 0)));
 
      if (!IS_AFFECTED(ch, AFF_SNEAK))
        act("$n has arrived.", TRUE, ch, 0, 0, TO_ROOM);
      look_at_room(ch, 0);
    }
d1721 6
@


1.30
log
@Artus> (Hopefully) Fixed all cases where the skill message would display after
       the victim had fled.

       Moved remaining violence checks from damage() to violence_check().

       damage() now takes an additional boolean arg, vcheck, when true,
       violence_check() will be called.

       added GET_EQ_WEIGHT(ch, wear_pos) define.
@
text
@d1761 1
a1761 1
    if (!has_stats_for_skill(ch, SKILL_MOUNT)) {
@


1.29
log
@Artus> Gravity, Some minor changes to clan messages, Violence check for
       violent spells.
@
text
@d1533 1
a1533 1
	    eqweight += (int)(GET_OBJ_WEIGHT(GET_EQ(ch, i))/2);
d1541 1
a1541 1
	eqweight += GET_OBJ_TYPE(GET_EQ(ch, i));
@


1.28
log
@
Modified: DM

Changed:
- Don't ask (large group checkin) - lots of bug fixes mainly.
- Use cvs diff if you really wanna see the changes.
@
text
@d1326 2
a1327 2
if (!IS_NPC(ch))  /* can't have all the mobs dying */
{
d1430 1
a1431 1
      break;
d1447 1
d1457 1
a1458 1
      break;
d1493 1
d1502 1
a1502 1

d1506 2
a1507 1
  switch(GRAVITY(sect_type))
d1509 67
a1575 9
    case SECT_DOUBLEGRAV :
      send_to_char("The gravity here is much higher than normal.\n\r", ch);
      break;
    case SECT_TRIPLEGRAV :
      send_to_char("The gravity here is is extremely strong.\n\r", ch);
      break;
    case SECT_CRUSH :
      send_to_char("You must be very near to a singularity, the gravity is approaching infinity.\n\r", ch);
      break;
a1603 2
 } /* end if (!IS_NPC(ch)) */
  return(0);
@


1.27
log
@
Modified: DM

Changed:
- Fixed aggro checks - added missing stuff and clean up ...
@
text
@d188 1
a188 1
  if (GET_LEVEL(ch)==LVL_IMPL)
d229 1
a229 1
  if (GET_LEVEL(ch)==LVL_IMPL)
d633 1
d654 3
d683 10
a692 8
    // Find the char with the best SKILL_DETECT_DEATH
    for (k = ch->followers; k; k = next) {
      next = k->next;
      if (!IS_NPC(k->follower) && (k->follower->in_room == was_in)) {
        this_skill = GET_SKILL(k->follower, SKILL_DETECT_DEATH);
        if (this_skill > best_skill) {
          best_skill = this_skill;
          best_char = k->follower;
a694 1
    }
d696 3
a698 3
    if (best_skill > 0) {
      percent = number(1, 101);     /* 101% is a complete failure */
      prob = GET_SKILL(ch, SKILL_DETECT_DEATH);
d700 9
a708 8
      if (percent <= prob) {
        for (k = ch->followers; k; k = next) {
          next = k->next;
          if (k->follower->in_room == was_in) {
            if (k->follower == best_char)
              send_to_char("You sense that moving in that direction will lead to your death.\r\n",ch);
            else
	      act("$N senses moving in that direction will lead to the group's death.\r\n", FALSE, best_char, 0, ch, TO_CHAR);
d710 1
d712 2
a713 3
        return (0); 
      }
    } 
@


1.26
log
@Artus> Added ghosts.. Newbies no longer die, they become ghosts.
@
text
@d574 2
d591 1
a591 1
      if (!IS_GHOST(ch) && !PRF_FLAGGED(i, PRF_NOHASSLE) && 
d606 1
d610 4
a613 1
    if (!PRF_FLAGGED(ch, PRF_NOHASSLE) && (MOB_FLAGGED(i, MOB_AGGRESSIVE) ||
d618 2
a619 2
        act("$n looks at $N with an indifference.",FALSE, ch, 0, i, TO_NOTVICT);
        act("$N looks at you with an indifference.",FALSE, i, 0, ch, TO_CHAR);
d621 1
a621 1
        hit(ch, i, TYPE_UNDEFINED);
@


1.25
log
@
Modified: DM

Changed:
- Pick Lock bug fix
@
text
@d589 2
a590 1
      if (!PRF_FLAGGED(i, PRF_NOHASSLE) && (MOB_FLAGGED(ch, MOB_AGGRESSIVE) ||
@


1.24
log
@
Modified: DM

Added:
- paralyze checks
@
text
@d919 2
a920 1
    else
d922 1
d958 1
d960 4
d966 1
a966 1
    sprintf(buf, "%s what?\r\n", cmd_door[subcmd]);
d975 1
a975 1
  if ((door = find_door(ch, type, dir, cmd_door[subcmd], FALSE)) < 0)
d979 1
a979 1
    find_door(ch, type, dir, cmd_door[subcmd], TRUE);
d983 1
a983 1
  //  door = find_door(ch, type, dir, cmd_door[subcmd]);
d1009 1
a1009 1
      act("You can't $F that!", FALSE, ch, 0, cmd_door[subcmd], TO_CHAR);
d1011 1
a1011 1
	     IS_SET(flags_door[subcmd], NEED_OPEN))
d1014 1
a1014 1
	     IS_SET(flags_door[subcmd], NEED_CLOSED))
d1017 1
a1017 1
	     IS_SET(flags_door[subcmd], NEED_LOCKED))
d1020 1
a1020 1
	     IS_SET(flags_door[subcmd], NEED_UNLOCKED))
@


1.23
log
@*** empty log message ***
@
text
@d627 5
d717 5
@


1.22
log
@
Modified: DM

Changed:
- hack fix for death traps causing crash in agro checks
@
text
@d573 4
a576 4
  for (struct char_data *i = world[ch->in_room].people; i; i = i->next_in_room) {
    // DM - hack fix - problems for death traps when ch->in_room == NOWHERE (-1)
    if ((ch->in_room == NOWHERE) || (i == ch) || (FIGHTING(i)) || 
		    (GET_POS(i) <= POS_SLEEPING))
@


1.21
log
@*** empty log message ***
@
text
@d574 3
a576 1
    if ((i == ch) || (FIGHTING(i)) || (GET_POS(i) <= POS_SLEEPING))
@


1.20
log
@*** empty log message ***
@
text
@d876 2
a877 2
  sprintf(buf + strlen(buf), "%s%s.", ((obj) ? "" : "the "), (obj) ? "$p" :
	  (EXIT(ch, door)->keyword ? "$F" : "door"));
@


1.19
log
@Modified: DM

Changed:
- check_environment_effects
- corpse creation in death traps
@
text
@d836 7
a842 1
  sprintf(buf, "$n %ss ", cmd_door[scmd]);
d873 3
@


1.18
log
@Artus- Added stuff for healing trance.
@
text
@d504 9
d520 1
d522 2
a523 1
    extract_char(ch);
@


1.17
log
@Added: meditate move restrictions
@
text
@d462 2
d1052 1
a1052 1
  if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_MEDITATE)) {
@


1.16
log
@Modified: DM

Changed:
- made mount a skill

TODO:
- failure rates for mount?
@
text
@a62 1

d457 6
d1048 7
@


1.15
log
@Artus - Newbie 'recall' skill.. Allows players to recall at no cost. Might
        change this to pluck some of their movement.. Only works from >=
	POS_STANDING.. Level <= LVL_NEWBIE..
@
text
@d1634 10
@


1.14
log
@Artus - Some punishment stuff, and put aggro checking in -- seemed to be
        missing, nothing was checking for aggro mobs.. *shrugs*.
@
text
@d61 1
d107 35
@


1.13
log
@*** empty log message ***
@
text
@d42 1
a42 1
void pun_aggro_check (struct char_data *ch);
a495 5
  /* ARTUS: Yeah.. It's kinda a lame way of doing it, but it's nice to the
   * resources :o) -- Makes mobs attack players with aggravate punish bits. */
  if ((!IS_NPC(ch)) && (PUN_FLAGGED(ch, PUN_AGGRAVATE)))
    pun_aggro_check(ch);
  
d506 57
d598 5
a602 1
      return (do_simple_move(ch, dir, need_specials_check));
a653 1

d661 2
a662 1
  perform_move(ch, subcmd - 1, 0);
d1558 6
@


1.12
log
@Modified: Rod

Removed:
- couple of comments
@
text
@d1547 3
a1549 2
  bits = generic_find(arg, FIND_CHAR_ROOM | FIND_OBJ_ROOM | FIND_OBJ_INV | 
                           FIND_OBJ_EQUIP, ch, &found_char, &found_obj);
d1599 1
a1599 1
    sprintf(buf, "%s mounts %s.\r\n", 
@


1.11
log
@Modified: Artus - Punishment (PUN_AGGRO)
@
text
@d747 1
a747 1
  case SCMD_PICK:
d781 1
a781 1
  if (scmd == SCMD_PICK) {
@


1.10
log
@automatic stand on "wake"
@
text
@d42 1
d496 5
@


1.9
log
@
Changed:
- do_gen_door to check for door directions and aliases prior to objects ...
@
text
@d1096 1
a1096 1
      GET_POS(vict) = POS_SITTING;
d1106 1
a1106 1
    send_to_char("You awaken, and sit up.\r\n", ch);
d1108 1
a1108 1
    GET_POS(ch) = POS_SITTING;
@


1.8
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d45 1
a45 1
int find_door(struct char_data *ch, const char *type, char *dir, const char *cmdname);
d604 1
a604 1
int find_door(struct char_data *ch, const char *type, char *dir, const char *cmdname)
d610 2
a611 1
      send_to_char("That's not a direction.\r\n", ch);
d619 4
a622 2
	  sprintf(buf2, "I see no %s there.\r\n", type);
	  send_to_char(buf2, ch);
d628 5
a632 2
      sprintf(buf2, "I really don't see how you can %s anything there.\r\n", cmdname);
      send_to_char(buf2, ch);
d637 4
a640 2
      sprintf(buf2, "What is it you want to %s?\r\n", cmdname);
      send_to_char(buf2, ch);
d649 4
a652 2
    sprintf(buf2, "There doesn't seem to be %s %s here.\r\n", AN(type), type);
    send_to_char(buf2, ch);
d712 8
d818 1
d826 1
d828 12
a839 2
  if (!generic_find(type, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &victim, &obj))
    door = find_door(ch, type, dir, cmd_door[subcmd]);
d841 3
d845 13
a857 16
  if( obj ) 
	if( GET_OBJ_TYPE(obj) == ITEM_TRAP ) {
	   if( IS_THIEF(ch) )
		chance = 15;
	   else if( IS_MAGIC_USER(ch) )
		chance = 5;
	   else
		chance = 2;

	   if( number(1, chance) == chance ) 
		ch_trigger_trap(ch, obj);
	   else
		send_to_char("Strange, it won't budge.\r\n", ch);

	   return;
	}
a858 4
  // a broken container - must be fixed before it can open again
  if (obj) {
    if (GET_OBJ_DAMAGE(obj) == 0) {
      send_to_char("Nope, its broken. Perhaps you should fix it!\r\n", ch);
d861 1
a861 2
  }
  
@


1.7
log
@
Added:
- breakable containers to seal shut

Changed:
- formatting of mount functions?
@
text
@d24 1
d437 7
d494 7
@


1.6
log
@
Added:
- olc stuff - sectors, zone flags

Changed:
- Heaps of little fixes ....
@
text
@a34 1
ACMD(do_hit);
d58 1
d814 8
d1427 1
a1427 1
	struct char_data *victim;
d1429 2
a1430 2
	if( IS_NPC(ch) )
		return;
d1432 2
a1433 2
	// Find the target
	one_argument(argument, arg);
d1435 23
a1457 19
	if( !*arg ) {
		send_to_char("Just what would you like to break in?\r\n", ch);
		return;
	}	
	// Check the target is present
	if( !(victim = get_char_vis(ch, arg, FIND_CHAR_ROOM)) ) {
		send_to_char("Noone here by that name.\r\n", ch);
		return;
	}
	// Fighting?
	if( FIGHTING(ch) || FIGHTING(victim) ) {
		send_to_char("You can't do that now!\r\n", ch);
		return;
	}
	// Taming themselves?
	if( victim == ch ) {
		send_to_char("You break yourself in, and feel quite susceptible to being ridden.\r\n",ch);
		return;
	}
d1459 4
a1462 4
	if( AFF_FLAGGED(victim, AFF_BROKEN_IN) ) {
		act("$N is already broken in.", FALSE, ch, 0, victim, TO_CHAR );
		return;
	}		
d1464 11
a1474 11
	// Is the mob mountable? 
	if( MOB_FLAGGED(victim, MOB_MOUNTABLE) ) {
		/* Check for skill here */
		act("You successfully break $N in.", FALSE, ch, 0, victim, TO_CHAR);
		SET_BIT(AFF_FLAGS(victim), AFF_BROKEN_IN);
	}
	else {
		act("You try to break $N in, but $M does not respond well.", FALSE, ch, 0, victim, TO_CHAR);
		if( GET_LEVEL(ch) < LVL_IMMORT )
			do_hit(victim, ch->player.name, 0, 0);		
	}
d1481 3
a1483 3
	int bits;
	struct char_data *found_char = NULL;
	struct obj_data *found_obj = NULL;
d1485 9
a1493 1
	if (IS_NPC(ch) ) return;
d1495 5
a1499 1
	one_argument(argument, arg);
d1501 32
a1532 4
	if(!*arg) {
		send_to_char("Mount what?\r\n", ch);
		return;
	}
d1534 2
a1535 5
	// Check character is not already mounted
	if( MOUNTING(ch) || MOUNTING_OBJ(ch) ) {
		send_to_char("You're already mounted!\r\n", ch);
		return; 
	}
d1537 5
a1541 2
	bits = generic_find(arg, FIND_CHAR_ROOM | FIND_OBJ_ROOM | FIND_OBJ_INV | FIND_OBJ_EQUIP, 
		ch, &found_char, &found_obj);
d1543 5
a1547 25
	// Character found 
	if( found_char != NULL ) {
		// Check that the char is mountable
		if( !MOB_FLAGGED(found_char, MOB_MOUNTABLE) ) {
			send_to_char("You can't mount that!\r\n", ch);
			return;
		}	
		// Check if it's tamed
		if( !AFF_FLAGGED(found_char, AFF_BROKEN_IN) ) {
			send_to_char("This beastie's a bit too wild for you.\r\n", ch);
			act("$n hopelessly chases $N around, trying to mount $M.", FALSE, ch, 0,found_char, TO_ROOM);
			return;
		}	
		// Check that noone is riding it already
		if( MOUNTING(found_char) ) {
			act("Someone is already riding $M.", FALSE, ch, 0, found_char, TO_CHAR);
			return;
		}	
		// Mount the beast.
		act("With a flourish you mount $N.", FALSE, ch, 0, found_char,TO_CHAR);
		act("$n gracefully mounts $N.", FALSE, ch, 0, found_char, TO_ROOM);
		MOUNTING(ch) = found_char;
		MOUNTING(found_char) = ch;
		return;
	}
d1549 10
a1558 23
	// Is it an item
	if( found_obj != NULL ) {
		// Check that the target item is mountable
		if( !OBJ_FLAGGED(found_obj, ITEM_RIDDEN) ) {
			send_to_char("You can't mount that!\r\n", ch);
			return;
		}
		// Check it is not already being ridden
		if( OBJ_RIDDEN(found_obj) ) {
			send_to_char("It is already being ridden.\r\n", ch);
			return;
		}	
		// Mount it
		sprintf(buf, "You mount %s.\r\n", found_obj->short_description);
		send_to_char(buf, ch);
		sprintf(buf, "%s mounts %s.\r\n", GET_NAME(ch),found_obj->short_description);
		act(buf, FALSE, ch, 0, 0, TO_ROOM);
		MOUNTING_OBJ(ch) = found_obj;
		OBJ_RIDDEN(found_obj) = ch;		
		return;	
	}
	
	send_to_char("Nothing here by that name.\r\n", ch);
d1560 2
d1566 30
a1595 12
	struct char_data *mount;
	struct obj_data *obj_mount;
        int tmp = 0;

	if( IS_NPC(ch) ) return;

	// May as well make it a social too
	if( !MOUNTING(ch) && !MOUNTING_OBJ(ch) ) {
		send_to_char("You get off your high horse.\r\n", ch);
		act("$n gets off $s high horse.", FALSE, ch, 0, 0, TO_ROOM);
		return;
	}
d1597 6
a1602 23
	// Mobile dismount
	if( MOUNTING(ch) ) {
		// Get the mount
		mount = MOUNTING(ch);
		// Get a keyword
		one_argument(mount->player.name, arg);
		// If it is not visible ...
		if ( mount != get_char_vis(ch, arg, FIND_CHAR_ROOM) ) {
			send_to_char("Oh dear, you seem to have lost your ride.\r\n", ch);
			send_to_char("... you fall off your imaginary mount.\r\n", ch);
			act("$n falls off $s imaginary mount.\r\n", FALSE, ch, 0, 0, TO_ROOM);
		}
		else {
			// Dismount successful.
			send_to_char("You dismount.\r\n", ch);
			act("$n easily hops off $N.", FALSE, ch, 0, mount, TO_ROOM);
		}
		// Regardless of whether the player can see it or not, dismount. 
		MOUNTING(mount) = NULL;
		MOUNTING(ch) = NULL;
		GET_POS(ch) = POS_STANDING;
		return;
	}
d1604 19
a1622 22
	// Item dismount
	if( MOUNTING_OBJ(ch) ) {
		// Get the object
		obj_mount = MOUNTING_OBJ(ch);
		// Check it's being carried or is in the room
		if( !((obj_mount != get_obj_in_list_vis(ch, obj_mount->name, ch->carrying)) || 
                    (obj_mount != get_obj_in_list_vis(ch, obj_mount->name,world[ch->in_room].contents)) ||
		    (obj_mount != get_object_in_equip_vis(ch, obj_mount->name, ch->equipment, &tmp))) ) {
			send_to_char("Oh dear, you seem to have lost your ride.\r\n", ch);
			send_to_char("... you fall off your imaginary mount.\r\n", ch);
			act("$n falls off $s imaginary mount.\r\n", FALSE, ch, 0, 0, TO_ROOM);
		} 
		else {
			send_to_char("You dismount.\r\n", ch);
			act("$n easily hops off $N.", FALSE, ch, obj_mount, 0, TO_ROOM);
		}
		// Dismount
		OBJ_RIDDEN(obj_mount) = NULL;
		MOUNTING_OBJ(ch) = NULL;
		GET_POS(ch) = POS_STANDING;
		return;
	}
d1624 6
a1630 2

/*********************************** END mount.c ********************/
@


1.5
log
@
Added:
- 2 checks for !IS_NPC to stop excessive syslog errors.
@
text
@d121 1
a121 1
     if (SECT(ch->in_room)  != SECT_INSIDE  && !ROOM_FLAGGED(ch->in_room, ROOM_INDOORS)) {
@


1.4
log
@
Changed:
- Fix for mob using pc flags (flooding the syslog)
@
text
@d382 1
a382 1
  if (IS_NPC(ch) && need_movement > 1 && GET_SKILL(ch, SKILL_MOUNTAINEER) && 
d466 1
a466 1
  if (IS_NPC(ch) && (PRF_FLAGGED(ch,PRF_VAMPIRE) && !IS_SET(ROOM_FLAGS(ch->in_room),ROOM_DARK)
@


1.3
log
@my new skills!


Added:
-
-

Removed:
-
-

Changed:
-
-

TODO:
-
-
@
text
@d382 1
a382 1
  if (need_movement > 1 && GET_SKILL(ch, SKILL_MOUNTAINEER) && 
d466 1
a466 1
  if (PRF_FLAGGED(ch,PRF_VAMPIRE) && !IS_SET(ROOM_FLAGS(ch->in_room),ROOM_DARK)
d468 1
a468 1
        weather_info.sunlight == SUN_SET) && OUTSIDE(ch)) {
@


1.2
log
@
Added:
- Some initial colour coding for mobs and objects

Changed:
- Various inclusions from the existing primal base ...
- Including Sector fixes, clan guards, listing items

TODO:
- Fix colours for mobs/objects - A player comes up as a mob colour
@
text
@d30 1
d297 5
d381 8
a388 2
 
  if (GET_MOVE(ch) < need_movement && !IS_NPC(ch)) {
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@a30 27
/* JA new sector types, ther are 4 types of sector attributes
   each taking up 3 bits in the sector type integer, the lower
   4 bits remain as the base for the movement loss */
#define SECT_THIN             1
#define SECT_UNBREATHABLE     2
#define SECT_VACUUM           3
#define SECT_CORROSIVE        4
#define SECT_HOT              1
#define SECT_SCORCH           2
#define SECT_INCINERATE       3
#define SECT_COLD             4
#define SECT_FREEZING         5
#define SECT_ABSZERO          6
#define SECT_DOUBLEGRAV       1
#define SECT_TRIPLEGRAV       2
#define SECT_CRUSH            3
#define SECT_RAD1             1
#define SECT_DISPELL          2
 
/* macros to decode the bit map in the sect type */
#define BASE_SECT(n) ((n) & 0x000f)
 
#define ATMOSPHERE(n)  (((n) & 0x0070) >> 4)
#define TEMPERATURE(n) (((n) & 0x0380) >> 7)
#define GRAVITY(n)     (((n) & 0x1c00) >> 10)
#define ENVIRON(n)     (((n) & 0xe000) >> 13)
 
d277 4
a280 1
  int need_movement;
d301 1
a301 1
  /* if this room or the one we're going to needs a boat, check for one */
d309 26
d337 36
d374 2
a375 6
  if (!MOUNTING(ch) || !MOUNTING_OBJ(ch))
     need_movement = movement_loss[BASE_SECT(SECT(ch->in_room))] +
                   movement_loss[BASE_SECT(SECT(EXIT(ch, dir)->to_room))] >> 1;   
  else
     need_movement = 1;

d451 24
@

