head	1.50;
access;
symbols
	A3_0_59:1.7
	LATEST:1.7
	A3_0_1:1.6;
locks; strict;
comment	@ * @;


1.50
date	2004.08.27.02.12.19;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	2004.07.15.02.41.32;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	2004.07.10.03.28.55;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.07.11.37.49;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	2004.07.03.12.03.06;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	2004.06.08.12.34.25;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.08.10.55.50;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	2004.05.25.06.52.17;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.06.02.23.30;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.29.08.00.18;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.11.00.25.16;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.27.10.48.09;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.23.06.11.30;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.21.08.09.08;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.16.00.44.54;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.14.05.56.01;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.10.22.27.44;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.10.14.08.02;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.10.12.02.26;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.06.04.32.51;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.31.22.20.28;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.17.02.25.06;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.09.05.42.45;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	2003.11.21.04.26.51;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.15.01.42.17;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.13.01.05.29;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.06.03.47.16;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.03.17.01.11;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.20.12.01.50;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.20.08.17.56;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.18.14.48.29;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.07.01.05.33;	author karma;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.25.12.14.56;	author rod;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.11.15.35.11;	author rod;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.11.13.56.34;	author artus;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.12.10.38.49;	author artus;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.09.03.33.16;	author artus;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.26.07.47.20;	author primal;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.11.14.35.19;	author artus;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.04.07.59.44;	author primal;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.08.15.26.24;	author primal;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.04.18.14.42;	author primal;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.02.04.34.48;	author primal;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.26.17.18.55;	author primal;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.20.16.49.27;	author primal;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.26.07.52.28;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.13.00.59.20;	author primal;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.12.29.20;	author talisman;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.13.14.25.13;	author mbd;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.59;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Artus> Formatting changes only.
@
text
@/* ************************************************************************
*   File: limits.c                                      Part of CircleMUD *
*  Usage: limits & gain funcs for HMV, exp, hunger/thirst, idle time      *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "spells.h"
#include "comm.h"
#include "db.h"
#include "handler.h"
#include "interpreter.h"
#include "dg_scripts.h"

extern struct char_data *character_list;
extern struct obj_data *object_list;
extern struct room_data *world;
extern struct spell_info_type spell_info[];
extern int max_exp_gain;
extern int max_exp_loss;
extern int idle_rent_time;
extern int idle_max_level;
extern int idle_void;
extern int use_autowiz;
extern int min_wizlist_lev;
extern int free_rent;

// External Functions.
int has_stats_for_prac(struct char_data *ch, int skillnum, bool show);

/* local functions */
void check_autowiz(struct char_data * ch);

void Crash_rentsave(struct char_data *ch, int cost);
int level_exp(struct char_data *ch, int level);
char *title_male(int chclass, int level);
char *title_female(int chclass, int level);
void update_char_objects(struct char_data * ch);	/* handler.c */
void reboot_wizlists(void);
void punish_update(struct char_data * ch);		/* ARTUS */
void gain_clan_exp(struct char_data *ch, long amount);	/* ARTUS */

/* When age < 15 return the value p0 */
/* When age in 15..29 calculate the line between p1 & p2 */
/* When age in 30..44 calculate the line between p2 & p3 */
/* When age in 45..59 calculate the line between p3 & p4 */
/* When age in 60..79 calculate the line between p4 & p5 */
/* When age >= 80 return the value p6 */
int graf(int age, int p0, int p1, int p2, int p3, int p4, int p5, int p6)
{

  if (age < 15)
    return (p0);		/* < 15   */
  else if (age <= 29)
    return (int) (p1 + (((age - 15) * (p2 - p1)) / 15));	/* 15..29 */
  else if (age <= 44)
    return (int) (p2 + (((age - 30) * (p3 - p2)) / 15));	/* 30..44 */
  else if (age <= 59)
    return (int) (p3 + (((age - 45) * (p4 - p3)) / 15));	/* 45..59 */
  else if (age <= 79)
    return (int) (p4 + (((age - 60) * (p5 - p4)) / 20));	/* 60..79 */
  else
    return (p6);		/* >= 80 */
}


/*
 * The hit_limit, mana_limit, and move_limit functions are gone.  They
 * added an unnecessary level of complexity to the internal structure,
 * weren't particularly useful, and led to some annoying bugs.  From the
 * players' point of view, the only difference the removal of these
 * functions will make is that a character's age will now only affect
 * the HMV gain per tick, and _not_ the HMV maximums.
 */

#if 0 // Artus> No longer required.
void dbg_managain_calc(struct char_data *ch, char *arg)
{
  int gain, base, dyear, dint, dwis, dclass, dlevel, dage;
  char arg1[MAX_INPUT_LENGTH]="";
  int parse_class(char *arg);
  extern const char *class_abbrevs[];

  if (*arg)
    skip_spaces(&arg);

  // Set Defaults.
  dyear = age(ch)->year;
  dint = GET_INT(ch);
  dwis = GET_WIS(ch);
  dlevel = GET_LEVEL(ch);
  dage = GET_AGE(ch);
  dclass = GET_CLASS(ch);
  if (*arg)
  {
    arg = one_argument(arg, arg1);
    if (!is_number(arg1))
    {
      send_to_char("Syntax: debug managain [level] [classabbrev] [age] [int] [wis]\r\n", ch);
      return;
    }
    dlevel = atoi(arg1);
    if (*arg)
      skip_spaces(&arg);
    if (*arg)
    {
      arg = one_argument(arg, arg1);
      dclass = parse_class(arg1);
      if (dclass == CLASS_UNDEFINED)
	dclass = GET_CLASS(ch);
      arg = one_argument(arg, arg1);
      if (*arg)
	skip_spaces(&arg);
      if (is_number(arg1))
      {
	dage = atoi(arg1);
	if (*arg)
	  skip_spaces(&arg);
	if (*arg)
	{
	  arg = one_argument(arg, arg1);
	  if (is_number(arg1))
	  {
	    dint = atoi(arg1);
	    if (*arg)
	      skip_spaces(&arg);
	    arg = one_argument(arg, arg1);
	    if (is_number(arg1))
	      dwis = atoi(arg1);
	  }
	}
      }
    }
  }

  sprintf(buf, "[DBG] Level: %d, Class: %s, Age: %d, Int: %d, Wis: %d\r\n",
          dlevel, class_abbrevs[dclass], dage, dint, dwis);
  send_to_char(buf, ch);
  
  base = dint + dwis;
  sprintf(buf, "[DBG] Int + Wis: %d", base);

  if (base < 25)
    base = 5 + (int)(dlevel / 2);
  else if (base < 30)
    base = 8 + (int)(dlevel * 0.75);
  else if (base < 35)
    base = 10 + dlevel;
  else if (base == 35)
    base = 12 + (int)(dlevel * 1.25);
  else if (base == 36)
    base = 15 + (int)(dlevel * 1.5);
  else if (base == 37)
    base = 17 + (int)(dlevel * 1.75);
  else
    base = 20 + (dlevel << 1);

  sprintf(buf + strlen(buf), ", Base: %d, Year: %d", base, dyear);

  if (dage < 15)
    base = (int)(base * 0.75);
  else if (dage < 25);
  else if (dage < 30) 
    base = (int)(base * 1.5);
  else if (dage < 45)
    base <<= 1;
  else if (dage < 55);
  else
    base = (int)(base * 0.75);
  
  sprintf(buf + strlen(buf), ", Post Age: %d\r\n", base);
  switch (dclass)
  {
    case CLASS_WARRIOR:
      gain = (int)(base * 0.75);
      break;
    case CLASS_MAGIC_USER:
    case CLASS_CLERIC:
      gain = (base << 1);
      break;
    case CLASS_DRUID:
    case CLASS_MASTER:
      gain = (int)(base * 2.5);
      break;
    case CLASS_PRIEST:
    case CLASS_BATTLEMAGE:
    case CLASS_SPELLSWORD:
    case CLASS_PALADIN:
      gain = (int)(base * 1.5);
      break;
    case CLASS_NIGHTBLADE:
      gain = (int)(base * 0.5);
      break;
    default: // Thief.
      gain = base;
      break;
  }
  sprintf(buf + strlen(buf), "[DBG] Result: %d\r\n", gain);
  send_to_char(buf, ch);
}
#endif

/* Artus> Lets try improving on this. */
int mana_gain(struct char_data *ch)
{
  int gain, base, chyear;

  if (IS_NPC(ch))
    return GET_LEVEL(ch);
  
  base = GET_INT(ch) + GET_WIS(ch);

  if (base < 25)
    base = 5 + (int)(GET_LEVEL(ch) / 2);
  else if (base < 30)
    base = 8 + (int)(GET_LEVEL(ch) * 0.75);
  else if (base < 35)
    base = 10 + GET_LEVEL(ch);
  else if (base == 35)
    base = 12 + (int)(GET_LEVEL(ch) * 1.25);
  else if (base == 36)
    base = 15 + (int)(GET_LEVEL(ch) * 1.5);
  else if (base == 37)
    base = 17 + (int)(GET_LEVEL(ch) * 1.75);
  else
    base = 20 + GET_LEVEL(ch) << 1;

  chyear = age(ch)->year;

  if (chyear < 15)
    base = (int)(base * 0.75);
  else if (chyear < 25);
  else if (chyear < 30) 
    base = (int)(base * 1.5);
  else if (chyear < 45)
    base <<= 1;
  else if (chyear < 55);
  else
    base = (int)(base * 0.75);
  
  switch (GET_CLASS(ch))
  {
    case CLASS_WARRIOR:
      gain = (int)(base * 0.75);
      break;
    case CLASS_MAGIC_USER:
    case CLASS_CLERIC:
      gain = (base << 1);
      break;
    case CLASS_DRUID:
    case CLASS_MASTER:
      gain = (int)(base * 2.5);
      break;
    case CLASS_PRIEST:
    case CLASS_BATTLEMAGE:
    case CLASS_SPELLSWORD:
    case CLASS_PALADIN:
      gain = (int)(base * 1.5);
      break;
    case CLASS_NIGHTBLADE:
      gain = (int)(base * 0.5);
      break;
    default: // Thief
      gain = base;
      break;
  }

  // Some restrictions.
  gain = MAX(GET_LEVEL(ch) + 5, 
             MIN((int)(GET_MAX_MANA(ch) * 0.125), gain));

  if (GET_POS(ch) == POS_SLEEPING)			// Sleeping
  {
    if ((GET_SKILL(ch, SKILL_CAMPING) &&
	  (SECT(ch->in_room) == SECT_FOREST ||
	   SECT(ch->in_room) == SECT_MOUNTAIN ||
	   SECT(ch->in_room) == SECT_FIELD ||
	   SECT(ch->in_room) == SECT_HILLS)) &&
	has_stats_for_prac(ch, SKILL_CAMPING, false))
      gain *= 3;
    else
      gain <<= 1;
  } else if (GET_POS(ch) == POS_RESTING) {		// Resting
    if ((GET_SKILL(ch, SKILL_CAMPING) &&
	  (SECT(ch->in_room) == SECT_FOREST ||
	   SECT(ch->in_room) == SECT_MOUNTAIN ||
	   SECT(ch->in_room) == SECT_FIELD ||
	   SECT(ch->in_room) == SECT_HILLS)) &&
	has_stats_for_prac(ch, SKILL_CAMPING, false))
      gain <<= 1;
    else
      gain = (int)(gain * 1.5);
  } else if (GET_POS(ch) == POS_SITTING) {		// Sitting
    if (char_affected_by_timer(ch, TIMER_MEDITATE))
      gain += MAX(5, (int)APPLY_SPELL_EFFEC(ch, SKILL_MEDITATE, (gain << 1)));
    if (char_affected_by_timer(ch, TIMER_HEAL_TRANCE))
      gain += MAX(10, (int)APPLY_SPELL_EFFEC(ch, SKILL_HEAL_TRANCE, gain * 3));
  } else if (GET_POS(ch) == POS_FIGHTING) {		// Fighting
    gain >>= 2;
  }

  // Hunger/Thirst
  if ((GET_COND(ch, FULL) == 0) || (GET_COND(ch, THIRST) == 0))
    gain >>= 1;

  // Double Regen
  if (IS_SET(world[ch->in_room].room_flags,ROOM_REGEN_2))
    gain <<= 1;
  // Half Regen
  else if (IS_SET(world[ch->in_room].room_flags,ROOM_REGEN_HALF))
    gain >>= 1;

  // Low Regen Punishment.
  if (PUN_FLAGGED(ch, PUN_LOWREGEN))
    gain >>= 1;

  // Poison.
  if (AFF_FLAGGED(ch, AFF_POISON))
    gain >>= 2;

  return (gain);
}

#if 0 // Artus> Old Routine.
/* manapoint gain pr. game hour */
int old_mana_gain(struct char_data * ch)
{
  int gain;

  if (IS_NPC(ch)) {
    /* Neat and fast */
    gain = GET_LEVEL(ch);
  } else {
    //gain = graf(age(ch)->year, 4, 8, 12, 16, 12, 10, 8);
    gain = graf(age(ch)->year, 7, 8, 9, 10, 8, 7, 7);

    /* Class calculations */

    /* Skill/Spell calculations */

    /* WIS adjustment */
    if (GET_AFF_WIS(ch) > 17)
      gain += GET_AFF_WIS(ch) - 17;

    /* Position calculations    */
    switch (GET_POS(ch)) {
    case POS_SLEEPING:
      if (GET_SKILL(ch, SKILL_CAMPING) && 
		(SECT(ch->in_room) == SECT_FOREST || 
                 SECT(ch->in_room) == SECT_MOUNTAIN || 
                 SECT(ch->in_room) == SECT_FIELD || 
                 SECT(ch->in_room) == SECT_HILLS) )
	gain *= 3;
      else
	gain <<= 1;
      break;
    case POS_RESTING:
      if (GET_SKILL(ch, SKILL_CAMPING) && 
		(SECT(ch->in_room) == SECT_FOREST || 
                 SECT(ch->in_room) == SECT_MOUNTAIN || 
                 SECT(ch->in_room) == SECT_FIELD || 
                 SECT(ch->in_room) == SECT_HILLS) )
         gain += gain;
      else
	 gain += (gain / 2);	/* 1.5* gain */
      break;
    case POS_SITTING:
      if (char_affected_by_timer(ch, TIMER_MEDITATE))
	gain += MAX(5, (int)(gain * 2 * (GET_SKILL(ch, SKILL_MEDITATE) / 100) * (SPELL_EFFEC(ch, SKILL_MEDITATE) / 100)));
      if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_HEAL_TRANCE))
	gain += MAX(10, (int)(gain * 3 * (GET_SKILL(ch, SKILL_HEAL_TRANCE) / 100) * (SPELL_EFFEC(ch, SKILL_HEAL_TRANCE) / 100)));

      if (GET_SKILL(ch, SKILL_CAMPING) && 
		(SECT(ch->in_room) == SECT_FOREST || 
                 SECT(ch->in_room) == SECT_MOUNTAIN || 
                 SECT(ch->in_room) == SECT_FIELD || 
                 SECT(ch->in_room) == SECT_HILLS) )
	gain += (gain /2);
      else
        gain += (gain / 4);	/* Divide by 4 */
      break;
    case POS_FIGHTING:
      gain = 1;
    }

    /* JA make gain percentage based * /
    Artus> I don't think this works for me...
    gain = MAX((gain * GET_MAX_MANA(ch)) / 100, 10); 
    if (IS_MAGIC_USER(ch) || IS_CLERIC(ch))
      gain *= 2;
    */
    if (GET_CLASS(ch) <= CLASS_WARRIOR)
      gain = MAX((gain * (GET_MAX_MANA(ch) / 100)), 10);
    else if (GET_CLASS(ch) < CLASS_MASTER)
      gain = MAX((gain * (GET_MAX_MANA(ch) / 85)), 20);
    else
      gain = MAX((gain * (GET_MAX_MANA(ch) / 70)), 30);

    if (!(IS_MAGIC_USER(ch) || IS_CLERIC(ch)))
      gain >>= 1;

    if ((GET_COND(ch, FULL) == 0) || (GET_COND(ch, THIRST) == 0))
      gain >>= 2;

    if (IS_SET(world[ch->in_room].room_flags,ROOM_REGEN_2))
      gain = (gain * 3) / 2;

    if (IS_SET(world[ch->in_room].room_flags,ROOM_REGEN_HALF))
      gain >>= 1;

    if (PUN_FLAGGED(ch, PUN_LOWREGEN)) /* ARTUS - Low Regen Punishment */
      gain >>= 1;
  }

  if (AFF_FLAGGED(ch, AFF_POISON))
    gain >>= 2;

  return (gain);
}
#endif

int hit_gain(struct char_data *ch)
{
  int gain, base, chyear;

  if (IS_NPC(ch))
    return GET_LEVEL(ch);
  
  base = GET_STR(ch) + GET_CON(ch);

  if (base < 25)
    base = 5 + (int)(GET_LEVEL(ch) / 2);
  else if (base < 30)
    base = 8 + (int)(GET_LEVEL(ch) * 0.75);
  else if (base < 35)
    base = 10 + GET_LEVEL(ch);
  else if (base == 35)
    base = 12 + (int)(GET_LEVEL(ch) * 1.25);
  else if (base == 36)
    base = 15 + (int)(GET_LEVEL(ch) * 1.5);
  else if (base == 37)
    base = 17 + (int)(GET_LEVEL(ch) * 1.75);
  else
    base = 20 + GET_LEVEL(ch) << 1;

  chyear = age(ch)->year;

  if (chyear < 14)
    base = (int)(base * 1.75);
  else if (chyear < 26)
    base <<= 1;
  else if (chyear < 33) 
    base = (int)(base * 1.75);
  else if (chyear < 40)
    base = (int)(base * 1.5);
  else if (chyear < 50);
  else
    base = (int)(base * 0.75);
  
  switch (GET_CLASS(ch))
  {
    case CLASS_WARRIOR:
    case CLASS_MASTER:
      gain = (base << 1);
      break;
    case CLASS_MAGIC_USER:
    case CLASS_CLERIC:
      gain = (int)(base * 0.75);
      break;
    case CLASS_DRUID:
      gain = (int)(base * 0.5);
      break;
      break;
    case CLASS_PRIEST:
    case CLASS_BATTLEMAGE:
    case CLASS_SPELLSWORD:
    case CLASS_PALADIN:
      gain = (int)(base * 1.5);
      break;
    case CLASS_NIGHTBLADE:
      gain = (int)(base * 2.5);
      break;
    default: // Thief
      gain = base;
      break;
  }

  // Some restrictions.
  gain = MAX(GET_LEVEL(ch) + 5, 
             MIN((int)(GET_MAX_HIT(ch) * 0.125), gain));

  if (GET_POS(ch) == POS_SLEEPING)			// Sleeping
  {
    if ((GET_SKILL(ch, SKILL_CAMPING) &&
	  (SECT(ch->in_room) == SECT_FOREST ||
	   SECT(ch->in_room) == SECT_MOUNTAIN ||
	   SECT(ch->in_room) == SECT_FIELD ||
	   SECT(ch->in_room) == SECT_HILLS)) &&
	has_stats_for_prac(ch, SKILL_CAMPING, false))
      gain *= 3;
    else
      gain <<= 1;
  } else if (GET_POS(ch) == POS_RESTING) {		// Resting
    if ((GET_SKILL(ch, SKILL_CAMPING) &&
	  (SECT(ch->in_room) == SECT_FOREST ||
	   SECT(ch->in_room) == SECT_MOUNTAIN ||
	   SECT(ch->in_room) == SECT_FIELD ||
	   SECT(ch->in_room) == SECT_HILLS)) &&
	has_stats_for_prac(ch, SKILL_CAMPING, false))
      gain <<= 1;
    else
      gain = (int)(gain * 1.5);
  } else if (GET_POS(ch) == POS_SITTING) {		// Sitting
    if (char_affected_by_timer(ch, TIMER_MEDITATE))
      gain += MAX(5, (int)APPLY_SPELL_EFFEC(ch, SKILL_MEDITATE, (gain << 1)));
    if (char_affected_by_timer(ch, TIMER_HEAL_TRANCE))
      gain += MAX(10, (int)APPLY_SPELL_EFFEC(ch, SKILL_HEAL_TRANCE, gain * 3));
  } else if (GET_POS(ch) == POS_FIGHTING) {		// Fighting
    gain >>= 2;
  }

  // Hunger/Thirst
  if ((GET_COND(ch, FULL) == 0) || (GET_COND(ch, THIRST) == 0))
    gain >>= 1;

  // Double Regen
  if (IS_SET(world[ch->in_room].room_flags,ROOM_REGEN_2))
    gain <<= 1;
  // Half Regen
  else if (IS_SET(world[ch->in_room].room_flags,ROOM_REGEN_HALF))
    gain >>= 1;

  // Low Regen Punishment.
  if (PUN_FLAGGED(ch, PUN_LOWREGEN))
    gain >>= 1;

  // Poison.
  if (AFF_FLAGGED(ch, AFF_POISON))
    gain >>= 2;

  return (gain);
}

#if 0 // Artus> Old Routine.
/* Hitpoint gain pr. game hour */
int old_hit_gain(struct char_data * ch)
{
  int gain;

  if (IS_NPC(ch))
  {
    /* Neat and fast */
    gain = GET_LEVEL(ch);
  } else {

  //gain = graf(age(ch)->year, 8, 12, 20, 32, 16, 10, 4);
    gain = graf(age(ch)->year, 4, 5, 6, 7, 6, 5, 4);

  /* CON adjustment */
    if (GET_AFF_CON(ch) > 17)
      gain += GET_AFF_CON(ch) - 18;

    /* Class/Level calculations */

    /* Skill/Spell calculations */

    /* Position calculations    */

    switch (GET_POS(ch))
    {
      case POS_SLEEPING:
	if (GET_SKILL(ch, SKILL_CAMPING) && 
		  (SECT(ch->in_room) == SECT_FOREST || 
		   SECT(ch->in_room) == SECT_MOUNTAIN || 
		   SECT(ch->in_room) == SECT_FIELD || 
		   SECT(ch->in_room) == SECT_HILLS) )
	  gain += gain;
	else
	  gain += (gain / 2);	/* Divide by 2 */
	break;
      case POS_RESTING:
	if (GET_SKILL(ch, SKILL_CAMPING) && 
		  (SECT(ch->in_room) == SECT_FOREST || 
		   SECT(ch->in_room) == SECT_MOUNTAIN || 
		   SECT(ch->in_room) == SECT_FIELD || 
		   SECT(ch->in_room) == SECT_HILLS) )
	  gain += (gain /2);
	else
	  gain += (gain / 4);	/* Divide by 4 */
	break;
      case POS_SITTING:
	if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_MEDITATE))
	  gain += MAX(5, (int)(gain * 2 * (GET_SKILL(ch, SKILL_MEDITATE) / 100) * (SPELL_EFFEC(ch, SKILL_MEDITATE) / 100)));
	if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_HEAL_TRANCE))
	  gain += MAX(10, (int)(gain * 3 * (GET_SKILL(ch, SKILL_HEAL_TRANCE) / 100) * (SPELL_EFFEC(ch, SKILL_HEAL_TRANCE) / 100)));	

	if (GET_SKILL(ch, SKILL_CAMPING) && 
		  (SECT(ch->in_room) == SECT_FOREST || 
		   SECT(ch->in_room) == SECT_MOUNTAIN || 
		   SECT(ch->in_room) == SECT_FIELD || 
		   SECT(ch->in_room) == SECT_HILLS) )
	  gain += (gain / 4);
	else
	  gain += (gain / 8);	/* Divide by 8 */


	break;
    }

    /* Artus> This is wrong too.. 
    if (IS_MAGIC_USER(ch) || IS_CLERIC(ch))
      gain /= 2;	/ * Ouch. */
    if (IS_WARRIOR(ch))
      gain <<= 1;
    else if (IS_THIEF(ch))
      gain = (int)(gain * 1.5);

    if ((GET_COND(ch, FULL) == 0) || (GET_COND(ch, THIRST) == 0))
      gain >>= 2;

    /* JA make gain percent based * /
     * Artus> Lets make this a little nicer.
    gain = MAX((gain * GET_MAX_HIT(ch)) / 100, 10); */

    if (GET_CLASS(ch) <= CLASS_WARRIOR)
      gain = MAX((gain * (GET_MAX_HIT(ch) / 100)), 10);
    else if (GET_CLASS(ch) < CLASS_MASTER)
      gain = MAX((gain * (GET_MAX_HIT(ch) / 85)), 20);
    else
      gain = MAX((gain * (GET_MAX_HIT(ch) / 70)), 30);

    if ((GET_COND(ch, FULL) == 0) || (GET_COND(ch, THIRST) == 0))
      gain >>= 2;

    if (IS_SET(world[ch->in_room].room_flags,ROOM_REGEN_2))
      gain = (gain * 3) / 2;

    if (IS_SET(world[ch->in_room].room_flags,ROOM_REGEN_HALF))
      gain >>= 1;

    if (PUN_FLAGGED(ch, PUN_LOWREGEN)) /* ARTUS - Low Regen Punishment */
      gain >>= 1;
  }

  if (AFF_FLAGGED(ch, AFF_POISON))
    gain >>= 2;

  return (gain);
}
#endif

int move_gain(struct char_data *ch)
{
  int gain, base, chyear;

  if (IS_NPC(ch))
    return GET_LEVEL(ch);
  
  base = GET_DEX(ch) + GET_STR(ch);

  if (base < 25)
    base = 2 + (int)(GET_LEVEL(ch) * 0.2);
  else if (base < 30)
    base = 3 + (int)(GET_LEVEL(ch) * 0.3);
  else if (base < 35)
    base = 5 + (int)(GET_LEVEL(ch) * 0.4);
  else if (base == 35)
    base = 7 + (int)(GET_LEVEL(ch) * 0.5);
  else if (base == 36)
    base = 10 + (int)(GET_LEVEL(ch) * 0.6);
  else if (base == 37)
    base = 12 + (int)(GET_LEVEL(ch) * 0.7);
  else
    base = 15 + (int)(GET_LEVEL(ch) * 0.8);

  chyear = age(ch)->year;

  if (chyear < 14)
    base = (int)(base * 0.75);
  else if (chyear < 20)
    base <<= 1;
  else if (chyear < 28) 
    base = (int)(base * 1.75);
  else if (chyear < 35)
    base = (int)(base * 1.5);
  else if (chyear < 45);
  else
    base = (int)(base * 0.75);
  
  switch (GET_CLASS(ch))
  {
    case CLASS_WARRIOR:
    case CLASS_PRIEST:
    case CLASS_BATTLEMAGE:
    case CLASS_SPELLSWORD:
    case CLASS_PALADIN:
      gain = (int)(base * 1.25);
      break;
    case CLASS_THIEF:
    case CLASS_NIGHTBLADE:
    case CLASS_MASTER:
      gain = (int)(base * 1.5);
      break;
    default: // Druid, Magic User, Cleric
      gain = base;
      break;
  }

  // Some restrictions.
  gain = MAX(GET_LEVEL(ch) + 5, 
             MIN((int)(GET_MAX_MOVE(ch) * 0.125), gain));

  if (GET_POS(ch) == POS_SLEEPING)			// Sleeping
  {
    if ((GET_SKILL(ch, SKILL_CAMPING) &&
	  (SECT(ch->in_room) == SECT_FOREST ||
	   SECT(ch->in_room) == SECT_MOUNTAIN ||
	   SECT(ch->in_room) == SECT_FIELD ||
	   SECT(ch->in_room) == SECT_HILLS)) &&
	has_stats_for_prac(ch, SKILL_CAMPING, false))
      gain *= 3;
    else
      gain <<= 1;
  } else if (GET_POS(ch) == POS_RESTING) {		// Resting
    if ((GET_SKILL(ch, SKILL_CAMPING) &&
	  (SECT(ch->in_room) == SECT_FOREST ||
	   SECT(ch->in_room) == SECT_MOUNTAIN ||
	   SECT(ch->in_room) == SECT_FIELD ||
	   SECT(ch->in_room) == SECT_HILLS)) &&
	has_stats_for_prac(ch, SKILL_CAMPING, false))
      gain <<= 1;
    else
      gain = (int)(gain * 1.5);
  } else if (GET_POS(ch) == POS_SITTING) {		// Sitting
    if (char_affected_by_timer(ch, TIMER_MEDITATE))
      gain += MAX(5, (int)APPLY_SPELL_EFFEC(ch, SKILL_MEDITATE, (gain << 1)));
    if (char_affected_by_timer(ch, TIMER_HEAL_TRANCE))
      gain += MAX(10, (int)APPLY_SPELL_EFFEC(ch, SKILL_HEAL_TRANCE, gain * 3));
  } else if (GET_POS(ch) == POS_FIGHTING) {		// Fighting
    gain >>= 2;
  }

  // Hunger/Thirst
  if ((GET_COND(ch, FULL) == 0) || (GET_COND(ch, THIRST) == 0))
    gain >>= 1;

  // Double Regen
  if (IS_SET(world[ch->in_room].room_flags,ROOM_REGEN_2))
    gain <<= 1;
  // Half Regen
  else if (IS_SET(world[ch->in_room].room_flags,ROOM_REGEN_HALF))
    gain >>= 1;

  // Low Regen Punishment.
  if (PUN_FLAGGED(ch, PUN_LOWREGEN))
    gain >>= 2;

  // Poison.
  if (AFF_FLAGGED(ch, AFF_POISON))
    gain >>= 2;

  return (gain);
}

#if 0 // Artus> Old Routine.
/* move gain pr. game hour */
int old_move_gain(struct char_data * ch)
{
  int gain;

  if (IS_NPC(ch)) {
    /* Neat and fast */
    gain = GET_LEVEL(ch);
  } else {
    //gain = graf(age(ch)->year, 16, 20, 24, 20, 16, 12, 10);
    gain = graf(age(ch)->year, 5, 7, 10, 15, 14, 12, 9);

    /* Class/Level calculations */

    /* Skill/Spell calculations */

    /* Position calculations    */
    switch (GET_POS(ch)) 
    {
      case POS_SLEEPING:
	if (GET_SKILL(ch, SKILL_CAMPING) && 
		  (SECT(ch->in_room) == SECT_FOREST || 
		   SECT(ch->in_room) == SECT_MOUNTAIN || 
		   SECT(ch->in_room) == SECT_FIELD || 
		   SECT(ch->in_room) == SECT_HILLS) )
	  gain += gain;
	else
	  gain += (gain / 2);	/* Divide by 2 */
	break;
      case POS_RESTING:
	if (GET_SKILL(ch, SKILL_CAMPING) && 
		  (SECT(ch->in_room) == SECT_FOREST || 
		   SECT(ch->in_room) == SECT_MOUNTAIN || 
		   SECT(ch->in_room) == SECT_FIELD || 
		   SECT(ch->in_room) == SECT_HILLS) )
	  gain += (gain /2);
	else
	  gain += (gain / 4);	/* Divide by 4 */
	break;
      case POS_SITTING:
	if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_MEDITATE))
	  gain += MAX(5, (int)(gain * 2 * (GET_SKILL(ch, SKILL_MEDITATE) / 100) * (SPELL_EFFEC(ch, SKILL_MEDITATE) / 100)));
	if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_HEAL_TRANCE))
	  gain += MAX(10, (int)(gain * 2 * (GET_SKILL(ch, SKILL_HEAL_TRANCE) / 100) * (SPELL_EFFEC(ch, SKILL_HEAL_TRANCE) / 100)));

	if (GET_SKILL(ch, SKILL_CAMPING) && 
		  (SECT(ch->in_room) == SECT_FOREST || 
		   SECT(ch->in_room) == SECT_MOUNTAIN || 
		   SECT(ch->in_room) == SECT_FIELD || 
		   SECT(ch->in_room) == SECT_HILLS) )
	  gain += (gain / 4);
	else
	  gain += (gain / 8);	/* Divide by 8 */
	break;
      case POS_FIGHTING:
	gain = 1;
    }

    /* JA make gain percent based * /
     * Artus> Interferes again :o)..
    gain = MAX((gain * GET_MAX_MOVE(ch)) / 100, 10); */
    if (GET_CLASS(ch) <= CLASS_WARRIOR)
      gain = MAX((gain * (GET_MAX_MOVE(ch) / 100)), 10);
    else if (GET_CLASS(ch) < CLASS_MASTER)
      gain = MAX((gain * (GET_MAX_MOVE(ch) / 85)), 20);
    else
      gain = MAX((gain * (GET_MAX_MOVE(ch) / 70)), 30);

    if (IS_THIEF(ch))
      gain = (int)(gain * 1.7);
    else if (IS_WARRIOR(ch))
      gain = (int)(gain * 1.25);

    if ((GET_COND(ch, FULL) == 0) || (GET_COND(ch, THIRST) == 0))
      gain >>= 2;
    
    if (IS_SET(world[ch->in_room].room_flags,ROOM_REGEN_2))
      gain = (gain * 3) / 2;

    if (IS_SET(world[ch->in_room].room_flags,ROOM_REGEN_HALF))
      gain >>= 1;

    if (PUN_FLAGGED(ch, PUN_LOWREGEN)) /* ARTUS - Low Regen Punishment */
      gain >>= 1;
  }

  if (AFF_FLAGGED(ch, AFF_POISON))
    gain >>= 2;

  return (gain);
}
#endif

void set_title(struct char_data * ch, char *title)
{
  if (title == NULL) {
    if (GET_TITLE(ch) != NULL)
      free(GET_TITLE(ch));

    GET_TITLE(ch) = str_dup("");
    return;
  }

  if (strlen(title) > MAX_TITLE_LENGTH)
    title[MAX_TITLE_LENGTH] = '\0';

  if (GET_TITLE(ch) != NULL)
    free(GET_TITLE(ch));

  GET_TITLE(ch) = str_dup(title);
}


// Dont use unless u fix up the code in util/autowiz.c <- DM
// (causes a crash)
void check_autowiz(struct char_data * ch)
{
#if defined(CIRCLE_UNIX) || defined(CIRCLE_WINDOWS)
  if (use_autowiz && GET_LEVEL(ch) >= LVL_IMPL)
  {
    char xbuf[128];
#if defined(CIRCLE_UNIX)
    sprintf(xbuf, "nice ../bin/autowiz %d %s %d %s %d &", min_wizlist_lev,
	    WIZLIST_FILE, LVL_IMPL, IMMLIST_FILE, (int) getpid());
#elif defined(CIRCLE_WINDOWS)
    sprintf(xbuf, "autowiz %d %s %d %s", min_wizlist_lev,
	    WIZLIST_FILE, LVL_IMPL, IMMLIST_FILE);
#endif /* CIRCLE_WINDOWS */

    mudlog("Initiating autowiz.", CMP, LVL_IMPL, FALSE);
    system(xbuf);
    reboot_wizlists();
  }
#endif /* CIRCLE_UNIX || CIRCLE_WINDOWS */
}

/* Artus> Changed to int, will return the actual amount gained. */
int gain_exp(struct char_data * ch, int gain)
{
  int is_altered = FALSE;
  int newgain;
  int num_levels = 0;
  char buf[128];

  if (!IS_NPC(ch) && ((GET_LEVEL(ch) < 1) || !CAN_LEVEL(ch)))
    return 0;

  if (IS_NPC(ch)) 
  {
    GET_EXP(ch) += gain;
    return gain;
  }

  // The famous exp cap :) TODO: decide whether we want to lessen this, at
  // least for remort characters...
  if (gain > 0) 
  {
    // DM: apply the exp modifier ...
#ifndef IGNORE_DEBUG
    if (GET_DEBUG(ch)) 
    {
      sprintf(buf, "raw exp = %d", gain); 
      send_to_char(buf, ch);
    }
#endif
    gain = (int)((float)(gain * (1 / GET_MODIFIER(ch))));
    newgain = MIN(GET_LEVEL(ch) * 10000, gain);
    if ((newgain < gain) && (GET_CLASS(ch) > CLASS_WARRIOR))
    {
      if (GET_CLASS(ch) == CLASS_MASTER)
	newgain = MIN(GET_LEVEL(ch) * 15000, gain);
      else
	newgain = MIN(GET_LEVEL(ch) * 12500, gain);
    }

    /* Artus: Increase modifier for remorts.
    if (!IS_NPC(ch) && (GET_CLASS(ch) > CLASS_WARRIOR) && (newgain < gain))
      newgain = (int)(newgain * 1.5); 
     * Artus> Why??? */
#ifndef IGNORE_DEBUG
    if (GET_DEBUG(ch)) 
    {
      sprintf(buf, "gain = %d, newgain = %d\r\n", gain, newgain); 
      send_to_char(buf, ch);
    }
#endif
    gain_clan_exp(ch, gain); /* ARTUS - Give clan exp.. */
    if (newgain < gain)
    {
      sprintf(buf,"You receive less experience (%d) due to help.\n",newgain);
      send_to_char(buf,ch);
      gain=newgain;
    } 

//    gain = MIN(max_exp_gain, gain);	/* put a cap on the max gain per kill */
    GET_EXP(ch) += gain;

   /* DM_exp - change for new exp system */
    GET_EXP(ch)=MIN(GET_EXP(ch),level_exp((ch),LVL_IMMORT-1)*2);
 
    while (CAN_LEVEL(ch) && (GET_EXP(ch) >= level_exp((ch),GET_LEVEL(ch)))) 
    {
  //    send_to_char("You rise a level!\r\n", ch);
      GET_LEVEL(ch) += 1;
      num_levels++;
  /* DM_exp - reset the exp */
      GET_EXP(ch) = GET_EXP(ch)-level_exp((ch),GET_LEVEL(ch)-1);
      advance_level(ch);
      is_altered = TRUE;
    }
    if (is_altered) 
    {
      if (num_levels == 1)
      {
        send_to_char("You rise a level!\r\n", ch);
      } else {
	sprintf(buf, "You rise %d levels!\r\n", num_levels);
	send_to_char(buf, ch);
      }
    }
  } else if (gain < 0) {
    /* CAP removed bm 3/95 */
    /* gain = MAX(-max_exp_loss, gain);*/       /* Cap max exp lost per death */
    GET_EXP(ch) += gain;
    if (GET_EXP(ch) < 0)
      GET_EXP(ch) = 0;
  }
  return (gain);
}

/* DM_exp - changed to take the number of levels advanced */  
void gain_exp_regardless(struct char_data * ch, int /*gain*/ newlevel)
{
  int is_altered = FALSE;
  int num_levels = 0;

  GET_EXP(ch) = 0; 

//  GET_EXP(ch) += gain;
//  if (GET_EXP(ch) < 0)
//    GET_EXP(ch) = 0;

  if (!IS_NPC(ch)) 
  {
    if (newlevel > LVL_IMPL)
      newlevel = LVL_IMPL;
    while (LR_FAIL(ch, LVL_IMPL) && GET_LEVEL(ch) < newlevel)
    { 
      GET_LEVEL(ch) += 1;
      num_levels++;
      advance_level(ch);
      is_altered = TRUE;
    }

    if (is_altered) {
//      sprintf(buf, "%s advanced %d level%s to level %d.",
//		GET_NAME(ch), num_levels, num_levels == 1 ? "" : "s",
//		GET_LEVEL(ch));
//      mudlog(buf, BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
      if (num_levels == 1)
        send_to_char("You rise a level!\r\n", ch);
      else {
	sprintf(buf, "You rise %d levels!\r\n", num_levels);
	send_to_char(buf, ch);
      }
//      set_title(ch, NULL);
      //check_autowiz(ch);
    }
  }
}


void gain_condition(struct char_data * ch, int condition, int value)
{
  void perform_eat(struct char_data *ch, struct obj_data *food, int subcmd);
  bool intoxicated;
  int i, check_cond=0, move_val;
  struct obj_data *food, *fewd;

  if (IS_NPC(ch) || GET_COND(ch, condition) == -1)	/* No change */
    return;

  switch (condition)
  {
    case FULL: check_cond = ITEM_NOHUNGER;break;
    case THIRST: check_cond=ITEM_NOTHIRST;break;
    case DRUNK: check_cond=ITEM_NODRUNK;break;
  }
  /* check for items with NOHUNGER, NOTHIRST, or NODRUNK */
  for (i=0; i<NUM_WEARS;i++)
    if (ch->equipment[i])
      if (IS_OBJ_STAT(ch->equipment[i],check_cond)) {
        /* to make sure they dont keep getting warnings */
        if (GET_COND(ch, condition)==0)
          GET_COND(ch, condition)=1; 
        return;
      }

  intoxicated = (GET_COND(ch, DRUNK) > 0);

  GET_COND(ch, condition) += value;

  GET_COND(ch, condition) = MAX(0, GET_COND(ch, condition));
  GET_COND(ch, condition) = MIN(24, GET_COND(ch, condition));

  if (GET_COND(ch, condition) || PLR_FLAGGED(ch, PLR_WRITING))
    return;

  switch (condition)
  {
    case FULL:
      send_to_char("You are hungry.\r\n", ch);
      // Artus> AutoEat.
      // Possible TODO: If Detect Poison, Skip Bad Food...
      if (!(EXT_FLAGGED(ch, EXT_AUTOEAT) && (ch->carrying)))
	return;
      if (GET_POS(ch) < POS_RESTING) // No eating while sleeping :o)
	return;
      move_val = 5;
      if (FIGHTING(ch)) 
	move_val += 5;
      if (GET_MOVE(ch) < move_val)
	return;
      for (food = ch->carrying; food; food=food->next_content)
      {
	fewd = NULL;
	if (!CAN_SEE_OBJ(ch, food))
	  continue;
	if (GET_OBJ_TYPE(food) == ITEM_FOOD)
	{
	  fewd = food;
	  break;
	}
	if ((GET_OBJ_TYPE(food) == ITEM_CONTAINER) &&
	    (!OBJVAL_FLAGGED(food, CONT_CLOSED)) && (food->contains) &&
	    (GET_MOVE(ch) >= move_val + 5))
	  for (fewd = food->contains; fewd; fewd = fewd->next_content)
	    if ((GET_OBJ_TYPE(fewd) == ITEM_FOOD) && CAN_SEE_OBJ(ch, fewd))
	    {
	      sprintf(buf, "You get &5%s&n from &5%s&n.\r\n", 
		      OBJS(fewd, ch), OBJS(food, ch));
	      send_to_char(buf, ch);
	      move_val += 5;
	      break;
	    }
	if ((fewd) && (GET_OBJ_TYPE(fewd) == ITEM_FOOD))
	  break;
      }
      if (!(fewd))
	return;
      GET_MOVE(ch) -= move_val;
      perform_eat(ch, fewd, SCMD_EAT);
      return;
    case THIRST:
      send_to_char("You are thirsty.\r\n", ch);
      return;
    case DRUNK:
      if (intoxicated)
	send_to_char("You are now sober.\r\n", ch);
      return;
    default:
      break;
  }
}

#define IDLE_ROOM_VNUM  1102

void check_idling(struct char_data * ch)
{
  extern room_rnum r_mortal_start_room;

  // DM - changed idle_max_level to LVL_OWNER, just added the angel line here
  if (++(ch->char_specials.timer) > idle_void && LR_FAIL(ch, LVL_IS_GOD))
  {
    if (GET_WAS_IN(ch) == NOWHERE && ch->in_room != NOWHERE)
    {
      GET_WAS_IN(ch) = ch->in_room;
      if (FIGHTING(ch))
      {
	stop_fighting(FIGHTING(ch));
	stop_fighting(ch);
      }
      act("$n disappears into the void.", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You have been idle, and are pulled into a void.\r\n", ch);
      save_char(ch, NOWHERE);
      Crash_crashsave(ch);
      char_from_room(ch);
      char_to_room(ch, real_room(IDLE_ROOM_VNUM));
    } else if (ch->char_specials.timer > idle_rent_time)
    {
      if (ch->in_room != NOWHERE)
	char_from_room(ch);
      if (GET_WAS_IN(ch) != NOWHERE)
	char_to_room(ch, GET_WAS_IN(ch));
      else 
	char_to_room(ch, real_room(r_mortal_start_room));
      sprintf(buf, "%s force-rented and extracted (idle).", GET_NAME(ch));
      if (ch->desc)
      {
	mudlog(buf, NRM, LVL_GOD, TRUE);
	sprintf(buf, "&7%s &ghas left the game.", GET_NAME(ch));
	info_channel(buf, ch);
	STATE(ch->desc) = CON_DISCONNECT;
	/*
	 * For the 'if (d->character)' test in close_socket().
	 * -gg 3/1/98 (Happy anniversary.)
	 */
	ch->desc->character = NULL;
	ch->desc = NULL;
      } else {
	mudlog(buf, CMP, LVL_GOD, TRUE);
      }
      if (free_rent)
	Crash_rentsave(ch, 0);
      else
	Crash_idlesave(ch);
      extract_char(ch);
    }
  }
}



/* Update PCs, NPCs, and objects */
void point_update(void)
{
  extern struct index_data *obj_index;
  struct char_data *i, *next_char;
  struct obj_data *j, *next_thing, *jj, *next_thing2;
  struct timer_type *timer, *next_timer;
  void death_cry(struct char_data * ch);

  /* characters */
  for (i = character_list; i; i = next_char)
  {
    next_char = i->next;
	
    if (GET_POS(i) >= POS_STUNNED) 
    {
/* below ifs are so you can have more HIT/MANA/MOVE then MAX_HIT/MANA/MOVE
 * when wolf/vamp. this is so ya can have BIG bonuses instead of the max
 * of 128 that ya get with an affection cos the number is an sbyte - Vader */
      if (GET_HIT(i) < GET_MAX_HIT(i))
        GET_HIT(i) = MIN(GET_HIT(i) + hit_gain(i), GET_MAX_HIT(i));

      // Remove Ghost Status
      if (!IS_NPC(i) && IS_GHOST(i) && (GET_HIT(i) >= GET_MAX_HIT(i)))
        REMOVE_BIT(EXT_FLAGS(i), EXT_GHOST);

      if(GET_MANA(i) < GET_MAX_MANA(i))
        GET_MANA(i) = MIN(GET_MANA(i) + mana_gain(i), GET_MAX_MANA(i));

      if(GET_MOVE(i) < GET_MAX_MOVE(i))
        GET_MOVE(i) = MIN(GET_MOVE(i) + move_gain(i), GET_MAX_MOVE(i));

      // Artus> Remove meditate.
      if ((GET_POS(i) == POS_SITTING) && !IS_NPC(i) &&
	  ((timer = char_affected_by_timer(i, TIMER_MEDITATE)) ||
	   (timer = char_affected_by_timer(i, TIMER_HEAL_TRANCE))) &&
	  (GET_HIT(i) >= GET_MAX_HIT(i)) &&
	  (GET_MANA(i) >= GET_MAX_MANA(i)) &&
	  (GET_MOVE(i) >= GET_MAX_MOVE(i)))
      {
	timer->duration = 0;
	timer_remove_char(i, timer);
      }

      if (IS_AFFECTED(i, AFF_POISON))
	if (damage(i, i, 2, SPELL_POISON, FALSE) == -1)
	  continue;	/* Oops, they died. -gg 6/24/98 */

      if(!IS_NPC(i) && !IS_AFFECTED(i,AFF_WATERBREATHE) &&
	 (UNDERWATER(i)) && LR_FAIL(i, LVL_IS_GOD))
      {
        send_to_char("You take a deep breath of water. OUCH!\r\n",i);
        send_to_char("Your chest protests terrebly causing great pain.\r\n", i);
        act("$n suddenly turns a deep blue color holding $s throat.", 
            TRUE, i, 0, 0 , TO_ROOM);
        // GET_HIT(i)-= GET_LEVEL(i)*5;
	damage(NULL, i, GET_LEVEL(i)*5, TYPE_UNDEFINED, FALSE);
	if (GET_HIT(i) <0)
	{
	  send_to_char("Your life flashes before your eyes.  You have Drowned.  RIP!\r\n", i);
	  act("$n suddenly turns a deep blue color holding $s throat.", 
	      TRUE, i, 0, 0 , TO_ROOM);
	  act("$n has drowned. RIP!.", TRUE, i, 0, 0, TO_ROOM);
	  if (MOUNTING(i))
	  {
	    send_to_char("Your mount suffers as it dies.\r\n", i);
	    death_cry(MOUNTING(i));
	    raw_kill(MOUNTING(i), NULL);
	  }
	  death_cry(i);
	  die(i,NULL,"drowning");
	  continue;
	}
      }                  
      if (GET_POS(i) <= POS_STUNNED)
	update_pos(i);
    } else if (GET_POS(i) == POS_INCAP) {
      if (FIGHTING(i))
      { // Artus> Let the opponent get exp :o)
	if (damage(i, FIGHTING(i), 1, TYPE_SUFFERING, FALSE) == -1)
	  continue;
      } else {
	if (damage(i, i, 1, TYPE_SUFFERING, FALSE) == -1)
	  continue;
      }
    } else if (GET_POS(i) == POS_MORTALLYW) {
      if (FIGHTING(i))
      {
	if (damage(i, FIGHTING(i), 2, TYPE_SUFFERING, FALSE) == -1)
	  continue;
      } else {
	if (damage(i, i, 2, TYPE_SUFFERING, FALSE) == -1)
	  continue;
      }
    }
    if (!IS_NPC(i))
    {
      update_char_objects(i);
      if (GET_LEVEL(i) < idle_max_level)
	check_idling(i);
    }
    gain_condition(i, FULL, -1);
    gain_condition(i, DRUNK, -1);
    gain_condition(i, THIRST, -1);
    punish_update(i);
  }

  /* objects */
  for (j = object_list; j; j = next_thing)
  {
    next_thing = j->next;	/* Next in object list */
    // Remove timers-structures 
    for (timer = OBJ_TIMERS(j); timer; timer = next_timer)
    {
      next_timer = timer->next;
                      
      // Decrement time
      if (timer->duration > 1)
        timer->duration--;
      else if (timer->duration == -1)      /* No action */
        timer->duration = -1;
      // Remove Timer
      else
        timer_remove_obj(j, timer);
    }

    /* If this is a corpse */
    if (IS_CORPSE(j))
    {
      /* timer count down */
      if (GET_OBJ_TIMER(j) > 0)
	GET_OBJ_TIMER(j)--;

      if (!GET_OBJ_TIMER(j))
      {
	if (j->carried_by)
	  act("$p decays in your hands.", FALSE, j->carried_by, j, 0, TO_CHAR);
	else if ((j->in_room != NOWHERE) && (world[j->in_room].people))
	{
          if(GET_OBJ_VNUM(j) == 22300)
	  { /* check if its a gate */
            act("The space/time continuum heals itself causing $p to disappear.",
                TRUE, world[j->in_room].people, j, 0, TO_ROOM);
            act("The space/time continuum heals itself causing $p to disappear.",
                TRUE, world[j->in_room].people, j, 0, TO_CHAR);
          } else { 
	    act("A quivering horde of maggots consumes $p.",
	        TRUE, world[j->in_room].people, j, 0, TO_ROOM);
	    act("A quivering horde of maggots consumes $p.",
	        TRUE, world[j->in_room].people, j, 0, TO_CHAR);
          }
	}
	// Artus> Only empty player corpses. Mob corpses can die.
	if (GET_CORPSEID(j) > 0)
	  for (jj = j->contains; jj; jj = next_thing2) 
	  {
	    next_thing2 = jj->next_content;	/* Next in inventory */
	    obj_from_obj(jj);

	    if (j->in_obj)
	      obj_to_obj(jj, j->in_obj);
	    else if (j->carried_by)
	      obj_to_room(jj, j->carried_by->in_room);
	    else if (j->in_room != NOWHERE)
	      obj_to_room(jj, j->in_room);
	    else
	      core_dump();
	  }
	extract_obj(j);
      }
    /* If the timer is set, count it down and at 0, try the trigger */
    /* note to .rej hand-patchers: make this last in your point-update() */
    } else if (GET_OBJ_TIMER(j) > 0) {
      GET_OBJ_TIMER(j)--;
      if (!GET_OBJ_TIMER(j))
        timer_otrigger(j);
    }
  }
}
@


1.49
log
@Artus> Logging death by drowning here, too.
@
text
@d892 3
a894 3
  if (use_autowiz && GET_LEVEL(ch) >= LVL_IMMORT) {
    char buf[128];

d896 2
a897 2
    sprintf(buf, "nice ../bin/autowiz %d %s %d %s %d &", min_wizlist_lev,
	    WIZLIST_FILE, LVL_IMMORT, IMMLIST_FILE, (int) getpid());
d899 2
a900 2
    sprintf(buf, "autowiz %d %s %d %s", min_wizlist_lev,
	    WIZLIST_FILE, LVL_IMMORT, IMMLIST_FILE);
d903 2
a904 2
    mudlog("Initiating autowiz.", CMP, LVL_IMMORT, FALSE);
    system(buf);
a983 1

@


1.48
log
@Artus> #ifdef (0)'d around a few old routines.
@
text
@d1205 1
d1261 9
a1269 1
	  raw_kill(i,NULL);
@


1.47
log
@Artus> Healing Trance and Meditate are now removed when health is recovered.
@
text
@d84 1
d209 1
d332 1
d428 1
d552 1
d658 1
d773 1
d865 1
a865 2


@


1.46
log
@Artus> Introduced ceiling for gain values.
@
text
@d1201 2
a1202 1
  for (i = character_list; i; i = next_char) {
d1223 12
d1248 10
a1257 10
      if (GET_HIT(i) <0){
        send_to_char("Your life flashes before your eyes.  You have Drowned.  RIP!\r\n", i);
        act("$n suddenly turns a deep blue color holding $s throat.", 
          TRUE, i, 0, 0 , TO_ROOM);
        act("$n has drowned. RIP!.", TRUE, i, 0, 0, TO_ROOM);
        raw_kill(i,NULL);
      }
    }                  

    if (GET_POS(i) <= POS_STUNNED)
d1278 2
a1279 1
    if (!IS_NPC(i)) {
d1291 2
a1292 1
  for (j = object_list; j; j = next_thing) {
a1293 1

d1295 2
a1296 1
    for (timer = OBJ_TIMERS(j); timer; timer = next_timer) {
d1305 1
a1305 1
      else {
a1306 1
      }
d1310 2
a1311 1
    if (IS_CORPSE(j)) {
d1316 2
a1317 2
      if (!GET_OBJ_TIMER(j)) {

d1320 4
a1323 2
	else if ((j->in_room != NOWHERE) && (world[j->in_room].people)) {
         if(GET_OBJ_VNUM(j) == 22300) { /* check if its a gate */
@


1.45
log
@Artus> Fixed bad typecast.
@
text
@d274 4
d492 4
d711 4
@


1.44
log
@Artus> Changed regen calculations.
@
text
@d662 1
a662 1
    base = 7 + (int)GET_LEVEL(ch) * 0.5;
@


1.43
log
@Artus> Changed in-game idling routine. Now logs chars being extracted to all.
@
text
@d36 3
a39 1
int graf(int age, int p0, int p1, int p2, int p3, int p4, int p5, int p6);
d84 242
d327 1
a327 1
int mana_gain(struct char_data * ch)
d369 1
a369 1
      if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_MEDITATE))
d422 117
d541 1
a541 1
int hit_gain(struct char_data * ch)
d646 97
d744 10
d756 1
a756 1
int move_gain(struct char_data * ch)
@


1.42
log
@Artus> Now warning free :o)
@
text
@d658 2
d661 4
a664 2
  if (++(ch->char_specials.timer) > idle_void && LR_FAIL(ch, LVL_IS_GOD)) {
    if (GET_WAS_IN(ch) == NOWHERE && ch->in_room != NOWHERE) {
d666 2
a667 1
      if (FIGHTING(ch)) {
d677 2
a678 1
    } else if (ch->char_specials.timer > idle_rent_time) {
d681 10
a690 2
      char_to_room(ch, 3);
      if (ch->desc) {
d698 2
a704 2
      sprintf(buf, "%s force-rented and extracted (idle).", GET_NAME(ch));
      mudlog(buf, CMP, LVL_GOD, TRUE);
@


1.41
log
@Artus> Conditionals for IGNORE_DEBUG.
@
text
@a430 2
  struct event_data *ev;
  extern struct event_list events;
d565 1
a565 1
  int i, check_cond, move_val;
a703 1
  int index;
@


1.40
log
@Artus> Removed a redundant check.
@
text
@d448 1
d454 1
d469 1
a469 1

d475 1
@


1.39
log
@Artus> Fixed bug in werewolf where you could quit and reenter for free hit.
       Can no longer quit from anywhere other than haven, lunar city, hope,
       or your house.
@
text
@d434 1
a434 2
  if (!IS_NPC(ch) && ((GET_LEVEL(ch) < 1) || !LR_FAIL(ch, LVL_IMMORT) ||
      !CAN_LEVEL(ch)))
@


1.38
log
@Artus> No autoeat while sleeping.
@
text
@d431 2
@


1.37
log
@Artus> Fixed another (hopefully last) bug in autoeat.
@
text
@d603 2
@


1.36
log
@Artus> Re-wrote autoeat handling. No longer charges stupid amounts of movement.
@
text
@d630 2
@


1.35
log
@Artus> Fix for death by suffering so players don't lose exp, and death triggers
       are still called.
@
text
@d563 2
a564 1
  int i, check_cond;
d595 14
a608 7
  switch (condition) {
  case FULL:
    send_to_char("You are hungry.\r\n", ch);
    // Artus> AutoEat.
    // Possible TODO: If Detect Poison, Skip Bad Food...
    if (EXT_FLAGGED(ch, EXT_AUTOEAT) && (ch->carrying) && (GET_MOVE(ch) > 0))
      for (struct obj_data *food = ch->carrying; food; food=food->next_content)
d610 3
a612 2
	if (FIGHTING(ch)) 
	  GET_MOVE(ch) = MAX(0, GET_MOVE(ch) - 5);
d615 1
a615 2
	  GET_MOVE(ch) = MAX(0, GET_MOVE(ch) - 5);
	  perform_eat(ch, food, SCMD_EAT);
d619 4
a622 3
	    (!OBJVAL_FLAGGED(food, CONT_CLOSED)) && (food->contains))
	  for (struct obj_data *fewd = food->contains; fewd; fewd = fewd->next_content)
	    if (GET_OBJ_TYPE(fewd) == ITEM_FOOD)
d624 2
a625 3
	      GET_MOVE(ch) = MAX(0, GET_MOVE(ch) - 5);
	      sprintf(buf, "You get &5%s&n from &5%s&n.\r\n", OBJS(fewd, ch), 
		      OBJS(food, ch));
d627 1
a627 1
	      perform_eat(ch, fewd, SCMD_EAT);
d631 14
a644 10
    return;
  case THIRST:
    send_to_char("You are thirsty.\r\n", ch);
    return;
  case DRUNK:
    if (intoxicated)
      send_to_char("You are now sober.\r\n", ch);
    return;
  default:
    break;
a645 1

@


1.34
log
@Artus> Remort classes will now gain a little more.
@
text
@d737 8
a744 2
      if (damage(i, i, 1, TYPE_SUFFERING, FALSE) == -1)
	continue;
d746 8
a753 2
      if (damage(i, i, 2, TYPE_SUFFERING, FALSE) == -1)
	continue;
@


1.33
log
@Artus> Crash bug fix, exp bug fix.
@
text
@d112 1
a112 1
	gain *= 2;
d122 1
a122 1
	 gain += (gain / 2);	/* Divide by 2 */
d149 6
a154 1
    gain = MAX((gain * (GET_MAX_MANA(ch) / 100)), 10);
d157 1
a157 1
      gain /= 2;
d160 1
a160 1
      gain /= 4;
d169 1
a169 1
      gain /= 2;
d173 1
a173 1
    gain /= 4;
d184 2
a185 1
  if (IS_NPC(ch)) {
d191 1
a191 1
  gain = graf(age(ch)->year, 4, 5, 6, 7, 6, 5, 4);
d194 2
a195 2
  if (GET_AFF_CON(ch) > 17)
    gain += GET_AFF_CON(ch) - 18;
d203 36
a238 35
    switch (GET_POS(ch)) {
    case POS_SLEEPING:
      if (GET_SKILL(ch, SKILL_CAMPING) && 
		(SECT(ch->in_room) == SECT_FOREST || 
                 SECT(ch->in_room) == SECT_MOUNTAIN || 
                 SECT(ch->in_room) == SECT_FIELD || 
                 SECT(ch->in_room) == SECT_HILLS) )
	gain += gain;
      else
        gain += (gain / 2);	/* Divide by 2 */
      break;
    case POS_RESTING:
      if (GET_SKILL(ch, SKILL_CAMPING) && 
		(SECT(ch->in_room) == SECT_FOREST || 
                 SECT(ch->in_room) == SECT_MOUNTAIN || 
                 SECT(ch->in_room) == SECT_FIELD || 
                 SECT(ch->in_room) == SECT_HILLS) )
	gain += (gain /2);
      else
        gain += (gain / 4);	/* Divide by 4 */
      break;
    case POS_SITTING:
      if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_MEDITATE))
	gain += MAX(5, (int)(gain * 2 * (GET_SKILL(ch, SKILL_MEDITATE) / 100) * (SPELL_EFFEC(ch, SKILL_MEDITATE) / 100)));
      if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_HEAL_TRANCE))
	gain += MAX(10, (int)(gain * 3 * (GET_SKILL(ch, SKILL_HEAL_TRANCE) / 100) * (SPELL_EFFEC(ch, SKILL_HEAL_TRANCE) / 100)));	

      if (GET_SKILL(ch, SKILL_CAMPING) && 
		(SECT(ch->in_room) == SECT_FOREST || 
                 SECT(ch->in_room) == SECT_MOUNTAIN || 
                 SECT(ch->in_room) == SECT_FIELD || 
                 SECT(ch->in_room) == SECT_HILLS) )
	gain += (gain / 4);
      else
        gain += (gain / 8);	/* Divide by 8 */
d241 1
a241 1
      break;
d248 1
a248 1
      gain *= 2;
d253 1
a253 1
      gain /= 4;
d259 6
a264 1
    gain = MAX((gain * (GET_MAX_HIT(ch) / 100)), 10);
d276 1
a276 1
      gain /= 2;
d280 1
a280 1
    gain /= 4;
a302 1

d304 39
a342 38
    switch (GET_POS(ch)) {
    case POS_SLEEPING:
      if (GET_SKILL(ch, SKILL_CAMPING) && 
		(SECT(ch->in_room) == SECT_FOREST || 
                 SECT(ch->in_room) == SECT_MOUNTAIN || 
                 SECT(ch->in_room) == SECT_FIELD || 
                 SECT(ch->in_room) == SECT_HILLS) )
	gain += gain;
      else
        gain += (gain / 2);	/* Divide by 2 */
      break;
    case POS_RESTING:
      if (GET_SKILL(ch, SKILL_CAMPING) && 
		(SECT(ch->in_room) == SECT_FOREST || 
                 SECT(ch->in_room) == SECT_MOUNTAIN || 
                 SECT(ch->in_room) == SECT_FIELD || 
                 SECT(ch->in_room) == SECT_HILLS) )
	gain += (gain /2);
      else
        gain += (gain / 4);	/* Divide by 4 */
      break;
    case POS_SITTING:
      if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_MEDITATE))
	gain += MAX(5, (int)(gain * 2 * (GET_SKILL(ch, SKILL_MEDITATE) / 100) * (SPELL_EFFEC(ch, SKILL_MEDITATE) / 100)));
      if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_HEAL_TRANCE))
	gain += MAX(10, (int)(gain * 2 * (GET_SKILL(ch, SKILL_HEAL_TRANCE) / 100) * (SPELL_EFFEC(ch, SKILL_HEAL_TRANCE) / 100)));

      if (GET_SKILL(ch, SKILL_CAMPING) && 
		(SECT(ch->in_room) == SECT_FOREST || 
                 SECT(ch->in_room) == SECT_MOUNTAIN || 
                 SECT(ch->in_room) == SECT_FIELD || 
                 SECT(ch->in_room) == SECT_HILLS) )
	gain += (gain / 4);
      else
        gain += (gain / 8);	/* Divide by 8 */
      break;
    case POS_FIGHTING:
      gain = 1;
d348 6
a353 1
    gain = MAX((gain * (GET_MAX_MOVE(ch) / 200)), 10);
d361 1
a361 1
      gain /= 4;
d370 1
a370 1
      gain /= 2;
d374 1
a374 1
    gain /= 4;
@


1.32
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d415 1
a415 1
  if (!IS_NPC(ch) && (GET_LEVEL(ch) < 1 || LR_FAIL(ch, LVL_IMMORT) ||
@


1.31
log
@Artus>
act.informative.c: Fixed bug where examining a container was always listng the
                   objects in the first container matched.
                   Gold rush finishing is now only displayed within the same
		   world.
act.movement.c   : Environmental damage is now passed through damage().
act.offensive.c  : Throw() now calls damage().
act.other.c      : When you fail to create a torch, it hurts.
dg_mobcmd.c      : mdamage() now calls damage().
dg_objcmd.c      : odamage() now calls damage().
dg_wldcmd.c      : wdamage() now calls damage().
fight.c          : Changed damage() to allow a NULL ch.
interpreter.c    : Falling because fly has worn off now calls damage().
limits.c         : No waterbreathe underwater now calls damage().
magic.c          : Added handle_fireball() for fire breathing, fireball, type
                   stuff..
                   Random chance of objs in inventory/open containers burning
                   up :o)
spec_assign.c    : Removed some unused/wasted assigns: corridor_guard,
                   receiptionist, virus, bacteria.
spec_procs.c     : Removed some unused/wasted procs. Changed lots of tali's
                   indenting.
                   Fixed gaping hole in deadlyblade proc.
                   Replaced GET_HIT(vict) -= with damage(ch, vict...
spell_parser.c   : Added awake and can_see checks to magic fail = mob attacks.
@
text
@d415 2
a416 7
  if (!IS_NPC(ch) && (GET_LEVEL(ch) < 1 || GET_LEVEL(ch) >= LVL_ISNOT_GOD))
    return 0;

  // Artus: Restrict 1st/2nd Tier Chars to Lower Levels.
  if ((GET_CLASS(ch) <= CLASS_WARRIOR) && (GET_LEVEL(ch) >= RONE_MAX_LVL))
    return 0;
  else if ((GET_CLASS(ch) < CLASS_MASTER) && (GET_LEVEL(ch) >= RTWO_MAX_LVL))
d437 9
a445 1
    // Artus: Increase modifier for remorts.
d447 2
a448 1
      newgain = (int)(newgain * 1.5);
d469 1
a469 2
    while (GET_LEVEL(ch) < LVL_ISNOT_GOD &&
        GET_EXP(ch) >= level_exp((ch),GET_LEVEL(ch))) 
d512 6
a517 2
  if (!IS_NPC(ch)) {
    while (GET_LEVEL(ch) < LVL_IMPL && GET_LEVEL(ch) < newlevel) { 
d598 1
a598 1
	      GET_MOVE(ch) = MAX(0, GET_MOVE(ch) - 10);
d625 1
a625 1
  if (++(ch->char_specials.timer) > idle_void && (GET_LEVEL(ch) < LVL_ANGEL)) {
d700 1
a700 2
          ((UNDERWATER(i))) &&
	   (GET_LEVEL(i) < LVL_IS_GOD))
@


1.30
log
@Artus> Moving stuff across to live.

act.informative.c:
  Info on it's own will now display the info file. Use me or self to see your
own info.
  Score and Exp now both show gained and remaining exp.
  Gold value is now to a max of 30000. (60000 in lvl 40+ zones, 120 in 70+)
  Gold rushes no longer occur in !GOLDRUSH zones, city sectors, etc.

act.other.c:
  Mana retained on remort is now floored at 100 instead of 50.
  Added elitist bonus for chars who play past the earliest remort point(s).

act.wizard.c:
  Gold rush events are now only advertised within the world they occur.

genolc.h:
  Added special #defines for different OLC levels whether running live or test.
  (Noted by compiling with -DPRIMAL_LIVE)

interpreter.c:
  Aliases will now be saved automatically, when added or remoed.
  Added elitist_modifier() to modifier calculation.
  Replaced Huh?!? with HUH.

limits.c:
  NPC corpses are no longer emptied before they are purged. Too much clutter.

spells.c:
  Reduced the amount of weight applied by create water to 1/3 of what it was.

comm.c:       Added send_to_not_zone_world()
db.c:         Added elitist_modifier() to modifier calculation.
dg_mobcmd.c:  Replaced Huh?!? with the define, HUH.
dg_scripts.h: Changed version string so it will fit on one line :o)
fight.c:      Eq should no longer be damaged when a hit fails.
handler.c:    Now, when the sleep spell wears of an NPC, it will wake up.
structs.h:    Added HUH define.
utils.c:      Added elitist_modifier() calculation.
utils.h:      Added elitist_modifier() prototype.
@
text
@d700 2
a701 1
        GET_HIT(i)-= GET_LEVEL(i)*5;
@


1.29
log
@Artus> Mostly just cosmetic changes, mostly for underwater stuff..
       Added some more stuff to dg_scripts:

       %actor.affected(aff_bit)% - Is actor affected by whatever.
       %self.people(countpc)%    - (Rooms): Count players.
       %self.people(countnpc)%   - (Rooms): Count npcs.
       %self.people(countall)%   - (Rooms): Count chars.
       %firstchar.<room_vnum>%   - First character in room <vnum>

       Possibly a bugfix to one of the forest specials that was attacking you
       if you were affected by poison.
@
text
@d772 6
a777 3
	for (jj = j->contains; jj; jj = next_thing2) {
	  next_thing2 = jj->next_content;	/* Next in inventory */
	  obj_from_obj(jj);
d779 9
a787 9
	  if (j->in_obj)
	    obj_to_obj(jj, j->in_obj);
	  else if (j->carried_by)
	    obj_to_room(jj, j->carried_by->in_room);
	  else if (j->in_room != NOWHERE)
	    obj_to_room(jj, j->in_room);
	  else
	    core_dump();
	}
@


1.28
log
@Artus>
\r\n appended to gold rush message: act.informative.c

Imms no longer affected by underwater: act.movement.c, limits.c

Changed remort some more.. New special, tracker (SPECIAL_TRACKER):
act.other.c, act.wizard.c, constants.c, graph.c, structs.h, utils.c

Object and Room triggers can now %send% <room vnum> <message>:
dg_objcmd.c, dg_wldcmd.c

%self.direction% now has a vnum subfield to return the exit room's vnum.
(Eg: %self.north(vnum)%): dg_scripts.c

%actor.hisher%, %actor.himher%, %actor.heshe% implemented: dg_scripts.c

vnum, name, can_see, can_see_me added to %actor.next_in_room%, returning char
vnum, char name, if actor can see char, and if char can see actor respectively:
dg_scripts.c

Changed "do not know that spell" to "do not know of that spell": spell_parser.c

Changed "do not of know that skill/spell" to "do not know of..": utils.c

SECT_UNDERWATER and SECT_INSIDE now checked in OUTSIDE() macro: utils.h
@
text
@d693 2
a694 2
          ((BASE_SECT(world[i->in_room].sector_type) == SECT_UNDERWATER)) &&
	  (GET_LEVEL(i) < LVL_IS_GOD))
@


1.27
log
@Artus> Fixed up sense wounds.. Implemented movement cost for autoeat..
       Moved autoeat after autoexits in interpreter.c.
@
text
@d418 1
a418 1
  // Artus: Restring 1st/2nd Teir Chars to Lower Levels.
d693 2
a694 1
          ((BASE_SECT(world[i->in_room].sector_type) == SECT_UNDERWATER)))
@


1.26
log
@Artus> Implemented Autoeat.
       Putting objs in cursed containers now results in obj being cursed :o)
@
text
@d575 1
a575 1
    if (EXT_FLAGGED(ch, EXT_AUTOEAT) && (ch->carrying))
d578 2
d582 1
d591 4
@


1.25
log
@Artus> Added !KILL flag for mobs... Things like gamina, postmaster, etc, can
       have this set, which should make it pretty damn impossible for them to
       die..
       Modified more stuff for dark ritual and vampires.. Have added a switch
       statement to affect_remove, which should be a good central place to
       handle triggers on affect removal.. Mainly to reset mana/move/hit to
       make sure they're not higher than max values when removing werewolf/
       vampire.
@
text
@d537 1
d573 19
@


1.24
log
@Artus> Changes to do_simple_move().
       Added char_can_enter() -- Tests room levels, zone levels, water/fly/etc.

       Changes to die(): Exp lost is now whichever is lesser of half earned
       exp and quater max exp. When autocorpse, instead of doubling it, we
       multiply by 1.5.

       pc killed by char now logged in die(), with lost_exp display.

       gain_exp now returns the amount of exp that was gained rather than void.
@
text
@d144 1
a144 1
    Artus> I dun think this works for me...
d643 2
a644 1
    if (GET_POS(i) >= POS_STUNNED) {
d646 3
a648 4
 *  * when wolf/vamp. this is so ya can have BIG bonuses instead of the max
 *   * of 128 that ya get with an affection cos the number is an sbyte - Vader
 *    */
      if(!(GET_HIT(i) > GET_MAX_HIT(i) && affected_by_spell(i,SPELL_CHANGED)))
d655 1
a655 1
      if(!(GET_MANA(i) > GET_MAX_MANA(i) && affected_by_spell(i,SPELL_CHANGED)))
d658 1
a658 1
      if(!(GET_MOVE(i) > GET_MAX_MOVE(i) && affected_by_spell(i,SPELL_CHANGED)))
d666 2
a667 1
          ((BASE_SECT(world[i->in_room].sector_type) == SECT_UNDERWATER))){
@


1.23
log
@Artus> (Hopefully) Fixed all cases where the skill message would display after
       the victim had fled.

       Moved remaining violence checks from damage() to violence_check().

       damage() now takes an additional boolean arg, vcheck, when true,
       violence_check() will be called.

       added GET_EQ_WEIGHT(ch, wear_pos) define.
@
text
@d407 2
a408 3


void gain_exp(struct char_data * ch, int gain)
d416 1
a416 1
    return;
d420 1
a420 1
    return;
d422 1
a422 1
    return;
d424 2
a425 1
  if (IS_NPC(ch)) {
d427 1
a427 1
    return;
d432 2
a433 1
  if (gain > 0) {
d435 2
a436 1
    if (GET_DEBUG(ch)) {
d446 2
a447 1
    if (GET_DEBUG(ch)) {
d466 2
a467 1
        GET_EXP(ch) >= level_exp((ch),GET_LEVEL(ch))) {
d477 2
a478 1
    if (is_altered) {
d480 1
d482 1
a482 1
      else {
a485 2
      // set_title(ch, NULL);
      // check_autowiz(ch);
d494 1
@


1.22
log
@Artus> A3_0_315
@
text
@d657 1
a657 1
	if (damage(i, i, 2, SPELL_POISON) == -1)
d679 1
a679 1
      if (damage(i, i, 1, TYPE_SUFFERING) == -1)
d682 1
a682 1
      if (damage(i, i, 2, TYPE_SUFFERING) == -1)
@


1.21
log
@Latest Version
@
text
@d126 1
a126 1
	gain += (int)(gain * 2 * (GET_SKILL(ch, SKILL_MEDITATE) / 100) * (SPELL_EFFEC(ch, SKILL_MEDITATE) / 100));
d128 1
a128 1
	gain += (int)(gain * 3 * (GET_SKILL(ch, SKILL_HEAL_TRANCE) / 100) * (SPELL_EFFEC(ch, SKILL_HEAL_TRANCE) / 100));
d220 1
a220 1
	gain += (int)(gain * 2 * (GET_SKILL(ch, SKILL_MEDITATE) / 100) * (SPELL_EFFEC(ch, SKILL_MEDITATE) / 100));	
d222 1
a222 1
	gain += (int)(gain * 3 * (GET_SKILL(ch, SKILL_HEAL_TRANCE) / 100) * (SPELL_EFFEC(ch, SKILL_HEAL_TRANCE) / 100));	
d316 1
a316 1
	gain += (int)(gain * 2 * (GET_SKILL(ch, SKILL_MEDITATE) / 100) * (SPELL_EFFEC(ch, SKILL_MEDITATE) / 100));	
d318 1
a318 1
	gain += (int)(gain * 2 * (GET_SKILL(ch, SKILL_HEAL_TRANCE) / 100) * (SPELL_EFFEC(ch, SKILL_HEAL_TRANCE) / 100));	
@


1.20
log
@

Modified: DM

Changed:
- fixed an exp calculation (needed a float cast)
@
text
@d143 3
a145 3
    /* JA make gain percentage based */
    gain = MAX((gain * GET_MAX_MANA(ch)) / 100, 10);

d148 5
d237 1
d239 5
a243 1
      gain /= 2;	/* Ouch. */
d248 5
a252 2
    /* JA make gain percent based */
    gain = MAX((gain * GET_MAX_HIT(ch)) / 100, 10);
d333 9
a341 2
    /* JA make gain percent based */
    gain = MAX((gain * GET_MAX_MOVE(ch)) / 100, 10);
@


1.19
log
@Artus> Added ghosts.. Newbies no longer die, they become ghosts.
@
text
@d414 5
a418 1
    gain = (int)(gain * (1 / GET_MODIFIER(ch)));
a419 1

d424 4
@


1.18
log
@
Modified: DM

Changed:
- gain_exp(): to give the proper exp based on the modifier (needed to be the
  exp * inverse of exp modifier ...) - was exp * exp modifier
@
text
@d619 4
@


1.17
log
@
Modified: DM

Changed:
- set_title - using arg variable when NULL to set title to ""
@
text
@d414 1
a414 1
    gain = (int)(gain * GET_MODIFIER(ch));
@


1.16
log
@Modified: Artus

Added:
- remort level settings
@
text
@d347 5
a351 4
    if (GET_SEX(ch) == SEX_FEMALE)
      title = title_female(GET_CLASS(ch), GET_LEVEL(ch));
    else
      title = title_male(GET_CLASS(ch), GET_LEVEL(ch));
@


1.15
log
@Artus- Changed for healing trance.
@
text
@d398 6
d415 5
@


1.14
log
@Modifications for meditate skill.
@
text
@d126 3
a128 1
	gain += (int)(gain * 2 * (GET_SKILL(ch, SKILL_MEDITATE) / 100) * (SPELL_EFFEC(ch, SKILL_MEDITATE) / 100));	
d216 2
d304 2
@


1.13
log
@Artus - Removed an extra 'You Rise A Level!'.
@
text
@d26 1
d125 3
d212 3
d223 2
d298 3
@


1.12
log
@Modified: Artus - Punish, Clan
@
text
@d407 1
a407 1
      send_to_char("You rise a level!\r\n", ch);
@


1.11
log
@Added exp modification (in gain_exp) - moved from elsewhere
@
text
@d45 2
d151 3
d236 3
d313 3
d344 1
d391 1
d632 1
@


1.10
log
@
Added:
- TODO comment regarding the capping of exp and remort levels
@
text
@d376 2
@


1.9
log
@

Added:
- NOHUNGER, NOTHIRST, NODRUNK checks
@
text
@d372 3
@


1.8
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d458 1
d462 16
@


1.7
log
@
Removed:
- Commented out autowiz call (which calls the autowiz program to generate the
  wizlist (but it currently causes a crash and we haven't bothered using it
  before. Perhaps later if we have time, we can update the autowiz code).
@
text
@d21 1
d656 6
@


1.6
log
@
Changed:
- regen values
@
text
@d332 2
a333 1

d405 1
a405 1
      check_autowiz(ch);
d448 1
a448 1
      check_autowiz(ch);
@


1.5
log
@
Added:
- timers (like affects)
- new skills, fixes

TODO:
- test timers on objects - add to stat obj screen
@
text
@d87 2
a88 1
    gain = graf(age(ch)->year, 4, 8, 12, 16, 12, 10, 8);
d94 4
d102 4
a105 2
		(SECT(ch->in_room) == SECT_FOREST || SECT(ch->in_room) == SECT_MOUNTAIN 
		 || SECT(ch->in_room) == SECT_FIELD || SECT(ch->in_room) == SECT_HILLS) )
d112 4
a115 2
		(SECT(ch->in_room) == SECT_FOREST || SECT(ch->in_room) == SECT_MOUNTAIN 
		 || SECT(ch->in_room) == SECT_FIELD || SECT(ch->in_room) == SECT_HILLS) )
d122 4
a125 2
		(SECT(ch->in_room) == SECT_FOREST || SECT(ch->in_room) == SECT_MOUNTAIN 
		 || SECT(ch->in_room) == SECT_FIELD || SECT(ch->in_room) == SECT_HILLS) )
d130 2
d134 3
d142 6
d167 6
a172 1
    gain = graf(age(ch)->year, 8, 12, 20, 32, 16, 10, 4);
d183 4
a186 2
		(SECT(ch->in_room) == SECT_FOREST || SECT(ch->in_room) == SECT_MOUNTAIN 
		 || SECT(ch->in_room) == SECT_FIELD || SECT(ch->in_room) == SECT_HILLS) )
d193 4
a196 2
		(SECT(ch->in_room) == SECT_FOREST || SECT(ch->in_room) == SECT_MOUNTAIN 
		 || SECT(ch->in_room) == SECT_FIELD || SECT(ch->in_room) == SECT_HILLS) )
d203 4
a206 2
		(SECT(ch->in_room) == SECT_FOREST || SECT(ch->in_room) == SECT_MOUNTAIN 
		 || SECT(ch->in_room) == SECT_FIELD || SECT(ch->in_room) == SECT_HILLS) )
d218 12
d249 2
a250 1
    gain = graf(age(ch)->year, 16, 20, 24, 20, 16, 12, 10);
d261 4
a264 2
		(SECT(ch->in_room) == SECT_FOREST || SECT(ch->in_room) == SECT_MOUNTAIN 
		 || SECT(ch->in_room) == SECT_FIELD || SECT(ch->in_room) == SECT_HILLS) )
d271 4
a274 2
		(SECT(ch->in_room) == SECT_FOREST || SECT(ch->in_room) == SECT_MOUNTAIN 
		 || SECT(ch->in_room) == SECT_FIELD || SECT(ch->in_room) == SECT_HILLS) )
d281 4
a284 2
		(SECT(ch->in_room) == SECT_FOREST || SECT(ch->in_room) == SECT_MOUNTAIN 
		 || SECT(ch->in_room) == SECT_FIELD || SECT(ch->in_room) == SECT_HILLS) )
d289 2
d293 3
d298 6
@


1.4
log
@
Added:
- olc stuff - sectors, zone flags

Changed:
- Heaps of little fixes ....
@
text
@d475 1
d537 15
@


1.3
log
@my new skills!


Added:
-
-

Removed:
-
-

Changed:
-
-

TODO:
-
-
@
text
@d424 1
d441 1
a441 1
      char_to_room(ch, 1);
@


1.2
log
@
Added:
- Some initial colour coding for mobs and objects

Changed:
- Various inclusions from the existing primal base ...
- Including Sector fixes, clan guards, listing items

TODO:
- Fix colours for mobs/objects - A player comes up as a mob colour
@
text
@d96 6
a101 1
      gain *= 2;
d104 6
a109 1
      gain += (gain / 2);	/* Divide by 2 */
d112 6
a117 1
      gain += (gain / 4);	/* Divide by 4 */
d155 6
a160 1
      gain += (gain / 2);	/* Divide by 2 */
d163 6
a168 1
      gain += (gain / 4);	/* Divide by 4 */
d171 6
a176 1
      gain += (gain / 8);	/* Divide by 8 */
d214 6
a219 1
      gain += (gain / 2);	/* Divide by 2 */
d222 6
a227 1
      gain += (gain / 4);	/* Divide by 4 */
d230 6
a235 1
      gain += (gain / 8);	/* Divide by 8 */
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d425 1
a433 4
    gain_condition(i, FULL, -1);
    gain_condition(i, DRUNK, -1);
    gain_condition(i, THIRST, -1);
	
d435 14
a448 4
      GET_HIT(i) = MIN(GET_HIT(i) + hit_gain(i), GET_MAX_HIT(i));
      GET_MANA(i) = MIN(GET_MANA(i) + mana_gain(i), GET_MAX_MANA(i));
      GET_MOVE(i) = MIN(GET_MOVE(i) + move_gain(i), GET_MAX_MOVE(i));
      if (AFF_FLAGGED(i, AFF_POISON))
d451 18
a468 1
      if (GET_POS(i) <= POS_STUNNED)
d482 3
d502 11
a512 4
	  act("A quivering horde of maggots consumes $p.",
	      TRUE, world[j->in_room].people, j, 0, TO_ROOM);
	  act("A quivering horde of maggots consumes $p.",
	      TRUE, world[j->in_room].people, j, 0, TO_CHAR);
@

