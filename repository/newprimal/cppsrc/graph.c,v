head	1.15;
access;
symbols
	A3_0_59:1.2
	LATEST:1.2
	A3_0_1:1.2;
locks; strict;
comment	@ * @;


1.15
date	2004.08.27.02.11.36;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.05.14.43.24;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.04.12.32.14;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.10.03.23.46;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.06.02.23.30;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.29.07.59.37;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.10.13.04.50;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.10.12.02.26;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.09.05.42.45;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.17.12.36.24;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.12.11.00.13;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.20.08.17.56;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.05.12.04.13;	author rod;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.27.11.26.38;	author talisman;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.58;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Artus> LVL_CHAMP for track through !TRACK.
@
text
@/* ************************************************************************
*   File: graph.c                                       Part of CircleMUD *
*  Usage: various graph algorithms                                        *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"

#ifdef __CXREF__
#undef FD_ZERO
#undef FD_SET
#undef FD_ISSET
#undef FD_CLR
#define FD_ZERO(x)
#define FD_SET(x, y) 0
#define FD_ISSET(x, y) 0
#define FD_CLR(x, y)
#endif

/* Externals */
ACMD(do_say);
extern struct char_data *character_list;
extern struct hunt_data *hunt_list;
extern const char *dirs[];
extern struct room_data *world;
extern int track_through_doors;
extern int process_output(struct descriptor_data *t);

/* local functions */
int VALID_EDGE(struct char_data *ch, room_rnum x, int y);
void bfs_enqueue(room_rnum room, int dir);
void bfs_dequeue(void);
void bfs_clear_queue(void);
int find_first_step(struct char_data *ch, room_rnum src, room_rnum target);
ACMD(do_track);
void hunt_victim(struct char_data * ch);
int getMeHere(sh_int chroom, sh_int victroom);
int MY_VALID_EDGE(sh_int room, int dir );
void do_playerhunt( struct char_data *ch, struct char_data *victim );

struct bfs_queue_struct {
  room_rnum room;
  char dir;
  struct bfs_queue_struct *next;
};

static struct bfs_queue_struct *queue_head = 0, *queue_tail = 0;

/* Utility macros */
#define MARK(room)	(SET_BIT(ROOM_FLAGS(room), ROOM_BFS_MARK))
#define UNMARK(room)	(REMOVE_BIT(ROOM_FLAGS(room), ROOM_BFS_MARK))
#define IS_MARKED(room)	(ROOM_FLAGGED(room, ROOM_BFS_MARK))
#define TOROOM(x, y)	(world[(x)].dir_option[(y)]->to_room)
#define IS_CLOSED(x, y)	(EXIT_FLAGGED(world[(x)].dir_option[(y)], EX_CLOSED))

int VALID_EDGE(struct char_data *ch, room_rnum x, int y)
{
  if (world[x].dir_option[y] == NULL || TOROOM(x, y) == NOWHERE)
    return 0;
  if (track_through_doors == FALSE && IS_CLOSED(x, y))
    return 0;
  if IS_MARKED(TOROOM(x, y))
  {
#ifndef IGNORE_DEBUG
    if (GET_DEBUG(ch))
      send_to_char(".", ch);
#endif
    return 0;
  }
  if ((LR_FAIL(ch, LVL_CHAMP)) && 
      ROOM_FLAGGED(TOROOM(x, y), ROOM_NOTRACK) &&
      !IS_SET(GET_SPECIALS(ch), SPECIAL_TRACKER))
  {
#ifndef IGNORE_DEBUG
    if (GET_DEBUG(ch))
      send_to_char("!", ch);
#endif
    return 0;
  }
  return 1;
}

void bfs_enqueue(room_rnum room, int dir)
{
  struct bfs_queue_struct *curr;

  CREATE(curr, struct bfs_queue_struct, 1);
  curr->room = room;
  curr->dir = dir;
  curr->next = 0;

  if (queue_tail) {
    queue_tail->next = curr;
    queue_tail = curr;
  } else
    queue_head = queue_tail = curr;
}


void bfs_dequeue(void)
{
  struct bfs_queue_struct *curr;

  curr = queue_head;

  if (!(queue_head = queue_head->next))
    queue_tail = 0;
  free(curr);
}


void bfs_clear_queue(void)
{
  while (queue_head)
    bfs_dequeue();
}


/* 
 * find_first_step: given a source room and a target room, find the first
 * step on the shortest path from the source to the target.
 *
 * Intended usage: in mobile_activity, give a mob a dir to go if they're
 * tracking another mob or a PC.  Or, a 'track' skill for PCs.
 */
int find_first_step(struct char_data *ch, room_rnum src, room_rnum target)
{
  int curr_dir;
  room_rnum curr_room;

  if (src < 0 || src > top_of_world || target < 0 || target > top_of_world) 
  {
    basic_mud_log("SYSERR: Illegal value %d or %d passed to find_first_step. (%s)", src, target, __FILE__);
    return (BFS_ERROR);
  }
  if (src == target)
    return (BFS_ALREADY_THERE);

  /* clear marks first, some OLC systems will save the mark. */
  for (curr_room = 0; curr_room <= top_of_world; curr_room++)
    UNMARK(curr_room);

  MARK(src);

  /* first, enqueue the first steps, saving which direction we're going. */
  for (curr_dir = 0; curr_dir < NUM_OF_DIRS; curr_dir++)
    if (VALID_EDGE(ch, src, curr_dir)) 
    {
      MARK(TOROOM(src, curr_dir));
      bfs_enqueue(TOROOM(src, curr_dir), curr_dir);
    }

  /* now, do the classic BFS. */
  while (queue_head) {
    if (queue_head->room == target) 
    {
      curr_dir = queue_head->dir;
      bfs_clear_queue();
      return (curr_dir);
    } else {
      for (curr_dir = 0; curr_dir < NUM_OF_DIRS; curr_dir++)
	if (VALID_EDGE(ch, queue_head->room, curr_dir)) 
	{
	  MARK(TOROOM(queue_head->room, curr_dir));
	  bfs_enqueue(TOROOM(queue_head->room, curr_dir), queue_head->dir);
	}
      bfs_dequeue();
    }
  }

  return (BFS_NO_PATH);
}

// Artus> Set a character as hunting, add to the hunt list.
void begin_hunting(struct char_data *ch, struct char_data *vict)
{
  struct hunt_data *huntrec;
  if ((is_valid_char(ch) != ch) || (is_valid_char(vict) != vict))
    return;
  CREATE(huntrec, struct hunt_data, 1);
  huntrec->hunter = ch;
  huntrec->victim = vict;
  if (hunt_list)
    huntrec->next = hunt_list;
  else
    huntrec->next = NULL;
  hunt_list = huntrec;
  HUNTING(ch) = vict;
}
// Artus> Stop a character hunting, remove from the hunt list.
void stop_hunting(struct char_data *ch)
{
  struct hunt_data *hcur, *hnext;
  for (hcur = hunt_list; hcur; hcur = hnext)
  {
    hnext = hcur->next;
    if (hcur->hunter == ch) 
    {
      struct hunt_data *temp;
      REMOVE_FROM_LIST(hcur, hunt_list, next);
      free(hcur);
    }
  }
  HUNTING(ch) = NULL;
}
// Artus> Is this hunt still valid.. Sanity.
struct hunt_data *valid_hunt(struct char_data *ch)
{
  if ((HUNTING(ch) == NULL || hunt_list == NULL))
    return NULL;
  for (struct hunt_data *hrec = hunt_list; hrec; hrec = hrec->next)
    if ((hrec->hunter == ch) && (hrec->victim == HUNTING(ch)))
      return hrec;
  return NULL;
}
// Artus> Stop a character being hunted.
void stop_hunters(struct char_data *ch)
{
  struct hunt_data *hcur, *hnext;
  if ((ch == NULL) || (hunt_list == NULL))
    return;
  for (hcur = hunt_list; hcur; hcur = hnext)
  {
    hnext = hcur->next;
    if (hcur->victim == ch) 
    {
      struct hunt_data *temp;
      if (hcur->hunter != NULL)
      {
	if (hcur->hunter->desc)
	  send_to_char("&[&rYour victim no longer seems to exist.&]\r\n", 
	               hcur->hunter);
	if (IS_NPC(hcur->hunter))
	  do_say(hcur->hunter, "Damn!  My prey is gone!!", 0, 0);
	if (ch == HUNTING(hcur->hunter))
	  stop_hunting(hcur->hunter);
      }
      REMOVE_FROM_LIST(hcur, hunt_list, next);
      free(hcur);
    }
  }
}

/********************************************************
* Functions and Commands which use the above functions. *
********************************************************/

ACMD(do_track)
{
  struct char_data *vict;
  int dir, num;

  if ((!GET_SKILL(ch, SKILL_TRACK) && 
       !IS_SET(GET_SPECIALS(ch), SPECIAL_TRACKER)) || 
      (!GET_SKILL(ch, SKILL_HUNT) && (subcmd == /*SCMD_HUNT*/SKILL_HUNT))) 
  {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }
 
  if(subcmd == SCMD_AUTOHUNT) 
  {
    if (!(valid_hunt(ch)) || !CAN_SEE(ch, HUNTING(ch)) ||
	(IN_ROOM(ch) == NOWHERE) ||
	(IN_ROOM(HUNTING(ch)) == NOWHERE))
    {
      stop_hunting(ch);
      send_to_char("You seem to have lost the trail!\r\n", ch);
/*
    if((!CAN_SEE(ch,vict)) || (HUNTING(ch)->in_room == NOWHERE)) 
    {
      send_to_char("You seem to have lost the trail!\r\n",ch);
      HUNTING(ch) = NULL;
*/
      return;
    }
    vict = HUNTING(ch);
  } else {
    one_argument(argument, arg);
    if (!*arg) 
    {
      if(subcmd == /*SCMD_HUNT*/SKILL_HUNT) 
      {
	if(HUNTING(ch)) 
	{
	  act("You stop hunting $N.",FALSE,ch,0,HUNTING(ch),TO_CHAR);
	  stop_hunting(ch);
	  return;
        } else {
          send_to_char("Hunt who?\r\n",ch);
          return;
	}
      } else {
	send_to_char("Whom are you trying to track?\r\n", ch);
	return;
      }
    }
    if (!(vict = generic_find_char(ch, arg, FIND_CHAR_WORLD))) 
    {
      send_to_char("No-one around by that name.\r\n", ch);
      return;
    }
    if (IS_AFFECTED(vict, AFF_NOTRACK))
    {
      send_to_char("You sense no trail.\r\n", ch);
      return;
    }
    if (!IS_NPC(vict) && PRF_FLAGGED(vict, PRF_TAG)) 
    {
      send_to_char("CHEAT! Ya can't track people who are playing tag!\r\n",ch);
      return;
    }
    // Artus> Otherworlds.
    if (!same_world(ch, vict))
    {
      send_to_char("They aren't even in this world!\r\n", ch);
      return;
    }
    if(subcmd == /*SCMD_HUNT*/SKILL_HUNT)
      begin_hunting(ch, vict);
  }
  /* this shood stop errors if the peron ya hunting dies b4 ya get there */
  if((subcmd == /*SCMD_HUNT*/SKILL_HUNT || subcmd == SCMD_AUTOHUNT) && HUNTING(ch))
    if((HUNTING(ch)->in_room < 0 || HUNTING(ch)->in_room > top_of_world) ||
       (GET_HIT(HUNTING(ch)) <= 0)) 
    {
      send_to_char("You can no longer find a path to your prey!\r\n",ch);
      stop_hunting(ch);
      return;
    }
    dir = find_first_step(ch, ch->in_room, vict->in_room);
    switch (dir) 
    {
      case BFS_ERROR:
	send_to_char("Hmm.. something seems to be wrong.\r\n", ch);
	break;
      case BFS_ALREADY_THERE:
	if ((subcmd == /*SCMD_HUNT*/SKILL_HUNT || subcmd == SCMD_AUTOHUNT) && 
	    HUNTING(ch)) 
	{
	  send_to_char("You've found your prey!\r\n",ch);
	  stop_hunting(ch);
	} else {
	  send_to_char("You're already in the same room!!\r\n", ch);
	}
	break;
      case BFS_NO_PATH: 
	sprintf(buf, "You can't sense a trail to %s from here.\r\n",
		HMHR(vict));
	send_to_char(buf, ch);
	break;
      default:
	if (!IS_SET(GET_SPECIALS(ch), SPECIAL_TRACKER))
	{
	  num = number(0, 101);       /* 101% is a complete failure */
	  if (GET_SKILL(ch, SKILL_TRACK) < num)
	    dir = 0;
	  else if (subcmd == SKILL_TRACK)
	    apply_spell_skill_abil(ch, SKILL_TRACK);
	  else
	    apply_spell_skill_abil(ch, SKILL_HUNT);
	}
/* this can sometimes get into an endless loop */
/*      do {
        dir = number(0, NUM_OF_DIRS - 1);
      } while (!CAN_GO(ch, dir));
*/
	sprintf(buf, "You sense a trail %s from here!\r\n", dirs[dir]);
	send_to_char(buf, ch);
	break;
    }
} 

void hunt_victim(struct char_data * ch)
{
  int dir;

  if (!ch || !HUNTING(ch) || FIGHTING(ch))
    return;

  if ((!valid_hunt(ch)) || (IN_ROOM(ch) == NOWHERE) || 
      (IN_ROOM(HUNTING(ch)) == NOWHERE))
  {
    do_say(ch, "Damn!  My prey is gone!!", 0, 0);
    stop_hunting(ch);
    return;
  }
  if ((dir = find_first_step(ch, ch->in_room, HUNTING(ch)->in_room)) < 0)
  {
    sprintf(buf, "Damn!  I lost %s!", HMHR(HUNTING(ch)));
    do_say(ch, buf, 0, 0);
    stop_hunting(ch);
  } else {
    perform_move(ch, dir, 1);
    if (ch->in_room == HUNTING(ch)->in_room)
      hit(ch, HUNTING(ch), TYPE_UNDEFINED);
  }
}



void do_playerhunt( struct char_data *ch, struct char_data *victim ) {

  	ACMD(do_say);
        int direction = getMeHere(ch->in_room, victim->in_room);
 
        if( direction != -1 )
                perform_move( ch, direction, 0);
 
        // Check if we're there
        if( ch->in_room == victim->in_room ) {
                sprintf(buf1, "Your time is at hand %s, defend thyself!!", victim->player.name);
                do_say(ch, buf1, 0,0);
                hit(ch, victim, TYPE_UNDEFINED);
                return;
        }
} 

int getMeHere(sh_int chroom, sh_int victroom) {
 
        int currdir = 0;
        sh_int curr_room = 0;
 
        // Check if the rooms are the same
        if( chroom == victroom )
                return -1;
 
        // Clear all marks
        for (curr_room = 0; curr_room <= top_of_world; curr_room++)
                UNMARK(curr_room);
 
        MARK(chroom);                                   // Mark our start room
 
        // Get the initial directions available from current room, creating queue
        for( currdir = 0; currdir < NUM_OF_DIRS; currdir++) {
                if(MY_VALID_EDGE(chroom, currdir) ) {                   // If room exists
                        MARK( TOROOM(chroom, currdir));                 // Mark it
                        bfs_enqueue( TOROOM(chroom, currdir), currdir); // Queue it
                }
        }
        // now, loop through all the potential directions,
        // and return the direction to move in
        while( queue_head  ) {
                if( queue_head->room == victroom ) {                    // If we're at the last room
                        currdir = queue_head->dir;                      // Set direction
                        bfs_clear_queue();                              // Clean up
                        return currdir;                                 // Move
                }
                else {                                                  // Didn't find target at head
                        // Check this room for potential paths, add them to the queue if valid
                        for( currdir = 0; currdir < NUM_OF_DIRS; currdir++ ) {
                                if( MY_VALID_EDGE(queue_head->room, currdir) ) {
                                        MARK( TOROOM(queue_head->room, currdir) );
                                        bfs_enqueue( TOROOM(queue_head->room, currdir), currdir );
                                }
                        }
                        bfs_dequeue();          // Got all paths off this one, remove it
 
                }
        }
 
        // If we're here, there's no valid path
        return -1;
} 

int MY_VALID_EDGE(sh_int room, int dir ) {
 
        // If direction is invalid, or room goes nowhere
        if ((world[room].dir_option[dir] == NULL) || (TOROOM(room, dir) == NOWHERE)
	    || (TOROOM(room, dir) == room) )
                return 0;
 
#ifdef TRACK_THROUGH_DOORS
#else
        // If there's a closed door in our way
        if (IS_CLOSED(room, dir))
                return 0;
#endif
 
        // If the room's been marked already, we don't want it
        if( IS_MARKED(TOROOM(room, dir)) )
                return 0;
 
        // If the room's marked with a !MOB flag, invalidate it
        if( ROOM_FLAGGED(TOROOM(room,dir), ROOM_NOMOB) )
                return 0;
 
        return 1;                       // Valid edge
} 


int EscapeValidEdge(int x, int y)
{
  if (world[x].dir_option[y] == NULL)
    return 0;
  if ((TOROOM(x, y) == NOWHERE) || (world[x].dir_option[y] == NULL) || 
      (TOROOM(x, y) == x))
    return 0;
  if (IS_MARKED(TOROOM(x, y)) || ROOM_FLAGGED(TOROOM(x, y), ROOM_GODROOM) || 
       ROOM_FLAGGED(TOROOM(x, y), ROOM_DEATH) || 
       ROOM_FLAGGED(TOROOM(x, y), ROOM_PRIVATE))
    return 0;
  return 1;
}

int Escape(struct char_data *ch)
{
  int currdir = 0, chroom = ch->in_room;
  sh_int curr_room = 0;
	 
  // Clear all marks
  for (curr_room = 0; curr_room <= top_of_world; curr_room++)
    UNMARK(curr_room);
 
  MARK(chroom);                                   // Mark our start room
	
  // Get the initial directions available from current room, creating queue
  for (currdir = 0; currdir < NUM_OF_DIRS; currdir++)
    if(EscapeValidEdge(chroom, currdir))
    {                   // If room exists
      MARK(TOROOM(chroom, currdir));                 // Mark it
      bfs_enqueue(TOROOM(chroom, currdir), currdir); // Queue it
    }
  // now, loop through all the potential directions,
  // and return the direction to move in
  while (queue_head)
  {
    if (SECT(queue_head->room) != SECT_INSIDE &&
      !ROOM_FLAGGED(queue_head->room, ROOM_INDOORS))
    {           // If we're out
      chroom = queue_head->room;
      bfs_clear_queue();                    // Clean up
      return chroom;                        // Move
    } else {                                // Didn't find target at head
      // Check this room for potential paths, add them to the queue if valid
      for (currdir = 0; currdir < NUM_OF_DIRS; currdir++)
	if (EscapeValidEdge(queue_head->room, currdir))
	{
	  MARK(TOROOM(queue_head->room, currdir));
	  bfs_enqueue(TOROOM(queue_head->room, currdir), currdir);
	}
      bfs_dequeue();          // Got all paths off this one, remove it
    }
  }
  return NOWHERE;		// Can't get outta here!
}
@


1.14
log
@Artus> Just some tidying up.
@
text
@d84 1
a84 1
  if ((LR_FAIL(ch, LVL_IMMORT)) && 
@


1.13
log
@Artus> Required changes for new find_xxx functions.
@
text
@d506 2
a507 2
int EscapeValidEdge(int x, int y) {
 
a508 3
	return 0;

  if (TOROOM(x, y) == NOWHERE || world[x].dir_option[y] == NULL || TOROOM(x, y) == x)
d510 6
a515 2
  if ( IS_MARKED(TOROOM(x, y)) || ROOM_FLAGGED(TOROOM(x, y), ROOM_GODROOM) || 
       ROOM_FLAGGED(TOROOM(x, y), ROOM_DEATH) || ROOM_FLAGGED(TOROOM(x, y), ROOM_PRIVATE))
a516 1

d520 4
a523 4
int Escape(struct char_data *ch) {

        int currdir = 0, chroom = ch->in_room;
        sh_int curr_room = 0;
d525 3
a527 3
        // Clear all marks
        for (curr_room = 0; curr_room <= top_of_world; curr_room++)
                UNMARK(curr_room);
d529 1
a529 1
        MARK(chroom);                                   // Mark our start room
d531 29
a559 30
        // Get the initial directions available from current room, creating queue
        for( currdir = 0; currdir < NUM_OF_DIRS; currdir++) {
                if(EscapeValidEdge(chroom, currdir) ) {                   // If room exists
                        MARK( TOROOM(chroom, currdir));                 // Mark it
                        bfs_enqueue( TOROOM(chroom, currdir), currdir); // Queue it
                }
        }
        // now, loop through all the potential directions,
        // and return the direction to move in
        while( queue_head  ) {
                if( SECT(queue_head->room) != SECT_INSIDE &&
		   !ROOM_FLAGGED(queue_head->room, ROOM_INDOORS) ) {           // If we're out
			chroom = queue_head->room; 
                        bfs_clear_queue();                              // Clean up
                        return chroom;                        // Move
                }
                else {                                                  // Didn't find target at head
                        // Check this room for potential paths, add them to the queue if valid
                        for( currdir = 0; currdir < NUM_OF_DIRS; currdir++ ) {
                                if( EscapeValidEdge(queue_head->room, currdir) ) {
                                        MARK( TOROOM(queue_head->room, currdir) );
                                        bfs_enqueue( TOROOM(queue_head->room, currdir), currdir );
                                }
                        }
                        bfs_dequeue();          // Got all paths off this one, remove it
 
                }
        }
 
	return NOWHERE;		// Can't get outta here!
@


1.12
log
@Artus> Modified hunting, should no longer crash when victims are removed from
       the game.
@
text
@d312 1
a312 1
    if (!(vict = get_char_vis(ch, arg, FIND_CHAR_WORLD))) 
d327 6
@


1.11
log
@Artus> Now warning free :o)
@
text
@d37 1
d188 69
d277 7
a283 1
    vict = HUNTING(ch);
d288 1
d291 1
d301 1
a301 1
	  HUNTING(ch) = NULL;
d322 1
a322 1
    if(PRF_FLAGGED(vict, PRF_TAG)) 
d328 1
a328 1
      HUNTING(ch) = vict;
d336 1
a336 1
      HUNTING(ch) = NULL;
d350 1
a350 1
	  HUNTING(ch) = NULL;
a384 2
  byte found;
  struct char_data *tmp;
d389 3
a391 6
  /* make sure the char still exists */
  for (found = FALSE, tmp = character_list; tmp && !found; tmp = tmp->next)
    if (HUNTING(ch) == tmp)
      found = TRUE;

  if (!found) {
d393 1
a393 1
    HUNTING(ch) = NULL;
d396 2
a397 1
  if ((dir = find_first_step(ch, ch->in_room, HUNTING(ch)->in_room)) < 0) {
d400 1
a400 1
    HUNTING(ch) = NULL;
@


1.10
log
@Artus> Conditionals for IGNORE_DEBUG.
@
text
@a70 1
  char temp[MAX_STRING_LENGTH];
@


1.9
log
@Artus> LR_FAIL_MAX fix, SPECIAL_TRACKER now provides SKILL_TRACK.
       Track and hunt now increase.
@
text
@d78 1
d81 1
d88 1
d91 1
@


1.8
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d194 2
a195 1
  if ((!GET_SKILL(ch, SKILL_TRACK)) || 
d280 10
a289 3
	num = number(0, 101);       /* 101% is a complete failure */
	if (GET_SKILL(ch, SKILL_TRACK) < num)
	  dir = 0;
a294 1
 
@


1.7
log
@Artus>
\r\n appended to gold rush message: act.informative.c

Imms no longer affected by underwater: act.movement.c, limits.c

Changed remort some more.. New special, tracker (SPECIAL_TRACKER):
act.other.c, act.wizard.c, constants.c, graph.c, structs.h, utils.c

Object and Room triggers can now %send% <room vnum> <message>:
dg_objcmd.c, dg_wldcmd.c

%self.direction% now has a vnum subfield to return the exit room's vnum.
(Eg: %self.north(vnum)%): dg_scripts.c

%actor.hisher%, %actor.himher%, %actor.heshe% implemented: dg_scripts.c

vnum, name, can_see, can_see_me added to %actor.next_in_room%, returning char
vnum, char name, if actor can see char, and if char can see actor respectively:
dg_scripts.c

Changed "do not know that spell" to "do not know of that spell": spell_parser.c

Changed "do not of know that skill/spell" to "do not know of..": utils.c

SECT_UNDERWATER and SECT_INSIDE now checked in OUTSIDE() macro: utils.h
@
text
@d82 1
a82 1
  if ((GET_LEVEL(ch) < LVL_IMMORT) && 
@


1.6
log
@Artus>
---
drop_otrigger takes an extra paramater for subcmd. With drop triggers you can
now specify whether the trigger is for drop, junk, donate and put. Specify
in the argument either/combination of 'junk', 'drop', 'donate', 'put'. No
argument means any type will be triggered:

act.item.c, dg_scripts.h, dg_triggers.c, interpreter.h
---
fixed colour bleed in dc:

act.wizard.c
---
Not reapplying empty timers in char_to_store:
Not calling object triggers from char_to_store:

db.c
---
Modified hunt so that with special_elf you can track through !TRACK rooms
(Modifier for Elf has been increased from 0.02 to 0.07%):

graph.c, utils.c
---
Timers should only show remove messages when being removed because they're
wearing off (duration = 0):

handler.c
---
Not calling object triggers when auto_equipping.

objsave.c
---
#defined around love_ring specproc. What a joke. define DRAX_IS_TEH_SUXOR if
you want it back ;o)

spec_assign.c, spec_procs.c
---
@
text
@d84 1
a84 1
      !IS_SET(GET_SPECIALS(ch), SPECIAL_ELF))
@


1.5
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@a71 1

d76 11
a86 2
  if (ROOM_FLAGGED(TOROOM(x, y), ROOM_NOTRACK) || IS_MARKED(TOROOM(x, y))) {
    if (GET_DEBUG(ch)) {
a87 1
    }
a89 1

d141 2
a142 1
  if (src < 0 || src > top_of_world || target < 0 || target > top_of_world) {
d157 2
a158 1
    if (VALID_EDGE(ch, src, curr_dir)) {
d165 2
a166 1
    if (queue_head->room == target) {
d172 2
a173 1
	if (VALID_EDGE(ch, queue_head->room, curr_dir)) {
d194 3
a196 1
  if ((!GET_SKILL(ch, SKILL_TRACK)) || (!GET_SKILL(ch, SKILL_HUNT) && (subcmd == /*SCMD_HUNT*/SKILL_HUNT))) {
d201 2
a202 1
  if(subcmd == SCMD_AUTOHUNT) {
d204 2
a205 1
    if((!CAN_SEE(ch,vict)) || (HUNTING(ch)->in_room == NOWHERE)) {
d209 12
a220 9
      }
    } else {
  one_argument(argument, arg);
  if (!*arg) {
    if(subcmd == /*SCMD_HUNT*/SKILL_HUNT) {
      if(HUNTING(ch)) {
        act("You stop hunting $N.",FALSE,ch,0,HUNTING(ch),TO_CHAR);
        HUNTING(ch) = NULL;
        return;
d224 1
a224 1
          }
d226 12
a237 1
      send_to_char("Whom are you trying to track?\r\n", ch);
d240 7
d248 8
a255 22
  if (!(vict = get_char_vis(ch, arg, FIND_CHAR_WORLD))) {
    send_to_char("No-one around by that name.\r\n", ch);
    return;
  }
  if (IS_AFFECTED(vict, AFF_NOTRACK)) {
    send_to_char("You sense no trail.\r\n", ch);
    return;
  }
  if(PRF_FLAGGED(vict, PRF_TAG)) {
    send_to_char("CHEAT! Ya can't track people who are playing tag!\r\n",ch);
    return;
  }
  if(subcmd == /*SCMD_HUNT*/SKILL_HUNT)
    HUNTING(ch) = vict;
}
/* this shood stop errors if the peron ya hunting dies b4 ya get there */
if((subcmd == /*SCMD_HUNT*/SKILL_HUNT || subcmd == SCMD_AUTOHUNT) && HUNTING(ch))
  if((HUNTING(ch)->in_room < 0 || HUNTING(ch)->in_room > top_of_world) ||
     (GET_HIT(HUNTING(ch)) <= 0)) {
    send_to_char("You can no longer find a path to your prey!\r\n",ch);
    HUNTING(ch) = NULL;
    return;
d257 25
a281 24
 
  dir = find_first_step(ch, ch->in_room, vict->in_room);
 
  switch (dir) {
  case BFS_ERROR:
    send_to_char("Hmm.. something seems to be wrong.\r\n", ch);
    break;
  case BFS_ALREADY_THERE:
    if((subcmd == /*SCMD_HUNT*/SKILL_HUNT || subcmd == SCMD_AUTOHUNT) && HUNTING(ch)) {
      send_to_char("You've found your prey!\r\n",ch);
      HUNTING(ch) = NULL;
      } else {
        send_to_char("You're already in the same room!!\r\n", ch);
      }
    break;
  case BFS_NO_PATH: 
    sprintf(buf, "You can't sense a trail to %s from here.\r\n",
            HMHR(vict));
    send_to_char(buf, ch);
    break;
  default:
    num = number(0, 101);       /* 101% is a complete failure */
    if (GET_SKILL(ch, SKILL_TRACK) < num)
                        dir = 0;
d288 4
a291 4
    sprintf(buf, "You sense a trail %s from here!\r\n", dirs[dir]);
    send_to_char(buf, ch);
    break;
  }
@


1.4
log
@Latest Version
@
text
@d136 1
a136 1
    log("SYSERR: Illegal value %d or %d passed to find_first_step. (%s)", src, target, __FILE__);
@


1.3
log
@Modified: Rod

Changed:
- SCMD_xx to SKILL_xx (for uniformity of command info stuff)
@
text
@d23 10
d40 1
d43 1
a43 1
int VALID_EDGE(room_rnum x, int y);
d47 1
a47 1
int find_first_step(room_rnum src, room_rnum target);
d69 1
a69 1
int VALID_EDGE(room_rnum x, int y)
d71 2
d77 4
a80 1
  if (ROOM_FLAGGED(TOROOM(x, y), ROOM_NOTRACK) || IS_MARKED(TOROOM(x, y)))
d82 1
d130 1
a130 1
int find_first_step(room_rnum src, room_rnum target)
d150 1
a150 1
    if (VALID_EDGE(src, curr_dir)) {
d163 1
a163 1
	if (VALID_EDGE(queue_head->room, curr_dir)) {
d237 1
a237 1
  dir = find_first_step(ch->in_room, vict->in_room);
d291 1
a291 1
  if ((dir = find_first_step(ch->in_room, HUNTING(ch)->in_room)) < 0) {
@


1.2
log
@

Added:
- more shite
@
text
@d167 1
a167 1
  if ((!GET_SKILL(ch, SKILL_TRACK)) || (!GET_SKILL(ch, SKILL_HUNT) && (subcmd == SCMD_HUNT))) {
d182 1
a182 1
    if(subcmd == SCMD_HUNT) {
d208 1
a208 1
  if(subcmd == SCMD_HUNT)
d212 1
a212 1
if((subcmd == SCMD_HUNT || subcmd == SCMD_AUTOHUNT) && HUNTING(ch))
d227 1
a227 1
    if((subcmd == SCMD_HUNT || subcmd == SCMD_AUTOHUNT) && HUNTING(ch)) {
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d379 4
a382 1
  if (world[x].dir_option[y] == NULL || TOROOM(x, y) == NOWHERE || TOROOM(x, y) == x)
@

