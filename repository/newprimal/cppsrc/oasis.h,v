head	1.15;
access;
symbols
	A3_0_59:1.5
	LATEST:1.5
	A3_0_1:1.5;
locks; strict;
comment	@ * @;


1.15
date	2004.05.18.11.06.58;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.23.03.04.24;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.10.12.02.26;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.13.01.05.29;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.12.05.32.35;	author primal;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.11.13.53.39;	author artus;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.21.13.40.13;	author artus;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.08.15.29.03;	author primal;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.03.01.26.14;	author primal;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.02.04.34.48;	author primal;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.20.16.47.40;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.17.13.47.04;	author primal;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.05.02.28.46;	author primal;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.13.00.59.20;	author primal;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.59;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Artus> Unholy Vengeance.
@
text
@/************************************************************************
 * OasisOLC - General / oasis.h					v2.0	*
 * Original author: Levork						*
 * Copyright 1996 by Harvey Gilpin					*
 * Copyright 1997-1999 by George Greer (greerga@@circlemud.org)		*
 ************************************************************************/

#define _OASISOLC	0x200   /* 2.0.0 */

/*
 * Used to determine what version of OasisOLC is installed.
 *
 * Ex: #if _OASISOLC >= OASIS_VERSION(2,0,0)
 */
#define OASIS_VERSION(x,y,z)	(((x) << 8 | (y) << 4 | (z))

/*
 * Set this to 1 to enable MobProg support.  MobProgs are available on
 * the CircleMUD FTP site in the contrib/code directory.
 */
#define CONFIG_OASIS_MPROG	0

/* -------------------------------------------------------------------------- */

/*
 * Macros, defines, structs and globals for the OLC suite.  You will need
 * to adjust these numbers if you ever add more.
 */
#define NUM_ROOM_FLAGS 	        31	
#define NUM_ZONE_FLAGS          27
#define NUM_ROOM_SECTORS_BASE   9 
#define NUM_ROOM_SECTORS_ATMOS  4 
#define NUM_ROOM_SECTORS_TEMP   6 
#define NUM_ROOM_SECTORS_GRAV   3 
#define NUM_ROOM_SECTORS_ENVIRO 2 
#define NUM_BURGLE_TYPES        12

#define NUM_MOB_FLAGS		25
#define NUM_AFF_FLAGS	        30	
#define NUM_ATTACK_TYPES	31

#define NUM_ITEM_TYPES		42 //24
#define NUM_ITEM_FLAGS		30 //17
#define NUM_ITEM_WEARS 		18
#define NUM_APPLIES		25
#define NUM_LIQ_TYPES 		17
#define NUM_POSITIONS		15 // ?? TODO - check
#define NUM_SPELLS		84

#define NUM_GENDERS		4
#define NUM_SHOP_FLAGS 		2
#define NUM_TRADERS 		7

#if CONFIG_OASIS_MPROG
/*
 * Define this to how many MobProg scripts you have.
 */
#define NUM_PROGS		12
#define ERROR_PROG        -1
#define IN_FILE_PROG       0
#define ACT_PROG           1
#define SPEECH_PROG        2
#define RAND_PROG          4
#define FIGHT_PROG         8
#define DEATH_PROG        16
#define HITPRCNT_PROG     32
#define ENTRY_PROG        64
#define GREET_PROG       128
#define ALL_GREET_PROG   256
#define GIVE_PROG        512
#define BRIBE_PROG      1024
#endif

#define LIST_MOB        0
#define LIST_OBJ        1
#define LIST_ROOM       2

/* -------------------------------------------------------------------------- */

/*
 * Limit information.
 */
#define MAX_ROOM_NAME	1024//75
#define MAX_MOB_NAME	100//50
#define MAX_OBJ_NAME	100//50
#define MAX_ROOM_DESC	2048//1024
#define MAX_EXIT_DESC	1024//256
#define MAX_EXTRA_DESC  1024//512
#define MAX_MOB_DESC	1024//512
#define MAX_OBJ_DESC	1024//512
#define MAX_TRIGGER_LENGTH MAX_STRING_LENGTH

/* -------------------------------------------------------------------------- */

extern int list_top;

/*
 * Utilities exported from olc.c.
 */
void cleanup_olc(struct descriptor_data *d, byte cleanup_type);
void get_char_colors(struct char_data *ch);

/*
 * OLC structures.
 */

struct oasis_olc_data {
  int mode;
  int zone_num;
  int number;
  int value;
  int total_mprogs;
  struct char_data *mob;
  struct room_data *room;
  struct obj_data *obj;
  struct zone_data *zone;
  struct shop_data *shop;
  struct extra_descr_data *desc;
#if CONFIG_OASIS_MPROG
  struct mob_prog_data *mprog;
  struct mob_prog_data *mprogl;
#endif
  struct trig_data *trig;
  int script_mode;
  int trigger_position;
  int item_type;
  struct trig_proto_list *script;
  char *storage; /* for holding commands etc.. */
  long balance_bits;
};

/*
 * Exported globals.
*/
extern const char *nrm, *grn, *cyn, *yel;

/*
 * Descriptor access macros.
 */
#define OLC(d)		((struct oasis_olc_data *)(d)->olc)
#define OLC_MODE(d) 	(OLC(d)->mode)		/* Parse input mode.	*/
#define OLC_NUM(d) 	(OLC(d)->number)	/* Room/Obj VNUM.	*/
#define OLC_VAL(d) 	(OLC(d)->value)		/* Scratch variable.	*/
#define OLC_ZNUM(d) 	(OLC(d)->zone_num)	/* Real zone number.	*/
#define OLC_ROOM(d) 	(OLC(d)->room)		/* Room structure.	*/
#define OLC_OBJ(d) 	(OLC(d)->obj)		/* Object structure.	*/
#define OLC_ZONE(d)     (OLC(d)->zone)		/* Zone structure.	*/
#define OLC_MOB(d)	(OLC(d)->mob)		/* Mob structure.	*/
#define OLC_SHOP(d) 	(OLC(d)->shop)		/* Shop structure.	*/
#define OLC_DESC(d) 	(OLC(d)->desc)		/* Extra description.	*/
#if CONFIG_OASIS_MPROG
#define OLC_MPROG(d)	(OLC(d)->mprog)		/* Temporary MobProg.	*/
#define OLC_MPROGL(d)	(OLC(d)->mprogl)	/* MobProg list.	*/
#define OLC_MTOTAL(d)	(OLC(d)->total_mprogs)	/* Total mprog number.	*/
#endif
#define OLC_TRIG(d)     (OLC(d)->trig)          /* Trigger structure.   */
#define OLC_STORAGE(d)  (OLC(d)->storage)       /* For command storage  */
#define OLC_BALBITS(d)  (OLC(d)->balance_bits)  /* Stores balance bits  */

/*
 * Other macros.
 */
#define OLC_EXIT(d)		(OLC_ROOM(d)->dir_option[OLC_VAL(d)])
#define GET_OLC_ZONE(c)		((c)->player_specials->saved.olc_zone)

/*
 * Cleanup types.
 */
#define CLEANUP_ALL		1	/* Free the whole lot.	*/
#define CLEANUP_STRUCTS 	2	/* Don't free strings.	*/

/*
 * Submodes of OEDIT connectedness.
 */
#define OEDIT_MAIN_MENU              	1
#define OEDIT_EDIT_NAMELIST          	2
#define OEDIT_SHORTDESC              	3
#define OEDIT_LONGDESC               	4
#define OEDIT_ACTDESC                	5
#define OEDIT_TYPE                   	6
#define OEDIT_EXTRAS                 	7
#define OEDIT_WEAR                  	8
#define OEDIT_WEIGHT                	9
#define OEDIT_COST                  	10
#define OEDIT_COSTPERDAY            	11
#define OEDIT_TIMER                 	12
#define OEDIT_VALUE_1               	13
#define OEDIT_VALUE_2               	14
#define OEDIT_VALUE_3               	15
#define OEDIT_VALUE_4               	16
#define OEDIT_APPLY                 	17
#define OEDIT_APPLYMOD              	18
#define OEDIT_EXTRADESC_KEY         	19
#define OEDIT_CONFIRM_SAVEDB        	20
#define OEDIT_CONFIRM_SAVESTRING    	21
#define OEDIT_PROMPT_APPLY          	22
#define OEDIT_EXTRADESC_DESCRIPTION 	23
#define OEDIT_EXTRADESC_MENU        	24
#define OEDIT_LEVEL                 	25
#define OEDIT_PERM			26
#define OEDIT_MAXDAMAGE                 27
#define OEDIT_DAMAGE                    28
#define OEDIT_CONFIRM_BALANCE        	29

/*
 * Submodes of REDIT connectedness.
 */
#define REDIT_MAIN_MENU 		1
#define REDIT_NAME 			2
#define REDIT_DESC 			3
#define REDIT_FLAGS 			4
#define REDIT_SECTOR     		5
#define REDIT_EXIT_MENU 		6
#define REDIT_CONFIRM_SAVEDB 		7
#define REDIT_CONFIRM_SAVESTRING 	8
#define REDIT_EXIT_NUMBER 		9
#define REDIT_EXIT_DESCRIPTION 		10
#define REDIT_EXIT_KEYWORD 		11
#define REDIT_EXIT_KEY 			12
#define REDIT_EXIT_DOORFLAGS 		13
#define REDIT_EXTRADESC_MENU 		14
#define REDIT_EXTRADESC_KEY 		15
#define REDIT_EXTRADESC_DESCRIPTION 	16
#define REDIT_SECTOR_BASE               17
#define REDIT_SECTOR_ATMOS              18
#define REDIT_SECTOR_TEMP               19
#define REDIT_SECTOR_GRAV               20
#define REDIT_SECTOR_ENVIRO             21
#define REDIT_SECTOR_MENU               22
#define REDIT_BURGLE                    23

/*
 * Submodes of ZEDIT connectedness.
 */
#define ZEDIT_MAIN_MENU              	0
#define ZEDIT_DELETE_ENTRY		1
#define ZEDIT_NEW_ENTRY			2
#define ZEDIT_CHANGE_ENTRY		3
#define ZEDIT_COMMAND_TYPE		4
#define ZEDIT_IF_FLAG			5
#define ZEDIT_ARG1			6
#define ZEDIT_ARG2			7
#define ZEDIT_ARG3			8
#define ZEDIT_ZONE_NAME			9
#define ZEDIT_ZONE_LIFE			10
#define ZEDIT_ZONE_TOP			11
#define ZEDIT_ZONE_RESET		12
#define ZEDIT_CONFIRM_SAVESTRING	13
#define ZEDIT_WORLD                     14
#define ZEDIT_FLAGS                     15
#define ZEDIT_SARG1                     16
#define ZEDIT_SARG2                     17


/*
 * Submodes of MEDIT connectedness.
 */
#define MEDIT_MAIN_MENU              	0
#define MEDIT_ALIAS			1
#define MEDIT_S_DESC			2
#define MEDIT_L_DESC			3
#define MEDIT_D_DESC			4
#define MEDIT_NPC_FLAGS			5
#define MEDIT_AFF_FLAGS			6
#define MEDIT_CONFIRM_SAVESTRING	7
#define MEDIT_CONFIRM_BALANCE		8

/*
 * Numerical responses.
 */
#define MEDIT_NUMERICAL_RESPONSE	10
#define MEDIT_SEX			11
#define MEDIT_HITROLL			12
#define MEDIT_DAMROLL			13
#define MEDIT_NDD			14
#define MEDIT_SDD			15
#define MEDIT_NUM_HP_DICE		16
#define MEDIT_SIZE_HP_DICE		17
#define MEDIT_ADD_HP			18
#define MEDIT_AC			19
#define MEDIT_EXP			20
#define MEDIT_GOLD			21
#define MEDIT_POS			22
#define MEDIT_DEFAULT_POS		23
#define MEDIT_ATTACK			24
#define MEDIT_LEVEL			25
#define MEDIT_ALIGNMENT			26
#if CONFIG_OASIS_MPROG
#define MEDIT_MPROG                     27
#define MEDIT_CHANGE_MPROG              28
#define MEDIT_MPROG_COMLIST             29
#define MEDIT_MPROG_ARGS                30
#define MEDIT_MPROG_TYPE                31
#define MEDIT_PURGE_MPROG               32
#endif
#define MEDIT_CLASS                     33

/*
 * Submodes of SEDIT connectedness.
 */
#define SEDIT_MAIN_MENU              	0
#define SEDIT_CONFIRM_SAVESTRING	1
#define SEDIT_NOITEM1			2
#define SEDIT_NOITEM2			3
#define SEDIT_NOCASH1			4
#define SEDIT_NOCASH2			5
#define SEDIT_NOBUY			6
#define SEDIT_BUY			7
#define SEDIT_SELL			8
#define SEDIT_PRODUCTS_MENU		11
#define SEDIT_ROOMS_MENU		12
#define SEDIT_NAMELIST_MENU		13
#define SEDIT_NAMELIST			14
/*
 * Numerical responses.
 */
#define SEDIT_NUMERICAL_RESPONSE	20
#define SEDIT_OPEN1			21
#define SEDIT_OPEN2			22
#define SEDIT_CLOSE1			23
#define SEDIT_CLOSE2			24
#define SEDIT_KEEPER			25
#define SEDIT_BUY_PROFIT		26
#define SEDIT_SELL_PROFIT		27
#define SEDIT_TYPE_MENU			29
#define SEDIT_DELETE_TYPE		30
#define SEDIT_DELETE_PRODUCT		31
#define SEDIT_NEW_PRODUCT		32
#define SEDIT_DELETE_ROOM		33
#define SEDIT_NEW_ROOM			34
#define SEDIT_SHOP_FLAGS		35
#define SEDIT_NOTRADE			36

/*
 * Prototypes to keep.
 */
void clear_screen(struct descriptor_data *);
//ACMD(do_oasis);

/*
 * Prototypes, to be moved later.
 */
void medit_free_mobile(struct char_data *mob);
void medit_setup_new(struct descriptor_data *d);
void medit_setup_existing(struct descriptor_data *d, int rmob_num);
void init_mobile(struct char_data *mob);
void medit_save_internally(struct descriptor_data *d);
void medit_save_to_disk(zone_vnum zone_num);
void medit_disp_positions(struct descriptor_data *d);
void medit_disp_mprog(struct descriptor_data *d);
void medit_change_mprog(struct descriptor_data *d);
void medit_disp_mprog_types(struct descriptor_data *d);
void medit_disp_sex(struct descriptor_data *d);
void medit_disp_attack_types(struct descriptor_data *d);
void medit_disp_mob_flags(struct descriptor_data *d);
void medit_disp_aff_flags(struct descriptor_data *d);
void medit_disp_classes(struct descriptor_data *d);
void medit_disp_menu(struct descriptor_data *d);
void medit_parse(struct descriptor_data *d, char *arg);
void medit_string_cleanup(struct descriptor_data *d, int terminator);

void oedit_setup_new(struct descriptor_data *d);
void oedit_setup_existing(struct descriptor_data *d, int real_num);
void oedit_save_internally(struct descriptor_data *d);
void oedit_save_to_disk(int zone_num);
void oedit_disp_container_flags_menu(struct descriptor_data *d);
void oedit_disp_extradesc_menu(struct descriptor_data *d);
void oedit_disp_prompt_apply_menu(struct descriptor_data *d);
void oedit_liquid_type(struct descriptor_data *d);
void oedit_disp_apply_menu(struct descriptor_data *d);
void oedit_disp_weapon_menu(struct descriptor_data *d);
void oedit_disp_spells_menu(struct descriptor_data *d);
void oedit_disp_val1_menu(struct descriptor_data *d);
void oedit_disp_val2_menu(struct descriptor_data *d);
void oedit_disp_val3_menu(struct descriptor_data *d);
void oedit_disp_val4_menu(struct descriptor_data *d);
void oedit_disp_type_menu(struct descriptor_data *d);
void oedit_disp_extra_menu(struct descriptor_data *d);
void oedit_disp_wear_menu(struct descriptor_data *d);
void oedit_disp_menu(struct descriptor_data *d);
void oedit_disp_battery_menu(struct descriptor_data *d);
void oedit_parse(struct descriptor_data *d, char *arg);
void oedit_disp_perm_menu(struct descriptor_data *d);
void oedit_string_cleanup(struct descriptor_data *d, int terminator);

void redit_string_cleanup(struct descriptor_data *d, int terminator);
void redit_setup_new(struct descriptor_data *d);
void redit_setup_existing(struct descriptor_data *d, int real_num);
void redit_save_internally(struct descriptor_data *d);
void redit_save_to_disk(zone_vnum zone_num);
void redit_disp_extradesc_menu(struct descriptor_data *d);
void redit_disp_exit_menu(struct descriptor_data *d);
void redit_disp_exit_flag_menu(struct descriptor_data *d);
void redit_disp_flag_menu(struct descriptor_data *d);
void redit_disp_sector_menu(struct descriptor_data *d);
void redit_disp_menu(struct descriptor_data *d);
void redit_parse(struct descriptor_data *d, char *arg);
void free_room(struct room_data *room);

void sedit_setup_new(struct descriptor_data *d);
void sedit_setup_existing(struct descriptor_data *d, int rshop_num);
void sedit_save_internally(struct descriptor_data *d);
void sedit_save_to_disk(int zone_num);
void sedit_products_menu(struct descriptor_data *d);
void sedit_compact_rooms_menu(struct descriptor_data *d);
void sedit_rooms_menu(struct descriptor_data *d);
void sedit_namelist_menu(struct descriptor_data *d);
void sedit_shop_flags_menu(struct descriptor_data *d);
void sedit_no_trade_menu(struct descriptor_data *d);
void sedit_types_menu(struct descriptor_data *d);
void sedit_disp_menu(struct descriptor_data *d);
void sedit_parse(struct descriptor_data *d, char *arg);

void trigedit_string_cleanup(struct descriptor_data *d, int terminator);
void trigedit_setup_new(struct descriptor_data *d);
void trigedit_setup_existing(struct descriptor_data *d, int rtrg_num);
void trigedit_parse(struct descriptor_data *d, char *arg);

void zedit_setup(struct descriptor_data *d, int room_num);
void zedit_sect_all(struct char_data *ch, int new_sect);
void zedit_new_zone(struct char_data *ch, int vzone_num);
void zedit_create_index(int znum, char *type);
void zedit_save_internally(struct descriptor_data *d);
void zedit_save_to_disk(int zone_num);
void zedit_disp_menu(struct descriptor_data *d);
void zedit_disp_comtype(struct descriptor_data *d);
void zedit_disp_arg1(struct descriptor_data *d);
void zedit_disp_arg2(struct descriptor_data *d);
void zedit_disp_arg3(struct descriptor_data *d);
void zedit_parse(struct descriptor_data *d, char *arg);
@


1.14
log
@Artus> Increased NUM_GENDERS to allow mobs to be created with random sex.
@
text
@d48 1
a48 1
#define NUM_SPELLS		83
@


1.13
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d50 1
a50 1
#define NUM_GENDERS		3
@


1.12
log
@Artus> Added !KILL flag for mobs... Things like gamina, postmaster, etc, can
       have this set, which should make it pretty damn impossible for them to
       die..
       Modified more stuff for dark ritual and vampires.. Have added a switch
       statement to affect_remove, which should be a good central place to
       handle triggers on affect removal.. Mainly to reset mana/move/hit to
       make sure they're not higher than max values when removing werewolf/
       vampire.
@
text
@d420 1
@


1.11
log
@*** empty log message ***
@
text
@d38 1
a38 1
#define NUM_MOB_FLAGS		24
@


1.10
log
@Modified: DM

Added:
- balancing checking
@
text
@d29 1
a29 1
#define NUM_ROOM_FLAGS 		25
@


1.9
log
@Modified: DM

Added:
- !GOLDRUSH zone flag checking
@
text
@d129 1
d158 1
d203 1
d266 2
@


1.8
log
@
Added:
- LIST_XXX defines for olist/mlist/rlist
@
text
@d30 1
a30 1
#define NUM_ZONE_FLAGS          26
@


1.7
log
@
Changed:
- NUM_SPELLS -> 83 (for identify and greater remove curse)
@
text
@d74 4
@


1.6
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d48 1
a48 1
#define NUM_SPELLS		81
@


1.5
log
@
Added:
- burgle flags, item flags (29->30), item damage
@
text
@d59 13
d87 1
d119 6
d151 2
d244 3
d329 1
a329 1
ACMD(do_oasis);
d404 5
@


1.4
log
@
Changed:
- NUM_ITEM_WEARS 15 -> 18
@
text
@d36 1
d43 1
a43 1
#define NUM_ITEM_FLAGS		29 //17
d173 2
d201 1
@


1.3
log
@
Added:
- Cant remember
@
text
@d43 1
a43 1
#define NUM_ITEM_WEARS 		15
@


1.2
log
@
Added:
- olc stuff - sectors, zone flags

Changed:
- Heaps of little fixes ....
@
text
@d38 1
a38 1
#define NUM_AFF_FLAGS		28
d343 1
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d30 6
a35 1
#define NUM_ROOM_SECTORS	10
d65 8
a72 8
#define MAX_ROOM_NAME	75
#define MAX_MOB_NAME	50
#define MAX_OBJ_NAME	50
#define MAX_ROOM_DESC	1024
#define MAX_EXIT_DESC	256
#define MAX_EXTRA_DESC  512
#define MAX_MOB_DESC	512
#define MAX_OBJ_DESC	512
d180 1
a180 1
#define REDIT_SECTOR 			5
d192 6
d217 1
@

