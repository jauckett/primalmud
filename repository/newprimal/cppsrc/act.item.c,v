head	1.56;
access;
symbols
	A3_0_59:1.5
	LATEST:1.5
	A3_0_1:1.4;
locks; strict;
comment	@ * @;


1.56
date	2004.11.24.05.47.31;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	2004.11.24.01.38.10;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	2004.08.27.01.44.21;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	2004.07.11.02.17.39;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	2004.07.07.11.36.16;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	2004.06.08.12.27.23;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.04.12.21.16;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	2004.05.26.06.50.43;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	2004.05.24.11.39.39;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.23.07.19.05;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.21.14.13.42;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.07.06.08.22;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.06.02.23.29;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.01.03.29.57;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.23.02.59.30;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.09.06.19.32;	author john;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.30.04.06.06;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.21.06.21.42;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.12.04.33.03;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.11.03.44.53;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.10.12.02.25;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.04.12.17.15;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.24.01.24.56;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.17.02.25.06;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	2003.11.25.05.37.15;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.24.00.14.49;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.17.12.36.24;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	2003.11.15.01.42.17;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	2003.11.14.22.37.14;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	2003.11.14.06.25.13;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.12.11.00.13;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.05.12.17.13;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.05.03.39.27;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.21.05.31.31;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.20.08.17.56;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.14.06.10.18;	author primal;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.17.04.16.43;	author rod;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.09.13.06.10;	author rod;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.09.12.18.20;	author rod;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.30.13.33.50;	author rod;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.13.10.05.41;	author primal;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.11.14.17.02;	author artus;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.21.02.45.50;	author artus;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.10.10.41.39;	author karma;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.09.03.44.08;	author artus;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.23.11.26.22;	author primal;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.10.06.50.04;	author primal;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.08.15.17.49;	author primal;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.05.00.09.35;	author primal;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.04.18.10.03;	author primal;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.02.04.34.44;	author primal;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.21.47.20;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.20.23.56.38;	author primal;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.17.12.37.03;	author primal;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.12.29.15;	author talisman;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.57;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Artus> Added bus routine.
@
text
@/*
************************************************************************
*   File: act.item.c                                    Part of CircleMUD *
*  Usage: object handling routines -- get/drop and container handling     *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "constants.h"
#include "corpses.h"
#include "dg_scripts.h"
#include "genzon.h"
#include "quest.h"

/* extern variables */
extern room_rnum donation_room_1;
#if 0
extern room_rnum donation_room_2;  /* uncomment if needed! */
extern room_rnum donation_room_3;  /* uncomment if needed! */
#endif
extern struct obj_data *obj_proto;
extern struct room_data *world;
extern struct index_data *obj_index;	/* index table for object file	 */
extern CorpseData corpseData;

/* extern functions */
int check_environment_effect(struct char_data *ch); 
struct char_data *get_player_by_id(long idnum);
void send_to_zone(const char *, zone_rnum);
int handle_quest_item_take(struct char_data *ch, struct obj_data *obj);
ACMD(do_qcomm);

/* local functions */
int isPlayerFriend(struct char_data *ch, long idnumOwner);
void perform_repair(struct char_data *ch, struct obj_data *obj);
int can_take_obj(struct char_data * ch, struct obj_data * obj);
void get_check_money(struct char_data * ch, struct obj_data * obj);
int perform_get_from_room(struct char_data * ch, struct obj_data * obj);
void get_from_room(struct char_data * ch, char *arg, int amount);
void perform_give_gold(struct char_data * ch, struct char_data * vict, int amount);
void perform_give(struct char_data * ch, struct char_data * vict, struct obj_data * obj);
int perform_drop(struct char_data * ch, struct obj_data * obj, byte mode, const char *sname, room_rnum RDR);
void perform_drop_gold(struct char_data * ch, int amount, byte mode, room_rnum RDR);
struct char_data *give_find_vict(struct char_data * ch, char *arg);
void weight_change_object(struct obj_data * obj, int weight);
void perform_put(struct char_data * ch, struct obj_data * obj, struct obj_data * cont);
/* Artus> I think these should go..
void name_from_drinkcon(struct obj_data * obj);
void name_to_drinkcon(struct obj_data * obj, int type); */
void get_from_container(struct char_data * ch, struct obj_data * cont, char *arg, int mode, int amount, int *corpseModified);
void wear_message(struct char_data * ch, struct obj_data * obj, int where);
void perform_wear(struct char_data * ch, struct obj_data * obj, int where);
int find_eq_pos(struct char_data * ch, struct obj_data * obj, char *arg);
void perform_get_from_container(struct char_data * ch, struct obj_data * obj, struct obj_data * cont, int mode, int *corpseModified);
void perform_remove(struct char_data * ch, int pos);
ACMD(do_remove);
ACMD(do_put);
ACMD(do_get);
ACMD(do_drop);
ACMD(do_give);
ACMD(do_drink);
ACMD(do_eat);
ACMD(do_pour);
ACMD(do_wear);
ACMD(do_wield);
ACMD(do_grab);

/* Artus> Futureworld Bus. */
void move_bus(void)
{
  static int loc = 5;
  struct obj_data *obj = NULL;
  room_rnum rd, rs;

  switch (loc)
  {
    case 0: /* Angel Grove */
      rd = real_room(20002);
      rs = real_room(11698);
      send_to_room("The 406 bus pulls up at the curb.\r\n", rd);
      send_to_room("The bus has stopped at angel grove.\r\n"
	           "The door opens.\r\n", rs);
      send_to_room("The bus has stopped at angel grove.\r\n"
	           "The door at the front of the bus opens.\r\n",
		   real_room(11699));
      obj = read_object(11693, VIRTUAL);
      GET_OBJ_VAL(obj, 0) = 20002;
      GET_OBJ_VAL(obj, 1) = 50;
      GET_OBJ_VAL(obj, 3) = 0;
      GET_OBJ_LEVEL(obj) = 50;
      obj_to_room(obj, rs);
      obj = read_object(11694, VIRTUAL);
      GET_OBJ_VAL(obj, 3) = 10000;
      obj_to_room(obj, rd);
      loc++;
      return;
    case 1: /* En Route -> Concert Hall */
      rd = real_room(20002);
      rs = real_room(11698);
      send_to_room("The bus door closes, and the bus pulls away from the curb.\r\n", rd);
      send_to_room("The bus door closes.  You feel the bus begin to move.\r\n",
	           rs);
      send_to_room("You feel the bus begin to move beneath you.\r\n",
	           real_room(11699));
      if ((obj = get_obj_in_list_num(real_object(11693), world[rs].contents)))
      { /* Remove the bus door */
	obj_from_room(obj);
	extract_obj(obj);
      }
      if ((obj = get_obj_in_list_num(real_object(11694), world[rd].contents)))
      { /* Remove the bus */
	obj_from_room(obj);
	extract_obj(obj);
      }
      loc++;
      return;
    case 2: /* At Concert Hall */
      rd = real_room(11600);
      rs = real_room(11698);
      send_to_room("The 406 bus pulls up at the curb.\r\n", rd);
      send_to_room("The bus has stopped at the city hall.\r\n"
	           "The door opens.\r\n", rs);
      send_to_room("The bus has stopped at the city hall.\r\n"
	           "The door at the front of the bus opens.\r\n",
		   real_room(11699));
      obj = read_object(11693, VIRTUAL);
      GET_OBJ_VAL(obj, 0) = 11600;
      GET_OBJ_VAL(obj, 1) = 50;
      GET_OBJ_VAL(obj, 3) = 5000;
      GET_OBJ_LEVEL(obj) = 50;
      obj_to_room(obj, rs);
      obj = read_object(11694, VIRTUAL);
      GET_OBJ_VAL(obj, 3) = 5000;
      obj_to_room(obj, rd);
      loc++;
      return;
    case 3: /* En Route -> Hollywood */
      rd = real_room(11600);
      rs = real_room(11698);
      send_to_room("The bus door closes, and the bus pulls away from the curb.\r\n", rd);
      send_to_room("The bus door closes.  You feel the bus begin to move.\r\n",
	           rs);
      send_to_room("You feel the bus begin to move beneath you.\r\n",
	           real_room(11699));
      if ((obj = get_obj_in_list_num(real_object(11693), world[rs].contents)))
      { /* Remove the bus door */
	obj_from_room(obj);
	extract_obj(obj);
      }
      if ((obj = get_obj_in_list_num(real_object(11694), world[rd].contents)))
      { /* Remove the bus */
	obj_from_room(obj);
	extract_obj(obj);
      }
      loc++;
      return;
    case 4: /* Hollywood */
      rd = real_room(26100);
      rs = real_room(11698);
      send_to_room("The 406 bus pulls up at the curb.\r\n", rd);
      send_to_room("The bus has stopped at hollywood.\r\n"
	           "The door opens.\r\n", rs);
      send_to_room("The bus has stopped at the city hall.\r\n"
	           "The door at the front of the bus opens.\r\n",
		   real_room(11699));
      obj = read_object(11693, VIRTUAL);
      GET_OBJ_VAL(obj, 0) = 26100;
      GET_OBJ_VAL(obj, 1) = 80;
      GET_OBJ_VAL(obj, 3) = 10000;
      GET_OBJ_LEVEL(obj) = 80;
      obj_to_room(obj, rs);
      obj = read_object(11694, VIRTUAL);
      GET_OBJ_VAL(obj, 3) = 0;
      obj_to_room(obj, rd);
      loc++;
      return;
    case 5: /* En Route - Angel Grove */
      rd = real_room(26100);
      rs = real_room(11698);
      send_to_room("The bus door closes, and the bus pulls away from the curb.\r\n", rd);
      send_to_room("The bus door closes.  You feel the bus begin to move.\r\n",
	           rs);
      send_to_room("You feel the bus begin to move beneath you.\r\n",
	           real_room(11699));
      if ((obj = get_obj_in_list_num(real_object(11693), world[rs].contents)))
      { /* Remove the bus door */
	obj_from_room(obj);
	extract_obj(obj);
      }
      if ((obj = get_obj_in_list_num(real_object(11694), world[rd].contents)))
      { /* Remove the bus */
	obj_from_room(obj);
	extract_obj(obj);
      }
      loc = 0;
      return;
  }
  sprintf(buf, "SYSERR: Made it to end of move_bus() without doing anything! [%d]", loc);
  loc = 0;
  mudlog(buf, BRF, LVL_GOD, TRUE); 
}

/* JA 2/4/95 */
void move_ship(void)
{
  extern struct descriptor_data *descriptor_list;
  extern struct zone_data *zone_table;
  static int loc = 0;
  room_vnum chrv;
  struct obj_data *obj;
  struct descriptor_data *d;
  struct char_data *ch;
  const char *pship_messages[][3] =
  { // Room, Zone-Haven, Zone-Danger
    {"The crew tie up and roll out the gangway.\r\n",
     "A cannon fires as the pirate ship arrives at Haven wharf.\r\n",
     "A bell tolls, the ship has dropped anchor at Haven wharf.\r\n"
    },
    {"The crew remove the gangway and weigh the anchor.\r\n",
     "A cannon fires as the Pirate ship sails away from Haven wharf.\r\n",
     "A cannon fires as the Pirate ship sails away from Haven wharf.\r\n"
    },
    {"The crew tie up and roll out the gangway.\r\n",
     "You hear the sound of a far off cannon shot. This Pirate ship has arrived.\r\n",
     "A cannon fires, the ship has dropped anchor at the island.\r\n"
    },
    {"The crew tie remove the gangway and weigh anchor.\r\n",
     "You hear the echo of a distant cannon shot. The Pirate ship has left the island.\r\n",
     "The ship has weighed anchor and sailed away from the island.\r\n"
    }
  };
  for (d=descriptor_list; d; d=d->next)
  {
    ch = d->character;
    if (!(ch) || (STATE(d) != CON_PLAYING) || IS_NPC(ch))
      continue;
    chrv = world[IN_ROOM(ch)].number;
    switch (zone_table[world[IN_ROOM(ch)].zone].number)
    {
      case 88: // Danger Island
	if (loc < 2) 
	  break;
	if (chrv == 8854)
	{
	  send_to_char(pship_messages[loc][0], ch);
	  break;
	}
	if (!EXT_FLAGGED(ch, EXT_NOHINTS))
	  send_to_char(pship_messages[loc][2], ch);
	break;
      case 11: // Haven
	if (loc > 1)
	  break;
	if (!EXT_FLAGGED(ch, EXT_NOHINTS))
	  send_to_char(pship_messages[loc][1], ch);
	break;
      case 86: // Pirate Ship
	if (loc < 2)
	{
	  if ((chrv == 8690) || (chrv == 8669))
	  {
	    send_to_char(pship_messages[loc][0], ch);
	    break;
	  }
	} else {
	  if (chrv == 8629)
	  {
	    send_to_char(pship_messages[loc][0], ch);
	    break;
	  }
	}
	if (!EXT_FLAGGED(ch, EXT_NOHINTS))
	  send_to_char(pship_messages[loc][2], ch);
	break;
      default: // Anywhere else.
	break;
    }
  }
  switch (loc)
  {
    case 0:              /* arrive to haven */
      obj_to_room(read_object(8615, VIRTUAL), real_room(8690)); 
      obj_to_room(read_object(8616, VIRTUAL), real_room(8669)); 
      loc = 1;
      return;
    case 1:              /* en-route to island */
      if ((obj = get_obj_in_list_num(real_object(8615), world[real_room(8690)].contents)))
      {     /* remove the ship */
        obj_from_room(obj);
        extract_obj(obj);
      }     /* remove the gangway */
      if ((obj = get_obj_in_list_num(real_object(8616), world[real_room(8669)].contents)))
      {
        obj_from_room(obj);
        extract_obj(obj);
      }
      loc = 2;
      return;
    case 2:              /*  at island */
      obj_to_room(read_object(8617, VIRTUAL), real_room(8854)); 
      obj_to_room(read_object(8618, VIRTUAL), real_room(8629));
      loc = 3;
      return;
    case 3:              /* en-route to haven */
      if ((obj = get_obj_in_list_num(real_object(8617), world[real_room(8854)].contents)))
      {
        obj_from_room(obj);
        extract_obj(obj);
      }
      if ((obj = get_obj_in_list_num(real_object(8618), world[real_room(8629)].contents)))
      {
        obj_from_room(obj);
        extract_obj(obj);
      }
      loc = 0;
      return;
  }
}

void move_falcon(void)
{
  static int loc = 2;
  struct obj_data *obj;

  switch (loc)
  {
    case 0 :              /* arrive to haven */
      send_to_room("\n\rThe Millenium Falcon has landed", real_room(25019));
      send_to_room("\n\rThe Millenium Falcon has landed", real_room(25044));
      send_to_room("\n\rThe exit ramp automatically opens.", real_room(25044));
      obj_to_room(read_object(25015, VIRTUAL), real_room(25019)); 
      obj_to_room(read_object(25016, VIRTUAL), real_room(25044)); 
      loc = 1;
      return;
    case 1 :              /* en-route to island */
      send_to_room("\n\rThe Millenium Falcon takes off!", real_room(25019));
      send_to_room("\n\rThe Millenium Falcon takes off!", real_room(25044));
      if ((obj = get_obj_in_list_num(real_object(25015), world[real_room(25019)].contents)))
      {     /* remove the ship */
        obj_from_room(obj);
        extract_obj(obj);
      }     /* remove the gangway */
      if ((obj = get_obj_in_list_num(real_object(25016), world[real_room(25044)].contents)))
      {
        obj_from_room(obj);
        extract_obj(obj);
      }
      loc = 2;
      return;
    case 2 :              /*  at island */
      send_to_room("\n\rThe Millenium Falcon has landed", real_room(22036));
      send_to_room("\n\rThe Millenium Falcon has landed", real_room(25044));
      send_to_room("\n\rThe exit ramp automatically opens.", real_room(25044));
      obj_to_room(read_object(25015, VIRTUAL), real_room(22036)); 
      obj_to_room(read_object(25017, VIRTUAL), real_room(25044));
      loc = 3;
      return;
    case 3 :              /* en-route to haven */
      send_to_room("\n\rThe Millenium Falcon takes off!", real_room(22036));
      send_to_room("\n\rThe Millenium Falcon takes off!", real_room(25044));
      if ((obj = get_obj_in_list_num(real_object(25015), world[real_room(22036)].contents)))
      {
        obj_from_room(obj);
        extract_obj(obj);
      }
      if ((obj = get_obj_in_list_num(real_object(25017), world[real_room(25044)].contents)))
      {
        obj_from_room(obj);
        extract_obj(obj);
      }
      loc = 0;
      return;
  }
}
/*
 * Returns TRUE if the idnum of ch is a friend of the player for idnumOwner.
 * First the player table in memory is checked, then we resort to file.
 */
int isPlayerFriend(struct char_data *ch, long idnumOwner)
{
  struct char_data *owner = NULL;
  struct char_file_u tmp_store;
  int i;
        
  // First check player table in memory
  if ((owner = get_player_by_id(idnumOwner)))
    for (i = 0; i < MAX_FRIENDS; i++)
      if (GET_FRIEND(owner, i) == GET_IDNUM(ch))
        return TRUE;
  // Now resort to file
  if (load_char(get_name_by_id(idnumOwner), &tmp_store))
    for (i = 0; i < MAX_FRIENDS; i++)
      if (tmp_store.player_specials_primalsaved.friends[i] == GET_IDNUM(ch))
        return TRUE;
  return FALSE;
}

/* ARMOURCRAFT and WEAPONCRAFT */
ACMD(do_repair)
{
  struct obj_data *o;

  one_argument(argument, buf);
  if (!*buf)
  {
    send_to_char("Repair what?!\r\n", ch);
    return;
  }
  if (!(o = generic_find_obj(ch, buf, FIND_OBJ_INV)))
  {
    send_to_char("You don't seem to have that item.\r\n", ch);
    return;
  }
  if ((GET_OBJ_TYPE(o) == ITEM_WEAPON && !GET_SKILL(ch, SKILL_WEAPONCRAFT)) ||
      (GET_OBJ_TYPE(o) == ITEM_ARMOR  && !GET_SKILL(ch, SKILL_ARMOURCRAFT)))
  {
    send_to_char("You don't have the appropriate skill"
                 " to repair that item.\r\n", ch);
    return;
  }
  if (GET_OBJ_TYPE(o) != ITEM_WEAPON && GET_OBJ_TYPE(o) != ITEM_ARMOR)
  {
    send_to_char("That item cannot be repaired by normal means.\r\n", ch);
    return;
  }
  // Check the damage status of the item
  if ((GET_OBJ_MAX_DAMAGE(o) == -1) ||
      (GET_OBJ_DAMAGE(o) == GET_OBJ_MAX_DAMAGE(o)))
  {
    send_to_char("It's in perfect condition already.\r\n", ch);
    return;
  }
  // Do a check here for some items that might be required to repair
  // ie - anvil, hammer, etc
  perform_repair(ch, o);	
}

void perform_repair(struct char_data *ch, struct obj_data *obj)
{
  int skillAmt = (GET_OBJ_TYPE(obj) == ITEM_WEAPON ? 
                  GET_SKILL(ch, SKILL_WEAPONCRAFT) :
	          GET_SKILL(ch, SKILL_ARMOURCRAFT));
  int modifier = 0, str = GET_STR(ch), con = GET_CON(ch);
  float maxAmt = GET_OBJ_MAX_DAMAGE(obj) / 10;
	
  if (maxAmt < 1)
    maxAmt = 1;	// Minimum of at least 1 point up or down
  modifier += (str >= 21 ? 3 : (str >= 18 ? 2 : (str >= 15 ? 1 : 
              (str >= 10 ? 0 : str >= 7 ? -1 : -2))));
  modifier += (con >= 21 ? 3 : (con >= 18 ? 2 : (con >= 15 ? 1 : 
              (con >= 10 ? 0 : con >= 7 ? -1 : -2))));
  skillAmt += modifier;
  // Skill amount is now a percentage, max is 95
  if (skillAmt > MAX_SKILL_ABIL)
    skillAmt = MAX_SKILL_ABIL;
  if (number(1, 100) > skillAmt)
  {
    // Fucked up, damaged the item
    act("&r$n strikes badly, further damaging $p!&n", 
	FALSE, ch, obj, 0, TO_ROOM);
    act("&rYou struck badly, damaging $p!&n", FALSE, ch, obj, 0, TO_CHAR);
    GET_OBJ_DAMAGE(obj) -= (sh_int)maxAmt;
  } else {	// Did a repair on the sucker 
    act("&g$n strikes truely, repairing $p.&n", FALSE, ch, obj, 0, TO_ROOM);
    act("&gYou strike well, repairing $p.&n", FALSE, ch, obj, 0, TO_CHAR);
    GET_OBJ_DAMAGE(obj) += (sh_int)maxAmt;
  }
  // Some checking
  if ((GET_OBJ_DAMAGE(obj) <= 0) && (GET_OBJ_MAX_DAMAGE(obj) != -1))
  {
    act("&r... $p is destroyed completely.&n", FALSE, ch, obj, 0, TO_ROOM);
    act("&r... you destroyed $p completely.&n", FALSE, ch, obj, 0, TO_CHAR);
    extract_obj(obj);
  }
  if ((GET_OBJ_DAMAGE(obj) > GET_OBJ_MAX_DAMAGE(obj)) || 
      (GET_OBJ_MAX_DAMAGE(obj) == -1))
    GET_OBJ_DAMAGE(obj) = GET_OBJ_MAX_DAMAGE(obj);
}

void perform_put(struct char_data * ch, struct obj_data * obj,
		 struct obj_data * cont)
{
  int House_can_enter(struct char_data * ch, room_vnum house);
  if (!drop_otrigger(obj, ch, SCMD_IS_PUT))
    return;
  if (OBJ_RIDDEN(obj))
  {
    act("$p - You're riding that!\r\n", FALSE, ch, obj, NULL, TO_CHAR);
    return;
  }
  if (GET_OBJ_WEIGHT(cont) + GET_OBJ_WEIGHT(obj) > GET_OBJ_VAL(cont, 0))
  {
    act("$p won't fit in $P.", FALSE, ch, obj, cont, TO_CHAR);
    return;
  }
  if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER)
  {
    act("$p - You can't put a container inside a container!", FALSE, ch, obj, NULL, TO_CHAR);
    return;
  }
  if ((cont->carried_by != ch) && IS_OBJ_STAT(obj, ITEM_NODROP) &&
      !House_can_enter(ch, world[IN_ROOM(ch)].number))
  {
    act("You can't seem to let go of $p.", TRUE, ch, obj, NULL, TO_CHAR);
    return;
  }
  /* Yes, I realize this is strange until we have auto-equip on rent. -gg */
  /* Artus> gg, you am teh sux0r. We'll check when we go to drop, in stead.
  if (IS_OBJ_STAT(obj, ITEM_NODROP) && !IS_OBJ_STAT(cont, ITEM_NODROP)) {
    SET_BIT(GET_OBJ_EXTRA(cont), ITEM_NODROP);
    act("You get a strange feeling as you put $p in $P.", FALSE,
	      ch, obj, cont, TO_CHAR);
    return;
  } else */
  // Artus> Curse objects put inside cursed container.
  if (IS_OBJ_STAT(cont, ITEM_NODROP) && !IS_OBJ_STAT(obj, ITEM_NODROP)) 
  {
    SET_BIT(GET_OBJ_EXTRA(obj), ITEM_NODROP);
    act("You get a strange feeling as you put $p in $P.", FALSE, ch, obj,
	cont, TO_CHAR);
  } else {
    act("$n puts $p in $P.", TRUE, ch, obj, cont, TO_ROOM);
    act("You put $p in $P.", FALSE, ch, obj, cont, TO_CHAR);
  }
  obj_from_char(obj);
  obj_to_obj(obj, cont);
}


/* The following put modes are supported by the code below:

	1) put <object> <container>
	2) put all.<object> <container>
	3) put all <container>

	<container> must be in inventory or on ground.
	all objects to be put into container must be in inventory.
*/

ACMD(do_put)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  char arg3[MAX_INPUT_LENGTH];
  struct obj_data *obj, *next_obj, *cont;
  struct char_data *tmp_char;
  int obj_dotmode, cont_dotmode, found = 0, howmany = 1;
  char *theobj, *thecont;

  argument = two_arguments(argument, arg1, arg2);
  one_argument(argument, arg3);

  if (*arg3 && is_number(arg1))
  {
    howmany = atoi(arg1);
    theobj = arg2;
    thecont = arg3;
  } else {
    theobj = arg1;
    thecont = arg2;
  }
  obj_dotmode = find_all_dots(theobj);
  cont_dotmode = find_all_dots(thecont);

  if (!*theobj)
    send_to_char("Put what in what?\r\n", ch);
  else if (cont_dotmode != FIND_INDIV)
    send_to_char("You can only put things into one container at a time.\r\n",
	         ch);
  else if (!*thecont)
  {
    sprintf(buf, "What do you want to put %s in?\r\n",
	    ((obj_dotmode == FIND_INDIV) ? "it" : "them"));
    send_to_char(buf, ch);
  } else {
    generic_find(thecont, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tmp_char, &cont);
    if (!cont)
    {
      sprintf(buf, "You don't see %s %s here.\r\n", AN(thecont), thecont);
      send_to_char(buf, ch);
    } else if (GET_OBJ_TYPE(cont) != ITEM_CONTAINER)
      act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
    else if (OBJVAL_FLAGGED(cont, CONT_CLOSED))
      send_to_char("You'd better open it first!\r\n", ch);
    else
    {
      if (obj_dotmode == FIND_INDIV)
      {	/* put <obj> <container> */
	if (!(obj = generic_find_obj(ch, theobj, FIND_OBJ_INV)))
	{
	  sprintf(buf, "You aren't carrying %s %s.\r\n", AN(theobj), theobj);
	  send_to_char(buf, ch);
	} else if (obj == cont)
	  send_to_char("You attempt to fold it into itself, but fail.\r\n", ch);
	else
	{
	  struct obj_data *next_obj;
	  while(obj && howmany--)
	  {
	    next_obj = obj->next_content;
	    perform_put(ch, obj, cont);
	    obj = find_obj_list(ch, theobj, next_obj);
	  }
	}
      } else {
	for (obj = ch->carrying; obj; obj = next_obj)
	{
	  next_obj = obj->next_content;
	  if (obj != cont && CAN_SEE_OBJ(ch, obj) &&
	      (obj_dotmode == FIND_ALL || isname(theobj, obj->name)))
	  {
	    found = 1;
	    perform_put(ch, obj, cont);
	  }
	}
	if (!found)
	{
	  if (obj_dotmode == FIND_ALL)
	    send_to_char("You don't seem to have anything to put in it.\r\n",
		         ch);
	  else
	  {
	    sprintf(buf, "You don't seem to have any %ss.\r\n", theobj);
	    send_to_char(buf, ch);
	  }
	}
      }
    }
  }
}

int can_take_obj(struct char_data * ch, struct obj_data * obj)
{
  struct event_data *find_quest_event();

  if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
  {
    act("$p: you can't carry that many items.", FALSE, ch, obj, 0, TO_CHAR);
    return (0);
  } 
  if ((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) > CAN_CARRY_W(ch))
  {
    act("$p: you can't carry that much weight.", FALSE, ch, obj, 0, TO_CHAR);
    return (0);
  } 
  if (!(CAN_WEAR(obj, ITEM_WEAR_TAKE)))
  {
    act("$p: you can't take that!", FALSE, ch, obj, 0, TO_CHAR);
    return (0);
  }
  // Artus> Quest Items ala QUEST_ITEM_HUNT.
  if (GET_OBJ_TYPE(obj) == ITEM_QUEST)
    return (handle_quest_item_take(ch, obj));
  return (1);
}

void get_check_money(struct char_data * ch, struct obj_data * obj)
{
  int value = GET_OBJ_VAL(obj, 0);

  if (GET_OBJ_TYPE(obj) != ITEM_MONEY || value <= 0)
    return;
  obj_from_char(obj);
  extract_obj(obj);
  GET_GOLD(ch) += value;
  if (value == 1)
    send_to_char("There was &Y1&n coin.\r\n", ch);
  else
  {
    sprintf(buf, "There were &Y%d&n coins.\r\n", value);
    send_to_char(buf, ch);
  }
}

void perform_get_from_container(struct char_data * ch, struct obj_data * obj,
				struct obj_data * cont, int mode, 
				int *corpseModified)
{
  if ((mode == FIND_OBJ_INV) || can_take_obj(ch, obj))
  {
    if (GET_OBJ_TYPE(obj) == ITEM_QUEST)
    {
      handle_quest_item_take(ch, obj);
      return;
    }
    if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
      act("$p: you can't hold any more items.", FALSE, ch, obj, 0, TO_CHAR);
    else if (get_otrigger(obj, ch))
    {
      // Dont let NPCS touch PC corpses
      if (IS_NPC(ch))
      {
        send_to_char("Bugger off!", ch);
        return;
      }
      // DM - set corpseModified value indicating to save the CorpseData when 
      // we return to do_get function 
      if (GET_CORPSEID(cont) > 0)
      {
        *corpseModified = 1;
        sprintf(buf, "%s got obj %s from corpse of %s", GET_NAME(ch), 
		obj->name, get_name_by_id(GET_CORPSEID(cont))); 
        mudlog(buf, CMP, MAX(GET_INVIS_LEV(ch), LVL_GOD), TRUE); 
      }
      obj_from_obj(obj);
      obj_to_char(obj, ch, __FILE__, __LINE__);
      act("You get $p from $P.", FALSE, ch, obj, cont, TO_CHAR);
      act("$n gets $p from $P.", TRUE, ch, obj, cont, TO_ROOM);
      get_check_money(ch, obj);
    }
  }
}


void get_from_container(struct char_data * ch, struct obj_data * cont,
			char *arg, int mode, int howmany,
			int *corpseModified)
{
  struct obj_data *obj, *next_obj;
  int obj_dotmode, found = 0;

  // DM: check if container is corpse, and if ch is allowed to modify it
  if (GET_CORPSEID(cont) > 0)
  {
    if (GET_IDNUM(ch) != GET_CORPSEID(cont) && LR_FAIL(ch, LVL_ANGEL) && 
	!isPlayerFriend(ch, GET_CORPSEID(cont)))
    {
      sprintf(buf, "Umm, you'd better not touch that. Ask &7%s&n for permission.", get_name_by_id(GET_CORPSEID(cont)));
      send_to_char(buf, ch);
      return;
    }  
  }
  obj_dotmode = find_all_dots(arg);
  if (OBJVAL_FLAGGED(cont, CONT_CLOSED))
    act("$p is closed.", FALSE, ch, cont, 0, TO_CHAR);
  else if (obj_dotmode == FIND_INDIV)
  {
    if (!(obj = find_obj_list(ch, arg, cont->contains)))
    {
      sprintf(buf, "There doesn't seem to be %s %s in $p.", AN(arg), arg);
      act(buf, FALSE, ch, cont, 0, TO_CHAR);
    } else {
      struct obj_data *obj_next;
      while(obj && howmany--)
      {
        obj_next = obj->next_content;
        perform_get_from_container(ch, obj, cont, mode, corpseModified);
        obj = find_obj_list(ch, arg, obj_next);
      }
    }
  } else {
    if (obj_dotmode == FIND_ALLDOT && !*arg)
    {
      send_to_char("Get all of what?\r\n", ch);
      return;
    }
    for (obj = cont->contains; obj; obj = next_obj)
    {
      next_obj = obj->next_content;
      if (CAN_SEE_OBJ(ch, obj) &&
	  (obj_dotmode == FIND_ALL || isname(arg, obj->name)))
      {
	found = 1;
	perform_get_from_container(ch, obj, cont, mode, corpseModified);
	if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
	{
	  send_to_char("Your arms are now full.\r\n", ch);
	  break;
	}
      }
    }
    if (!found)
    {
      if (obj_dotmode == FIND_ALL)
	act("$p seems to be empty.", FALSE, ch, cont, 0, TO_CHAR);
      else
      {
	sprintf(buf, "You can't seem to find any %ss in $p.", arg);
	act(buf, FALSE, ch, cont, 0, TO_CHAR);
      }
    }
  }
}

int perform_get_from_room(struct char_data * ch, struct obj_data * obj)
{
  if (can_take_obj(ch, obj) && get_otrigger(obj, ch))
  {
    int sleight = 0;
    // DM: check if obj is corpse, and if ch is allowed to modify it
    if ((GET_CORPSEID(obj) > 0) && (GET_IDNUM(ch) != GET_CORPSEID(obj)) && 
	LR_FAIL(ch, LVL_IS_GOD) && !isPlayerFriend(ch, GET_CORPSEID(obj)))
    {
      sprintf(buf, "Umm, you'd better not touch that. Ask &7%s&n for permission.", get_name_by_id(GET_CORPSEID(obj)));
      send_to_char(buf, ch);
      return(0);
    } 
    if (!IS_NPC(ch) && GET_SKILL(ch,SKILL_SLEIGHT) && 
	has_stats_for_skill(ch,SKILL_SLEIGHT,FALSE) &&
	(number(0, 101) < GET_SKILL(ch, SKILL_SLEIGHT)) &&
	(CAN_CARRY_W(ch) > (GET_OBJ_WEIGHT(obj) * 3)))
      sleight = 1;
    obj_from_room(obj);
    obj_to_char(obj, ch, __FILE__, __LINE__);
    if (sleight == 0)
    {
      act("You get $p.", FALSE, ch, obj, 0, TO_CHAR);
      act("$n gets $p.", TRUE, ch, obj, 0, TO_ROOM);
    } else {
      act("You get $p while noone is looking.", FALSE, ch, obj, 0, TO_CHAR);
      apply_spell_skill_abil(ch, SKILL_SLEIGHT);
    }
    get_check_money(ch, obj);
    return (1);
  }
  return (0);
}

void get_from_room(struct char_data * ch, char *arg, int howmany)
{
  struct obj_data *obj, *next_obj;
  int dotmode, found = 0;

  dotmode = find_all_dots(arg);

  if (dotmode == FIND_INDIV)
  {
    if (!(obj = find_obj_list(ch, arg, world[IN_ROOM(ch)].contents)))
    {
      sprintf(buf, "You don't see %s %s here.\r\n", AN(arg), arg);
      send_to_char(buf, ch);
    } else {
      struct obj_data *obj_next;
      while(obj && howmany--)
      {
	obj_next = obj->next_content;
        perform_get_from_room(ch, obj);
        obj = find_obj_list(ch, arg, obj_next);
      }
    }
  } else {
    if (dotmode == FIND_ALLDOT && !*arg)
    {
      send_to_char("Get all of what?\r\n", ch);
      return;
    }
    for (obj = world[ch->in_room].contents; obj; obj = next_obj)
    {
      next_obj = obj->next_content;
      if (CAN_SEE_OBJ(ch, obj) &&
	  ((dotmode == FIND_ALL) || isname(arg, obj->name)))
      {
	found = 1;
	perform_get_from_room(ch, obj);
      }
    }
    if (!found)
    {
      if (dotmode == FIND_ALL)
	send_to_char("There doesn't seem to be anything here.\r\n", ch);
      else
      {
	sprintf(buf, "You don't see any %ss here.\r\n", arg);
	send_to_char(buf, ch);
      }
    }
  }
}

ACMD(do_get)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  char arg3[MAX_INPUT_LENGTH];

  int cont_dotmode, found = 0, mode;
  struct obj_data *cont;
  struct char_data *tmp_char;
  int corpseModified = 0;

  argument = two_arguments(argument, arg1, arg2);
  one_argument(argument, arg3);
/*  int sleight = 0;		// Sleighting?
  if (!IS_NPC(ch))
    if (GET_SKILL(ch, SKILL_SLEIGHT) && 
        has_stats_for_skill(ch, SKILL_SLEIGHT,FALSE)) 
      if (number(0, 101) < GET_SKILL(ch, SKILL_SLEIGHT))
	sleight := 1; */
  if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
    send_to_char("Your arms are already full!\r\n", ch);
  else if (!*arg1)
    send_to_char("Get what?\r\n", ch);
  else if (!*arg2)
    get_from_room(ch, arg1, 1);
  else if (is_number(arg1) && !*arg3)
    get_from_room(ch, arg2, atoi(arg1));
  else
  {
    int amount = 1;
    if (is_number(arg1))
    {
      amount = atoi(arg1);
      strcpy(arg1, arg2);
      strcpy(arg2, arg3);
    }
    cont_dotmode = find_all_dots(arg2);
    if (cont_dotmode == FIND_INDIV)
    {
      mode = generic_find(arg2, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tmp_char, &cont);
      if (!cont)
      {
	sprintf(buf, "You don't have %s %s.\r\n", AN(arg2), arg2);
	send_to_char(buf, ch);
      } else if (GET_OBJ_TYPE(cont) != ITEM_CONTAINER)
	act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
      else {
	get_from_container(ch, cont, arg1, mode, amount, &corpseModified);
        // DM - call addCorpse to update the data for this corpse and save
        if (corpseModified == 1)
	{
          corpseData.addCorpse(cont, GET_ROOM_VNUM(ch->in_room), 0);
          save_char(ch, NOWHERE);
        }
      }
    } else {
      if (cont_dotmode == FIND_ALLDOT && !*arg2)
      {
	send_to_char("Get from all of what?\r\n", ch);
	return;
      }
      for (cont = ch->carrying; cont; cont = cont->next_content)
      {
        corpseModified = 0;
	if (CAN_SEE_OBJ(ch, cont) &&
	    (cont_dotmode == FIND_ALL || isname(arg2, cont->name)))
	{
	  if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER)
	  {
	    found = 1;
	    get_from_container(ch, cont, arg1, FIND_OBJ_INV, amount, 
                            &corpseModified);
	  } else if (cont_dotmode == FIND_ALLDOT) {
	    found = 1;
	    act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
	  }
	}
        // DM - call addCorpse to update the data for this corpse and save
        if (corpseModified == 1)
	{
          corpseData.addCorpse(cont, GET_ROOM_VNUM(ch->in_room), 0);
          save_char(ch, NOWHERE);
        }
      }
      for (cont = world[ch->in_room].contents; cont; cont = cont->next_content)
      {
        corpseModified = 0;
	if (CAN_SEE_OBJ(ch, cont) &&
	    (cont_dotmode == FIND_ALL || isname(arg2, cont->name)))
	{
	  if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER)
	  {
	    get_from_container(ch, cont, arg1, FIND_OBJ_ROOM, amount, 
			       &corpseModified);
	    found = 1;
	  } else if (cont_dotmode == FIND_ALLDOT) {
	    act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
	    found = 1;
	  }
	}
	// DM - call addCorpse to update the data for this corpse and save
	if (corpseModified == 1)
	{
          corpseData.addCorpse(cont, GET_ROOM_VNUM(ch->in_room), 0);
          save_char(ch, NOWHERE);
        }
      }
      if (!found)
      {
	if (cont_dotmode == FIND_ALL)
	  send_to_char("You can't seem to find any containers.\r\n", ch);
	else
	{
	  sprintf(buf, "You can't seem to find any %ss here.\r\n", arg2);
	  send_to_char(buf, ch);
	}
      }
    }
  }
}

void perform_drop_gold(struct char_data * ch, int amount, byte mode,
                       room_rnum RDR)
{
  struct obj_data *obj;

  if (amount <= 0)
    send_to_char("Heh heh heh.. we are jolly funny today, eh?\r\n", ch);
  else if (GET_GOLD(ch) < amount)
    send_to_char("You don't have that many coins!\r\n", ch);
  else
  {
    if (mode != SCMD_JUNK)
    {
      WAIT_STATE(ch, PULSE_VIOLENCE);	/* to prevent coin-bombing */
      obj = create_money(amount);
      if (mode == SCMD_DONATE)
      {
	sprintf(buf, "You throw some gold into the %s where it disappears in a puff of smoke!\r\n", (UNDERWATER(ch)) ? "water" : "air");
	send_to_char(buf, ch);
	sprintf(buf, "$n throws some gold into the %s where it disappears in a puff of smoke!", (UNDERWATER(ch)) ? "water" : "air");
	act(buf, FALSE, ch, 0, 0, TO_ROOM);
	obj_to_room(obj, RDR);
	act("$p suddenly appears in a puff of orange smoke!", 0, 0, obj, 0, TO_ROOM);
      } else {
        if (!drop_wtrigger(obj, ch))
	{
          extract_obj(obj);
          return;
        }
	send_to_char("You drop some gold.\r\n", ch);
	sprintf(buf, "$n drops %s.", money_desc(amount));
	act(buf, TRUE, ch, 0, 0, TO_ROOM);
	obj_to_room(obj, ch->in_room);
      }
    } else {
      sprintf(buf, "$n drops %s which disappears in a puff of smoke!",
	      money_desc(amount));
      act(buf, FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("You drop some gold which disappears in a puff of smoke!\r\n", ch);
    }
    GET_GOLD(ch) -= amount;
  }
}

#define VANISH(mode) ((mode == SCMD_DONATE || mode == SCMD_JUNK) ? \
		      "  It vanishes in a puff of smoke!" : "")
int perform_drop(struct char_data * ch, struct obj_data * obj,
		     byte mode, const char *sname, room_rnum RDR)
{
  int value;
  if (!drop_otrigger(obj, ch, mode))
    return 0;
  if ((mode == SCMD_DROP) && !drop_wtrigger(obj, ch))
    return 0;
  if (IS_OBJ_STAT(obj, ITEM_NODROP) && LR_FAIL(ch,LVL_ANGEL)) 
  {
    sprintf(buf, "You can't %s $p, it must be CURSED!", sname);
    act(buf, FALSE, ch, obj, 0, TO_CHAR);
    return (0);
  }
  if (!IS_NPC(ch) && (GET_OBJ_TYPE(obj) == ITEM_REWARD) && (mode != SCMD_JUNK))
  {
    send_to_char("You can't drop rewards!\r\n", ch);
    return (0);
  }
  if (OBJ_RIDDEN(obj))
  {
    sprintf(buf, "You can't %s $p, it's being ridden!", sname);
    act( buf, FALSE, ch, obj, 0, TO_CHAR);
    return (0);
  }
  if ((GET_OBJ_TYPE(obj) == ITEM_CONTAINER) && (obj->contains) && 
      LR_FAIL(ch, LVL_ANGEL))
  {
    if ((mode == SCMD_JUNK) || (mode == SCMD_DONATE))
    {
      sprintf(buf, "You must empty $p before you %s it!\r\n", sname);
      act(buf, FALSE, ch, obj, 0, TO_CHAR);
      return (0);
    }
    for (struct obj_data *myobj = obj->contains; myobj; 
	 myobj = myobj->next_content)
    {
      if (OBJ_FLAGGED(myobj, ITEM_NODROP))
      {
	sprintf(buf, "You can't %s $p, it contains cursed items!", sname);
	act(buf, FALSE, ch, obj, 0, TO_CHAR);
	return(0);
      }
      if (!IS_NPC(ch) && (GET_OBJ_TYPE(obj) == ITEM_REWARD) && 
	  (mode != SCMD_JUNK))
      {
	sprintf(buf, "You can't %s $p, it contains rewards!", sname);
	act(buf, FALSE, ch, obj, 0, TO_CHAR);
	return(0);
      }
    }
    sprintf(buf, "You drop $p. You hear something rattle inside.");
  } else
    sprintf(buf, "You %s $p.%s", sname, VANISH(mode));
  act(buf, FALSE, ch, obj, 0, TO_CHAR);
  sprintf(buf, "$n %ss $p.%s", sname, VANISH(mode));
  act(buf, TRUE, ch, obj, 0, TO_ROOM);
  obj_from_char(obj);

  if ((mode == SCMD_DONATE) && IS_OBJ_STAT(obj, ITEM_NODONATE))
    mode = SCMD_JUNK;

  switch (mode)
  {
    case SCMD_DROP:
      obj_to_room(obj, ch->in_room);
      return (0);
    case SCMD_DONATE:
      obj_to_room(obj, RDR);
      act("$p suddenly appears in a puff a smoke!", FALSE, 0, obj, 0, TO_ROOM);
      return (0);
    case SCMD_JUNK:
      value = MAX(1, MIN(200, GET_OBJ_COST(obj) / 16));
      extract_obj(obj);
      return (value);
    default:
      basic_mud_log("SYSERR: Incorrect argument %d passed to perform_drop.", mode);
      break;
  }
  return (0);
}

ACMD(do_drop)
{
  struct obj_data *obj, *next_obj;
  room_rnum RDR = 0;
  byte mode = SCMD_DROP;
  int dotmode, amount = 0, multi;
  const char *sname;

  switch (subcmd)
  {
    case SCMD_JUNK:
      sname = "junk";
      mode = SCMD_JUNK;
      break;
    case SCMD_DONATE:
      sname = "donate";
      mode = SCMD_DONATE;
      switch (number(0, 2))
      {
	case 0:
	  mode = SCMD_JUNK;
	  break;
	case 1:
	case 2:
	  RDR = real_room(donation_room_1);
	  break;
      }
      if (RDR == NOWHERE)
      {
	send_to_char("Sorry, you can't donate anything right now.\r\n", ch);
	return;
      }
      break;
    default:
      sname = "drop";
      break;
  }

  argument = one_argument(argument, arg);

  if (!*arg)
  {
    sprintf(buf, "What do you want to %s?\r\n", sname);
    send_to_char(buf, ch);
    return;
  } else if (is_number(arg)) {
    multi = atoi(arg);
    one_argument(argument, arg);
    if (!str_cmp("coins", arg) || !str_cmp("coin", arg))
      perform_drop_gold(ch, multi, mode, RDR);
    else if (multi <= 0)
      send_to_char("Yeah, that makes sense.\r\n", ch);
    else if (!*arg)
    {
      sprintf(buf, "What do you want to %s %d of?\r\n", sname, multi);
      send_to_char(buf, ch);
    } else if (!(obj = find_obj_list(ch, arg, ch->carrying))) {
      sprintf(buf, "You don't seem to have any %ss.\r\n", arg);
      send_to_char(buf, ch);
    } else {
      do
      {
        next_obj = find_obj_list(ch, arg, obj->next_content);
        amount += perform_drop(ch, obj, mode, sname, RDR);
        obj = next_obj;
      } while (obj && --multi);
    }
  } else {
    dotmode = find_all_dots(arg);
    /* Can't junk or donate all, DM: unless you are lvl immort + */
    if ((dotmode == FIND_ALL) && 
	(subcmd == SCMD_JUNK || subcmd == SCMD_DONATE) &&
        LR_FAIL(ch, LVL_CHAMP))
    {
      if (subcmd == SCMD_JUNK)
	send_to_char("Go to the dump if you want to junk EVERYTHING!\r\n", ch);
      else
	send_to_char("Go do the donation room if you want to donate "
		     "EVERYTHING!\r\n", ch);
      return;
    }
    if (dotmode == FIND_ALL) 
    {
      if (!ch->carrying)
      {
	send_to_char("You don't seem to be carrying anything.\r\n", ch);
	return;
      }
      for (obj = ch->carrying; obj; obj = next_obj)
      {
	next_obj = obj->next_content;
	amount += perform_drop(ch, obj, mode, sname, RDR);
      }
    } else if (dotmode == FIND_ALLDOT) {
      if (!*arg) 
      {
	sprintf(buf, "What do you want to %s all of?\r\n", sname);
	send_to_char(buf, ch);
	return;
      }
      if (!(obj = find_obj_list(ch, arg, ch->carrying))) 
      {
	sprintf(buf, "You don't seem to have any %ss.\r\n", arg);
	send_to_char(buf, ch);
	return;
      }
      while (obj) 
      {
	next_obj = find_obj_list(ch, arg, obj->next_content);
	amount += perform_drop(ch, obj, mode, sname, RDR);
	obj = next_obj;
      }
    } else {
      if (!(obj = find_obj_list(ch, arg, ch->carrying)))
      {
	sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
	send_to_char(buf, ch);
      } else
	amount += perform_drop(ch, obj, mode, sname, RDR);
    }
  }
  if (amount && (subcmd == SCMD_JUNK))
  {
    send_to_char("You have been rewarded by the gods!\r\n", ch);
    act("$n has been rewarded by the gods!", TRUE, ch, 0, 0, TO_ROOM);
    GET_GOLD(ch) += amount;
  }
}

void perform_give(struct char_data * ch, struct char_data * vict,
		  struct obj_data * obj, int subcmd)
{
  if (LR_FAIL(ch, LVL_ANGEL))
  {
    if (IS_OBJ_STAT(obj, ITEM_NODROP)) 
    {
      act("You can't let go of $p!!  Yeech!", FALSE, ch, obj, 0, TO_CHAR);
      return;
    }
    if (!IS_NPC(ch) && GET_OBJ_TYPE(obj) == ITEM_REWARD)
    {
      send_to_char("You can't give rewards away!\r\n", ch);
      return;
    }
    if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER)
      for (struct obj_data *myobj = obj->contains; myobj; 
	   myobj = myobj->next_content)
      {
	if (OBJ_FLAGGED(myobj, ITEM_NODROP))
	{
	  act("You can't let go of $p, it contains cursed items!", FALSE, ch, obj, 0, TO_CHAR);
	  return;
	}
	if (!IS_NPC(ch) && GET_OBJ_TYPE(myobj) == ITEM_REWARD)
	{
	  act("You can't let go of $p, it contains rewards!", FALSE, ch, obj, 0, TO_CHAR);
	  return;
	}
      }
  }
  if (OBJ_RIDDEN(obj))
  {
    send_to_char("You can't give that, it's being ridden!\r\n", ch);
    return;
  }
  if (IS_CARRYING_N(vict) >= CAN_CARRY_N(vict))
  {
    act("$N seems to have $S hands full.", FALSE, ch, 0, vict, TO_CHAR);
    return;
  }
  if (GET_OBJ_WEIGHT(obj) + IS_CARRYING_W(vict) > CAN_CARRY_W(vict))
  {
    act("$E can't carry that much weight.", FALSE, ch, 0, vict, TO_CHAR);
    return;
  }
  if ((subcmd != SCMD_SLIP) && (!give_otrigger(obj, ch, vict) || !receive_mtrigger(vict, ch, obj)))
    return;
  switch (subcmd)
  {
    case SCMD_SLIP:
      if ((basic_skill_test(ch, SKILL_SLIP, FALSE) == 0) ||
	  (number(0, GET_DEX(vict)) > GET_DEX(ch)))
      {
	act("$N catches you in the act!\r\n", FALSE, ch, obj, vict, TO_CHAR);
	act("You catch $n trying to slip $p into your pack.\r\n", FALSE, ch, obj, vict, TO_VICT);
	return;
      }
      apply_spell_skill_abil(ch, SKILL_SLIP);
      act("You slip $p into $N's pack.", FALSE, ch, obj, vict, TO_CHAR);
      if (!LR_FAIL(ch, LVL_ANGEL))
	act("$n has just slipped $p into your pack.\r\n", FALSE, ch, obj, vict, TO_VICT);
      break;
    case SCMD_GIVE:
    default:
      act("You give $p to $N.", FALSE, ch, obj, vict, TO_CHAR);
      act("$n gives you $p.", FALSE, ch, obj, vict, TO_VICT);
      act("$n gives $p to $N.", TRUE, ch, obj, vict, TO_NOTVICT);
  }
  obj_from_char(obj);
  obj_to_char(obj, vict, __FILE__, __LINE__);
}

/* utility function for give */
struct char_data *give_find_vict(struct char_data * ch, char *arg)
{
  struct char_data *vict;

  if (!*arg)
  {
    send_to_char("To who?\r\n", ch);
    return (NULL);
  } else if (!(vict = generic_find_char(ch, arg, FIND_CHAR_ROOM))) {
    send_to_char(NOPERSON, ch);
    return (NULL);
  } else if (vict == ch) {
    send_to_char("What's the point of that?\r\n", ch);
    return (NULL);
  } else
    return (vict);
}


void perform_give_gold(struct char_data * ch, struct char_data * vict,
		            int amount)
{
  if (amount <= 0)
  {
    send_to_char("Heh heh heh ... we are jolly funny today, eh?\r\n", ch);
    return;
  }
  if ((GET_GOLD(ch) < amount) && (IS_NPC(ch) || LR_FAIL(ch, LVL_GOD)))
  {
    send_to_char("You don't have that many coins!\r\n", ch);
    return;
  }
  send_to_char(OK, ch);
  sprintf(buf, "$n gives you %d gold coin%s.", amount, amount == 1 ? "" : "s");
  act(buf, FALSE, ch, 0, vict, TO_VICT);
  sprintf(buf, "$n gives %s to $N.", money_desc(amount));
  act(buf, TRUE, ch, 0, vict, TO_NOTVICT);
  if (IS_NPC(ch) || LR_FAIL(ch, LVL_GOD))
    GET_GOLD(ch) -= amount;
  GET_GOLD(vict) += amount;
  bribe_mtrigger(vict, ch, amount);
}


ACMD(do_give)
{
  int amount, dotmode;
  struct char_data *vict;
  struct obj_data *obj, *next_obj;

  argument = one_argument(argument, arg);

  if ((subcmd == SCMD_SLIP) &&
      !has_stats_for_skill(ch, SKILL_SLIP, TRUE))
    return;
  if (!*arg)
    send_to_char("Give what to who?\r\n", ch);
  else if (is_number(arg)) {
    amount = atoi(arg);
    argument = one_argument(argument, arg);
    if (!str_cmp("coins", arg) || !str_cmp("coin", arg))
    {
      one_argument(argument, arg);
      if ((vict = give_find_vict(ch, arg)) != NULL)
	perform_give_gold(ch, vict, amount);
      return;
    } else if (!*arg) {	/* Give multiple code. */
      sprintf(buf, "What do you want to give %d of?\r\n", amount);
      send_to_char(buf, ch);
    } else if (!(vict = give_find_vict(ch, argument))) {
      return;
    } else if (!(obj = find_obj_list(ch, arg, ch->carrying))) {
      sprintf(buf, "You don't seem to have any %ss.\r\n", arg);
      send_to_char(buf, ch);
    } else {
      while (obj && amount--)
      {
	next_obj = find_obj_list(ch, arg, obj->next_content);
	perform_give(ch, vict, obj, subcmd);
	obj = next_obj;
      }
    }
  } else {
    one_argument(argument, buf1);
    if (!(vict = give_find_vict(ch, buf1)))
      return;
    dotmode = find_all_dots(arg);
    if (dotmode == FIND_INDIV)
    {
      if (!(obj = find_obj_list(ch, arg, ch->carrying)))
      {
	sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
	send_to_char(buf, ch);
      } else
	perform_give(ch, vict, obj, subcmd);
    } else {
      if (dotmode == FIND_ALLDOT && !*arg)
      {
	send_to_char("All of what?\r\n", ch);
	return;
      }
      if (!ch->carrying)
	send_to_char("You don't seem to be holding anything.\r\n", ch);
      else
	for (obj = ch->carrying; obj; obj = next_obj)
	{
	  next_obj = obj->next_content;
	  if (CAN_SEE_OBJ(ch, obj) &&
	      ((dotmode == FIND_ALL || isname(arg, obj->name))))
	    perform_give(ch, vict, obj, subcmd);
	}
    }
  }
}



void weight_change_object(struct obj_data * obj, int weight)
{
  struct obj_data *tmp_obj;
  struct char_data *tmp_ch;

  if (obj->in_room != NOWHERE)
    GET_OBJ_WEIGHT(obj) += weight;
  else if ((tmp_ch = obj->carried_by))
  {
    obj_from_char(obj);
    GET_OBJ_WEIGHT(obj) += weight;
    obj_to_char(obj, tmp_ch, __FILE__, __LINE__);
  } else if ((tmp_obj = obj->in_obj)) {
    obj_from_obj(obj);
    GET_OBJ_WEIGHT(obj) += weight;
    obj_to_obj(obj, tmp_obj);
  } else {
    basic_mud_log("SYSERR: Unknown attempt to subtract weight from an object.");
  }
}


/* Artus> I think these should go.
void name_from_drinkcon(struct obj_data * obj)
{
  int i;
  char *new_name;

  for (i = 0; (*((obj->name) + i) != ' ') && (*((obj->name) + i) != '\0'); i++);

  if (*((obj->name) + i) == ' ') {
    new_name = str_dup((obj->name) + i + 1);
    if (GET_OBJ_RNUM(obj) < 0 || obj->name != obj_proto[GET_OBJ_RNUM(obj)].name)
      free(obj->name);
    obj->name = new_name;
  }
}

void name_to_drinkcon(struct obj_data * obj, int type)
{
  char *new_name;

  CREATE(new_name, char, strlen(obj->name) + strlen(drinknames[type]) + 2);
  sprintf(new_name, "%s %s", drinknames[type], obj->name);
  if (GET_OBJ_RNUM(obj) < 0 || obj->name != obj_proto[GET_OBJ_RNUM(obj)].name)
    free(obj->name);
  obj->name = new_name;
}
*/


ACMD(do_drink)
{
  struct obj_data *temp;
  struct affected_type af;
  int amount, weight;
  int on_ground = 0;

  one_argument(argument, arg);

  if (IS_NPC(ch))	/* Cannot use GET_COND() on mobs. */
    return;

  if (!*arg)
  {
    send_to_char("Drink from what?\r\n", ch);
    return;
  }
  if (!(temp = find_obj_list(ch, arg, ch->carrying)))
  {
    if (!(temp = find_obj_list(ch, arg, world[ch->in_room].contents)))
    {
      send_to_char("You can't find it!\r\n", ch);
      return;
    } else
      on_ground = 1;
  }
  if ((GET_OBJ_TYPE(temp) != ITEM_DRINKCON) &&
      (GET_OBJ_TYPE(temp) != ITEM_FOUNTAIN))
  {
    send_to_char("You can't drink from that!\r\n", ch);
    return;
  }
  if (on_ground && (GET_OBJ_TYPE(temp) == ITEM_DRINKCON))
  {
    send_to_char("You have to be holding that to drink from it.\r\n", ch);
    return;
  }
  if ((GET_COND(ch, DRUNK) > 10) && (GET_COND(ch, THIRST) > 0))
  {
    /* The pig is drunk */
    send_to_char("You can't seem to get close enough to your mouth.\r\n", ch);
    act("$n tries to drink but misses $s mouth!", TRUE, ch, 0, 0, TO_ROOM);
    return;
  }
  if ((GET_COND(ch, FULL) > 20) && (GET_COND(ch, THIRST) > 0))
  {
    send_to_char("Your stomach can't contain anymore!\r\n", ch);
    return;
  }
  if (!GET_OBJ_VAL(temp, 1))
  {
    send_to_char("It's empty.\r\n", ch);
    return;
  }
  if (subcmd == SCMD_DRINK)
  {
    sprintf(buf, "$n drinks %s from $p.", drinks[GET_OBJ_VAL(temp, 2)]);
    act(buf, TRUE, ch, temp, 0, TO_ROOM);
    sprintf(buf, "You drink the %s.\r\n", drinks[GET_OBJ_VAL(temp, 2)]);
    send_to_char(buf, ch);
    if (drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK] > 0)
      amount = (25 - GET_COND(ch, THIRST)) / drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK];
    else
      amount = number(3, 10);
  } else {
    act("$n sips from $p.", TRUE, ch, temp, 0, TO_ROOM);
    sprintf(buf, "It tastes like %s.\r\n", drinks[GET_OBJ_VAL(temp, 2)]);
    send_to_char(buf, ch);
    amount = 1;
  }
  amount = MIN(amount, GET_OBJ_VAL(temp, 1));
  /* You can't subtract more than the object weighs */
  weight = MIN(amount, GET_OBJ_WEIGHT(temp));
  weight_change_object(temp, -weight);	/* Subtract amount */
  gain_condition(ch, DRUNK,
	  (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK] * amount) / 4);
  gain_condition(ch, FULL,
	  (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][FULL] * amount) / 4);
  gain_condition(ch, THIRST,
	  (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][THIRST] * amount) / 4);
  if (GET_COND(ch, DRUNK) > 10)
    send_to_char("You feel drunk.\r\n", ch);
  if (GET_COND(ch, THIRST) > 20)
    send_to_char("You don't feel thirsty any more.\r\n", ch);
  if (GET_COND(ch, FULL) > 20)
    send_to_char("You are full.\r\n", ch);
  if (GET_OBJ_VAL(temp, 3))
  {	/* The shit was poisoned ! */
    send_to_char("Oops, it tasted rather strange!\r\n", ch);
    act("$n chokes and utters some strange sounds.", TRUE, ch, 0, 0, TO_ROOM);
    af.type = SPELL_POISON;
    af.duration = amount * 3;
    af.modifier = 0;
    af.location = APPLY_NONE;
    af.bitvector = AFF_POISON;
    affect_join(ch, &af, FALSE, FALSE, FALSE, FALSE);
  }
  /* empty the container, and no longer poison. */
  GET_OBJ_VAL(temp, 1) -= amount;
  if (!GET_OBJ_VAL(temp, 1))
  {	/* The last bit */
    GET_OBJ_VAL(temp, 2) = 0;
    GET_OBJ_VAL(temp, 3) = 0;
    /* Artus> I think these should go.
    name_from_drinkcon(temp); */
  }
  return;
}

void perform_eat(struct char_data *ch, struct obj_data *food, int subcmd)
{
  int amount = GET_OBJ_VAL(food, 0);

  if ((amount > 1) && subcmd != SCMD_EAT)
    amount = 1;
  if (subcmd == SCMD_EAT) 
  {
    act("You eat $p.", FALSE, ch, food, 0, TO_CHAR);
    act("$n eats $p.", TRUE, ch, food, 0, TO_ROOM);
  } else {
    act("You nibble a little bit of $p.", FALSE, ch, food, 0, TO_CHAR);
    act("$n tastes a little bit of $p.", TRUE, ch, food, 0, TO_ROOM);
  }
  if (amount > 0)
  {
    gain_condition(ch, FULL, amount);
    if (GET_COND(ch, FULL) > 20)
      send_to_char("You are full.\r\n", ch);
  } else
    send_to_char("That wasn't satisfying, at all.\r\n", ch);
  
  if (GET_OBJ_VAL(food, 3) && LR_FAIL(ch, LVL_IMMORT))
  {
    struct affected_type af;
    /* The shit was poisoned ! */
    send_to_char("Oops, that tasted rather strange!\r\n", ch);
    act("$n coughs and utters some strange sounds.", FALSE, ch, 0, 0, TO_ROOM);
    af.type = SPELL_POISON;
    af.duration = amount * 2;
    af.modifier = 0;
    af.location = APPLY_NONE;
    af.bitvector = AFF_POISON;
    affect_join(ch, &af, FALSE, FALSE, FALSE, FALSE);
  }
  if (subcmd == SCMD_EAT)
    extract_obj(food);
  else if (--GET_OBJ_VAL(food, 0) < 1)
  {
    send_to_char("There's nothing left now.\r\n", ch);
    extract_obj(food);
  }
}

ACMD(do_eat)
{
  struct obj_data *food;

  one_argument(argument, arg);
  if (IS_NPC(ch))	/* Cannot use GET_COND() on mobs. */
    return;
  if (!*arg)
  {
    send_to_char("Eat what?\r\n", ch);
    return;
  }
  if (!(food = find_obj_list(ch, arg, ch->carrying)))
  {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
    return;
  }
  if (subcmd == SCMD_TASTE && ((GET_OBJ_TYPE(food) == ITEM_DRINKCON) ||
			       (GET_OBJ_TYPE(food) == ITEM_FOUNTAIN)))
  {
    do_drink(ch, argument, 0, SCMD_SIP);
    return;
  }
  if ((GET_OBJ_TYPE(food) != ITEM_FOOD) && LR_FAIL(ch, LVL_GOD))
  {
    send_to_char("You can't eat THAT!\r\n", ch);
    return;
  }
  if (GET_COND(ch, FULL) > 20) 
  {/* Stomach full */
    send_to_char("You are too full to eat more!\r\n", ch);
    return;
  }
  perform_eat(ch, food, subcmd);
  return;
}

ACMD(do_pour)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  struct obj_data *from_obj = NULL, *to_obj = NULL;
  int amount;

  two_arguments(argument, arg1, arg2);
  if (subcmd == SCMD_POUR)
  {
    if (!*arg1)		/* No arguments */
    {
      send_to_char("From what do you want to pour?\r\n", ch);
      return;
    }
    if (!(from_obj = find_obj_list(ch, arg1, ch->carrying)))
    {
      send_to_char("You can't find it!\r\n", ch);
      return;
    }
    if (GET_OBJ_TYPE(from_obj) != ITEM_DRINKCON) {
      send_to_char("You can't pour from that!\r\n", ch);
      return;
    }
  }
  if (subcmd == SCMD_FILL)
  {
    if (!*arg1)
    {		/* no arguments */
      send_to_char("What do you want to fill?  And what are you filling it from?\r\n", ch);
      return;
    }
    if (!(to_obj = find_obj_list(ch, arg1, ch->carrying)))
    {
      send_to_char("You can't find it!\r\n", ch);
      return;
    }
    if (GET_OBJ_TYPE(to_obj) != ITEM_DRINKCON)
    {
      act("You can't fill $p!", FALSE, ch, to_obj, 0, TO_CHAR);
      return;
    }
    if (!*arg2)
    {		/* no 2nd argument */
      act("What do you want to fill $p from?", FALSE, ch, to_obj, 0, TO_CHAR);
      return;
    }
    if (!(from_obj = find_obj_list(ch, arg2, world[ch->in_room].contents)))
    {
      sprintf(buf, "There doesn't seem to be %s %s here.\r\n", AN(arg2), arg2);
      send_to_char(buf, ch);
      return;
    }
    if (GET_OBJ_TYPE(from_obj) != ITEM_FOUNTAIN)
    {
      act("You can't fill something from $p.", FALSE, ch, from_obj, 0, TO_CHAR);
      return;
    }
  }
  if (GET_OBJ_VAL(from_obj, 1) == 0)
  {
    act("The $p is empty.", FALSE, ch, from_obj, 0, TO_CHAR);
    return;
  }
  if (subcmd == SCMD_POUR)
  {	/* pour */
    if (!*arg2)
    {
      send_to_char("Where do you want it?  Out or in what?\r\n", ch);
      return;
    }
    if (!str_cmp(arg2, "out"))
    {
      act("$n empties $p.", TRUE, ch, from_obj, 0, TO_ROOM);
      act("You empty $p.", FALSE, ch, from_obj, 0, TO_CHAR);
      weight_change_object(from_obj, -GET_OBJ_VAL(from_obj, 1)); /* Empty */
      GET_OBJ_VAL(from_obj, 1) = 0;
      GET_OBJ_VAL(from_obj, 2) = 0;
      GET_OBJ_VAL(from_obj, 3) = 0;
      /* Artus> I think these should go.
      name_from_drinkcon(from_obj); */
      return;
    }
    if (!(to_obj = find_obj_list(ch, arg2, ch->carrying)))
    {
      send_to_char("You can't find it!\r\n", ch);
      return;
    }
    if ((GET_OBJ_TYPE(to_obj) != ITEM_DRINKCON) &&
	(GET_OBJ_TYPE(to_obj) != ITEM_FOUNTAIN))
    {
      send_to_char("You can't pour anything into that.\r\n", ch);
      return;
    }
  }
  if (to_obj == from_obj)
  {
    send_to_char("A most unproductive effort.\r\n", ch);
    return;
  }
  if ((GET_OBJ_VAL(to_obj, 1) != 0) &&
      (GET_OBJ_VAL(to_obj, 2) != GET_OBJ_VAL(from_obj, 2)))
  {
    send_to_char("There is already another liquid in it!\r\n", ch);
    return;
  }
  if (!(GET_OBJ_VAL(to_obj, 1) < GET_OBJ_VAL(to_obj, 0)))
  {
    send_to_char("There is no room for more.\r\n", ch);
    return;
  }
  if (subcmd == SCMD_POUR)
  {
    sprintf(buf, "You pour the %s into the %s.",
	    drinks[GET_OBJ_VAL(from_obj, 2)], arg2);
    send_to_char(buf, ch);
  }
  if (subcmd == SCMD_FILL)
  {
    act("You gently fill $p from $P.", FALSE, ch, to_obj, from_obj, TO_CHAR);
    act("$n gently fills $p from $P.", TRUE, ch, to_obj, from_obj, TO_ROOM);
  }
  /* New alias */
  /* Artus> I think these should go.
  if (GET_OBJ_VAL(to_obj, 1) == 0)
    name_to_drinkcon(to_obj, GET_OBJ_VAL(from_obj, 2)); */

  /* First same type liq. */
  GET_OBJ_VAL(to_obj, 2) = GET_OBJ_VAL(from_obj, 2);

  /* Then how much to pour */
  GET_OBJ_VAL(from_obj, 1) -= (amount =
			 (GET_OBJ_VAL(to_obj, 0) - GET_OBJ_VAL(to_obj, 1)));

  GET_OBJ_VAL(to_obj, 1) = GET_OBJ_VAL(to_obj, 0);

  if (GET_OBJ_VAL(from_obj, 1) < 0)
  {	/* There was too little */
    GET_OBJ_VAL(to_obj, 1) += GET_OBJ_VAL(from_obj, 1);
    amount += GET_OBJ_VAL(from_obj, 1);
    GET_OBJ_VAL(from_obj, 1) = 0;
    GET_OBJ_VAL(from_obj, 2) = 0;
    GET_OBJ_VAL(from_obj, 3) = 0;
    /* Artus> I think these should go.
    name_from_drinkcon(from_obj); */
  }
  /* Then the poison boogie */
  GET_OBJ_VAL(to_obj, 3) =
    (GET_OBJ_VAL(to_obj, 3) || GET_OBJ_VAL(from_obj, 3));

  /* And the weight boogie */
  weight_change_object(from_obj, -amount);
  weight_change_object(to_obj, amount);	/* Add weight */
}

void wear_message(struct char_data * ch, struct obj_data * obj, int where)
{
  const char *wear_messages[][2] =
  {
    {"$n lights $p and holds it.",
    "You light $p and hold it."},

    {"$n slides $p on to $s finger.",
    "You slide $p on to your finger."},

    {"$n slides $p on to $s finger.",
    "You slide $p on to your finger."},

    {"$n wears $p around $s neck.",
    "You wear $p around your neck."},

    {"$n wears $p around $s neck.",
    "You wear $p around your neck."},

    {"$n wears $p on $s body.",
    "You wear $p on your body."},

    {"$n wears $p on $s head.",
    "You wear $p on your head."},

    {"$n puts $p on $s legs.",
    "You put $p on your legs."},

    {"$n wears $p on $s feet.",
    "You wear $p on your feet."},

    {"$n puts $p on $s hands.",
    "You put $p on your hands."},

    {"$n wears $p on $s arms.",
    "You wear $p on your arms."},

    {"$n straps $p around $s arm as a shield.",
    "You start to use $p as a shield."},

    {"$n wears $p about $s body.",
    "You wear $p around your body."},

    {"$n wears $p around $s waist.",
    "You wear $p around your waist."},

    {"$n puts $p on around $s right wrist.",
    "You put $p on around your right wrist."},

    {"$n puts $p on around $s left wrist.",
    "You put $p on around your left wrist."},

    {"$n wields $p.",
    "You wield $p."},

    {"$n grabs $p.",
    "You grab $p."},

    {"$n slides $p on to $s finger.",
    "You slide $p on to your finger."},

    {"$n slides $p on to $s finger.",
    "You slide $p on to your finger."},

    {"$n slides $p on to $s finger.",
    "You slide $p on to your finger."},

    {"$n places $p over $s eyes.",
    "You place $p over your eyes."},

    {"$n inserts $p into $s ear.",
    "You insert $p into your ear."},

    {"$n inserts $p into $s ear.",
    "You insert $p into your ear."},

    {"$n wears $p around $s ankle.",
    "You wear $p around your ankle."},

    {"$n wears $p around $s ankle.",
    "You wear $p around your ankle."}
  };
  act(wear_messages[where][0], TRUE, ch, obj, 0, TO_ROOM);
  act(wear_messages[where][1], FALSE, ch, obj, 0, TO_CHAR);
}

// Returns 0 if can use,
//         1 if cant use due to level or class
int invalid_level(struct char_data *ch, struct obj_data *object, bool display)
{
  int lr=0, questfound = 0;
  char buf[80];
  int invalid_class(struct char_data *ch, struct obj_data *obj);
 
  if (!LR_FAIL(ch, LVL_IMPL))
    return 0;

  // Quest eq checks
  if (OBJ_FLAGGED(object, ITEM_QEQ))
  {
    for (int i = 0; i < MAX_QUEST_ITEMS; i++)
      if (GET_QUEST_ITEM(ch,i) == GET_OBJ_VNUM(object))
      {
        questfound = GET_QUEST_ITEM_NUMB(ch,i);
	break;
      }
    if (questfound < 1)
    {
      if (display) 
	send_to_char("You only wish you could use this item!\r\n", ch);
      return 1;
    }
    for (int i = 0; i < NUM_WEARS; i++)
    {
      if (!GET_EQ(ch, i))
	continue;
      if (GET_OBJ_VNUM(GET_EQ(ch, i)) == GET_OBJ_VNUM(object))
	questfound--;
    }
    if (questfound < 1)
    {
      if (display)
	send_to_char("You cannot use any more of this item!\r\n", ch);
      return 1;
    }
  }

  lr = GET_OBJ_LR(object);
  // Artus> Only deduct lr if they're available to lower remorts..
  if (lr <= GET_MAX_LVL(ch))
  {
    if (GET_CLASS(ch) == CLASS_MASTER)
    {
      if (!OBJ_FLAGGED(object, ITEM_ANTI_WARRIOR) ||
	 !OBJ_FLAGGED(object, ITEM_ANTI_THIEF) ||
	 !OBJ_FLAGGED(object, ITEM_ANTI_CLERIC) ||
	 !OBJ_FLAGGED(object, ITEM_ANTI_MAGIC_USER))
	lr -= 20;
      else if (!OBJ_FLAGGED(object, ITEM_ANTI_NIGHTBLADE) ||
	       !OBJ_FLAGGED(object, ITEM_ANTI_BATTLEMAGE) ||
	       !OBJ_FLAGGED(object, ITEM_ANTI_SPELLSWORD) ||
	       !OBJ_FLAGGED(object, ITEM_ANTI_PALADIN) ||
	       !OBJ_FLAGGED(object, ITEM_ANTI_PRIEST) ||
	       !OBJ_FLAGGED(object, ITEM_ANTI_DRUID))
	lr -= 10;
    } else if ((GET_CLASS(ch) > CLASS_WARRIOR) && 
	(!OBJ_FLAGGED(object, ITEM_ANTI_WARRIOR) ||
	 !OBJ_FLAGGED(object, ITEM_ANTI_THIEF) ||
	 !OBJ_FLAGGED(object, ITEM_ANTI_CLERIC) ||
	 !OBJ_FLAGGED(object, ITEM_ANTI_MAGIC_USER)))
      lr -= 10;
  }
  
  if (LR_FAIL(ch, lr))
  {
    if (display) {
      if (lr < GET_OBJ_LR(object))
	sprintf(buf, "You are not knowledgable enough to use this item.\r\n");
      else
        sprintf(buf,"You can't figure out how to use this item?!?\r\n");
      act(buf, FALSE,ch,object, 0, TO_CHAR);
    }
    return 1;
  }

  if (invalid_class(ch, object))
  {
    if (display)
    {
      sprintf(buf, "%ss like yourself cannot use this item.\r\n", pc_class_types[(int)GET_CLASS(ch)]);
      send_to_char(buf, ch);
    }
    return 1;
  }
  return 0;
}     

// Artus> Apply items spells to a char.
void obj_wear_spells(struct char_data *ch, struct obj_data *obj)
{
  struct affected_type *af, *next;
  bool spellsused[3];
  int i = 0;
  
  if (!(ch) || !(obj))
    return;

  if (GET_OBJ_TYPE(obj) != ITEM_MAGIC_EQ)
    return;

  /* lower the charge */
  if (GET_OBJ_VAL(obj, 3) > 0)
    GET_OBJ_VAL(obj, 3)--;

/*  Artus> This is gay.
    // DM - Let them use the spell, iff they have the stats for it, and know it 
    for (int i = 0; i < 3; i ++)
    {
      if (GET_OBJ_VAL(obj, i) > 0)
      {
 *        if (has_stats_for_skill(ch, GET_OBJ_VAL(obj, i), FALSE) 
 *                        && GET_SKILL(ch, GET_OBJ_VAL(obj, i)) > 0)
 *        {  * /
          call_magic(ch, ch, NULL, GET_OBJ_VAL(obj, i), 
              / *DM - hmm why 2? 2 * / GET_LEVEL(ch), CAST_MAGIC_OBJ);
          spellsused[i] = TRUE;
//        }
      }
    } */
  for (i = 0; i < 3; i++)
  {
    spellsused[i] = FALSE;
    if (GET_OBJ_VAL(obj, i) > 0)
    {
      call_magic(ch, ch, NULL, GET_OBJ_VAL(obj, i), GET_LEVEL(ch),
		 CAST_MAGIC_OBJ);
      spellsused[i] = TRUE;
    }
  }

  for (af = ch->affected; af; af = next)
  {
    next = af->next;
    if (((spellsused[0] && af->type == GET_OBJ_VAL(obj, 0)) ||
	 (spellsused[1] && af->type == GET_OBJ_VAL(obj, 1)) ||
	 (spellsused[2] && af->type == GET_OBJ_VAL(obj, 2))) &&
	(af->duration != CLASS_ABILITY))
      af->duration = CLASS_ITEM;
  }

    /* if its out of power get rid of it */
  if (GET_OBJ_VAL(obj, 3) == 0)
  {
    act("$p disappears as its power deminishes.", FALSE, ch, obj, 0, TO_CHAR);
    extract_obj(obj);
  }
}

void perform_wear(struct char_data * ch, struct obj_data * obj, int where)
{
  bool dual_wield = FALSE;
  /*
   * ITEM_WEAR_TAKE is used for objects that do not require special bits
   * to be put into that position (e.g. you can hold any object, not just
   * an object with a HOLD bit.)
   */
  const int wear_bitvectors[] = 
  {
    ITEM_WEAR_TAKE, 
    ITEM_WEAR_FINGER, 
    ITEM_WEAR_FINGER, 
    ITEM_WEAR_NECK, 
    ITEM_WEAR_NECK, 
    ITEM_WEAR_BODY, 
    ITEM_WEAR_HEAD, 
    ITEM_WEAR_LEGS, 
    ITEM_WEAR_FEET, 
    ITEM_WEAR_HANDS, 
    ITEM_WEAR_ARMS, 
    ITEM_WEAR_SHIELD, 
    ITEM_WEAR_ABOUT, 
    ITEM_WEAR_WAIST, 
    ITEM_WEAR_WRIST, 
    ITEM_WEAR_WRIST, 
    ITEM_WEAR_WIELD, 
    ITEM_WEAR_TAKE,
    ITEM_WEAR_FINGER, 
    ITEM_WEAR_FINGER, 
    ITEM_WEAR_FINGER, 
    ITEM_WEAR_EYE, 
    ITEM_WEAR_EAR, 
    ITEM_WEAR_EAR, 
    ITEM_WEAR_ANKLE, 
    ITEM_WEAR_ANKLE
  };

  const char *pos_unavailable[] =
  {
    "Examining yourself, you realise you can't use a light.\r\n",
    "Examining yourself, you realise you can't wear anything on your fingers.\r\n",
    "You can't wear anything else on your fingers.\r\n",   
    "Examining yourself, you realise you can't wear anything around your neck.\r\n",
    "You can't wear anything else around your neck.\r\n",
    "Examining yourself, you realise you can't wear anything on your body.\r\n",
    "Examining yourself, you realise you can't wear anything on your head.\r\n",
    "Examining yourself, you realise you can't wear anything on your legs.\r\n",
    "Examining yourself, you realise you can't wear anything on your feet.\r\n",
    "Examining yourself, you realise you can't wear anything on your hands.\r\n",
    "Examining yourself, you realise you can't wear anything on your arms.\r\n",
    "Examining yourself, you realise you can't use a shield.\r\n",
    "Examining yourself, you realise you can't wear anything about your body.\r\n",
    "Examining yourself, you realise you can't wear anything around your waist.\r\n",
    "Examining yourself, you realise you can't wear anything on your wrists.\r\n",
    "You can't wear anything else on your wrists.\r\n",
    "Examining yourself, you realise you can't wield a weapon.\r\n",
    "Examining yourself, you realise you can't hold anything.\r\n",
    "You can't wear anything else on your fingers.\r\n",  
    "You can't wear anything else on your fingers.\r\n", 
    "You can't wear anything else on your fingers.\r\n",
    "Examining yourself, you realise you can't wear anything on your eyes.\r\n",
    "Examining yourself, you realise you can't wear anything on your ears.\r\n",
    "You can't wear anything else on your ears.\r\n",      // NOT USED
    "Examining yourself, you realise you can't wear anything around your ankles.\r\n",
    "You can't wear anything else around your ankles.\r\n" // NOT USED
  };


  const char *already_wearing[] =
  {
    "You're already using a light.\r\n",
    "You can't wear anything else on your fingers.\r\n",   // NOT USED
    "You can't wear anything else on your fingers.\r\n",   // NOT USED
    "You can't wear anything else around your neck.\r\n",
    "You can't wear anything else around your neck.\r\n",
    "You're already wearing something on your body.\r\n",
    "You're already wearing something on your head.\r\n",
    "You're already wearing something on your legs.\r\n",
    "You're already wearing something on your feet.\r\n",
    "You're already wearing something on your hands.\r\n",
    "You're already wearing something on your arms.\r\n",
    "You're already using a shield.\r\n",
    "You're already wearing something about your body.\r\n",
    "You already have something around your waist.\r\n",
    "You can't wear anything on your wrists.\r\n",
    "You can't wear anything else on your wrists.\r\n",
    "You're already wielding a weapon.\r\n",
    "You're already holding something.\r\n",
    "You can't wear anything else on your fingers.\r\n",
    "You can't wear anything else on your fingers.\r\n", 
    "You can't wear anything else on your fingers.\r\n",  
    "You're already wearing something on your eyes.\r\n",
    "You can't wear anything on your ears.\r\n",         
    "You're already wearing something on both your ears.\r\n", 
    "You can't wear anything around your ankles.\r\n",    
    "You can't wear anything else around your ankles.\r\n" 
  };

  /* first, make sure that the wear position is valid. */
  if (!CAN_WEAR(obj, wear_bitvectors[where]))
  {
    act("You can't wear $p there.", FALSE, ch, obj, 0, TO_CHAR);
    return;
  }

  // Find first available finger
  if (where == WEAR_FINGER_1) 
  {
    if (GET_EQ(ch, where))
      where = WEAR_FINGER_2;
    if (GET_EQ(ch, where)) 
      where = WEAR_FINGER_3;
    if (GET_EQ(ch, where)) 
      where = WEAR_FINGER_4;
    if (GET_EQ(ch, where)) 
      where = WEAR_FINGER_5;
  }

  /* for neck, ear, ankle and wrist, try pos 2 if pos 1 is already full */
  if ((where == WEAR_EAR_1) || (where == WEAR_NECK_1) || 
                  (where == WEAR_WRIST_R) || (where == WEAR_ANKLE_1))
    if (GET_EQ(ch, where))
      where++;

  // Ambidexterity - can wield 2 weapons, but not also a shield ...
  if (where == WEAR_WIELD && (GET_EQ(ch, WEAR_WIELD)) && IS_DUAL_CAPABLE(ch))
  {
    // wielding in 2nd wield position - shield check
    if (GET_EQ(ch, WEAR_SHIELD)) 
    {
      send_to_char("Your shield is in the way.\r\n", ch);
      return;
    }
    if (GET_EQ(ch, WEAR_HOLD))
    {
      if (CAN_WEAR(GET_EQ(ch, WEAR_HOLD), ITEM_WEAR_WIELD))
      {
	send_to_char("You're already wielding two weapons!\r\n", ch);
	return;
      }
      sprintf(buf, "You'll need to stop holding &5%s&n first.\r\n", 
	      GET_EQ(ch, WEAR_HOLD)->name);
      send_to_char(buf, ch);
      return;
    }
    where = WEAR_HOLD;
    dual_wield = TRUE;
  }

  if (where == WEAR_SHIELD && IS_DUAL_WIELDING(ch)) 
  {
    send_to_char("Your hands are tied up with weapons.\r\n", ch);
    return;
  }
  
  if (where == WEAR_HOLD && IS_DUAL_WIELDING(ch))
  {
    send_to_char("You try to grow a third arm, but fail. Try removing a weapon, first.\r\n", ch);
    return;
  }

  // Now check if the position is race restricted, or class restricted (fingers)
  if (!CAN_WEAR_POS(ch, obj, wear_bitvectors[where], where))
  {
    switch (GET_OBJ_TYPE(obj))
    {
      case ITEM_ENVIRON:
      case ITEM_GRAV1:
      case ITEM_SUBZERO:
      case ITEM_GRAV3:
      case ITEM_VACSUIT:
      case ITEM_RESPIRATE:
      case ITEM_HEATRES:
      case ITEM_COLD:
      case ITEM_HEATPROOF:
      case ITEM_STASIS:
      case ITEM_BREATHER:
	break;
      default:
	if (!OBJ_FLAGGED(obj, ITEM_QEQ))
	{
	  send_to_char(pos_unavailable[where], ch);
	  return;
	}
    }
  }

  if (GET_EQ(ch, where)) 
  {
    if (dual_wield)
      send_to_char(already_wearing[WEAR_WIELD], ch);
    else
      send_to_char(already_wearing[where], ch);
    return;
  }

  if (invalid_level(ch, obj, TRUE))
    return;
  
  // DM - quest item check
  if (!quest_obj_ok(ch, obj))
  {
    act("You can't use $p.", FALSE, ch, obj, 0, TO_CHAR);
    return;
  }
      
  if (!wear_otrigger(obj, ch, where)) // where not used in wear_trigger ..
    return;

  if (dual_wield)
    wear_message(ch, obj, WEAR_WIELD);
  else
    wear_message(ch, obj, where);

  obj_from_char(obj);

  if (!equip_char(ch, obj, where, TRUE))
    return;
 
/* 
 * modification to add spells to objects. 25/12/95 Vader
 * object type ITEM_MAGIC_EQ flagged ITEM_MAGIC will contain an affection
 * in VAL[0]
 * modified 17/3/96: VAL[1] and VAL[2] now have spells aswell
 * VAL[3] is the charge of the item -1 is unlimited
 *
 * 7/2/2001: Neatened up, and checked if player has stats for skill.. DM
 * 9/4/2001: checked if player knows spell, fixed typo checking obj values
 */
  if (eq_pos_ok(ch, where) || OBJ_FLAGGED(obj, ITEM_QEQ))
    obj_wear_spells(ch, obj);
}

int find_eq_pos(struct char_data * ch, struct obj_data * obj, char *arg)
{
  int where = -1;

  /* \r to prevent explicit wearing. Don't use \n, it's end-of-array marker. */
  const char *keywords[] =
  {
    "\r!RESERVED!", // light
    "finger",
    "\r!RESERVED!", // finger 2
    "neck",
    "\r!RESERVED!", // neck 2
    "body",
    "head",
    "legs",
    "feet",
    "hands",
    "arms",
    "shield",
    "about",
    "waist",
    "wrist",
    "\r!RESERVED!", // wrist 2
    "\r!RESERVED!", // wield
    "\r!RESERVED!", // hold
    "\r!RESERVED!", // finger 3
    "\r!RESERVED!", // finger 4
    "\r!RESERVED!", // finger 5
    "eyes", 
    "ear",
    "\r!RESERVED!", // ear 2 
    "ankle",
    "\r!RESERVED!", // ankle 2
    "\n"
  };

  if ((obj) && (!arg || !*arg))
  {
    if (CAN_WEAR(obj, ITEM_WEAR_FINGER))      where = WEAR_FINGER_1;
    if (CAN_WEAR(obj, ITEM_WEAR_NECK))        where = WEAR_NECK_1;
    if (CAN_WEAR(obj, ITEM_WEAR_EAR))         where = WEAR_EAR_1;
    if (CAN_WEAR(obj, ITEM_WEAR_BODY))        where = WEAR_BODY;
    if (CAN_WEAR(obj, ITEM_WEAR_HEAD))        where = WEAR_HEAD;
    if (CAN_WEAR(obj, ITEM_WEAR_LEGS))        where = WEAR_LEGS;
    if (CAN_WEAR(obj, ITEM_WEAR_ANKLE))       where = WEAR_ANKLE_1;
    if (CAN_WEAR(obj, ITEM_WEAR_FEET))        where = WEAR_FEET;
    if (CAN_WEAR(obj, ITEM_WEAR_HANDS))       where = WEAR_HANDS;
    if (CAN_WEAR(obj, ITEM_WEAR_ARMS))        where = WEAR_ARMS;
    if (CAN_WEAR(obj, ITEM_WEAR_SHIELD))      where = WEAR_SHIELD;
    if (CAN_WEAR(obj, ITEM_WEAR_ABOUT))       where = WEAR_ABOUT;
    if (CAN_WEAR(obj, ITEM_WEAR_WAIST))       where = WEAR_WAIST;
    if (CAN_WEAR(obj, ITEM_WEAR_WRIST))       where = WEAR_WRIST_R;
    if (CAN_WEAR(obj, ITEM_WEAR_EYE))         where = WEAR_EYES;
  } else if (arg) {
    //if ((where = search_block(arg, keywords, FALSE)) < 0) {
    if (((where = search_block(arg, keywords, FALSE)) < 0) || (*arg=='!')) {
      sprintf(buf, "'%s'?  What part of your body is THAT?\r\n", arg);
      send_to_char(buf, ch);
      return -1;
    }
  }
  return (where);
}

ACMD(do_wear)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  struct obj_data *obj, *next_obj;
  int where, dotmode, items_worn = 0;

  two_arguments(argument, arg1, arg2);

  if (!*arg1)
  {
    send_to_char("Wear what?\r\n", ch);
    return;
  }
  dotmode = find_all_dots(arg1);

  if (*arg2 && (dotmode != FIND_INDIV))
  {
    send_to_char("You can't specify the same body location for more than one item!\r\n", ch);
    return;
  }
  if (dotmode == FIND_ALL)
  {
    for (obj = ch->carrying; obj; obj = next_obj)
    {
      next_obj = obj->next_content;
      if (CAN_SEE_OBJ(ch, obj) && (where = find_eq_pos(ch, obj, 0)) >= 0)
      {
	items_worn++;
	perform_wear(ch, obj, where);
      }
    }
    if (!items_worn)
      send_to_char("You don't seem to have anything wearable.\r\n", ch);
  } else if (dotmode == FIND_ALLDOT) {
    if (!*arg1) 
    {
      send_to_char("Wear all of what?\r\n", ch);
      return;
    }
    if (!(obj = find_obj_list(ch, arg1, ch->carrying))) 
    {
      sprintf(buf, "You don't seem to have any %ss.\r\n", arg1);
      send_to_char(buf, ch);
    } else {
      while (obj) 
      {
	next_obj = find_obj_list(ch, arg1, obj->next_content);
	if ((where = find_eq_pos(ch, obj, 0)) >= 0)
	  perform_wear(ch, obj, where);
	else
	  act("You can't wear $p.", FALSE, ch, obj, 0, TO_CHAR);
	obj = next_obj;
      }
    }
  } else {
    if (!(obj = find_obj_list(ch, arg1, ch->carrying)))
    {
      sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg1), arg1);
      send_to_char(buf, ch);
    } else { // Artus> Removed level check. This is handled by peform_wear.
      if ((where = find_eq_pos(ch, obj, arg2)) >= 0)
	perform_wear(ch, obj, where);
      else if (!*arg2)
	act("You can't wear $p.", FALSE, ch, obj, 0, TO_CHAR);
    }
  }
}



ACMD(do_wield)
{
  struct obj_data *obj;

  one_argument(argument, arg);
  if (!*arg)
    send_to_char("Wield what?\r\n", ch);
  else if (!(obj = find_obj_list(ch, arg, ch->carrying)))
  {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
  } else {
    if (!CAN_WEAR(obj, ITEM_WEAR_WIELD))
      send_to_char("You can't wield that.\r\n", ch);
    // DM - wand/staff restriction ...
    else if (!(IS_CLERIC(ch) || IS_MAGIC_USER(ch)) && 
	GET_OBJ_TYPE(obj) == ITEM_STAFF || GET_OBJ_TYPE(obj) == ITEM_WAND)
      send_to_char("You do not know how to use this kind of item.\r\n", ch);
    else if (GET_OBJ_WEIGHT(obj)>str_app[STRENGTH_AFF_APPLY_INDEX(ch)].wield_w)
      send_to_char("It's too heavy for you to use.\r\n", ch);
    // DM, 11/99 - changed to obj level (was based on amount of dam it did)
    else if (!invalid_level(ch, obj, TRUE))
      perform_wear(ch, obj, WEAR_WIELD);  
  }
}

ACMD(do_grab)
{
  struct obj_data *obj;

  one_argument(argument, arg);
  if (!*arg)
    send_to_char("Hold what?\r\n", ch);
  else if (!(obj = find_obj_list(ch, arg, ch->carrying)))
  {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
  } else {
    if (GET_OBJ_TYPE(obj) == ITEM_LIGHT)
      perform_wear(ch, obj, WEAR_LIGHT);
    else {
      if (!CAN_WEAR(obj, ITEM_WEAR_HOLD) && (GET_OBJ_TYPE(obj) != ITEM_WAND) &&
                    (GET_OBJ_TYPE(obj) != ITEM_STAFF) &&
                    (GET_OBJ_TYPE(obj) != ITEM_SCROLL) &&
                    (GET_OBJ_TYPE(obj) != ITEM_POTION))
	send_to_char("You can't hold that.\r\n", ch);
      else
	perform_wear(ch, obj, WEAR_HOLD);
    }
  }
}

void perform_remove(struct char_data * ch, int pos)
{
  struct obj_data *obj;
  struct affected_type *af, *next;
  extern const char *spell_wear_off_msg[];
  bool was_dual = FALSE, apply = false;
 
  if (!(obj = ch->equipment[pos])) 
  {
    basic_mud_log("Error in perform_remove: bad pos passed.");
    return;
  } 
  if (IS_OBJ_STAT(obj, ITEM_NODROP) && LR_FAIL(ch, LVL_ANGEL)) 
  {
    act("You can't remove $p, it must be CURSED!", FALSE, ch, obj, 0, TO_CHAR);
    return;
  } 
  if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch)) 
  {
    act("$p: you can't carry that many items!", FALSE, ch, obj, 0, TO_CHAR);
    return;
  }
  
  if (!remove_otrigger(obj, ch))
    return;

  // Artus> Handle Dual Wield. (Better)
  if (pos == WEAR_WIELD && IS_DUAL_WIELDING(ch))
    was_dual = TRUE;

  if (eq_pos_ok(ch, pos) || OBJ_FLAGGED(obj, ITEM_QEQ))
    apply = true;

  obj_to_char(unequip_char(ch, pos, TRUE), ch, __FILE__, __LINE__);
  act("You stop using $p.", FALSE, ch, obj, 0, TO_CHAR);
  act("$n stops using $p.", TRUE, ch, obj, 0, TO_ROOM);
  if ((obj->obj_flags.type_flag >= BASE_PROTECT_GEAR) &&
      (obj->obj_flags.type_flag < (BASE_PROTECT_GEAR + MAX_PROTECT_GEAR)))
    check_environment_effect(ch);

  if (was_dual == TRUE)
  {
    GET_EQ(ch, WEAR_HOLD)->worn_on = WEAR_WIELD;
    GET_EQ(ch, WEAR_WIELD) = GET_EQ(ch, WEAR_HOLD);
    GET_EQ(ch, WEAR_HOLD) = NULL;
  }
 
  /* do a check for lightning and fire shields - DM */
  if (pos == WEAR_SHIELD) 
  {
    if (affected_by_spell(ch, SPELL_LIGHT_SHIELD)) 
    {
      for (af = ch->affected; af; af = next) 
      {
	next = af->next;
	if ((af->type == SPELL_LIGHT_SHIELD) && (af->duration > 0)) 
	{
	  send_to_char("The lightning upon your shield fades as you stop using it.\r\n", ch);
	  affect_remove(ch,af);
	}
      }
    } // SPELL_LIGHT_SHIELD
    if (affected_by_spell(ch, SPELL_FIRE_SHIELD)) 
    {
      for (af = ch->affected; af; af = next) 
      {
	next = af->next;
	if ((af->type == SPELL_FIRE_SHIELD) && (af->duration > 0)) 
	{
	  send_to_char("The flaming fire of your shield disappears as you stop using it.\r\n", ch);
	  affect_remove(ch,af);
	}
      }
    } // SPELL_FIRE_SHIELD
  } // WEAR_SHIELD

  /* modifications to remove magic eq AFF flags when eq is remove - Vader */
  if (GET_OBJ_TYPE(obj) == ITEM_MAGIC_EQ && apply)
  {
    for(af = ch->affected; af; af = next) 
    {
      next = af->next;
      if (((af->type == GET_OBJ_VAL(obj,0)) ||
	   (af->type == GET_OBJ_VAL(obj,1)) ||
	   (af->type == GET_OBJ_VAL(obj,2))) &&
	  (af->duration == CLASS_ITEM))
      {
	if(!af->next || (af->next->type != af->type) ||
	   (af->next->duration > 0))
	  if(*spell_wear_off_msg[af->type]) 
	  {
	    send_to_char("&r", ch);
	    send_to_char(spell_wear_off_msg[af->type], ch);
	    send_to_char("&n\r\n",ch);
	  }
	affect_remove(ch,af);
      } // Char affect matched obj affect.
    } // Character Affect Loop
  } // ITEM_MAGIC_EQ
}  

ACMD(do_remove)
{
  int i, dotmode, found;

  one_argument(argument, arg);
  if (!*arg)
  {
    send_to_char("Remove what?\r\n", ch);
    return;
  }
  dotmode = find_all_dots(arg);
  if (dotmode == FIND_ALL)
  {
    found = 0;
    for (i = NUM_WEARS-1; i >= 0; i--) // Artus> Loop down, Held before Wielded.
      if (GET_EQ(ch, i)) 
      {
	perform_remove(ch, i);
	found = 1;
      }
    if (!found)
      send_to_char("You're not using anything.\r\n", ch);
  } else if (dotmode == FIND_ALLDOT) {
    if (!*arg)
      send_to_char("Remove all of what?\r\n", ch);
    else
    {
      found = 0;
      for (i = 0; i < NUM_WEARS; i++)
	if (GET_EQ(ch, i) && CAN_SEE_OBJ(ch, GET_EQ(ch, i)) &&
	    isname(arg, GET_EQ(ch, i)->name))
	{
	  perform_remove(ch, i);
	  // Artus> Run through again if dual wielding.
	  if (IS_DUAL_WIELDING(ch) && (i == WEAR_WIELD)) i--;
	  found = 1;
	}
      if (!found)
      {
	sprintf(buf, "You don't seem to be using any %ss.\r\n", arg);
	send_to_char(buf, ch);
      }
    }
  } else {
    /* Returns object pointer but we don't need it, just true/false. */
    if ((i = find_obj_eqpos(ch, arg)) < 0)
    {
      sprintf(buf, "You don't seem to be using %s %s.\r\n", AN(arg), arg);
      send_to_char(buf, ch);
    } else
      perform_remove(ch, i);
  }
}
@


1.55
log
@Artus> Mostly looks like indent changes.. And a modification to determine
       whether we're moving, or fleeing.
@
text
@d82 134
@


1.54
log
@Artus> Junk all at LVL_CHAMP instead of LVL_IMMORT.
@
text
@d93 2
a94 1
  const char *pship_messages[][3] = { // Room, Zone-Haven, Zone-Danger
a111 1

a158 1

a214 1

a229 1

a237 1
    
d259 2
a260 1
int isPlayerFriend(struct char_data *ch, long idnumOwner) {
d266 3
a268 3
  if ((owner = get_player_by_id(idnumOwner))) {
    for (i = 0; i < MAX_FRIENDS; i++) {
      if (GET_FRIEND(owner, i) == GET_IDNUM(ch)) {
a269 4
      }
    } 
  }

d271 3
a273 3
  if (load_char(get_name_by_id(idnumOwner), &tmp_store)) {
    for (i = 0; i < MAX_FRIENDS; i++) {
      if (tmp_store.player_specials_primalsaved.friends[i] == GET_IDNUM(ch)) {
a274 4
      }
    }
  } 

d279 2
a280 2
ACMD(do_repair) {

d284 2
a285 2

  if (!*buf) {
a288 1

a293 1

d295 2
a296 1
	(GET_OBJ_TYPE(o) == ITEM_ARMOR  && !GET_SKILL(ch, SKILL_ARMOURCRAFT))) {
d301 2
a302 2

  if (GET_OBJ_TYPE(o) != ITEM_WEAPON && GET_OBJ_TYPE(o) != ITEM_ARMOR) {
a305 1

d307 3
a309 2
  if (GET_OBJ_MAX_DAMAGE(o) == -1 ||  
                  GET_OBJ_DAMAGE(o) == GET_OBJ_MAX_DAMAGE(o)) {
a312 1

a314 1

a317 1

a327 1

a329 1

a331 1

a332 1

d336 2
a337 2

  if (number(1, 100) > skillAmt) {
d340 1
a340 1
                    FALSE, ch, obj, 0, TO_ROOM);
a347 1

d349 2
a350 1
  if ((GET_OBJ_DAMAGE(obj) <= 0) && (GET_OBJ_MAX_DAMAGE(obj) != -1)) {
a354 1

d356 1
a356 1
                  (GET_OBJ_MAX_DAMAGE(obj) == -1))
d361 1
a361 1
		      struct obj_data * cont)
a363 1

d433 2
a434 1
  if (*arg3 && is_number(arg1)) {
d448 4
a451 2
    send_to_char("You can only put things into one container at a time.\r\n", ch);
  else if (!*thecont) {
d457 2
a458 1
    if (!cont) {
d465 6
a470 3
    else {
      if (obj_dotmode == FIND_INDIV) {	/* put <obj> <container> */
	if (!(obj = generic_find_obj(ch, theobj, FIND_OBJ_INV))) {
d475 2
a476 1
	else {
d478 2
a479 1
	  while(obj && howmany--) {
d486 2
a487 1
	for (obj = ch->carrying; obj; obj = next_obj) {
d490 2
a491 1
	      (obj_dotmode == FIND_ALL || isname(theobj, obj->name))) {
d496 2
a497 1
	if (!found) {
d499 4
a502 2
	    send_to_char("You don't seem to have anything to put in it.\r\n", ch);
	  else {
a542 1

a544 1

a545 1

d548 2
a549 1
  else {
d556 2
a557 2
				     struct obj_data * cont, int mode, 
                                     int *corpseModified)
d559 1
a559 1
  if (mode == FIND_OBJ_INV || can_take_obj(ch, obj))
d568 2
a569 3
    else if (get_otrigger(obj, ch)) {
    //else {

d571 2
a572 1
      if (IS_NPC(ch)) {
a575 1

d578 2
a579 1
      if (GET_CORPSEID(cont) > 0) { 
a580 1

d582 1
a582 1
                          obj->name, get_name_by_id(GET_CORPSEID(cont))); 
d596 2
a597 2
			     char *arg, int mode, int howmany,
                             int *corpseModified)
d603 6
a608 6
  if (GET_CORPSEID(cont) > 0) {
    if (GET_IDNUM(ch) != GET_CORPSEID(cont) &&
                LR_FAIL(ch, LVL_ANGEL) && 
                !isPlayerFriend(ch, GET_CORPSEID(cont))) {
      sprintf(buf, "Umm, you'd better not touch that. Ask &7%s&n for permission.", 
                      get_name_by_id(GET_CORPSEID(cont)));
a612 1

a613 1

d624 2
a625 1
      while(obj && howmany--) {
d632 2
a633 1
    if (obj_dotmode == FIND_ALLDOT && !*arg) {
d637 2
a638 1
    for (obj = cont->contains; obj; obj = next_obj) {
d641 2
a642 1
	  (obj_dotmode == FIND_ALL || isname(arg, obj->name))) {
d652 2
a653 1
    if (!found) {
d656 2
a657 1
      else {
a664 1

d667 3
a669 3
  if (can_take_obj(ch, obj) && get_otrigger(obj, ch)) {
  int sleight = 0;

d671 12
a682 15
    if (GET_CORPSEID(obj) > 0) {
      if (GET_IDNUM(ch) != GET_CORPSEID(obj) && LR_FAIL(ch, LVL_ANGEL) &&
                !isPlayerFriend(ch, GET_CORPSEID(obj))) {
        sprintf(buf, "Umm, you'd better not touch that. Ask &7%s&n for permission.",
                        get_name_by_id(GET_CORPSEID(obj)));
        send_to_char(buf, ch);
        return(0);
      } 
    }
    if (!IS_NPC(ch))
      if (GET_SKILL(ch,SKILL_SLEIGHT) && 
	  has_stats_for_skill(ch,SKILL_SLEIGHT,FALSE))
        if (number(0, 101) < GET_SKILL(ch, SKILL_SLEIGHT) 
	    && (CAN_CARRY_W(ch) > (GET_OBJ_WEIGHT(obj) * 3)))
          sleight = 1;
d685 2
a686 1
    if (sleight == 0) {
a698 1

d706 2
a707 1
  if (dotmode == FIND_INDIV) {
d714 2
a715 1
      while(obj && howmany--) {
d722 2
a723 1
    if (dotmode == FIND_ALLDOT && !*arg) {
d727 2
a728 1
    for (obj = world[ch->in_room].contents; obj; obj = next_obj) {
d731 2
a732 1
	  (dotmode == FIND_ALL || isname(arg, obj->name))) {
d737 2
a738 1
    if (!found) {
d741 2
a742 1
      else {
a749 2


a762 1

d777 2
a778 1
  else {
d780 2
a781 1
    if (is_number(arg1)) {
d787 2
a788 1
    if (cont_dotmode == FIND_INDIV) {
d790 2
a791 1
      if (!cont) {
d799 2
a800 1
        if (corpseModified == 1) {
d806 2
a807 1
      if (cont_dotmode == FIND_ALLDOT && !*arg2) {
d811 2
a812 1
      for (cont = ch->carrying; cont; cont = cont->next_content) {
d815 4
a818 2
	    (cont_dotmode == FIND_ALL || isname(arg2, cont->name))) {
	  if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER) {
d828 2
a829 1
        if (corpseModified == 1) {
d834 2
a835 1
      for (cont = world[ch->in_room].contents; cont; cont = cont->next_content){
d838 4
a841 2
	    (cont_dotmode == FIND_ALL || isname(arg2, cont->name))) {
	  if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER) {
d843 1
a843 1
                            &corpseModified);
d850 3
a852 2
        // DM - call addCorpse to update the data for this corpse and save
        if (corpseModified == 1) {
d857 2
a858 1
      if (!found) {
d861 2
a862 1
	else {
d871 2
a872 3

void perform_drop_gold(struct char_data * ch, int amount,
		            byte mode, room_rnum RDR)
a914 1

a916 1

a920 1

a924 1

a935 1

a941 1

d951 2
a952 1
    for (struct obj_data *myobj = obj->contains; myobj; myobj = myobj->next_content)
d960 2
a961 1
      if (!IS_NPC(ch) && (GET_OBJ_TYPE(obj) == ITEM_REWARD) && (mode != SCMD_JUNK))
a995 1

a998 2


a1127 1

d1129 1
a1129 1
		       struct obj_data * obj, int subcmd)
d1144 2
a1145 1
      for (struct obj_data *myobj = obj->contains; myobj; myobj = myobj->next_content)
a1158 1

d1164 2
a1165 2

  if (IS_CARRYING_N(vict) >= CAN_CARRY_N(vict)) {
d1169 2
a1170 1
  if (GET_OBJ_WEIGHT(obj) + IS_CARRYING_W(vict) > CAN_CARRY_W(vict)) {
d1176 2
a1177 2

  switch (subcmd) {
d1179 3
a1181 1
      if ((basic_skill_test(ch, SKILL_SLIP, FALSE) == 0) || (number(0, GET_DEX(vict)) > GET_DEX(ch))) {
d1224 2
a1225 1
  if (amount <= 0) {
d1229 2
a1230 1
  if ((GET_GOLD(ch) < amount) && (IS_NPC(ch) || LR_FAIL(ch, LVL_GOD))) {
a1241 1

d1262 2
a1263 1
    if (!str_cmp("coins", arg) || !str_cmp("coin", arg)) {
d1277 2
a1278 1
      while (obj && amount--) {
d1298 2
a1299 1
      if (dotmode == FIND_ALLDOT && !*arg) {
d1306 2
a1307 1
	for (obj = ch->carrying; obj; obj = next_obj) {
d1324 1
a1324 1
  if (obj->in_room != NOWHERE) {
d1326 2
a1327 1
  } else if ((tmp_ch = obj->carried_by)) {
d1382 2
a1383 1
  if (!*arg) {
d1397 2
a1398 1
      (GET_OBJ_TYPE(temp) != ITEM_FOUNTAIN)) {
d1402 2
a1403 1
  if (on_ground && (GET_OBJ_TYPE(temp) == ITEM_DRINKCON)) {
d1407 2
a1408 1
  if ((GET_COND(ch, DRUNK) > 10) && (GET_COND(ch, THIRST) > 0)) {
d1414 2
a1415 1
  if ((GET_COND(ch, FULL) > 20) && (GET_COND(ch, THIRST) > 0)) {
d1419 2
a1420 1
  if (!GET_OBJ_VAL(temp, 1)) {
d1424 2
a1425 1
  if (subcmd == SCMD_DRINK) {
a1427 1

a1429 1

a1433 1

a1439 1

a1440 1

a1442 1

a1443 1

d1445 1
a1445 2
	 (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK] * amount) / 4);

a1447 1

d1449 1
a1449 2
	(int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][THIRST] * amount) / 4);

a1451 1

a1453 1

d1456 2
a1457 2

  if (GET_OBJ_VAL(temp, 3)) {	/* The shit was poisoned ! */
a1459 1

d1469 2
a1470 1
  if (!GET_OBJ_VAL(temp, 1)) {	/* The last bit */
a1484 1

d1515 2
d1518 1
a1519 6
  } else {
    if (--GET_OBJ_VAL(food, 0) < 1)
    {
      send_to_char("There's nothing left now.\r\n", ch);
      extract_obj(food);
    }
a1527 1

d1569 2
a1570 2

  if (subcmd == SCMD_POUR) {
d1586 4
a1589 2
  if (subcmd == SCMD_FILL) {
    if (!*arg1) {		/* no arguments */
d1603 2
a1604 1
    if (!*arg2) {		/* no 2nd argument */
d1608 2
a1609 1
    if (!(from_obj = find_obj_list(ch, arg2, world[ch->in_room].contents))) {
d1614 2
a1615 1
    if (GET_OBJ_TYPE(from_obj) != ITEM_FOUNTAIN) {
d1620 2
a1621 1
  if (GET_OBJ_VAL(from_obj, 1) == 0) {
d1625 4
a1628 2
  if (subcmd == SCMD_POUR) {	/* pour */
    if (!*arg2) {
d1632 2
a1633 1
    if (!str_cmp(arg2, "out")) {
a1635 1

a1636 1

a1641 1

d1697 2
a1698 1
  if (GET_OBJ_VAL(from_obj, 1) < 0) {	/* There was too little */
a1715 2


d1718 2
a1719 1
  const char *wear_messages[][2] = {
a1796 1

a1797 1

a1956 1

d1962 1
a1962 2

  int wear_bitvectors[] = 
a2187 2


a2248 1

a2251 2


d2261 2
a2262 1
  if (!*arg1) {
d2278 2
a2279 1
      if (CAN_SEE_OBJ(ch, obj) && (where = find_eq_pos(ch, obj, 0)) >= 0) {
a2327 1

a2334 1

a2336 1

a2340 1

d2343 3
a2345 6

    else {
      // DM, 11/99 - changed to obj level (was based on amount of dam it did)
      if (!invalid_level(ch, obj, TRUE))
        perform_wear(ch, obj, WEAR_WIELD);  
    }
a2348 2


a2353 1

d2364 4
a2367 4
      if (!CAN_WEAR(obj, ITEM_WEAR_HOLD) && GET_OBJ_TYPE(obj) != ITEM_WAND 
                      && GET_OBJ_TYPE(obj) != ITEM_STAFF 
                      && GET_OBJ_TYPE(obj) != ITEM_SCROLL 
                      && GET_OBJ_TYPE(obj) != ITEM_POTION)
a2475 1

d2481 2
a2482 2

  if (!*arg) {
a2486 1

d2501 2
a2502 1
    else {
d2506 2
a2507 1
	    isname(arg, GET_EQ(ch, i)->name)) {
d2513 2
a2514 1
      if (!found) {
@


1.53
log
@Artus> You can now wear breathers and qeq in locations normally unavailable to
       your race/class. (Breather's do not apply/affect)
@
text
@d1005 4
a1008 10
  switch (subcmd) {
  case SCMD_JUNK:
    sname = "junk";
    mode = SCMD_JUNK;
    break;
  case SCMD_DONATE:
    sname = "donate";
    mode = SCMD_DONATE;
    switch (number(0, 2)) {
    case 0:
d1011 21
a1031 3
    case 1:
    case 2:
      RDR = real_room(donation_room_1);
a1032 12
/*    case 3: RDR = real_room(donation_room_2); break;
      case 4: RDR = real_room(donation_room_3); break;
*/
    }
    if (RDR == NOWHERE) {
      send_to_char("Sorry, you can't donate anything right now.\r\n", ch);
      return;
    }
    break;
  default:
    sname = "drop";
    break;
d1037 2
a1038 1
  if (!*arg) {
d1049 2
a1050 1
    else if (!*arg) {
d1057 2
a1058 1
      do {
d1069 1
a1069 1
        LR_FAIL(ch, LVL_IMMORT))
d1118 2
a1119 2

  if (amount && (subcmd == SCMD_JUNK)) {
@


1.52
log
@Artus> Prevented junking/donating of containers with contents.
       Dropping a container with items inside results in a rattle messasge.
@
text
@d1957 2
a1958 1
  int wear_bitvectors[] = {
d1987 2
a1988 1
  const char *pos_unavailable[] = {
d2018 2
a2019 1
  const char *already_wearing[] = {
d2049 2
a2050 1
  if (!CAN_WEAR(obj, wear_bitvectors[where])) {
d2114 21
a2134 2
    send_to_char(pos_unavailable[where], ch);
    return;
d2179 2
a2180 1
  obj_wear_spells(ch, obj);
d2190 2
a2191 1
  const char *keywords[] = {
d2388 1
a2388 1
  bool was_dual = FALSE;
d2413 3
d2460 1
a2460 1
  if(GET_OBJ_TYPE(obj) == ITEM_MAGIC_EQ)
@


1.51
log
@Artus> Fixed bug where food with zero fulfilment would crash the mud.
       (Eg: Item 13310 - Tabacco).
@
text
@d871 4
a874 2
  else {
    if (mode != SCMD_JUNK) {
d877 2
a878 1
      if (mode == SCMD_DONATE) {
d886 2
a887 2

        if (!drop_wtrigger(obj, ch)) {
a890 1

d941 7
d963 3
a965 1
  sprintf(buf, "You %s $p.%s", sname, VANISH(mode));
d974 16
a989 15
  switch (mode) {
  case SCMD_DROP:
    obj_to_room(obj, ch->in_room);
    return (0);
  case SCMD_DONATE:
    obj_to_room(obj, RDR);
    act("$p suddenly appears in a puff a smoke!", FALSE, 0, obj, 0, TO_ROOM);
    return (0);
  case SCMD_JUNK:
    value = MAX(1, MIN(200, GET_OBJ_COST(obj) / 16));
    extract_obj(obj);
    return (value);
  default:
    basic_mud_log("SYSERR: Incorrect argument %d passed to perform_drop.", mode);
    break;
a1062 1

@


1.50
log
@Artus> Required changes for new find_xxx functions.
@
text
@d1462 5
a1466 3
  int amount;
  amount = (subcmd == SCMD_EAT ? GET_OBJ_VAL(food, 0) : 1);
  gain_condition(ch, FULL, amount);
d1475 8
a1482 2
  if (GET_COND(ch, FULL) > 20)
    send_to_char("You are full.\r\n", ch);
d1500 1
a1500 1
    if (!(--GET_OBJ_VAL(food, 0))) 
@


1.49
log
@Artus> Moved quest item stuff to quest.c, handle_quest_item_take().
@
text
@d301 2
a302 1
  if (!(o = get_obj_in_list_vis(ch, buf, ch->carrying))) {
d484 1
a484 1
	if (!(obj = get_obj_in_list_vis(ch, theobj, ch->carrying))) {
d494 1
a494 1
	    obj = get_obj_in_list_vis(ch, theobj, next_obj);
d628 4
a631 2
  else if (obj_dotmode == FIND_INDIV) {
    if (!(obj = get_obj_in_list_vis(ch, arg, cont->contains))) {
d639 1
a639 1
        obj = get_obj_in_list_vis(ch, arg, obj_next);
d717 2
a718 1
    if (!(obj = get_obj_in_list_vis(ch, arg, world[ch->in_room].contents))) {
d726 1
a726 1
        obj = get_obj_in_list_vis(ch, arg, obj_next);
d1039 1
a1039 1
    } else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
d1044 1
a1044 1
        next_obj = get_obj_in_list_vis(ch, arg, obj->next_content);
d1083 1
a1083 1
      if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) 
d1091 1
a1091 1
	next_obj = get_obj_in_list_vis(ch, arg, obj->next_content);
d1096 1
a1096 1
      if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying)))
d1188 2
a1189 1
  if (!*arg) {
d1192 1
a1192 1
  } else if (!(vict = get_char_vis(ch, arg, FIND_CHAR_ROOM))) {
d1253 1
a1253 1
    } else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
d1258 1
a1258 1
	next_obj = get_obj_in_list_vis(ch, arg, obj->next_content);
d1268 4
a1271 2
    if (dotmode == FIND_INDIV) {
      if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
d1362 4
a1365 2
  if (!(temp = get_obj_in_list_vis(ch, arg, ch->carrying))) {
    if (!(temp = get_obj_in_list_vis(ch, arg, world[ch->in_room].contents))) {
d1513 1
a1513 1
  if (!(food = get_obj_in_list_vis(ch, arg, ch->carrying)))
d1549 2
a1550 1
    if (!*arg1) {		/* No arguments */
d1554 2
a1555 1
    if (!(from_obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
d1569 2
a1570 1
    if (!(to_obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
d1574 2
a1575 1
    if (GET_OBJ_TYPE(to_obj) != ITEM_DRINKCON) {
d1583 1
a1583 1
    if (!(from_obj = get_obj_in_list_vis(ch, arg2, world[ch->in_room].contents))) {
d1616 2
a1617 1
    if (!(to_obj = get_obj_in_list_vis(ch, arg2, ch->carrying))) {
d1622 2
a1623 1
	(GET_OBJ_TYPE(to_obj) != ITEM_FOUNTAIN)) {
d1628 2
a1629 1
  if (to_obj == from_obj) {
d1634 2
a1635 1
      (GET_OBJ_VAL(to_obj, 2) != GET_OBJ_VAL(from_obj, 2))) {
d1639 2
a1640 1
  if (!(GET_OBJ_VAL(to_obj, 1) < GET_OBJ_VAL(to_obj, 0))) {
d1644 2
a1645 1
  if (subcmd == SCMD_POUR) {
d1650 2
a1651 1
  if (subcmd == SCMD_FILL) {
a1863 80
#if 0
  // Now check class restrictions on object
  if (GET_CLASS(ch) == CLASS_WARRIOR && 
      OBJ_FLAGGED(object, ITEM_ANTI_WARRIOR))
  {
    if (display)
      send_to_char("A warrior like yourself cannot use this item.\r\n", ch);
    return 1;
  }
  if (GET_CLASS(ch) == CLASS_THIEF && 
      OBJ_FLAGGED(object, ITEM_ANTI_THIEF))
  {
    if (display)
      send_to_char("A thief like yourself cannot use this item.\r\n", ch);
    return 1;
  }
  if (GET_CLASS(ch) == CLASS_MAGIC_USER && 
      OBJ_FLAGGED(object, ITEM_ANTI_MAGIC_USER))
  {
    if (display)
      send_to_char("A mage like yourself cannot use this item.\r\n", ch);
    return 1;
  }
  if (GET_CLASS(ch) == CLASS_CLERIC && 
      OBJ_FLAGGED(object, ITEM_ANTI_CLERIC))
  {
    if (display)
      send_to_char("A cleric like yourself cannot use this item.\r\n", ch);
    return 1;
  }
  if (GET_CLASS(ch) == CLASS_DRUID && 
      OBJ_FLAGGED(object, ITEM_ANTI_DRUID))
  {
    if (display)
      send_to_char("A druid like yourself cannot use this item.\r\n", ch);
    return 1;
  }
  if (GET_CLASS(ch) == CLASS_PRIEST && 
      OBJ_FLAGGED(object, ITEM_ANTI_PRIEST))
  {
    if (display)
      send_to_char("A priest like yourself cannot use this item.\r\n", ch);
    return 1;
  }
  if (GET_CLASS(ch) == CLASS_NIGHTBLADE && 
      OBJ_FLAGGED(object, ITEM_ANTI_NIGHTBLADE))
  {
    if (display)
      send_to_char("A nightblade like yourself cannot use this item.\r\n", ch);
    return 1;
  }
  if (GET_CLASS(ch) == CLASS_BATTLEMAGE && 
      OBJ_FLAGGED(object, ITEM_ANTI_BATTLEMAGE))
  {
    if (display)
      send_to_char("A battlemage like yourself cannot use this item.\r\n", ch);
    return 1;
  }
  if (GET_CLASS(ch) == CLASS_SPELLSWORD && 
      OBJ_FLAGGED(object, ITEM_ANTI_SPELLSWORD))
  {
    if (display)
      send_to_char("A spellsword like yourself cannot use this item.\r\n", ch);
    return 1;
  }
  if (GET_CLASS(ch) == CLASS_PALADIN && 
      OBJ_FLAGGED(object, ITEM_ANTI_PALADIN))
  {
    if (display)
      send_to_char("A paladin like yourself cannot use this item.\r\n", ch);
    return 1;
  }
  if (GET_CLASS(ch) == CLASS_MASTER && 
      OBJ_FLAGGED(object, ITEM_ANTI_MASTER))
  {
    if (display)
      send_to_char("A master like yourself cannot use this item.\r\n", ch);
    return 1;
  }
#endif
d2246 1
a2246 1
    if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) 
d2253 1
a2253 1
	next_obj = get_obj_in_list_vis(ch, arg1, obj->next_content);
d2262 1
a2262 1
    if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying)))
d2285 2
a2286 1
  else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
d2320 2
a2321 1
  else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
a2338 2


d2450 2
a2451 1
  if (dotmode == FIND_ALL) {
d2481 2
a2482 1
    if (!get_object_in_equip_vis(ch, arg, ch->equipment, &i)) {
@


1.48
log
@Artus> Moved all the quest event stuff to quest.[ch].
       Added trivia quest type.
@
text
@d44 1
d539 1
a539 36
  {
    struct event_data *ev;
    struct itemhunt_data *qev;
    struct quest_score_data *player;
    if (IS_NPC(ch))
      return (0);
    if (!PRF_FLAGGED(ch, PRF_QUEST) && LR_FAIL(ch, LVL_GOD))
    {
      act("$p: you are not part of the quest!\r\n", FALSE, ch, obj, 0, TO_CHAR);
      return (0);
    }
    if (!LR_FAIL(ch, LVL_GOD))
      return (1);
    ev = find_quest_event();
    if (!(ev) || (ev->type != EVENT_QUEST) || (ev->info1 != QUEST_ITEM_HUNT))
      return (1);
    qev = (struct itemhunt_data *)ev->info2;
    if (!(qev) || (qev->ev != ev))
      return (1);
    qev->itemsfound++;
    for (player = qev->players; player; player = player->next)
    {
      if (player->chID == GET_IDNUM(ch))
      {
	player->score++;
	if (player->score == 1)
	  sprintf(buf, "&7%s&Y has found their first item!&n",
		  player->name);
	else
	  sprintf(buf, "&7%s&Y has found another item, for a total of &5%d&Y.&n", player->name, player->score);
	do_qcomm(ch, buf, CMD_NONE, SCMD_QECHO);
	extract_obj(obj);
	return (0);
      } // Found match!
    } // Search through quest->players.
  } // ITEM_QUEST.
d569 5
@


1.47
log
@Artus> No longer adding/removing aliases from drink containers when they are
       emptied/filled.
@
text
@d27 1
d557 1
@


1.46
log
@Artus> Implemented QUEST_ITEM_HUNT.
@
text
@d59 1
d61 1
a62 1
void name_to_drinkcon(struct obj_data * obj, int type);
d1337 1
a1337 1

a1352 2


d1363 1
a1363 1

d1472 2
a1473 1
    name_from_drinkcon(temp);
d1625 2
a1626 1
      name_from_drinkcon(from_obj);
d1663 1
d1665 1
a1665 1
    name_to_drinkcon(to_obj, GET_OBJ_VAL(from_obj, 2));
d1682 2
a1683 1
    name_from_drinkcon(from_obj);
@


1.45
log
@Artus> Changes for object spells.
@
text
@d43 1
a514 2


d517 4
a520 1
  if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch)) {
d523 3
a525 1
  } else if ((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) > CAN_CARRY_W(ch)) {
d528 3
a530 1
  } else if (!(CAN_WEAR(obj, ITEM_WEAR_TAKE))) {
d534 37
a573 1

d598 2
a599 1
  if (mode == FIND_OBJ_INV || can_take_obj(ch, obj)) {
@


1.44
log
@Artus> Now warning free :o)
@
text
@d1908 60
d1971 1
a1971 5
  struct affected_type *af, *next;      
  bool spellsused[3], dual_wield = FALSE;

  for (int i = 0; i < 3; i++)
    spellsused[i] = FALSE;
d2130 2
a2131 1
  if (!CAN_WEAR_POS(ch, obj, wear_bitvectors[where], where)) {
d2138 1
a2138 1
    if (dual_wield) {
d2140 1
a2140 1
    } else {
a2141 1
    }
d2149 2
a2150 1
  if (!quest_obj_ok(ch, obj)) {
d2158 1
a2158 1
  if (dual_wield) {
d2160 1
a2160 1
  } else {
a2161 1
  }
d2178 1
a2178 35
  if (GET_OBJ_TYPE(obj) == ITEM_MAGIC_EQ && GET_OBJ_VAL(obj,0) > 0) {

    /* lower the charge */
    if (GET_OBJ_VAL(obj, 3) > 0)
      GET_OBJ_VAL(obj, 3)--;

    // DM - Let them use the spell, iff they have the stats for it, and know it 
    for (int i = 0; i < 3; i ++) {
      if (GET_OBJ_VAL(obj, i) > 0)
      {
//        if (has_stats_for_skill(ch, GET_OBJ_VAL(obj, i), FALSE) 
//                        && GET_SKILL(ch, GET_OBJ_VAL(obj, i)) > 0)
//        { 
          call_magic(ch, ch, NULL, GET_OBJ_VAL(obj, i), 
              /*DM - hmm why 2? 2 */ GET_LEVEL(ch), CAST_MAGIC_OBJ);
          spellsused[i] = TRUE;
//        }
      }
    }

    for (af = ch->affected; af; af = next) {
      next = af->next;
      if ((spellsused[0] && af->type == GET_OBJ_VAL(obj, 0)) ||
          (spellsused[1] && af->type == GET_OBJ_VAL(obj, 1)) ||
          (spellsused[2] && af->type == GET_OBJ_VAL(obj, 2)))
        af->duration = 0;
      // DM HERE
      }

    /* if its out of power get rid of it */
    if (GET_OBJ_VAL(obj, 3) == 0) {
      act("$p disappears as its power deminishes.", FALSE, ch, obj, 0, TO_CHAR);
      extract_obj(obj);
    }
  }     
d2264 2
a2265 1
  if (*arg2 && (dotmode != FIND_INDIV)) {
d2269 4
a2272 2
  if (dotmode == FIND_ALL) {
    for (obj = ch->carrying; obj; obj = next_obj) {
d2303 2
a2304 1
    if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
d2459 4
a2462 3
      if((af->type == GET_OBJ_VAL(obj,0)) ||
	 (af->type == GET_OBJ_VAL(obj,1)) ||
	 (af->type == GET_OBJ_VAL(obj,2))) 
@


1.43
log
@Artus> No more putting cursed things in bags on the ground.
@
text
@d1741 1
a1741 1
  int lr=0, lvltest=0, questfound = 0;
d1820 1
a1820 1
      sprintf(buf, "%ss like yourself cannot use this item.\r\n", pc_class_types[GET_CLASS(ch)]);
@


1.42
log
@Artus> Changes for Pirate Ship.
@
text
@d378 2
d397 6
d1213 3
d2212 1
@


1.41
log
@Added pirate ship messages to zone
@
text
@d82 2
d85 1
d87 68
d158 1
a158 5
    case 0 :              /* arrive to haven */
      send_to_room("\n\rThe crew tie up and roll out the gangway.", real_room(8690));
      send_to_room("\n\rThe crew tie up and roll out the gangway.", real_room(8669));
      send_to_zone("\n\rA cannon fires as the Pirate ship arrives at Haven wharf.\r\n", real_zone(11));
      send_to_zone("\n\rA bell tolls, the ship has dropped anchor at Haven wharf.\n\r", real_zone(86));
d163 1
a163 7

    case 1 :              /* en-route to island */
      send_to_room("\n\rThe crew remove the gangway and weigh anchor.", real_room(8690));
      send_to_room("\n\rThe crew remove the gangway and weigh anchor.", real_room(8669));

      send_to_zone("\n\rA cannon fires as the Pirate ship sails away from Haven Wharf\r\n", real_zone(11));
      send_to_zone("\n\rA cannon fires as the Pirate ship sails away from Haven Wharf\r\n", real_zone(86));
d176 1
a176 6

    case 2 :              /*  at island */
      send_to_room("\n\rThe crew tie up and roll out the gangway.", real_room(8629));
      send_to_room("\n\rThe crew tie up and roll out the gangway.", real_room(8854));
      send_to_zone("\n\rYou hear the sound of a far off cannon shot. This Pirate ship has arrived.\n\r", real_zone(88));
      send_to_zone("\n\rA cannon fires, the ship has dropped anchor at the island.\n\r", real_zone(86));
d181 1
a181 7
    
    case 3 :              /* en-route to haven */
      send_to_room("\n\rThe crew remove the gangway and weigh anchor.", real_room(8629));
      send_to_room("\n\rThe crew remove the gangway and weigh anchor.", real_room(8854));

      send_to_zone("\n\rYou hear the sound of a far off cannon shot. This Pirate ship has left the island.\n\r", real_zone(88));
      send_to_zone("\n\rThe ship has weighed anchor and sailed away from the island.\n\r", real_zone(86));
@


1.40
log
@Artus> LR bonus now only works up to GET_MAX_LEVEL.
       No longer require knowledge of eq spells.
@
text
@d26 1
d42 1
d88 1
a88 2
      send_to_room("\n\rThe pirate ship has arrived at Haven.", real_room(8690));
      send_to_room("\n\rThe pirate ship has arrived at Haven.", real_room(8669));
d90 2
d98 5
a102 2
      send_to_room("\n\rThe ship sails away from Haven", real_room(8690));
      send_to_room("\n\rThe ship sails away from Haven", real_room(8669));
d117 4
a120 3
      send_to_room("\n\rThe ship has arrived at the island.", real_room(8854));
      send_to_room("\n\rThe ship has arrived at the island.", real_room(8629));
      send_to_room("\n\rThe crew tie up and roll out the gangway.", real_room(8629));      
d127 5
a131 2
      send_to_room("\n\rThe ship sails away from the island.", real_room(8629));
      send_to_room("\n\rThe ship sails away from the island.", real_room(8854));
@


1.39
log
@Artus> Minor changes to find_eq_pos.
@
text
@d1709 1
a1709 1
  if (GET_CLASS(ch) == CLASS_MASTER)
d1711 19
a1729 11
    if (!OBJ_FLAGGED(object, ITEM_ANTI_WARRIOR) ||
       !OBJ_FLAGGED(object, ITEM_ANTI_THIEF) ||
       !OBJ_FLAGGED(object, ITEM_ANTI_CLERIC) ||
       !OBJ_FLAGGED(object, ITEM_ANTI_MAGIC_USER))
      lr -= 20;
    else if (!OBJ_FLAGGED(object, ITEM_ANTI_NIGHTBLADE) ||
	     !OBJ_FLAGGED(object, ITEM_ANTI_BATTLEMAGE) ||
	     !OBJ_FLAGGED(object, ITEM_ANTI_SPELLSWORD) ||
	     !OBJ_FLAGGED(object, ITEM_ANTI_PALADIN) ||
	     !OBJ_FLAGGED(object, ITEM_ANTI_PRIEST) ||
	     !OBJ_FLAGGED(object, ITEM_ANTI_DRUID))
d1731 1
a1731 6
  } else if ((GET_CLASS(ch) > CLASS_WARRIOR) && 
      (!OBJ_FLAGGED(object, ITEM_ANTI_WARRIOR) ||
       !OBJ_FLAGGED(object, ITEM_ANTI_THIEF) ||
       !OBJ_FLAGGED(object, ITEM_ANTI_CLERIC) ||
       !OBJ_FLAGGED(object, ITEM_ANTI_MAGIC_USER)))
    lr -= 10;
d2060 4
a2063 2
        if (has_stats_for_skill(ch, GET_OBJ_VAL(obj, i), FALSE) 
                        && GET_SKILL(ch, GET_OBJ_VAL(obj, i)) > 0) {
d2067 2
a2068 1
        }
@


1.38
log
@Artus> 95 -> MAX_SKILL_ABIL
@
text
@d2119 2
a2120 1
  if (!arg || !*arg) {
d2135 1
a2135 1
  } else {
@


1.37
log
@Artus> Restricted number of quest objs.
       Now using invalid_class() for class checks.
@
text
@d288 2
a289 2
  if (skillAmt > 95)
    skillAmt = 95;
@


1.36
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d1670 1
a1670 1
  int lr=0, lvltest=0;
d1672 1
a1672 1
  bool questfound = FALSE;
d1682 5
a1686 2
        questfound = TRUE;
    if (!questfound)
d1692 13
d1742 10
d1830 1
@


1.35
log
@act.item.c    : Fixed bug that was causing slip to constantly fail.
act.other.c   : Steal and Sneak now call apply_spell_skill_abil()
interpreter.c : Can no longer pick remort classes when creating characters.
@
text
@d529 1
a529 1
                GET_LEVEL(ch) < LVL_ANGEL && 
d591 1
a591 2
      if (GET_IDNUM(ch) != GET_CORPSEID(obj) && 
                GET_LEVEL(ch) < LVL_ANGEL && 
d829 1
a829 1
  if ((GET_LEVEL(ch) < LVL_ANGEL) && IS_OBJ_STAT(obj, ITEM_NODROP)) 
d849 1
a849 1
      (GET_LEVEL(ch) < LVL_ANGEL))
d965 9
a973 10
                    (subcmd == SCMD_JUNK || subcmd == SCMD_DONATE)) {
      if (GET_LEVEL(ch) < LVL_IMMORT) {
        if (subcmd == SCMD_JUNK)
	  send_to_char("Go to the dump if you want to junk EVERYTHING!\r\n", 
                          ch);
        else
	  send_to_char("Go do the donation room if you want to donate "
                          "EVERYTHING!\r\n", ch);
        return;
      }
d975 2
a976 1
    if (dotmode == FIND_ALL) {
d978 1
d980 7
a986 5
      else
	for (obj = ch->carrying; obj; obj = next_obj) {
	  next_obj = obj->next_content;
	  amount += perform_drop(ch, obj, mode, sname, RDR);
	}
d988 2
a989 1
      if (!*arg) {
d994 2
a995 1
      if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
d998 1
d1000 2
a1001 1
      while (obj) {
d1007 2
a1008 1
      if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
d1027 1
a1027 1
  if (GET_LEVEL(ch) < LVL_ANGEL) 
d1081 1
a1081 1
      if (GET_LEVEL(vict) > LVL_IMMORT)
d1120 1
a1120 1
  if ((GET_GOLD(ch) < amount) && (IS_NPC(ch) || (GET_LEVEL(ch) < LVL_GOD))) {
d1129 1
a1129 1
  if (IS_NPC(ch) || (GET_LEVEL(ch) < LVL_GOD))
d1379 1
a1379 1
  if (GET_OBJ_VAL(food, 3) && (GET_LEVEL(ch) < LVL_IMMORT)) 
d1429 1
a1429 1
  if ((GET_OBJ_TYPE(food) != ITEM_FOOD) && (GET_LEVEL(ch) < LVL_GOD))
d1672 1
a1672 1
  bool questfound = TRUE;
d1674 3
d1678 4
a1681 4
  if (OBJ_FLAGGED(object, ITEM_QEQ)) {
    questfound = FALSE;
    for (int i = 0; i < MAX_QUEST_ITEMS; i++) {
      if (GET_QUEST_ITEM(ch,i) == GET_OBJ_VNUM(object)) {
d1683 5
a1687 1
      }
a1689 6
  if (!questfound) {
    if (display) 
      send_to_char("You only wish you could use this item!\r\n", ch);
    return 1;
  }

d1692 1
a1692 1
  lvltest = GET_LEVEL(ch);
d1694 19
a1712 4
    lvltest = GET_LEVEL(ch) + 20;
  else if (GET_CLASS(ch) > CLASS_WARRIOR)
    lvltest = GET_LEVEL(ch) + 10;

d1714 2
a1715 1
  if (lr && (lvltest < lr)) {
d1717 1
a1717 1
      if (lvltest > GET_LEVEL(ch))
d1728 3
a1730 2
                  OBJ_FLAGGED(object, ITEM_ANTI_WARRIOR)) {
    if (display) {
a1731 1
    }
d1735 3
a1737 2
                  OBJ_FLAGGED(object, ITEM_ANTI_THIEF)) {
    if (display) {
a1738 1
    }
d1742 3
a1744 2
                  OBJ_FLAGGED(object, ITEM_ANTI_MAGIC_USER)) {
    if (display) {
a1745 1
    }
d1749 3
a1751 2
                  OBJ_FLAGGED(object, ITEM_ANTI_CLERIC)) {
    if (display) {
a1752 1
    }
d1756 3
a1758 2
                  OBJ_FLAGGED(object, ITEM_ANTI_DRUID)) {
    if (display) {
a1759 1
    }
d1763 3
a1765 2
                  OBJ_FLAGGED(object, ITEM_ANTI_PRIEST)) {
    if (display) {
a1766 1
    }
d1770 3
a1772 2
                  OBJ_FLAGGED(object, ITEM_ANTI_NIGHTBLADE)) {
    if (display) {
a1773 1
    }
d1777 3
a1779 2
                  OBJ_FLAGGED(object, ITEM_ANTI_BATTLEMAGE)) {
    if (display) {
a1780 1
    }
d1784 3
a1786 2
                  OBJ_FLAGGED(object, ITEM_ANTI_SPELLSWORD)) {
    if (display) {
a1787 1
    }
d1791 3
a1793 2
                  OBJ_FLAGGED(object, ITEM_ANTI_PALADIN)) {
    if (display) {
a1794 1
    }
d1798 3
a1800 2
                  OBJ_FLAGGED(object, ITEM_ANTI_MASTER)) {
    if (display) {
a1801 1
    }
a1803 1

d2260 1
a2260 1
  if ((GET_LEVEL(ch) < LVL_ANGEL) && IS_OBJ_STAT(obj, ITEM_NODROP)) 
@


1.34
log
@Artus> No drop/throw rewards.
@
text
@d1067 1
a1067 1
      if ((basic_skill_test(ch, SKILL_SLIP, 0) == 0) || (number(0, GET_DEX(vict)) < GET_DEX(ch))) {
@


1.33
log
@Artus> Mostly just cosmetic changes, mostly for underwater stuff..
       Added some more stuff to dg_scripts:

       %actor.affected(aff_bit)% - Is actor affected by whatever.
       %self.people(countpc)%    - (Rooms): Count players.
       %self.people(countnpc)%   - (Rooms): Count npcs.
       %self.people(countall)%   - (Rooms): Count chars.
       %firstchar.<room_vnum>%   - First character in room <vnum>

       Possibly a bugfix to one of the forest specials that was attacking you
       if you were affected by poison.
@
text
@d836 5
d852 1
d859 7
d1027 5
d1034 1
d1040 6
@


1.32
log
@Artus> Imms no longer affected by hot/cold/etc.
       Debug no longer available to mortals, can be set though.
       Fixed buffer overflow in proc_color.
       Stops processing get_from_container when arms full.
       Changed the way remort abilities are listed.
@
text
@d788 4
a791 3
	send_to_char("You throw some gold into the air where it disappears in a puff of smoke!\r\n", ch);
	act("$n throws some gold into the air where it disappears in a puff of smoke!",
	    FALSE, ch, 0, 0, TO_ROOM);
@


1.31
log
@Artus> Changed remort, in particular, list remort abilities to char.. Also,
       spellsword was incorrectly being listed as a possible path for a
       warrior.

       Replaced #ifdef USE_LOCALTIME with #ifndef NO_LOCALTIME..

       Added define NOTELL_SOUNDPROOF .. Define this to stop people telling
       to/from soundproof rooms.

       Removed extraneous level checking from do_wear.. This is handled
       better by perform_wear.
@
text
@d565 5
@


1.30
log
@Artus>
---
drop_otrigger takes an extra paramater for subcmd. With drop triggers you can
now specify whether the trigger is for drop, junk, donate and put. Specify
in the argument either/combination of 'junk', 'drop', 'donate', 'put'. No
argument means any type will be triggered:

act.item.c, dg_scripts.h, dg_triggers.c, interpreter.h
---
fixed colour bleed in dc:

act.wizard.c
---
Not reapplying empty timers in char_to_store:
Not calling object triggers from char_to_store:

db.c
---
Modified hunt so that with special_elf you can track through !TRACK rooms
(Modifier for Elf has been increased from 0.02 to 0.07%):

graph.c, utils.c
---
Timers should only show remove messages when being removed because they're
wearing off (duration = 0):

handler.c
---
Not calling object triggers when auto_equipping.

objsave.c
---
#defined around love_ring specproc. What a joke. define DRAX_IS_TEH_SUXOR if
you want it back ;o)

spec_assign.c, spec_procs.c
---
@
text
@d2097 2
a2098 1
    if (!*arg1) {
d2102 2
a2103 1
    if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
d2106 3
a2108 2
    } else
      while (obj) {
d2116 1
d2121 1
a2121 3
    } else if (GET_LEVEL(ch) < GET_OBJ_LEVEL(obj))
      send_to_char("You are not experienced enough to use that.\r\n", ch);
    else {
@


1.29
log
@Artus> Implemented Autoeat.
       Putting objs in cursed containers now results in obj being cursed :o)
@
text
@d318 1
a318 1
  if (!drop_otrigger(obj, ch))
d819 1
a819 1
  if (!drop_otrigger(obj, ch))
@


1.28
log
@Artus> Fixed give/throw for cursed items/containers with cursed items.
@
text
@a319 1

a324 1

a329 1

a334 1

d343 10
a354 2
  act("$n puts $p in $P.", TRUE, ch, obj, cont, TO_ROOM);
  act("You put $p in $P.", FALSE, ch, obj, cont, TO_CHAR);
d1326 1
a1326 3


ACMD(do_eat)
a1327 2
  struct obj_data *food;
  struct affected_type af;
d1329 4
a1332 29

  one_argument(argument, arg);

  if (IS_NPC(ch))	/* Cannot use GET_COND() on mobs. */
    return;

  if (!*arg) {
    send_to_char("Eat what?\r\n", ch);
    return;
  }
  if (!(food = get_obj_in_list_vis(ch, arg, ch->carrying))) {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
    return;
  }
  if (subcmd == SCMD_TASTE && ((GET_OBJ_TYPE(food) == ITEM_DRINKCON) ||
			       (GET_OBJ_TYPE(food) == ITEM_FOUNTAIN))) {
    do_drink(ch, argument, 0, SCMD_SIP);
    return;
  }
  if ((GET_OBJ_TYPE(food) != ITEM_FOOD) && (GET_LEVEL(ch) < LVL_GOD)) {
    send_to_char("You can't eat THAT!\r\n", ch);
    return;
  }
  if (GET_COND(ch, FULL) > 20) {/* Stomach full */
    send_to_char("You are too full to eat more!\r\n", ch);
    return;
  }
  if (subcmd == SCMD_EAT) {
a1338 5

  amount = (subcmd == SCMD_EAT ? GET_OBJ_VAL(food, 0) : 1);

  gain_condition(ch, FULL, amount);

d1341 3
a1343 2

  if (GET_OBJ_VAL(food, 3) && (GET_LEVEL(ch) < LVL_IMMORT)) {
a1346 1

d1355 1
d1357 3
a1359 2
  else {
    if (!(--GET_OBJ_VAL(food, 0))) {
d1366 38
@


1.27
log
@Artus> Containers no longer flagged as cursed when cursed objects put inside,
       instead, we're now checking contents when we drop the container.
       Can no longer put containers inside containers.

       Healing Trance timer now displays "healing trance" rather than "timer 9"

       Now sending message when removing various timers from chars.
@
text
@d997 14
a1010 3
  if ((GET_LEVEL(ch) < LVL_ANGEL) && IS_OBJ_STAT(obj, ITEM_NODROP)) {
    act("You can't let go of $p!!  Yeech!", FALSE, ch, obj, 0, TO_CHAR);
    return;
d1012 1
d1018 1
@


1.26
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@d323 1
a323 1
    send_to_char("You're riding that!\r\n", ch);
d328 1
d330 2
a331 3
  else {
    obj_from_char(obj);
    obj_to_obj(obj, cont);
d333 5
a337 1
    act("$n puts $p in $P.", TRUE, ch, obj, cont, TO_ROOM);
d339 12
a350 8
    /* Yes, I realize this is strange until we have auto-equip on rent. -gg */
    if (IS_OBJ_STAT(obj, ITEM_NODROP) && !IS_OBJ_STAT(cont, ITEM_NODROP)) {
      SET_BIT(GET_OBJ_EXTRA(cont), ITEM_NODROP);
      act("You get a strange feeling as you put $p in $P.", FALSE,
                ch, obj, cont, TO_CHAR);
    } else
      act("You put $p in $P.", FALSE, ch, obj, cont, TO_CHAR);
  }
d820 2
a821 1
  if ((GET_LEVEL(ch) < LVL_ANGEL) && IS_OBJ_STAT(obj, ITEM_NODROP)) {
d834 9
@


1.25
log
@Artus> Sorry, Dish.. Another bastard change..

       has_stats_for_skill now takes an extra arg (bool) to determine whether
       or not to display messages.

       new routine: has_stats_for_prac.. Basically the same as
       has_stas_for_skill, without GET_SKILL(ch, i) == 0 check..

       Force is now restricted for <GRGOD.

       Score no longer displays punishment lines twice.

       New macro: IS_SKILL(skillnum) .. Used to determine whether skillnum is
                  a skill.
@
text
@d847 1
a847 1
    log("SYSERR: Incorrect argument %d passed to perform_drop.", mode);
d1144 1
a1144 1
    log("SYSERR: Unknown attempt to subtract weight from an object.");
d2160 1
a2160 1
    log("Error in perform_remove: bad pos passed.");
@


1.24
log
@Artus> Dual Wielding Wear/Remove/Display/Fighting Fixes.
       Cursed items can no longer be sold.
       Bodyslam message now appears in the right spot (hopefully).

       NOTE: IS_DUAL_WIELDING(ch) and IS_DUAL_CAPABLE(ch) defines in utils.h
             have been modified... If you plan to use them, check out how they
	     have changed first :o)
@
text
@d584 2
a585 1
      if (GET_SKILL(ch,SKILL_SLEIGHT) && has_stats_for_skill(ch,SKILL_SLEIGHT))
d666 2
a667 1
    if (GET_SKILL(ch, SKILL_SLEIGHT) && has_stats_for_skill(ch, SKILL_SLEIGHT)) 
d1935 1
a1935 1
        if (has_stats_for_skill(ch, GET_OBJ_VAL(obj, i)) 
@


1.23
log
@Artus> Remove all now removes dual wielded item, too.
@
text
@d1820 2
a1821 1
  if (where == WEAR_FINGER_1) {
d1839 2
a1840 3
  if (where == WEAR_WIELD && !IS_NPC(ch) && GET_SKILL(ch, SKILL_AMBIDEXTERITY) 
      && IS_SET(GET_SPECIALS(ch), SPECIAL_MULTIWEAPON)) {
    if (GET_EQ(ch, WEAR_WIELD)) {
d1842 10
a1851 2
      if (GET_EQ(ch, WEAR_SHIELD)) {
        send_to_char("Your shield is in the way.\r\n", ch);
d1854 4
a1857 2
      where = WEAR_HOLD;
      dual_wield = TRUE;
d1859 2
d1863 2
a1864 1
  if (where == WEAR_SHIELD && IS_DUAL_WIELDING(ch)) {
d1869 6
d1881 2
a1882 1
  if (GET_EQ(ch, where)) {
d2154 1
d2156 2
a2157 1
  if (!(obj = ch->equipment[pos])) {
d2160 3
a2162 2
  }
  else if ((GET_LEVEL(ch) < LVL_ANGEL) && IS_OBJ_STAT(obj, ITEM_NODROP))
d2164 4
a2167 1
  else if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
d2169 5
a2173 3
  else {
    if (!remove_otrigger(obj, ch))
      return;
d2175 17
a2191 14
    obj_to_char(unequip_char(ch, pos, TRUE), ch, __FILE__, __LINE__);
    act("You stop using $p.", FALSE, ch, obj, 0, TO_CHAR);
    act("$n stops using $p.", TRUE, ch, obj, 0, TO_ROOM);
    if ((obj->obj_flags.type_flag >= BASE_PROTECT_GEAR) &&
        (obj->obj_flags.type_flag < (BASE_PROTECT_GEAR + MAX_PROTECT_GEAR)))
      check_environment_effect(ch);

    // Transfer 2nd wielded item to primary position if first moved ...
    if (pos == WEAR_WIELD && !IS_NPC(ch) && GET_EQ(ch, WEAR_HOLD) &&
	CAN_WEAR(GET_EQ(ch, WEAR_HOLD), ITEM_WEAR_WIELD)) {
      GET_EQ(ch, WEAR_HOLD)->worn_on = WEAR_WIELD;
      GET_EQ(ch, WEAR_WIELD) = GET_EQ(ch, WEAR_HOLD);
      GET_EQ(ch, WEAR_HOLD) = NULL;
    }
d2193 13
a2205 9
/* do a check for lightning and fire shields - DM */
  if (pos == WEAR_SHIELD) {
    if (affected_by_spell(ch, SPELL_LIGHT_SHIELD)) {
      for (af = ch->affected; af; af = next) {
        next = af->next;
        if ((af->type == SPELL_LIGHT_SHIELD) && (af->duration > 0)) {
          send_to_char("The lightning upon your shield fades as you stop using it.\r\n", ch);
          affect_remove(ch,af);
        }
d2207 11
a2217 8
    } 
    if (affected_by_spell(ch, SPELL_FIRE_SHIELD)) {
      for (af = ch->affected; af; af = next) {
        next = af->next;
        if ((af->type == SPELL_FIRE_SHIELD) && (af->duration > 0)) {
          send_to_char("The flaming fire of your shield disappears as you stop using it.\r\n", ch);
          affect_remove(ch,af);
        }
d2219 2
a2220 22
    }
  }
 
/* modifications to remove magic eq AFF flags when eq is remove - Vader */
    if(GET_OBJ_TYPE(obj) == ITEM_MAGIC_EQ)
      for(af = ch->affected; af; af = next) {
        next = af->next;
        if((af->type == GET_OBJ_VAL(obj,0)) ||
           (af->type == GET_OBJ_VAL(obj,1)) ||
           (af->type == GET_OBJ_VAL(obj,2))) {
          if(!af->next || (af->next->type != af->type) ||
             (af->next->duration > 0))
            if(*spell_wear_off_msg[af->type]) {
	      send_to_char("&r", ch);
              send_to_char(spell_wear_off_msg[af->type], ch);
              send_to_char("&n\r\n",ch);
              }
          affect_remove(ch,af);
          }
        }
  }  
}
d2222 23
d2261 1
a2261 1
    for (i = 0; i < NUM_WEARS; i++)
a2263 3
	// Artus> Remove both weapons if dual wielding..
	if (IS_DUAL_WIELDING(ch) && (i == WEAR_WIELD))
	  perform_remove(ch, i);
@


1.22
log
@Latest Version
@
text
@a26 6
#define IS_DUAL_WIELDING(ch)    (!IS_NPC(ch) && \
    			GET_SKILL(ch, SKILL_AMBIDEXTERITY) && \
			GET_EQ(ch, WEAR_WIELD) && \
			GET_EQ(ch, WEAR_HOLD) && \
	    		CAN_WEAR(GET_EQ(ch, WEAR_HOLD), ITEM_WEAR_WIELD))

d2221 5
a2225 1
      if (GET_EQ(ch, i)) {
d2240 2
@


1.21
log
@
Modified: DM

Changed:
- Don't ask (large group checkin) - lots of bug fixes mainly.
- Use cvs diff if you really wanna see the changes.
@
text
@d1844 2
a1845 1
  if (where == WEAR_WIELD && !IS_NPC(ch) && GET_SKILL(ch, SKILL_AMBIDEXTERITY))
d1847 1
a1853 8

    // wielding in 2nd wield position - shield check
    } else if (IS_NPC(ch) && GET_SKILL(ch, SKILL_AMBIDEXTERITY) && 
	  GET_EQ(ch, WEAR_HOLD) && 
	  CAN_WEAR(GET_EQ(ch, WEAR_HOLD), ITEM_WEAR_WIELD) && 
	  GET_EQ(ch, WEAR_SHIELD)) {
        send_to_char("Your shield is in the way.\r\n", ch);
	return;
d1855 1
@


1.20
log
@
Modified: DM

Added:
- Quest eq wear check in invalid_level
@
text
@d2205 1
d2207 1
a2207 1
              send_to_char("\r\n",ch);
@


1.19
log
@
Modified: DM

Changed:
- Moved quest_obj_ok check after level check (in perform_wear)
@
text
@d1597 1
d1599 16
@


1.18
log
@
Modified: DM

Added:
- quest item check in perform_wear() - checks against questlog info ...
@
text
@a1807 6
  // DM - quest item check
  if (!quest_obj_ok(ch, obj)) {
    act("You can't use $p.", FALSE, ch, obj, 0, TO_CHAR);
    return;
  }
      
d1868 6
@


1.17
log
@
Modified: DM

Changed:
- colour touch ups
@
text
@d1808 6
@


1.16
log
@Modified: DM

Changed:
- caster level passed to call_magic for MAGIC_EQ spells/skills from
  2 * level -> level
@
text
@d525 1
a525 1
      sprintf(buf, "Umm, you'd better not touch that. Ask %s for permission.", 
d583 1
a583 1
        sprintf(buf, "Umm, you'd better not touch that. Ask %s for permission.",
@


1.15
log
@Modified: DM

Added:
- dual wielding
@
text
@d1902 3
a1904 3
                        && GET_SKILL(ch, GET_OBJ_VAL(obj, i) > 0)) {
          call_magic(ch, ch, NULL, GET_OBJ_VAL(obj, i), 2 * GET_LEVEL(ch),
                          CAST_MAGIC_OBJ);
d1915 1
@


1.14
log
@Modified: DM

Added:
- move_ship and move_falcon functions
@
text
@d27 6
d1595 1
a1595 1
  int lr=0;
d1599 8
a1606 1
  if (lr && GET_LEVEL(ch) < lr) {
d1608 4
a1611 1
      sprintf(buf,"You can't figure out how to use this item?!?\r\n");
d1703 1
a1703 1
  bool spellsused[3];
d1826 24
a1852 2
//    act("Examining yourself, you realise you cannot wear anything there.",
//                    FALSE, ch, obj, 0, TO_CHAR);
d1857 5
a1861 1
    send_to_char(already_wearing[where], ch);
d1864 1
d1868 1
a1868 1
  if (!wear_otrigger(obj, ch, where))
d1871 6
a1876 1
  wear_message(ch, obj, where);
d2140 8
@


1.13
log
@Artus - Sleight
@
text
@d77 118
@


1.12
log
@Added: slip
@
text
@d452 1
d465 5
d472 7
a478 2
    act("You get $p.", FALSE, ch, obj, 0, TO_CHAR);
    act("$n gets $p.", TRUE, ch, obj, 0, TO_ROOM);
d545 5
@


1.11
log
@*** empty log message ***
@
text
@d841 1
a841 1
		       struct obj_data * obj)
d860 1
a860 1
  if (!give_otrigger(obj, ch, vict) || !receive_mtrigger(vict, ch, obj))
d863 18
a882 3
  act("You give $p to $N.", FALSE, ch, obj, vict, TO_CHAR);
  act("$n gives you $p.", FALSE, ch, obj, vict, TO_VICT);
  act("$n gives $p to $N.", TRUE, ch, obj, vict, TO_NOTVICT);
d957 1
a957 1
	perform_give(ch, vict, obj);
d971 1
a971 1
	perform_give(ch, vict, obj);
d984 1
a984 1
	    perform_give(ch, vict, obj);
d1697 1
a1697 1
  if (!equip_char(ch, obj, where))
d1884 1
d1887 7
a1893 1
    else if (GET_OBJ_WEIGHT(obj) > str_app[STRENGTH_AFF_APPLY_INDEX(ch)].wield_w)
d1895 1
d1897 1
a1897 1
      // DM, 11/99 - changed to obj level (was based on amount of dam it did)    
d1952 1
a1952 1
    obj_to_char(unequip_char(ch, pos), ch, __FILE__, __LINE__);
@


1.10
log
@Modified: DM

Changed:
- Checked spell knowledge on magic eq (ie. does not apply if they dont know
  the spell)
@
text
@d1 2
a2 1
/* ************************************************************************
d203 6
d681 8
d845 5
@


1.9
log
@
Added:
- checks on wearing magic eq - check if player has stats for skill,
- tidyied up that section of peform_wear
@
text
@d1673 1
d1675 1
a1675 1
  if(GET_OBJ_TYPE(obj) == ITEM_MAGIC_EQ && GET_OBJ_VAL(obj,0) > 0) {
d1678 2
a1679 2
    if (GET_OBJ_VAL(obj,3) > 0)
      GET_OBJ_VAL(obj,3)--;
d1681 1
a1681 1
    // DM - Let them use the spell, iff they have the stats for it 
d1684 3
a1686 2
        if (has_stats_for_skill(ch, GET_OBJ_VAL(obj, 0))) {
          call_magic(ch, ch, NULL, GET_OBJ_VAL(obj,i), 2 * GET_LEVEL(ch),
@


1.8
log
@
Added:
- equip_item changes - so magic items are only checked if item is worn
@
text
@d1518 4
d1665 2
a1666 1
/* modification to add spells to objects. 25/12/95 Vader
d1671 2
d1675 3
a1677 2
/* lower the charge */
    if(GET_OBJ_VAL(obj,3) > 0)
d1679 12
a1690 6
    call_magic(ch,ch,NULL,GET_OBJ_VAL(obj,0),2*GET_LEVEL(ch),CAST_MAGIC_OBJ);
    if(GET_OBJ_VAL(obj,1) > 0)
      call_magic(ch,ch,NULL,GET_OBJ_VAL(obj,1),2*GET_LEVEL(ch),CAST_MAGIC_OBJ);
    if(GET_OBJ_VAL(obj,2) > 0)
      call_magic(ch,ch,NULL,GET_OBJ_VAL(obj,2),2*GET_LEVEL(ch),CAST_MAGIC_OBJ);
    for(af = ch->affected; af; af = next) {
d1692 3
a1694 3
      if(af->type == GET_OBJ_VAL(obj,0) ||
         af->type == GET_OBJ_VAL(obj,1) ||
         af->type == GET_OBJ_VAL(obj,2))
d1697 4
a1700 3
/* if its out of power get rid of it */
    if(GET_OBJ_VAL(obj,3) == 0) {
      act("$p disappears as its power deminishes.",FALSE,ch,obj,0,TO_CHAR);
d1702 2
a1703 2
      }
    }     
@


1.7
log
@
Changed:
- junk/donate so LVL_IMMORT+ can junk/donate all
@
text
@d1657 3
a1659 1
  equip_char(ch, obj, where);
@


1.6
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d772 12
a783 7
    /* Can't junk or donate all */
    if ((dotmode == FIND_ALL) && (subcmd == SCMD_JUNK || subcmd == SCMD_DONATE)) {
      if (subcmd == SCMD_JUNK)
	send_to_char("Go to the dump if you want to junk EVERYTHING!\r\n", ch);
      else
	send_to_char("Go do the donation room if you want to donate EVERYTHING!\r\n", ch);
      return;
@


1.5
log
@
Added:
- LVL_ANGEL + ignore on NO_DROP items
@
text
@d24 1
d199 3
d354 2
a355 1
    else {
d373 1
a373 1
      obj_to_char(obj, ch);
d444 1
a444 1
  if (can_take_obj(ch, obj)) {
d458 1
a458 1
    obj_to_char(obj, ch);
d634 6
d664 5
d835 3
d839 1
a839 1
  obj_to_char(obj, vict);
d883 2
d962 1
a962 1
    obj_to_char(obj, tmp_ch);
d1646 4
d1737 2
a1738 1
    if ((where = search_block(arg, keywords, FALSE)) < 0) {
d1741 1
d1882 4
a1885 1
    obj_to_char(unequip_char(ch, pos), ch);
@


1.4
log
@
Added:
- class restrictions on items in invalid_level
- corpse adding/modifying

Changed:
- repairing - just formatting I think
@
text
@d653 1
a653 1
  if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
d807 1
a807 1
  if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
d1850 1
a1850 1
  else if (IS_OBJ_STAT(obj, ITEM_NODROP))
@


1.3
log
@
Added:
- Corpses: to save corpse data when a corpse is modified
           friends, only friends can touch corpses

- Addition of new eq positions
@
text
@d108 1
a108 1
	struct obj_data *o;
d110 1
a110 1
	one_argument(argument, buf);
d112 9
a120 5
	if(!*buf)
	{
	  send_to_char("Repair what?!\r\n", ch);
	  return;
	}
d122 6
a127 5
	if (!(o = get_obj_in_list_vis(ch, buf, ch->carrying))) 
	{
		send_to_char("You don't seem to have that item.\r\n", ch);
		return;
	}
d129 4
a132 11
	if ((GET_OBJ_TYPE(o) == ITEM_WEAPON && !GET_SKILL(ch, SKILL_WEAPONCRAFT)) ||
	    (GET_OBJ_TYPE(o) == ITEM_ARMOR  && !GET_SKILL(ch, SKILL_ARMOURCRAFT)) )
	{
		send_to_char("You don't have the appropriate skill to repair that item.\r\n", ch);
		return;
	}
	if (GET_OBJ_TYPE(o) != ITEM_WEAPON && GET_OBJ_TYPE(o) != ITEM_ARMOR)
	{
		send_to_char("That item cannot be repaired by normal means.\r\n", ch);
		return;
	}
d134 6
a139 6
	// Check the damage status of the item
	if (GET_OBJ_MAX_DAMAGE(o) == -1 ||  GET_OBJ_DAMAGE(o) == GET_OBJ_MAX_DAMAGE(o))
	{
	   send_to_char("It's in perfect condition already.\r\n", ch);
	   return;
	}
d141 2
a142 2
	// Do a check here for some items that might be required to repair
	// ie - anvil, hammer, etc
d144 1
a144 1
	perform_repair(ch, o);	
d150 5
a154 10
	int skillAmt = (GET_OBJ_TYPE(obj) == ITEM_WEAPON ? GET_SKILL(ch, SKILL_WEAPONCRAFT) :
				                           GET_SKILL(ch, SKILL_ARMOURCRAFT)),
	    modifier = 0, str = GET_STR(ch), con = GET_CON(ch);
	float maxAmt = GET_OBJ_MAX_DAMAGE(obj) / 10;
	
	if (maxAmt < 1)
		maxAmt = 1;	// Minimum of at least 1 point up or down

	modifier += (str >= 21 ? 3 : (str >= 18 ? 2 : (str >= 15 ? 1 : (str >= 10 ? 0 : str >= 7 ? -1 : -2))));
	modifier += (con >= 21 ? 3 : (con >= 18 ? 2 : (con >= 15 ? 1 : (con >= 10 ? 0 : con >= 7 ? -1 : -2))));
d156 2
a157 1
	skillAmt += modifier;
d159 2
a160 17
	// Skill amount is now a percentage, max is 95
	if (skillAmt > 95)
		skillAmt = 95;

	if (number(1, 100) > skillAmt)
	{
		// Fucked up, damaged the item
		act("&r$n strikes badly, further damaging $p!&n", FALSE, ch, obj, 0, TO_ROOM);
		act("&rYou struck badly, damaging $p!&n", FALSE, ch, obj, 0, TO_CHAR);
		GET_OBJ_DAMAGE(obj) -= (sh_int)maxAmt;
	}
	else	// Did a repair on the sucker 
	{
		act("&g$n strikes truely, repairing $p.&n", FALSE, ch, obj, 0, TO_ROOM);
		act("&gYou strike well, repairing $p.&n", FALSE, ch, obj, 0, TO_CHAR);
		GET_OBJ_DAMAGE(obj) += (sh_int)maxAmt;
	}
d162 2
a163 7
	// Some checking
	if ((GET_OBJ_DAMAGE(obj) <= 0) && (GET_OBJ_MAX_DAMAGE(obj) != -1))
	{
		act("&r... $p is destroyed completely.&n", FALSE, ch, obj, 0, TO_ROOM);
		act("&r... you destroyed $p completely.&n", FALSE, ch, obj, 0, TO_CHAR);
		extract_obj(obj);
	}
d165 24
a188 2
	if ((GET_OBJ_DAMAGE(obj) > GET_OBJ_MAX_DAMAGE(obj)) || (GET_OBJ_MAX_DAMAGE(obj) == -1))
		GET_OBJ_DAMAGE(obj) = GET_OBJ_MAX_DAMAGE(obj);
d190 3
d450 1
a450 1
      }  
d549 1
a549 1
          corpseData.addCorpse(cont, GET_ROOM_VNUM(ch->in_room));
d573 1
a573 1
          corpseData.addCorpse(cont, GET_ROOM_VNUM(ch->in_room));
d592 1
a592 1
          corpseData.addCorpse(cont, GET_ROOM_VNUM(ch->in_room));
d1390 3
a1392 1
int invalid_level(struct char_data *ch, struct obj_data *object)
d1398 5
a1402 4
  if (lr && GET_LEVEL(ch) <lr)
  {
    sprintf(buf,"You can't figure out how to use this item?!?\r\n");
    act(buf, FALSE,ch,object, 0, TO_CHAR);
d1405 80
d1623 1
a1623 1
  if (invalid_level(ch,obj))
d1804 1
a1804 1
      if (!invalid_level(ch,obj))
@


1.2
log
@my new skills!


Added:
-
-

Removed:
-
-

Changed:
-
-

TODO:
-
-
@
text
@d23 1
d33 2
d38 1
d41 1
d55 1
a55 1
void get_from_container(struct char_data * ch, struct obj_data * cont, char *arg, int mode, int amount);
d60 1
a60 1
void perform_get_from_container(struct char_data * ch, struct obj_data * obj, struct obj_data * cont, int mode);
d75 30
a343 1

d345 2
a346 1
				     struct obj_data * cont, int mode)
d352 16
d379 2
a380 1
			     char *arg, int mode, int howmany)
d385 12
d409 1
a409 1
        perform_get_from_container(ch, obj, cont, mode);
d423 1
a423 1
	perform_get_from_container(ch, obj, cont, mode);
d441 12
d518 1
d546 8
a553 2
      else
	get_from_container(ch, cont, arg1, mode, amount);
d559 2
a560 1
      for (cont = ch->carrying; cont; cont = cont->next_content)
d565 2
a566 1
	    get_from_container(ch, cont, arg1, FIND_OBJ_INV, amount);
d572 8
a579 1
      for (cont = world[ch->in_room].contents; cont; cont = cont->next_content)
d583 2
a584 1
	    get_from_container(ch, cont, arg1, FIND_OBJ_ROOM, amount);
d591 6
d1310 2
a1311 2
    {"$n slides $p on to $s right ring finger.",
    "You slide $p on to your right ring finger."},
d1313 2
a1314 2
    {"$n slides $p on to $s left ring finger.",
    "You slide $p on to your left ring finger."},
d1359 26
a1384 1
    "You grab $p."}
d1418 26
a1443 5
    ITEM_WEAR_TAKE, ITEM_WEAR_FINGER, ITEM_WEAR_FINGER, ITEM_WEAR_NECK,
    ITEM_WEAR_NECK, ITEM_WEAR_BODY, ITEM_WEAR_HEAD, ITEM_WEAR_LEGS,
    ITEM_WEAR_FEET, ITEM_WEAR_HANDS, ITEM_WEAR_ARMS, ITEM_WEAR_SHIELD,
    ITEM_WEAR_ABOUT, ITEM_WEAR_WAIST, ITEM_WEAR_WRIST, ITEM_WEAR_WRIST,
    ITEM_WEAR_WIELD, ITEM_WEAR_TAKE
d1446 30
d1478 3
a1480 3
    "YOU SHOULD NEVER SEE THIS MESSAGE.  PLEASE REPORT.\r\n",
    "You're already wearing something on both of your ring fingers.\r\n",
    "YOU SHOULD NEVER SEE THIS MESSAGE.  PLEASE REPORT.\r\n",
d1491 2
a1492 2
    "YOU SHOULD NEVER SEE THIS MESSAGE.  PLEASE REPORT.\r\n",
    "You're already wearing something around both of your wrists.\r\n",
d1494 9
a1502 1
    "You're already holding something.\r\n"
d1510 16
a1525 2
  /* for neck, finger, and wrist, try pos 2 if pos 1 is already full */
  if ((where == WEAR_FINGER_R) || (where == WEAR_NECK_1) || (where == WEAR_WRIST_R))
d1529 8
d1585 1
a1585 1
    "\r!RESERVED!",
d1587 1
a1587 1
    "\r!RESERVED!",
d1589 1
a1589 1
    "\r!RESERVED!",
d1600 11
a1610 3
    "\r!RESERVED!",
    "\r!RESERVED!",
    "\r!RESERVED!",
d1615 1
a1615 1
    if (CAN_WEAR(obj, ITEM_WEAR_FINGER))      where = WEAR_FINGER_R;
d1617 1
d1621 1
d1745 4
a1748 3
      if (!CAN_WEAR(obj, ITEM_WEAR_HOLD) && GET_OBJ_TYPE(obj) != ITEM_WAND &&
      GET_OBJ_TYPE(obj) != ITEM_STAFF && GET_OBJ_TYPE(obj) != ITEM_SCROLL &&
	  GET_OBJ_TYPE(obj) != ITEM_POTION)
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d37 1
a68 1
ACMD(do_armourcraft) {
d70 42
d114 46
@

