head	1.92;
access;
symbols
	A3_0_59:1.6
	LATEST:1.6
	A3_0_1:1.6;
locks; strict;
comment	@ * @;


1.92
date	2005.02.01.00.27.20;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	2004.11.24.06.19.12;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	2004.08.27.02.10.46;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	2004.08.11.00.49.14;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	2004.07.19.12.34.55;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	2004.07.18.11.16.50;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	2004.07.07.11.37.10;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	2004.06.05.14.45.52;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	2004.06.05.14.43.56;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	2004.05.26.06.51.48;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	2004.05.25.04.39.25;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	2004.05.18.11.43.43;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	2004.05.17.01.12.45;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	2004.05.17.01.07.21;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	2004.05.16.14.33.55;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	2004.05.16.13.08.15;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	2004.05.16.13.06.39;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	2004.05.16.07.01.55;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	2004.05.16.06.06.20;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	2004.05.10.03.21.19;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	2004.05.07.06.09.18;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	2004.05.06.02.23.30;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	2004.04.29.07.59.23;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	2004.04.21.07.05.04;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.11.00.25.04;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	2004.03.01.03.31.52;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	2004.02.23.03.02.59;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	2004.01.30.04.07.56;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	2004.01.29.13.20.37;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.27.09.57.14;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	2004.01.23.06.10.42;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.21.08.07.46;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	2004.01.16.00.42.46;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	2004.01.14.05.55.04;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	2004.01.11.03.46.21;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.10.22.27.20;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.10.12.02.26;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.06.10.48.30;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.06.04.32.51;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.04.10.35.01;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	2004.01.02.02.59.54;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	2003.12.31.22.20.28;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	2003.12.17.02.25.06;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	2003.11.27.06.16.00;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	2003.11.21.05.04.13;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	2003.11.21.04.26.51;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	2003.11.21.02.48.06;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	2003.11.13.01.05.29;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	2003.11.12.11.00.13;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	2003.11.06.03.47.15;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	2003.11.05.12.17.14;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	2003.11.05.03.39.27;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	2003.11.03.17.01.11;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	2003.10.21.09.58.31;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.20.12.01.50;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.14.07.24.16;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	2002.07.20.08.17.56;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.07.14.49.16;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.07.05.14.11;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.26.06.49.04;	author primal;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.14.06.10.18;	author primal;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.25.03.50.02;	author primal;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.07.09.01.09;	author primal;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.07.01.05.33;	author karma;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.25.00.11.31;	author artus;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.20.06.28.41;	author karma;	state Exp;
branches;
next	1.26;

1.26
date	2001.10.28.06.37.47;	author karma;	state Exp;
branches;
next	1.25;

1.25
date	2001.10.28.00.35.51;	author primal;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.27.22.28.09;	author primal;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.12.05.00.04;	author primal;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.11.15.33.09;	author primal;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.11.14.08.34;	author artus;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.12.10.38.12;	author artus;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.09.03.36.13;	author artus;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.03.06.23.10;	author primal;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.03.05.22.22;	author artus;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.03.03.15.58;	author primal;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.28.07.45.21;	author artus;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.26.07.43.59;	author primal;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.26.06.48.31;	author primal;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.11.15.11.04;	author primal;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.11.14.33.04;	author artus;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.10.06.54.53;	author primal;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.11.03.28.30;	author primal;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.08.15.25.23;	author primal;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.02.04.34.48;	author primal;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.20.23.34.53;	author primal;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.17.13.32.40;	author primal;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.14.00.52.56;	author primal;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.14.00.14.59;	author primal;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.12.29.18;	author talisman;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.12.07.43.58;	author mbd;	state Exp;
branches;
next	;


desc
@@


1.92
log
@Artus> Minor bugfixes.. Mod to unholy vengeance.
@
text
@/* ************************************************************************
*   File: fight.c                                       Part of CircleMUD *
*  Usage: Combat system                                                   *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "handler.h"
#include "interpreter.h"
#include "db.h"
#include "spells.h"
#include "screen.h"
#include "constants.h"
#include "corpses.h"
#include "dg_scripts.h"
#include "clan.h"

/* Structures */
struct char_data *combat_list = NULL;	/* head of l-list of fighting chars */
struct char_data *next_combat_list = NULL;

/* External structures */
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct room_data *world;
extern struct message_list fight_messages[MAX_MESSAGES];
extern struct obj_data *object_list;
extern struct spell_info_type spell_info[]; 
extern int pk_allowed;		/* see config.c */
extern int max_exp_gain;	/* see config.c */
extern int max_exp_loss;	/* see config.c */
extern int max_npc_corpse_time, max_pc_corpse_time;

// DM - Saved Corpse Data
extern CorpseData corpseData;

/* External procedures */
char *fread_action(FILE * fl, int nr);
SPECIAL(titan);
ACMD(do_flee);
ACMD(do_violent_skill);
int backstab_mult(int level);
int ok_damage_shopkeeper(struct char_data * ch, struct char_data * victim);
void make_titan_corpse(struct char_data *ch);  
int compute_armor_class(struct char_data *ch, bool divide);
int num_attacks(struct char_data *ch);
int mag_savingthrow(struct char_data * ch, int type, int modifier);
int is_axe(struct obj_data *obj);
int is_blade(struct obj_data *obj);
void clan_pk_update (struct char_data *winner, struct char_data *loser);
int level_exp(struct char_data *ch, int level);
bool violence_check(struct char_data *ch, struct char_data *vict, int skillnum);

/* local functions */
void perform_group_gain(struct char_data * ch, int base, struct char_data * victim);
void dam_message(int dam, struct char_data * ch, struct char_data * victim, int w_type);
void appear(struct char_data * ch);
void load_messages(void);
void check_killer(struct char_data * ch, struct char_data * vict);
struct obj_data *make_corpse(struct char_data * ch);
void change_alignment(struct char_data * ch, struct char_data * victim);
void death_cry(struct char_data * ch);
void raw_kill(struct char_data * ch, struct char_data *killer);
void group_gain(struct char_data * ch, struct char_data * victim);
void solo_gain(struct char_data * ch, struct char_data * victim);
char *replace_string(const char *str, const char *weapon_singular, const char *weapon_plural);
void perform_violence(void);
// int compute_armor_class(struct char_data *ch, bool divide);
// int compute_thaco(struct char_data *ch);  // Artus - Not Used.

/* Weapon attack texts */
// DM - TODO fix the shoot stuff ...
struct attack_hit_type attack_hit_text[] =
{
  {"hit", "hits"},		/* 0 */
  {"sting", "stings"},
  {"whip", "whips"},
  {"slash", "slashes"},
  {"bite", "bites"},
  {"bludgeon", "bludgeons"},	/* 5 */
  {"crush", "crushes"},
  {"pound", "pounds"},
  {"claw", "claws"},
  {"maul", "mauls"},
  {"thrash", "thrashes"},	/* 10 */
  {"pierce", "pierces"},
  {"blast", "blasts"},
  {"punch", "punches"},
  {"stab", "stabs"},
  {"shot", "shoots"},
  {"ERR", "ERRORS"},
  {"ERR", "ERRORS"},
  {"ERR", "ERRORS"},
  {"ERR", "ERRORS"},
  {"shot", "shoot"},
  {"shot", "shoot"},
  {"shot", "shoot"},
  {"shot", "shoot"},
  {"shot", "shoot"},
  {"shot", "shoot"},
  {"shot", "shoot"},
  {"shot", "shoot"},
  {"shot", "shoot"},
  {"shot", "shoot"},
  {"blast", "blast"}     
};

#define IS_WEAPON(type) (((type) >= TYPE_HIT) && ((type) < TYPE_SUFFERING))

/* The Fight related routines */

void appear(struct char_data * ch)
{
  if( !IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_INVIS) )
	return;

  if (affected_by_spell(ch, SPELL_INVISIBLE))
    affect_from_char(ch, SPELL_INVISIBLE);

  REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE | AFF_HIDE);

  if (LR_FAIL(ch, LVL_ANGEL))
    act("$n slowly fades into existence.", FALSE, ch, 0, 0, TO_ROOM);
  else
    act("You feel a strange presence as $n appears, seemingly from nowhere.",
	FALSE, ch, 0, 0, TO_ROOM);
}


int compute_armor_class(struct char_data *ch, bool divide)
{
  /* Artus> I have modified this slightly so that it will always return
   * a figure between +20 and -20.. Make AC a little more meaningful. */
  int armorclass = GET_AC(ch);

  if (AWAKE(ch))
    armorclass += dex_app[GET_DEX(ch)].defensive;

  // Bonus to Armour Class if special  is set
  if ( !IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_SUPERMAN))
	armorclass -= (int)(armorclass * 0.10);

  armorclass = MIN(200, armorclass);
  if (divide)
  {
    if (armorclass > 0)
      armorclass += 5;
    else
      armorclass -= 4;
    armorclass /= 10;
    return (MAX(-20, armorclass));      /* -100 is lowest */
  }
  return (MAX(-200, armorclass));
}


void load_messages(void)
{
  FILE *fl;
  int i, type;
  struct message_type *messages;
  char chk[128];

  if (!(fl = fopen(MESS_FILE, "r"))) {
    basic_mud_log("SYSERR: Error reading combat message file %s: %s", MESS_FILE, strerror(errno));
    exit(1);
  }

  for (i = 0; i < MAX_MESSAGES; i++) {
    fight_messages[i].a_type = 0;
    fight_messages[i].number_of_attacks = 0;
    fight_messages[i].msg = 0;
  }


  fgets(chk, 128, fl);
  while (!feof(fl) && (*chk == '\n' || *chk == '*')) {
    fgets(chk, 128, fl);
  }

  while (*chk == 'M') {
    fgets(chk, 128, fl);
    sscanf(chk, " %d\n", &type);

    for (i = 0; (i < MAX_MESSAGES) && (fight_messages[i].a_type != type) &&
	 (fight_messages[i].a_type); i++);
    if (i >= MAX_MESSAGES) {
      basic_mud_log("SYSERR: Too many combat messages.  Increase MAX_MESSAGES and recompile.");
      exit(1);
    }
    CREATE(messages, struct message_type, 1);
    fight_messages[i].number_of_attacks++;
    fight_messages[i].a_type = type;
    messages->next = fight_messages[i].msg;
    fight_messages[i].msg = messages;

    messages->die_msg.attacker_msg = fread_action(fl, i);
    messages->die_msg.victim_msg = fread_action(fl, i);
    messages->die_msg.room_msg = fread_action(fl, i);
    messages->miss_msg.attacker_msg = fread_action(fl, i);
    messages->miss_msg.victim_msg = fread_action(fl, i);
    messages->miss_msg.room_msg = fread_action(fl, i);
    messages->hit_msg.attacker_msg = fread_action(fl, i);
    messages->hit_msg.victim_msg = fread_action(fl, i);
    messages->hit_msg.room_msg = fread_action(fl, i);
    messages->god_msg.attacker_msg = fread_action(fl, i);
    messages->god_msg.victim_msg = fread_action(fl, i);
    messages->god_msg.room_msg = fread_action(fl, i);
    fgets(chk, 128, fl);
    while (!feof(fl) && (*chk == '\n' || *chk == '*')) {
      fgets(chk, 128, fl);
    }
  }

  fclose(fl);
}


void update_pos(struct char_data * victim)
{
  if ((GET_HIT(victim) > 0) && (GET_POS(victim) > POS_STUNNED))
    return;
  else if (GET_HIT(victim) > 0)
    GET_POS(victim) = POS_STANDING;
  else if (GET_HIT(victim) <= -11)
    GET_POS(victim) = POS_DEAD;
  else if (GET_HIT(victim) <= -6)
    GET_POS(victim) = POS_MORTALLYW;
  else if (GET_HIT(victim) <= -3)
    GET_POS(victim) = POS_INCAP;
  else
    GET_POS(victim) = POS_STUNNED;
}


void check_killer(struct char_data * ch, struct char_data * vict)
{
  char buf[256];

  
  if (PLR_FLAGGED(vict, PLR_KILLER) || PLR_FLAGGED(vict, PLR_THIEF))
    return;
  if (PLR_FLAGGED(ch, PLR_KILLER) || IS_NPC(ch) || IS_NPC(vict) || ch == vict)
    return;
  if (!LR_FAIL(ch, LVL_IS_GOD))
    return;
  if (((GET_CLAN(ch) > 0) || (EXT_FLAGGED(ch, EXT_PKILL))) && 
      ((GET_CLAN(vict) > 0) || (EXT_FLAGGED(vict, EXT_PKILL))))
    return;
  // Artus> Mortal Kombat.
  if (PRF_FLAGGED(ch, PRF_MORTALK) && PRF_FLAGGED(vict, PRF_MORTALK))
    return;

  SET_BIT(PLR_FLAGS(ch), PLR_KILLER);
  sprintf(buf, "PC Killer bit set on %s for initiating attack on %s at %s.",
	    GET_NAME(ch), GET_NAME(vict), world[vict->in_room].name);
  mudlog(buf, BRF, LVL_ANGEL, TRUE);
  send_to_char("If you want to be a PLAYER KILLER, so be it...\r\n", ch);
}


/* start one char fighting another (yes, it is horrible, I know... )  */
void set_fighting(struct char_data * ch, struct char_data * vict, int skillnum)
{
  if (ch == vict)
    return;

  // Artus> Prevent fighting when in writing states.
  if (!IS_NPC(ch) && (ch->desc) && (STATE(ch->desc) > CON_PLAYING))
    return;
  if (!IS_NPC(vict) && (vict->desc) && (STATE(vict->desc) > CON_PLAYING))
    return;

  if (FIGHTING(ch)) {
    core_dump();
    return;
  }

  /* Artus> Don't start them fighting if vict is fighting someone else, and it
   *        was a spell, or throw style skill that was performed. */
  if (FIGHTING(vict) && (FIGHTING(vict) != ch))
  {
    if ((skillnum > 0) && (skillnum <= MAX_SPELLS))
      return;
    switch (skillnum)
    {
      case SKILL_PRIMAL_SCREAM:
      case SKILL_THROW:
      case SKILL_AXETHROW:
	return;
    }
  }
  ch->next_fighting = combat_list;
  combat_list = ch;

  if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_MEDITATE))
    timer_from_char(ch, TIMER_MEDITATE);
  
  if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_HEAL_TRANCE))
    timer_from_char(ch, TIMER_HEAL_TRANCE);
  
  if (AFF_FLAGGED(ch, AFF_SLEEP))
    affect_from_char(ch, SPELL_SLEEP);

  FIGHTING(ch) = vict;
  GET_POS(ch) = POS_FIGHTING;
  
  if (!IS_NPC(ch) && !IS_NPC(vict))
    if (!INSTIGATOR(vict)) 
      INSTIGATOR(ch) = TRUE;

  if (!pk_allowed)
    check_killer(ch, vict);
}



/* remove a char from the list of fighting chars */
void stop_fighting(struct char_data * ch)
{
  struct char_data *temp;

  if (ch == next_combat_list)
    next_combat_list = ch->next_fighting;

  REMOVE_FROM_LIST(ch, combat_list, next_fighting);
  ch->next_fighting = NULL;
  FIGHTING(ch) = NULL;
  GET_POS(ch) = POS_STANDING;
  update_pos(ch);

  if (!IS_NPC(ch) && (AFF_FLAGGED(ch, AFF_BERSERK)))
    REMOVE_BIT(AFF_FLAGS(ch), AFF_BERSERK);

  if (MOUNTING(ch) && FIGHTING(MOUNTING(ch)))
	stop_fighting(MOUNTING(ch));
}

struct obj_data *make_corpse(struct char_data * ch)
{
  struct obj_data *corpse, *o;
  struct obj_data *money;
  room_rnum deathroom = NOWHERE; // Artus> Replaces room_vnum roomvnum;
  int i;

  corpse = create_obj();

  corpse->item_number = NOTHING;
  corpse->in_room = NOWHERE;

  sprintf(buf2, "The corpse of %s is lying here.", GET_NAME(ch));
  corpse->description = str_dup(buf2);

  sprintf(buf2, "the corpse of %s", GET_NAME(ch));
  corpse->short_description = str_dup(buf2);

  GET_OBJ_TYPE(corpse) = ITEM_CONTAINER;
  GET_OBJ_WEAR(corpse) = ITEM_WEAR_TAKE;
  GET_OBJ_EXTRA(corpse) = ITEM_NODONATE;
  GET_OBJ_VAL(corpse, 0) = 0;	/* You can't store stuff in a corpse */

  GET_OBJ_VAL(corpse, 3) = 1;	/* corpse identifier */
  // DM - Using obj value 2 to store whether the idnum of the player if it is 
  // a PC corpse, use GET_CORPSEID macro to get idnum
  if (IS_NPC(ch)) {
    GET_OBJ_VAL(corpse, 2) = 0;	/* npc corpse identifier */
    corpse->name = str_dup("corpse");
  } else {
    sprintf(buf,"Creating PC corpse of %s", GET_NAME(ch));
    basic_mud_log(buf);
    corpse->name = str_dup("corpse pcorpse");
    GET_OBJ_VAL(corpse, 2) = GET_IDNUM(ch);	/* pc corpse identifier */
  }
  //sprintf(buf,"Idnum of corpse: %d", GET_CORPSEID(corpse));
  //basic_mud_log(buf);

  GET_OBJ_WEIGHT(corpse) = GET_WEIGHT(ch) + IS_CARRYING_W(ch);
  GET_OBJ_COST(corpse) = GET_LEVEL(ch);  
  GET_OBJ_RENT(corpse) = 100000;
  if (IS_NPC(ch))
    GET_OBJ_TIMER(corpse) = max_npc_corpse_time;
  else
    GET_OBJ_TIMER(corpse) = max_pc_corpse_time;

  /* transfer character's inventory to the corpse */
  corpse->contains = ch->carrying;
  for (o = corpse->contains; o != NULL; o = o->next_content)
    o->in_obj = corpse;
  object_list_new_owner(corpse, NULL);

  /* transfer character's equipment to the corpse */
  for (i = 0; i < NUM_WEARS; i++) 
    if (GET_EQ(ch, i))
    {
      remove_otrigger(GET_EQ(ch, i), ch);
      obj_to_obj(unequip_char(ch, i, FALSE), corpse);
    }

  /* transfer gold */
  if (GET_GOLD(ch) > 0)
  {
    /* following 'if' clause added to fix gold duplication loophole */
    if (IS_NPC(ch) || (!IS_NPC(ch) && ch->desc))
    {
      money = create_money(GET_GOLD(ch));
      obj_to_obj(money, corpse);
    }
    GET_GOLD(ch) = 0;
  }
  ch->carrying = NULL;
  IS_CARRYING_N(ch) = 0;
  IS_CARRYING_W(ch) = 0;

#define VNUM_TAVERN 1112
// Artus> What's the point?... We use the rnum for everything.
// room_vnum roomvnum;

  // Artus> Changed to drop corpse outside DTs.
  if (!IS_NPC(ch) && EXT_FLAGGED(ch, EXT_AUTOCORPSE))
    deathroom = real_room(VNUM_TAVERN);
  else
    deathroom = IN_ROOM(ch);
  if ((deathroom == NOWHERE) || is_death_room(deathroom))
  {
    if (LASTROOM(ch) != NOWHERE)
      deathroom = LASTROOM(ch);
  }
  if (!IS_NPC(ch))
  {
    if (deathroom == NOWHERE)
    {
      deathroom = real_room(VNUM_TAVERN);
      if (deathroom == NOWHERE)
      {
	sprintf(buf, "SYSERR: NOWHERE for corpse of %s. (Tav: %d, In: %d(v%d), Last: %d(v%d)", GET_NAME(ch), VNUM_TAVERN, IN_ROOM(ch), 
	       world[IN_ROOM(ch)].number, LASTROOM(ch), 
	       world[LASTROOM(ch)].number);
	mudlog(buf, NRM, MAX(GET_INVIS_LEV(ch), LVL_GOD), TRUE);
	deathroom = 1;
      }
    }
    sprintf(buf, "(PCorpse) Corpse of %s left in room #%d - %s.",
	    GET_NAME(ch), world[deathroom].number, world[deathroom].name);
    mudlog(buf, CMP, MAX(GET_INVIS_LEV(ch), LVL_GOD), TRUE);
  }

  /* Artus> The old way...
  if (!IS_NPC(ch) && EXT_FLAGGED(ch, EXT_AUTOCORPSE))
    roomvnum = VNUM_TAVERN;
  else
    roomvnum = GET_ROOM_VNUM(ch->in_room); */

  // DM - Save the corpse data, addCorpse will be called again in obj_to_room,
  // but we must set the weight first ...
  if (!IS_NPC(ch))
    corpseData.addCorpse(corpse, world[deathroom].number, GET_WEIGHT(ch)); 

  obj_to_room(corpse, deathroom);

  return corpse;
}

// DM - TODO - see if ch->affected->type is actually being used

/* When ch kills victim */
void change_alignment(struct char_data * ch, struct char_data * victim)
{
  struct affected_type *af, *next;        

  /*
   * new alignment change algorithm: if you kill a monster with alignment A,
   * you move 1/16th of the way to having alignment -A.  Simple and fast.
   */
  GET_ALIGNMENT(ch) += (-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) / 16;

  /* Check alignment restrictions - DM */
  if (affected_by_spell(ch,SPELL_PROT_FROM_GOOD) && !IS_EVIL(ch))
      for (af = ch->affected; af; af = next) {
        next = af->next;
        if ((af->type == SPELL_PROT_FROM_GOOD) && (af->duration > 0)) {
          send_to_char("You no longer feel the need for protection from good beings.\r\n", ch);
          affect_remove(ch,af);
        }
      }
 
  if (affected_by_spell(ch,SPELL_PROT_FROM_EVIL) && !IS_GOOD(ch))
      for (af = ch->affected; af; af = next) {
        next = af->next;
        if ((af->type == SPELL_PROT_FROM_EVIL) && (af->duration > 0)) {
          send_to_char("You no longer feel the need for protection from evil beings.\r\n", ch);
          affect_remove(ch,af);
        }
      }     
}



void death_cry(struct char_data * ch)
{
  int door;

  act("Your blood freezes as you hear $n's death cry.", FALSE, ch, 0, 0, TO_ROOM);

  for (door = 0; door < NUM_OF_DIRS; door++)
    if (CAN_GO(ch, door))
      send_to_room("Your blood freezes as you hear someone's death cry.\r\n",
		   world[ch->in_room].dir_option[door]->to_room);
}

void raw_kill(struct char_data * ch, struct char_data *killer)
{
  void clan_tax_update (struct char_data *ch, struct char_data *vict);
  struct obj_data *corpse = NULL, *obj, *next_obj = NULL;
  bool found=FALSE, arms_full=FALSE;
  int amount, num=1, share;
  struct char_data *k, *scab;
  struct follow_type *f;
  struct affected_type *af, *next_af;
  int corpseModified = 0;
  void handle_quest_mob_death(struct char_data *ch, struct char_data *killer);
 
  extern struct index_data *mob_index;
 
  void perform_get_from_container(struct char_data * ch, struct obj_data * obj,
				  struct obj_data * cont, int mode, 
				  int *corpseModified);
  stop_fighting(ch);
  // Artus> Stop the killer fighting, if necessary.
  if ((killer) && (FIGHTING(killer) == ch)) 
    stop_fighting(killer);
 
  if (IS_NPC(ch) && MOB_FLAGGED(ch, MOB_QUEST))
    handle_quest_mob_death(ch, killer);

  for(af = ch->affected; af; af = next_af)
  {
    next_af = af->next;
    if ((af->duration != CLASS_ABILITY) &&
	(af->duration != CLASS_ITEM))
      affect_remove(ch, ch->affected);
  }
 
  if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_MORTALK))
  {
    REMOVE_BIT(PRF_FLAGS(ch), PRF_MORTALK);
    call_magic(ch,ch,NULL,SPELL_WORD_OF_RECALL,GET_LEVEL(ch),CAST_MAGIC_OBJ);
    GET_HIT(ch) = MAX(GET_HIT(ch), GET_MAX_HIT(ch));
    GET_MANA(ch) = 100;
    GET_POS(ch) = POS_STUNNED;
  } else {
    /* remove wolf/vamp infections so ya hafta be reinfected after death */
    if (!IS_NPC(ch))
    {
      REMOVE_BIT(PRF_FLAGS(ch),PRF_WOLF | PRF_VAMPIRE);
      SET_BIT(EXT_FLAGS(ch), EXT_GHOST);
    }

    if(GET_HIT(ch) > 0)
      GET_HIT(ch) = 0;
 
    // DM - added killer != ch, check - suicide ...
    if (killer && killer != ch) 
    {
      if (!IS_NPC(ch) && !IS_NPC(killer)) 
        clan_pk_update(killer, ch);
      if (IS_NPC(ch) && !IS_NPC(killer))
      {
	GET_MOBKILLS(killer)++;
	clan_tax_update(killer, ch);
      }
      if (!IS_NPC(ch) && IS_NPC(killer))
	GET_KILLSBYMOB(ch)++;
      if (death_mtrigger(ch, killer))
        death_cry(ch);
    } else
      death_cry(ch);

    if (GET_MOB_SPEC(ch) == titan)
    {
      make_titan_corpse(ch);
      extract_char(ch);
      return;
    }
    corpse = make_corpse(ch);
 
    // Dismount
    if (MOUNTING(ch)) 
	MOUNTING(MOUNTING(ch)) = NULL;
    if (MOUNTING_OBJ(ch))
	OBJ_RIDDEN(MOUNTING_OBJ(ch)) = NULL;

    MOUNTING(ch) = NULL;
    MOUNTING_OBJ(ch) = NULL;

    /* DM - check to see if someone killed ch, or if we dont have a corpse */
    if (!killer || !corpse) 
    {
      extract_char(ch);
      return;
    }
 
  /* DM - autoloot/autogold - automatically loot if ch is NPC
        and they are in the same room */
 
    if (((!IS_NPC(killer) && IS_NPC(ch)) && 
         (killer->in_room == ch->in_room)) ||
         (IS_CLONE_ROOM(killer))) 
    {
      // make sure we have the master if a clone made the kill
      scab = (IS_CLONE_ROOM(killer) ? killer->master : killer);
      if (!scab || IS_NPC(scab)) // bail
        return;
      /* Auto Loot */
      if (EXT_FLAGGED(scab, EXT_AUTOLOOT)) 
      {
        for (obj = corpse->contains; obj && !arms_full; obj = next_obj) {
          if (IS_CARRYING_N(scab) >= CAN_CARRY_N(scab)) 
	  {
            send_to_char("Your arms are already full!\r\n", scab);
            arms_full = TRUE;
            continue;
          }
          next_obj = obj->next_content;
          if (CAN_SEE_OBJ(scab, obj) && (GET_OBJ_TYPE(obj) != ITEM_MONEY)) 
	  {
            // DM - autoloot isnt going to work on PC corpses, ignore corpse
            // saving
            perform_get_from_container(scab, obj, corpse, 0, &corpseModified);
            found = TRUE;
          }
        }
        if (!found)
          act("$p seems to be empty.", FALSE, scab, corpse, 0, TO_CHAR);
      } 
 
      /* Auto Gold */
      if (EXT_FLAGGED(scab, EXT_AUTOGOLD)) 
      {
        for (obj = corpse->contains; obj; obj = next_obj) 
	{
          next_obj = obj->next_content;
          if ((GET_OBJ_TYPE(obj) == ITEM_MONEY) && (GET_OBJ_VAL(obj, 0) > 0)) 
	  {
            /* Auto Split */
            if (EXT_FLAGGED(scab, EXT_AUTOSPLIT) && 
		IS_AFFECTED(scab, AFF_GROUP)) 
	    {
              amount = GET_OBJ_VAL(obj, 0);
              k = (scab->master ? scab->master : scab);
              // check followers of master
              for (f = k->followers; f; f = f->next) {
                if (IS_AFFECTED(f->follower, AFF_GROUP) && 
		    (!IS_NPC(f->follower)) && (f->follower != scab) && 
                    (f->follower->in_room == scab->in_room))
                  num++;
              }
              // now check scab vs master
              if (k != scab && k->in_room == scab->in_room)
                num++;
              if (num == 1)
                perform_get_from_container(scab, obj, corpse, 0,
                                &corpseModified);
              else 
	      {
                obj_from_obj(obj); 
                share = amount / num;
                GET_GOLD(scab) += share;
                sprintf(buf, "You split &Y%d&n coins among %d members -- &Y%d&n coins each.\r\n", amount, num, share); send_to_char(buf, scab);
                // check followers of master
                for (f=k->followers; f;f=f->next) 
		{
                  if (IS_AFFECTED(f->follower, AFF_GROUP) &&
                      (!IS_NPC(f->follower)) &&
                      (f->follower->in_room == scab->in_room) &&
                      f->follower != scab) 
		  {
                    GET_GOLD(f->follower) += share;
                    sprintf(buf, "&7%s&n splits &Y%d&n coins; you receive &Y%d&n.\r\n",
                      GET_NAME(scab), amount, share);
                    send_to_char(buf, f->follower);
                  }
                }
		extract_obj(obj);
                // now check scab vs master
                if (k != scab && IS_AFFECTED(k, AFF_GROUP) && (k->in_room == scab->in_room)
                    && !(IS_NPC(k))) 
		{
                  GET_GOLD(k) += share;
                  sprintf(buf, "&7%s&n splits &Y%d&n coins; you receive &Y%d&n.\r\n", GET_NAME(scab), amount, share);
                  send_to_char(buf, k);
                }
              }
          /* Not grouped or autosplitting */
            } else
              // DM - autoloot isnt going to work on PC corpses, ignore corpse
              // saving
              perform_get_from_container(scab, obj, corpse, 0, &corpseModified);
          }
        }
      } /* End of Autogold */
    } /* End of Auto loot/gold/split able */
    extract_char(ch);
  } 
}



void die(struct char_data * ch, struct char_data *killer, char *msg)
{
  int exp_lost = 0;
  extern struct zone_data *zone_table;
  
  if (killer)
    GET_WAIT_STATE(killer) = 0;

  if (IS_NPC(ch))
  {
    raw_kill(ch, killer);
    return;
  }

  basic_mud_log("DBG: %s exp prior to death: %d", GET_NAME(ch), GET_EXP(ch));

  if (!PRF_FLAGGED(ch, PRF_MORTALK))
  {
  /* DM_exp : If exp is not negative (which it shouldn't be ie level min = 0)
                use (exp this level)/2 */
    if (GET_EXP(ch) > 0) 
    {
      exp_lost = MIN((int)(level_exp(ch, GET_LEVEL(ch) + 2)/4),
	             (int)(GET_EXP(ch)/2));
      exp_lost = 0-gain_exp(ch, 0-exp_lost);
      // autocorpse - half of current level exp ...
      if (EXT_FLAGGED(ch, EXT_AUTOCORPSE))
        exp_lost += gain_exp(ch, exp_lost>>1);
    } else
      GET_EXP(ch) = 0;
    if (killer)
    {
      if (PLR_FLAGGED(ch, PLR_KILLER) && (killer != ch))
	REMOVE_BIT(PLR_FLAGS(ch), PLR_KILLER);
      sprintf(buf2, "%s killed by %s at %s (Lost %d Exp)", GET_NAME(ch), 
	      (killer != ch) ? GET_NAME(killer) : "stupidity", 
	      world[killer->in_room].name, exp_lost);
      mudlog(buf2, BRF, LVL_ANGEL, TRUE);
    } else if (msg) {
      sprintf(buf2, "%s killed by %s at %s (Lost %d Exp)", GET_NAME(ch),
	      msg, world[IN_ROOM(ch)].name, exp_lost);
      mudlog(buf2, BRF, LVL_ANGEL, TRUE);
    } else {
      sprintf(buf2, "%s killed by unknown at %s (Lost %d Exp)", 
	      GET_NAME(ch), world[IN_ROOM(ch)].name, exp_lost);
      mudlog(buf2, BRF, LVL_ANGEL, TRUE);
    }
    sprintf(buf2, "&[&7%s&] has been slain in %s!", GET_NAME(ch), 
	    zone_table[world[IN_ROOM(ch)].zone].name);
    info_channel(buf2, ch);
    GET_GOLD(ch)=(int)(GET_GOLD(ch)*0.9);
    REMOVE_BIT(PLR_FLAGS(ch), PLR_KILLER | PLR_THIEF);
  }

  basic_mud_log("DBG: %s exp after death: %d", GET_NAME(ch), GET_EXP(ch));

  // Artus - Newbie Protection
  if (LR_FAIL_MAX(ch, LVL_NEWBIE))
  {
    if (killer && killer != ch)
    {
      if (!IS_NPC(ch) && !IS_NPC(killer)) 
        clan_pk_update(killer, ch);
      if (IS_NPC(ch) && !IS_NPC(killer))
	GET_MOBKILLS(killer)++;
      if (!IS_NPC(ch) && IS_NPC(killer))
	GET_KILLSBYMOB(ch)++;
      if (death_mtrigger(ch, killer))
        death_cry(ch);
    }
    stop_fighting(ch);
    char_from_room(ch);
    char_to_room(ch, real_room(SAVE_ROOM_VNUM));
    GET_HIT(ch) = 1;
    GET_POS(ch) = POS_RESTING;
    SET_BIT(EXT_FLAGS(ch), EXT_GHOST);
    send_to_char("You wake up in Haven's riverside tavern, however you find yourself to be\r\nnot quite whole. You are have become a &WGhost&n. This affect will last\r\nuntil you have reached your maximum hit point level.\r\n", ch);
    return;
  }

  raw_kill(ch,killer);
}



void perform_group_gain(struct char_data * ch, int base,
			     struct char_data * victim)
{
  int share;
  struct event_data *ev;
  extern struct event_list events;

  share = MIN(max_exp_gain, MAX(1, base));

  if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_MORTALK))
    return;
  if (PLR_FLAGGED(victim, PLR_KILLER))
    return;
  if (IS_NPC(victim) && (GET_MOB_VZNUM(victim) == CLAN_ZONE) || 
      MOB_FLAGGED(victim, MOB_NOKILL))
    return;

  if (share > 1) 
  {
    sprintf(buf2, "You receive your share of experience -- &c%d&n points.\r\n", (int)(share * (1/GET_MODIFIER(ch))));
    send_to_char(buf2, ch);
  } else
    send_to_char("You receive your share of experience -- one measly little point!\r\n", ch);

  share = gain_exp(ch, share);
  if (share > 0) 
    for(ev = events.list; ev; ev = ev->next)
      if (ev->type == EVENT_HAPPY_HR)
      {
	sprintf(buf, "Happy Hour! You gain a further &c%d&n exp!\r\n", share);
	send_to_char(buf, ch);
	gain_exp(ch, share);
	break;
      }
  change_alignment(ch, victim);
}


void group_gain(struct char_data * ch, struct char_data * victim)
{
  int tot_members, base, exp;
  struct char_data *k;
  struct follow_type *f;
  int min_level = LVL_IMPL, max_level = 0, group_level, av_group_level, percent; 

  if (!(k = ch->master))
    k = ch;

  if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_MORTALK))
  {
     stop_fighting(ch);
     stop_fighting(victim);
     send_to_char("You are the SUPREME warrior of the Mortal Kombat arena!\r\n",
                  ch);
     return;
  }
  if (PLR_FLAGGED(victim, PLR_KILLER)){
           send_to_char("You receive No EXP for killing players with the KILLER flag\r\n", ch);
           return;
   }
 
  group_level = GET_LEVEL(k);
  max_level = min_level = MAX(max_level, GET_LEVEL(k));

  if (AFF_FLAGGED(k, AFF_GROUP) && (k->in_room == ch->in_room))
    tot_members = 1;
  else
    tot_members = 0;

  // TODO: construct a fancier base exp - based on classes in group etc ...
  // ie. something to replace the next 30 odd lines in a new function.
//  base = calc_group_exp_base(ch, &min_level, &max_level, &tot_members);
  
  for (f = k->followers; f; f = f->next)
    if (AFF_FLAGGED(f->follower, AFF_GROUP) && 
                    f->follower->in_room == ch->in_room)

      // DM - Dont include CLONES if they are grouped 
      // if (!IS_CLONE(f->follower)) {
      // Artus - Don't include NPCs if they are grouped.
      if (!IS_NPC(f->follower))
      {
        tot_members++;
        group_level += GET_LEVEL(f->follower);
        min_level = MIN(min_level, GET_LEVEL(f->follower));
        max_level = MAX(max_level, GET_LEVEL(f->follower));
      }   
  
  av_group_level = group_level / tot_members;

  /* cap it to LVL_IMPL */
  group_level = MIN(LVL_IMPL, group_level - tot_members);  

  /* round up to the next highest tot_members */
  base = (GET_EXP(victim) / 3) + tot_members - 1;

  /* prevent illegal xp creation when killing players */
  //if (!IS_NPC(victim))
  //  base = MIN(max_exp_loss * 2 / 3, tot_gain);

  /* DM group gain percentage */
  if (tot_members >= 1) {
    /* base = MAX(1, GET_EXP(victim) / 3) / tot_members; */
    if (tot_members == 2)
        base=(GET_EXP(victim)*50/*80*/)/100;
    else if (tot_members == 3)
        base=(GET_EXP(victim)*55/*85*/)/100;
    else if (tot_members == 4)
        base=(GET_EXP(victim)*60/*90*/)/100;
    else if (tot_members == 5)
        base=(GET_EXP(victim)*40/*70*/)/100;
    else if (tot_members == 6)
        base=(GET_EXP(victim)*35/*65*/)/100;
    else if (tot_members == 7)
        base=(GET_EXP(victim)*25/*55*/)/100;
    else if (tot_members == 8)
        base=(GET_EXP(victim)*5/*20*/)/100;
    else
      base=0;
  } else
    base = 0;  


//  if (AFF_FLAGGED(k, AFF_GROUP) && k->in_room == ch->in_room)
//    perform_group_gain(k, base, victim);

  if (IS_AFFECTED(k, AFF_GROUP) && k->in_room == ch->in_room)
  {
      if (GET_LEVEL(victim) < av_group_level)
      {
        base = ((GET_EXP(victim) / 3) + tot_members - 1)/tot_members;
        percent = MAX(10, 100 - ((GET_LEVEL(ch) - GET_LEVEL(victim)) * 10));
        exp = (base * percent) / 100;
        sprintf(buf2, "Your opponent was out of your group's league! You don't learn as much.\n\r");
        send_to_char(buf2, k);
      }
      else
        exp = base;
 
      if (((max_level - min_level) > 10) && (tot_members > 1))
      {
        if (exp > (((GET_EXP(victim) / 3) + tot_members - 1)/tot_members))
          exp = base = ((GET_EXP(victim) / 3) + tot_members - 1)/tot_members;
        sprintf(buf2, "The group is unbalanced! You learn much less.\n\r");
        send_to_char(buf2, k);
        exp = (exp * GET_LEVEL(k)) / group_level;
      }
      perform_group_gain(k, exp, victim);
   }                                       

//  for (f = k->followers; f; f = f->next)
//    if (AFF_FLAGGED(f->follower, AFF_GROUP) && f->follower->in_room == ch->in_room)
//      perform_group_gain(f->follower, base, victim);

  for (f = k->followers; f; f = f->next)
    if (IS_AFFECTED(f->follower, AFF_GROUP) && f->follower->in_room == ch->in_room)
    {
    /* DM - Dont include CLONES if they are grouped */
    if (!IS_CLONE(f->follower)) {
 
      if (GET_LEVEL(victim) < av_group_level)
      {
        percent = MAX(10, 100 - ((GET_LEVEL(ch) - GET_LEVEL(victim)) * 10));
        exp = (base * percent) / 100;
        sprintf(buf2, "Your opponent was out of your group's league! You don't learn as much.\n\r");
        send_to_char(buf2, f->follower);
      }
      else
        exp = base;
      if ((max_level - min_level) > 10)
      {
        sprintf(buf2, "The group is unbalanced! You learn much less.\n\r");
        send_to_char(buf2, f->follower);
        exp = (exp * GET_LEVEL(f->follower)) / (group_level*2);
      }
      perform_group_gain(f->follower, exp, victim);
    }
  }           
}


void solo_gain(struct char_data * ch, struct char_data * victim)
{
  int exp, percent, mod_exp;
  struct event_data *ev;
  extern struct event_list events;

  exp = MIN(max_exp_gain, GET_EXP(victim) / 3);
 
  if (IS_NPC(victim) && (GET_MOB_VZNUM(victim) == CLAN_ZONE))
  {
    if (!IS_NPC(ch))
      send_to_char("You are satisfied with your kill even though you gain nothing.\r\n", ch);
    return;
  }

  /* Calculate level-difference bonus */
  if (IS_NPC(ch) && !IS_CLONE(ch))
    exp += MAX(0, (exp * MIN(4, (GET_LEVEL(victim) - GET_LEVEL(ch)))) >> 3);
  else {
//          exp += MAX(0, (exp * MIN(8, (GET_LEVEL(victim) - GET_LEVEL(ch)))) >> 3);
 
    // Give exp to rider
    if (MOUNTING(ch) && IS_NPC(ch) && !IS_CLONE(ch))
      ch = MOUNTING(ch);

/* JA new level difference code */
    if (GET_LEVEL(victim) < GET_LEVEL(ch)) {
      percent = MAX(10, 100 - ((GET_LEVEL(ch) - GET_LEVEL(victim)) * 10));
      percent = MIN(percent, 100);
      exp = (exp * percent) / 50;
      if (percent <= 60) {
        sprintf(buf2, "Your opponent was out of your league! You don't learn "
                        "as much.\n\r");
        if (IS_CLONE(ch) && IS_CLONE_ROOM(ch))
          send_to_char(buf2, ch->master);
        else
          send_to_char(buf2, ch);
      }
    }
  }
 
/* this is to stop people abusing the no exp loss below your level code
 * and it adds a punishment for killing in a non-pk zone - Vader
 */
#ifdef JOHN_DISABLE
  if(GET_EXP(victim) <= level_exp(ch,GET_LEVEL(victim)) + 10000 ||
     !IS_SET(zone_table[world[ch->in_room].zone].zflag,ZN_PK_ALLOWED))
    exp = -(GET_LEVEL(victim) * 10000);
  else
#endif
    exp = MAX(exp, 1);    

  // Disp the actual exp they will gain - apply the modifiers here...
  if (IS_NPC(ch) && !IS_CLONE(ch)) {
    mod_exp = exp;
  } else {
    if (IS_CLONE(ch) ) {
      mod_exp = (int)(exp * (1 / GET_MODIFIER(ch->master)));
    } else {
      mod_exp = (int)(exp * (1 / GET_MODIFIER(ch)));
    }
  }

  if (IS_CLONE(ch) && IS_CLONE_ROOM(ch))
    ch = ch->master;

  // DM - TODO - check player specials in here ...
  if (PLR_FLAGGED(victim, PLR_KILLER)){
/*  if (IS_CLONE(ch) && IS_CLONE_ROOM(ch))
      send_to_char("You receive No EXP for killing players with the KILLER "
                      "flag!.\r\n", ch->master);
    else
    */
      send_to_char("You receive No EXP for killing players with the KILLER "
                      "flag!.\r\n", ch);
    exp = 0;
  } else if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_MORTALK)) {
/*  if (IS_CLONE(ch) && IS_CLONE_ROOM(ch))
      send_to_char("You are the SUPREME winner of Mortal Kombat!!\r\n", 
                      ch->master);
    else
    */
      send_to_char("You are the SUPREME winner of Mortal Kombat!!\r\n", ch);
    exp = 0;
  } else if (exp > 1) {
/*  if (IS_CLONE(ch) && IS_CLONE_ROOM(ch)) {
      sprintf(buf2, "You receive %s%d%s experience points.\r\n",
                CCEXP(ch->master,C_NRM),mod_exp,CCNRM(ch->master,C_NRM));
      send_to_char(buf2, ch->master);
    } else {
      sprintf(buf2, "You receive %s%d%s experience points.\r\n",
                CCEXP(ch,C_NRM),mod_exp,CCNRM(ch,C_NRM));
      send_to_char(buf2, ch);
    }
    */
    sprintf(buf2, "You receive %s%d%s experience points.\r\n",
	      CCEXP(ch,C_NRM),mod_exp,CCNRM(ch,C_NRM));
    send_to_char(buf2, ch);
  } else 
/*  if (IS_CLONE(ch) && IS_CLONE_ROOM(ch))
      send_to_char("You receive one lousy experience point.\r\n", ch->master);
    else
    */
      send_to_char("You receive one lousy experience point.\r\n", ch);
 
  /* DM - dont let clones steal exp */
  /*
  if (IS_CLONE_ROOM(ch)) {
    mod_exp = gain_exp(ch->master, exp);
    change_alignment(ch->master, victim);
  } else {
    mod_exp = gain_exp(ch, exp);
    if (!IS_CLONE(ch))
      change_alignment(ch, victim); 
  }
  */
  mod_exp = gain_exp(ch, exp);
  if (!IS_CLONE(ch))
    change_alignment(ch, victim);

  if (mod_exp > 0) 
    for(ev = events.list; ev; ev = ev->next)
      if (ev->type == EVENT_HAPPY_HR)
      {
	sprintf(buf, "Happy Hour! You gain a further &c%d&n exp!\r\n", mod_exp);
	send_to_char(buf, ch);
	gain_exp(ch, mod_exp);
	break;
      }
}


char *replace_string(const char *str, const char *weapon_singular, const char *weapon_plural)
{
  static char buf[256];
  char *cp = buf;

  for (; *str; str++) {
    if (*str == '#') {
      switch (*(++str)) {
      case 'W':
	for (; *weapon_plural; *(cp++) = *(weapon_plural++));
	break;
      case 'w':
	for (; *weapon_singular; *(cp++) = *(weapon_singular++));
	break;
      default:
	*(cp++) = '#';
	break;
      }
    } else
      *(cp++) = *str;

    *cp = 0;
  }				/* For */

  return (buf);
}


/* message for doing damage with a weapon */
void dam_message(int dam, struct char_data * ch, struct char_data * victim,
		      int w_type)
{
  char *buf;
  int msgnum;

  static struct dam_weapon_type {
    const char *to_room;
    const char *to_char;
    const char *to_victim;
  } dam_weapons[] = {
 
    /* use #w for singular (i.e. "slash") and #W for plural (i.e. "slashes") */
 
    {
      "$n tries to #w $N, but misses.", /* 0: 0     */
      "You try to #w $N, but miss.",
      "$n tries to #w you, but misses."
    },
 
    {
      "$n tickles $N as $e #W $M.",     /* 1: 1..2  */
      "You tickle $N as you #w $M.",
      "$n tickles you as $e #W you."
    },
 
    {
      "$n barely #W $N.",               /* 2: 3..4  */
      "You barely #w $N.",
      "$n barely #W you."
    },
 
    {
      "$n #W $N.",                      /* 3: 5..6  */
      "You #w $N.",
      "$n #W you."
    },
 
    {
      "$n #W $N hard.",                 /* 4: 7..10  */
      "You #w $N hard.",
      "$n #W you hard."
    },
 
    {
      "$n #W $N very hard.",            /* 5: 11..14  */
      "You #w $N very hard.",
      "$n #W you very hard."
    },
 
    {
      "$n #W $N extremely hard.",       /* 6: 15..19  */
      "You #w $N extremely hard.",
      "$n #W you extremely hard."
    },
 
    {
      "$n causes internal BLEEDING on $N with $s #w!!", /* 8: 23..30   */
      "You cause internal BLEEDING on $N  with your #w!!",
      "$n causes internal BLEEDING on you with $s #w!!"
    },
 
    {
      "$n severely injures $N with $s #w!!",    /* 8: 23..30   */
      "You severely injure $N with your #w!!",
      "$n severely injures you with $s #w!!"
    },
 
    {
      "$n wipes $N out with $s deadly #w!!",    /* 8: 23..30   */
      "You wipe out $N with your deadly #w!!",
      "$n wipes you with $s #w!!"
    },
 
    {
      "$n massacres $N to small fragments with $s #w.", /* 7: 19..23 */
      "You massacre $N to small fragments with your #w.",
      "$n massacres you to small fragments with $s #w."
    },
 
 
    {
      "$n SHATTERS $N with $s deadly #w!!",     /* 8: 23..30   */
      "You SHATTER $N with your deadly #w!!",
      "$n SHATTERS you with $s deadly #w!!"
    },
 
    {    
      "$n OBLITERATES $N with $s deadly #w!!",  /* 8: 23..30   */
      "You OBLITERATE $N with your deadly #w!!",
      "$n OBLITERATES you with $s deadly #w!!"
    },
 
    {
      "$n DESTROYS $N with $s deadly #w!!",     /* 9: > 30   */
      "You DESTROY $N with your deadly #w!!",
      "$n DESTROYS you with $s deadly #w!!"
    },
    {
      "$n FUBARS $N with $s deadly #w!!",
      "You FUBAR $N with your deadly #w!!",
      "$n FUBARS you with $s deadly #w!!"
    },
    {
      "$n NUKES $N with $s deadly #w!!",
      "You NUKE $N with your deadly #w!!",
      "$n NUKES you with $s deadly #w!!"
    },
    {
      "$n does UNSPEAKABLE things to $N with $s deadly #w!!",
      "You do UNSPEAKABLE things to $N with your deadly #w!!",
      "$n does UNSPEAKABLE things to you with $s deadly #w!!"
    }
  };                                             

  w_type -= TYPE_HIT;		/* Change to base of table with text */

  if (dam == 0)		msgnum = 0;
  else if (dam <= 2)    msgnum = 1;
  else if (dam <= 8)    msgnum = 2;
  else if (dam <= 14)   msgnum = 3;
  else if (dam <= 20)   msgnum = 4;
  else if (dam <= 25)   msgnum = 5;
  else if (dam <= 30)   msgnum = 6;
  else if (dam <= 35)   msgnum = 7;
  else if (dam <= 40)   msgnum = 8;
  else if (dam <= 45)   msgnum = 9;
  else if (dam <= 50)   msgnum = 10;
  else if (dam <= 60)   msgnum = 11;
  else if (dam <= 70)   msgnum = 12;
  else if (dam <= 80)   msgnum = 13;
  else if (dam <= 90)   msgnum = 14;
  else if (dam <=100)   msgnum = 15;
  else                  msgnum = 16;  

  /* damage message to onlookers */
  buf = replace_string(dam_weapons[msgnum].to_room,
	  attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
  act(buf, FALSE, ch, NULL, victim, TO_NOTVICT);

  /* damage message to damager */
  send_to_char(CCYEL(ch, C_CMP), ch);
  buf = replace_string(dam_weapons[msgnum].to_char,
	  attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
  act(buf, FALSE, ch, NULL, victim, TO_CHAR);
  send_to_char(CCNRM(ch, C_CMP), ch);

  /* damage message to damagee */
  send_to_char(CCRED(victim, C_CMP), victim);
  buf = replace_string(dam_weapons[msgnum].to_victim,
	  attack_hit_text[w_type].singular, attack_hit_text[w_type].plural);
  act(buf, FALSE, ch, NULL, victim, TO_VICT | TO_SLEEP);
  send_to_char(CCNRM(victim, C_CMP), victim);
}


/*
 * message for doing damage with a spell or skill
 *  C3.0: Also used for weapon damage on miss and death blows
 */
int skill_message(int dam, struct char_data * ch, struct char_data * vict,
		      int attacktype)
{
  int i, j, nr;
  struct message_type *msg;
  struct obj_data *weap = GET_EQ(ch, WEAR_WIELD);

  for (i = 0; i < MAX_MESSAGES; i++) {
    if (fight_messages[i].a_type == attacktype) {
      nr = dice(1, fight_messages[i].number_of_attacks);
      for (j = 1, msg = fight_messages[i].msg; (j < nr) && msg; j++)
	msg = msg->next;

      if (!IS_NPC(vict) && !LR_FAIL(vict, LVL_IS_GOD)) {
	act(msg->god_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	act(msg->god_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT);
	act(msg->god_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
      } else if (dam != 0) {
	if (GET_POS(vict) == POS_DEAD) {
	  send_to_char(CCYEL(ch, C_CMP), ch);
	  act(msg->die_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	  send_to_char(CCNRM(ch, C_CMP), ch);

	  send_to_char(CCRED(vict, C_CMP), vict);
	  act(msg->die_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
	  send_to_char(CCNRM(vict, C_CMP), vict);

	  act(msg->die_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
	} else {
	  send_to_char(CCYEL(ch, C_CMP), ch);
	  act(msg->hit_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	  send_to_char(CCNRM(ch, C_CMP), ch);

	  send_to_char(CCRED(vict, C_CMP), vict);
	  act(msg->hit_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
	  send_to_char(CCNRM(vict, C_CMP), vict);

	  act(msg->hit_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
	}
      } else if (ch != vict) {	/* Dam == 0 */
	send_to_char(CCYEL(ch, C_CMP), ch);
	act(msg->miss_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
	send_to_char(CCNRM(ch, C_CMP), ch);

	send_to_char(CCRED(vict, C_CMP), vict);
	act(msg->miss_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
	send_to_char(CCNRM(vict, C_CMP), vict);

	act(msg->miss_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
      }
      return (1);
    }
  }
  return (0);
}

/*
 * Called when an item is broken, appropiately handles what to do with the item
 * TODO: do we use an act to notify others? or does send_to_char suffice?
 */
void break_obj(struct obj_data *obj, struct char_data *ch) {

  if (!obj || !ch) {
    basic_mud_log("SYSERR: NULL object or char passed to break_obj");
    return;
  }

  switch (GET_OBJ_TYPE(obj) /* WTF is this -> ??? == ITEM_LIGHT ??? */) {
    // Destoryable items
    case ITEM_LIGHT:
    case ITEM_SCROLL:
    case ITEM_STAFF:
    case ITEM_WEAPON:
    case ITEM_FIREWEAPON:
    case ITEM_MISSILE:
    case ITEM_ARMOR:
    case ITEM_POTION:
    case ITEM_WORN:
    case ITEM_TRASH:
    case ITEM_DRINKCON:
    case ITEM_KEY:
    case ITEM_FOOD:
    case ITEM_PEN:
    case ITEM_BOAT:
    case ITEM_JOINABLE:
      sprintf(buf, "... &r%s is destroyed!&n\r\n", obj->short_description);
      obj_from_char(obj);  // Obj from before extraction. 
      extract_obj(obj);
      send_to_char(buf, ch);
      break;

    // Handle containers - make contents go to what container was in, and
    // filter downwards towards ground??
    // Or just make them unopenable till they are fixed? - easiest code wise
    // and rather reasonable I think?
    case ITEM_CONTAINER:
      sprintf(buf, "&r%s is broken and seals shut!&n\r\n", 
                      obj->short_description);
      send_to_char(buf, ch);
      GET_OBJ_VAL(obj, 1) = CONT_CLOSED; 
      break;

    // Undestoryable items (fixable with max damage)
    case ITEM_OTHER:
    case ITEM_WAND:
    case ITEM_TREASURE:
    case ITEM_TRAP:
    case ITEM_NOTE:
    case ITEM_MONEY:
    case ITEM_FOUNTAIN:
    case ITEM_MAGIC_EQ:
    case ITEM_QUEST:
      sprintf(buf, "... &r%s breaks!&n\r\n", obj->short_description);
      send_to_char(buf, ch);
      // put in inventory if obj gets broken
      for (int i = 0; i < NUM_WEARS; i++) {
        if (GET_EQ(ch, i) == obj) {
          unequip_char(ch, i, FALSE);
          obj_to_char(obj, ch, __FILE__, __LINE__); 
        }
      }
      break;
    default:
      basic_mud_log("SYSERR: invalid obj type given to break_obj (%d)", 
                      GET_OBJ_TYPE(obj));
      return;
  }
}

/* perform the damage and display the message */
void damage_obj(struct obj_data *obj, int damage, struct char_data *ch) {
  if (!obj || !ch)
  {
    basic_mud_log("SYSERR: NULL obj or char passed to damage_obj");
    return;
  }
  GET_OBJ_DAMAGE(obj) -= damage;
  sprintf(buf, "&r%s is damaged.&n\r\n", obj->short_description);
  send_to_char(buf, ch);
}

/* Damages a random piece of equipment on the target */
void damage_equipment(struct char_data *ch) {

  int i, found = 0;
  struct obj_data *obj;

  // ahh lets ignore eq on mobs? ... DM
  // short way to fix something that cores - and we dont need
  // it damaging mob eq :)
  if (IS_NPC(ch)) {
    return;
  }
  
  for (i = 0; i < NUM_WEARS && !found; i++)
  {
    if (GET_EQ(ch, i) && (number(1, NUM_WEARS) == NUM_WEARS) &&
	(GET_OBJ_MAX_DAMAGE(GET_EQ(ch, i)) != -1) &&
	!OBJ_FLAGGED(GET_EQ(ch, i), ITEM_QEQ))
    {
      damage_obj(GET_EQ(ch, i), number(1, 5), ch);
      found = 1;
      break;
    }
  }
  // Nothing damaged. Try inventory.
  if (found)
  {
    if (GET_OBJ_DAMAGE(GET_EQ(ch, i)) <= 0 && 
	GET_OBJ_MAX_DAMAGE(GET_EQ(ch, i)) != -1)
    {
      GET_OBJ_DAMAGE(GET_EQ(ch,i)) = 0;
      break_obj(GET_EQ(ch, i), ch);
    }
    return;
  }
  // nothing was damaged, slight chance of getting inventory
  for (obj = ch->carrying; obj; obj = obj->next_content)
  {
    if ((number(0, 10) == 0) &&
	(GET_OBJ_DAMAGE(obj) != -1) && !OBJ_FLAGGED(obj, ITEM_QEQ))
    {
      damage_obj(obj, number(1, 5), ch);
      if (GET_OBJ_DAMAGE(obj) <= 0)
      {
	GET_OBJ_DAMAGE(obj) = 0;
	break_obj(obj, ch);
      }
      return;
    }
  }
}

/*
 * Alert: As of bpl14, this function returns the following codes:
 *	< 0	Victim died.
 *	= 0	No damage.
 *	> 0	How much damage done.
 */
int damage(struct char_data * ch, struct char_data * victim, int dam, int attacktype, bool vcheck)
{
  int manastolen = 0, damChance = 0; 

  /////// TODO - Artus> Break this up if possible.
  if (!victim)
  {
    if (ch)
      basic_mud_log("SYSERR: Attempt to damage null victim in room #%d by '%s'.", world[IN_ROOM(ch)].number, GET_NAME(ch));
    else
      basic_mud_log("SYSERR: Damage called with no char or victim!");
    return (0);
  }

  if (IS_GHOST(victim))
    return (0);

  if ((ch) && (vcheck))
  {
    if (violence_check(ch, victim, attacktype) == FALSE)
      return (0);
  } else {
    if (GET_POS(victim) <= POS_DEAD)
    {
      basic_mud_log("SYSERR: Attempt to damage corpse '%s' in room #%d by '%s'.",
 		    GET_NAME(victim), GET_ROOM_VNUM(IN_ROOM(victim)), GET_NAME(ch));
      die(victim,ch);
      return (0);			/* -je, 7/7/92 */
    }
  }

#ifndef IGNORE_DEBUG
  if ((ch) && GET_DEBUG(ch))
  {
    sprintf(buf, "DEBUG: Damage=%d AttackType=%d\r\n", dam, attacktype);
    send_to_char(buf, ch);
  }
#endif
  /* You can't damage an immortal! */
  if (!IS_NPC(victim) && !LR_FAIL(victim, LVL_IS_GOD))
    dam = 0;

  if (IS_NPC(victim) && MOB_FLAGGED(victim, MOB_NOKILL))
    dam = 0;

  if ((ch) && (victim != ch))
  {
    struct obj_data *weapon;

    /* Start the attacker fighting the victim */
    if ((GET_POS(ch) > POS_STUNNED) && (FIGHTING(ch) == NULL) &&
	(IN_ROOM(ch) == IN_ROOM(victim))) 
    {
      set_fighting(ch, victim, attacktype);

      // DM - TODO - wtf is this??
      // -Tal- I dont know, I didnt put it in   
      // ch and victim are mobs, victim has a master, 1/10 times if vict charmed and vict's master is
      // in same room as ch, then stop ch fighting, and make ch fight the victims master
      if (IS_NPC(ch) && IS_NPC(victim) && victim->master &&
          !number(0, 10) && IS_AFFECTED(victim, AFF_CHARM) &&
          (victim->master->in_room == ch->in_room))
      {
        if (FIGHTING(ch))
          stop_fighting(ch);
        hit(ch, victim->master, TYPE_UNDEFINED);
        return (0);
      }    
    }

    /* If you attack a pet, it hates your guts */
    if ((victim->master) && (victim->master == ch))
    {
      if (IS_CLONE(victim))
      {
	sprintf(buf, "Being your clone, %s knows your weakness.\r\n", HSSH(ch));
	send_to_char(buf, ch);
	GET_HIT(ch) = 0;
	GET_POS(ch) = POS_DEAD;
	raw_kill(ch, victim);
	raw_kill(victim, NULL);
	return (0);
      }
      stop_follower(victim);
    }
    
    /* If the victim is autoassisting the attacker, make them stop. */
    if (AUTOASSIST(victim) == ch)
      stop_assisting(victim);

    /* If the attacker is invisible, he becomes visible */
    if (AFF_FLAGGED(ch, AFF_INVISIBLE | AFF_HIDE))
      appear(ch);

    /* Start the victim fighting the attacker */
    if (GET_POS(victim) > POS_STUNNED && (FIGHTING(victim) == NULL)) {
      set_fighting(victim, ch, attacktype);

      // stay down u little bitch
      if (dam > 0 && attacktype == SKILL_TRIP)
        GET_POS(victim) = POS_SITTING;

      if (MOB_FLAGGED(victim, MOB_MEMORY) && !IS_NPC(ch))
	remember(victim, ch);
    }

    /* check for particular type of weapon mastery for more damage */
    if (!IS_NPC(ch) && (GET_EQ(ch, WEAR_WIELD))) 
    {
      if (GET_SKILL(ch, SKILL_AXEMASTERY) && is_axe(GET_EQ(ch, WEAR_WIELD))) 
      {
	//send_to_char("Your axe mastery comes in handy.\r\n", ch);
	dam += (int)(dam * 0.10);
      }
      if (GET_SKILL(ch, SKILL_BLADEMASTERY) && is_blade(GET_EQ(ch, WEAR_WIELD))) 
      {
	//send_to_char("Your blade mastery comes in handy.\r\n", ch);
	dam += (int)(dam * 0.10);
      }
    }

    /* check if victim has DEFEND skill  */
    /* Could potentially do much more with this skill -- ie, parry, riposte, and so on */
    // TODO: check for attack type?
    if (!IS_NPC(victim) && GET_SKILL(victim, SKILL_DEFEND))
    {
      if (number(1, 101) < GET_SKILL(victim, SKILL_DEFEND)) 
      {
	if (GET_LEVEL(ch) >= LVL_CHAMP)
	  dam -= ((int)(dam / 2));	// champs can halve damage
	else if (GET_LEVEL(ch) >= 75)
	  dam -= ((int)(dam / 3));	// 2/3's damage
	else if (GET_LEVEL(ch) >= 40)
	  dam -= ((int)(dam / 4));	// 3/4's damage
	else
	  dam -= ((int)(dam  / 5));	// 4/5's damage
	if (dam < 0)
	  dam = 0;   
	apply_spell_skill_abil(ch, SKILL_DEFEND);
  //	act("You defend yourself well against $n's attack.", FALSE, ch, 0, victim, TO_VICT);
  //	act("$N defends against your attack, avoiding some damage.", FALSE, ch, 0, victim,TO_CHAR);
      }
    }

    /* Double damage if char is berserk */
    if (!IS_NPC(ch))
    {
      if (AFF_FLAGGED(ch, AFF_BERSERK))
	if ((SPELL_EFFEC(ch, SKILL_BERSERK) / 100) > 0.5)
	  dam = (int)(dam * (2 * (SPELL_EFFEC(ch, SKILL_BERSERK) / 100)));
      // Artus> 1.5* Damage if BattleMage && Spell Type Attack.
      if ((attacktype > 1) && (attacktype < NUM_SPELLS))
	  dam = (int)((double)(dam * 1.5));
    }
  
    /* Check for PK if this is not a PK MUD */
    if (!pk_allowed) 
    {
      check_killer(ch, victim);
      if (PLR_FLAGGED(ch, PLR_KILLER) && (ch != victim))
	dam = 0;
    }

    // DM: Tumble skill - chance vict tumbles avoiding attack
    // hmm is this best place? - first thoughts yeah, but of course this will
    // get called each attack (ie. wouldn't make sense tumbling three times if
    // ch has 3 attacks - not that it would be likely to happen. 
    // TODO: check for attack type?
    if (basic_skill_test(victim, SKILL_TUMBLE, FALSE)) 
      // 1 in 10 chance victim gets to attempt a tumble
      if (!number(0, 9))
	if (number(1, 100) < GET_SKILL(victim, SKILL_TUMBLE))
	{
	  dam = 0;
	  act("$N performs a tumble roll avoiding your attack!",
	      TRUE, ch, 0, victim, TO_CHAR);
	  act("You perform a tumble roll avoiding $n's attack!",
	      TRUE, ch, 0, victim, TO_VICT);
	  act("$N performs a tumble roll avoiding $n's attack!",
	      TRUE, ch, 0, victim, TO_NOTVICT);
	  apply_spell_skill_abil(victim, SKILL_TUMBLE);
	}
    
    // DM: Poison blade - Add percentage based poison damage, set poison on vict
    // NOTE: dont think there is a MAX_TYPE thingy for attacks - if anything is 
    // added after TYPE_STAB - this should be updated.
    //
    // We are ignoring the number of uses - it 
    // TODO: add in any resistance spells etc ...
    if ((weapon = GET_EQ(ch, WEAR_WIELD))) 
    {
      if (obj_affected_by_timer(weapon, TIMER_POISONBLADE) && attacktype >= 
	  TYPE_HIT && attacktype <= TYPE_STAB) 
      {
	dam = dam + (int)(MIN(50, (int)((SPELL_EFFEC(ch, SKILL_POISONBLADE) / 100) * (GET_SKILL(ch, SKILL_POISONBLADE) / 100) * (GET_LEVEL(ch) / 2))));
	act("$N is affected by your poison blade!", TRUE, ch, 0, victim, TO_CHAR);
	act("You are poisoned by $n's blade!", TRUE, ch, 0, victim, TO_VICT);
	act("$N is poisoned by $n's blade!", TRUE, ch, 0, victim, TO_ROOM);

	// add affect to char if not already affected by poison
	if (!IS_AFFECTED(victim, AFF_POISON)) 
	{
	  struct affected_type af;
	  af.type = SPELL_POISON;
	  af.duration = MIN(1, (int)(GET_LEVEL(ch) / GET_LEVEL(victim)));
	  af.modifier = 0;
	  af.location = APPLY_NONE;
	  af.bitvector = AFF_POISON;
	  affect_join(victim, &af, FALSE, FALSE, FALSE, FALSE);
	}
      }
    } // PoisonBlade Check.

    /* Gain exp for the hit */
    if (!IS_NPC(ch) && !PRF_FLAGGED(ch, PRF_MORTALK))
    {
      if (!IS_NPC(victim) || 
	  ((GET_MOB_VZNUM(victim) != CLAN_ZONE) &&
	   !MOB_FLAGGED(victim, MOB_NOKILL)))
	gain_exp(ch, GET_LEVEL(victim) * dam);
    } else if (IS_NPC(ch)) {
      gain_exp(ch, GET_LEVEL(victim) * dam);
    }
  } // (ch) && (ch != victim)

  /* Cut damage in half if victim has sanct, to a minimum 1 */
  if (AFF_FLAGGED(victim, AFF_SANCTUARY) && dam >= 2)
    dam /= 2;

  /* Cut in half again if vict is berserk */
  if (!IS_NPC(victim) && (AFF_FLAGGED(victim, AFF_BERSERK)))
    if ((SPELL_EFFEC(victim, SKILL_BERSERK) / 100) > 0.5) 
      dam = (int)(dam / (2 * (SPELL_EFFEC(victim, SKILL_BERSERK) / 100)));

  /* Set the maximum damage per round and subtract the hit points */
  dam = MAX(MIN(dam, 1000), 0);
  GET_HIT(victim) -= dam;

  update_pos(victim);

  if (!(ch))
    return (dam);

  /*
   * skill_message sends a message from the messages file in lib/misc.
   * dam_message just sends a generic "You hit $n extremely hard.".
   * skill_message is preferable to dam_message because it is more
   * descriptive.
   * 
   * If we are _not_ attacking with a weapon (i.e. a spell), always use
   * skill_message. If we are attacking with a weapon: If this is a miss or a
   * death blow, send a skill_message if one exists; if not, default to a
   * dam_message. Otherwise, always send a dam_message.
   */
  if (!IS_WEAPON(attacktype))
  {
    skill_message(dam, ch, victim, attacktype);
  } else {
    if (GET_POS(victim) == POS_DEAD || dam == 0)
    {
      if (!skill_message(dam, ch, victim, attacktype))
	dam_message(dam, ch, victim, attacktype);
    } else {
      dam_message(dam, ch, victim, attacktype);
    }
  }

// DM - need a check in here for 2nd/3rd attack - when calling 
// damage(ch,vict,0,2/3attack)?? This elimates the "extra message" shown when 
// the 2nd or 3rd attack isn't called.

// Artus - From now on skills with violent set to > 1 will also eliminate the
// message and flee checks.. These skills should later call damage with the
// same skillnum and a damage of 0... Stops flee message being sent before
// skill message.
  
/*  if (!((dam == 0) && 
	(attacktype == SKILL_2ND_ATTACK || attacktype == SKILL_3RD_ATTACK))) */
  if (!(((dam == 0) && (attacktype == SKILL_2ND_ATTACK || 
	              attacktype == SKILL_3RD_ATTACK)) ||
       ((dam != 0) && (IS_SKILL(attacktype) &&
		       spell_info[attacktype].violent > 1))))

  {
    /* Use send_to_char -- act() doesn't send message if you are DEAD. */
    switch (GET_POS(victim)) 
    {
      case POS_MORTALLYW:
	act("$n is mortally wounded, and will die soon, if not aided.", 
	    TRUE, victim, 0, 0, TO_ROOM);
	send_to_char("You are mortally wounded, and will die soon, if not "
		     "aided.\r\n", victim);
	break;
      case POS_INCAP:
	act("$n is incapacitated and will slowly die, if not aided.", 
	    TRUE, victim, 0, 0, TO_ROOM);
	send_to_char("You are incapacitated an will slowly die, if not "
			"aided.\r\n", victim);
	break;
      case POS_STUNNED:
	act("$n is stunned, but will probably regain consciousness again.", 
	    TRUE, victim, 0, 0, TO_ROOM);
	send_to_char("You're stunned, but will probably regain consciousness "
		      "again.\r\n", victim);
	break;
      case POS_DEAD:
	act("$n is dead!  R.I.P.", FALSE, victim, 0, 0, TO_ROOM);
	send_to_char("You are dead!  Sorry...\r\n", victim);
	break;
      default:			/* >= POSITION SLEEPING */
	if (dam > (GET_MAX_HIT(victim) / 4))
	  send_to_char("That really did HURT!\r\n", victim);
	if (GET_HIT(victim) < (GET_MAX_HIT(victim) / 4)) 
	{
	  sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so "
			"much!%s\r\n",
		  CCRED(victim, C_SPR), CCNRM(victim, C_SPR));
	  send_to_char(buf2, victim);
	  if ((ch != victim && MOB_FLAGGED(victim, MOB_WIMPY) && 
	       GET_POS(victim) >= POS_FIGHTING) &&
	      (IN_ROOM(ch) == IN_ROOM(victim)))
  	  do_flee(victim, NULL, 0, 0);
	}
	if (!IS_NPC(victim) && GET_WIMP_LEV(victim) && (victim != ch) &&
	    GET_HIT(victim) < GET_WIMP_LEV(victim) && GET_HIT(victim) > 0 &&
	    GET_POS(victim) >= POS_FIGHTING && IN_ROOM(ch) == IN_ROOM(victim))
	{
	  send_to_char("You wimp out, and attempt to flee!\r\n", victim);
	  do_flee(victim, NULL, 0, 0);
	}
	break;
    } // Switch (POS)
  } // If (Going to send messages, check flees).

  /* 
   *By this stage,  they're having a swing, damage eq regardless. 
   * Random chance of damaging EQ
   */
  if ((dam > 0) && (attacktype != SPELL_POISON))
  {
    damChance = 100 - (GET_LEVEL(ch) - GET_LEVEL(victim)) - GET_STR(ch);
    // Want to probably modify it depending on the
    // ch's damRoll as well (a % perhaps)
    if (damChance < 0)
      damChance = 1;
    if (number(0, damChance) == damChance) 	// Damaged eq! 
      damage_equipment(victim);
  }

  /* Help out poor linkless people who are attacked */
  if (!IS_NPC(victim) && !(victim->desc) && GET_POS(victim) > POS_STUNNED)
  {
    do_flee(victim, NULL, 0, 0);
    if (!FIGHTING(victim))
    {
      act("$n is rescued by divine forces.", FALSE, victim, 0, 0, TO_ROOM);
      GET_WAS_IN(victim) = victim->in_room;
      char_from_room(victim);
      char_to_room(victim, 0);
    }
  }

  /* stop someone from fighting if they're stunned or worse */
  if ((GET_POS(victim) <= POS_STUNNED) && (FIGHTING(victim) != NULL))
    stop_fighting(victim);

  /* Uh oh.  Victim died. */
  if (GET_POS(victim) == POS_DEAD)
  {
    /* fix for poisoned players getting exp, and their group! bm */
    if (attacktype==SPELL_POISON || attacktype==TYPE_SUFFERING) 
    {
      if ((IS_NPC(ch)) && (MOB_FLAGGED(ch, MOB_MEMORY)))
	forget(ch, victim);
      die(victim,ch,"poison");
      return(0);  
    }

    if ((ch != victim) && (IS_NPC(victim) || victim->desc))
    {
      /* DM - if CLONE makes kill in group - only give exp to CLONES master */
      if (AFF_FLAGGED(ch, AFF_GROUP) && !IS_CLONE(ch))
        group_gain(ch, victim);
      else if (MOUNTING(ch) && IS_NPC(ch))
        solo_gain(MOUNTING(ch), victim);	// XP to rider
      else
        solo_gain(ch, victim);
    }
    if (!IS_NPC(victim)) 
    {
/* moved to die()
 * sprintf(buf2, "%s killed by %s at %s", GET_NAME(victim), GET_NAME(ch),
 *	      world[victim->in_room].name);
 *    mudlog(buf2, BRF, LVL_ANGEL, TRUE); */
      if (MOB_FLAGGED(ch, MOB_MEMORY))
	forget(ch, victim);
    }
    die(victim,ch);
    return (-1);
  }
  // Mana stealing for mana thieves (spellswords)
  if ((dam > 0) && !IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_MANA_THIEF))
  {
    /* Some semi random chance of draining
     * Current mana / (level * modifier) -- Becomes more likely when mana is
     * lower */
    if (number(0, (int)(GET_MANA(ch)/(GET_LEVEL(ch) * GET_MODIFIER(ch)))) != 0)
      return (dam);
    if (GET_MANA(ch) < GET_MAX_MANA(ch))
    {
      if (!IS_NPC(victim))
	manastolen += number(1, (int)(GET_MAX_MANA(victim) * 0.05));
      else
	manastolen += number(1, (int)(GET_MAX_MANA(ch) * 0.05));
      if (manastolen > GET_MANA(victim) && !IS_NPC(victim))
	manastolen = GET_MANA(victim);
      if (!IS_NPC(victim))
        GET_MANA(victim) -= manastolen;
      GET_MANA(ch) += manastolen;
      if (GET_MANA(ch) > GET_MAX_MANA(ch))
	GET_MANA(ch) = GET_MAX_MANA(ch);
      if (manastolen > 0)
      {
	act("You manage to steal some mana from $N as you hit $M.", FALSE,
	    ch, 0, victim, TO_CHAR);
	act("$n stole some of your mana!", FALSE, ch, 0, victim, TO_VICT);
      }
    }
  }

  // Extra damage for those with SPECIAL_FOREST_HELP
  if ((dam > 0) && !IS_NPC(ch) && 
      IS_SET(GET_SPECIALS(ch), SPECIAL_FOREST_HELP) &&
      (SECT(ch->in_room) == SECT_FOREST) && (victim != ch))
  {
    // Semi random chance of aid
    // Current hp / (level * modifier) -- Becomes more likely as druid is dying 
    if (number(0, (int)(GET_HIT(ch)/(GET_LEVEL(ch) * GET_MODIFIER(ch)))) != 0)
      return (dam);
    if (GET_CLASS(victim) == CLASS_DRUID)
    {
      act("Your forest allies are unable to harm another druid.",
	  FALSE, ch, 0, 0, TO_CHAR);
      act("You discourage $n's forest allies from attacking you.",
	  FALSE, ch, 0, victim, TO_VICT);
      return (dam);
    }
    act("Your forest allies come to your aid, briefly attacking $N.",
	FALSE, ch, 0, victim, TO_CHAR);
    act("$n's forest allies aid $s attack on $N.",
	FALSE, ch, 0, victim, TO_ROOM);
    act("$n's forest allies attack you briefly, aiding $m.",
	FALSE, ch, 0, victim, TO_VICT);
    dam += number(1, (int)(GET_LEVEL(ch) * GET_MODIFIER(ch) *
		  (GET_WIS(ch) < 15 ? 1 : GET_WIS(ch) < 19 ? 2 : 3)));
  }
 
  // Chance for outright destruction of undead for paladins
  if ((dam > 0) && !IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_HOLY) &&
      (GET_CLASS(victim) == CLASS_UNDEAD))
  {
    if (number(1, (int)(GET_HIT(ch) / (GET_MODIFIER(ch) *
		      (GET_WIS(ch) < 15 ? 1 : GET_WIS(ch) < 19 ? 2 : 3)))) != 1)
      return (dam);
    act("&WThe holy powers within you arise and slay $N as you strike at $m.&n",
	FALSE, ch, 0, 0, TO_CHAR);
    act("&WOverwhelmed by $n's holy power, $N is banished from this realm!&n",
	FALSE, ch, 0, victim, TO_ROOM);
    act("&R$n's holy power overwhelms you, banishing you to the nether realms!&n", FALSE, ch, 0, victim, TO_VICT); 
    raw_kill(victim, ch);
    return (-1); // deaaaaaaaaad
  }

  // Damage enhancement for dwarves and elves
  if (!IS_NPC(ch) && ((IS_SET(GET_SPECIALS(ch), SPECIAL_ELF) &&
      (SECT(ch->in_room) == SECT_FOREST)) ||
      (IS_SET(GET_SPECIALS(ch), SPECIAL_DWARF) &&
      (SECT(ch->in_room) == SECT_INSIDE))))
    dam = (int)(dam * 1.10); 	

  // Extra damage for those with SPECIAL_GORE
  if ((dam > 0) && !IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_GORE))
  {
    /* Semi random chance of aid
     * Current hp / (level * modifier) -- Becomes more likely as character is
     * dying */
    if (number(0, (int)(GET_HIT(ch)/(GET_LEVEL(ch) * GET_MODIFIER(ch)))) !=0)
      return (dam);	

    if (GET_CLASS(victim) == CLASS_DRUID)
    {
      act("Your forest allies are unable to harm another druid.",
	  FALSE, ch, 0, 0, TO_CHAR);
      act("You discourage $n's forest allies from attacking you.",
	  FALSE, ch, 0, victim, TO_VICT);
      return (dam);
    }
    act("You viciously lay about with your horns, wounding $N.",
	FALSE, ch, 0, victim, TO_CHAR);
    act("$n's horns gore $N.", FALSE, ch, 0, victim, TO_ROOM);
    act("$n's horns dig deeply into you.", FALSE, ch, 0, victim, TO_VICT);
    dam += number(1, (int)(GET_LEVEL(ch) * GET_MODIFIER(ch) *
	                   (GET_STR(ch) < 15 ? 1 : GET_STR(ch) < 19 ? 2 : 3))); 
  }
  return (dam);
}



void hit(struct char_data * ch, struct char_data * victim, int type)
{
  struct obj_data *wielded = GET_EQ(ch, WEAR_WIELD);
  int w_type, victim_ac, calc_thaco, dam, diceroll;
  struct char_data *real_vict = victim;    
  struct char_data *char_room; 

  // Artus> Are we sane?
  if (!VALID_FIGHT(ch, victim))
  {
    if (ch && FIGHTING(ch) && FIGHTING(ch) == victim)
      stop_fighting(ch);
    return;
  }

  // dual wield attack
  if (type == TYPE_DUAL_ATTACK)
    wielded = GET_EQ(ch, WEAR_HOLD);

  /* check if the character has a fight trigger */
  if ((fight_mtrigger(ch) == 1) && !VALID_FIGHT(ch, victim))
    return;

/* JA code to randomly select a player to hit */
/* to stop the tank from getting hit all the time */
 
  /* pseudo-randomly choose someone in the room who is fighting me */
  /* Artus> Might make life easier if we put this bak into victim, no? */
  if (IS_NPC(ch))
  {
    for (real_vict = world[ch->in_room].people; real_vict; real_vict = real_vict->next_in_room)
      if (FIGHTING(real_vict) == ch && !number(0, 3))
        break;
  }

  if (real_vict == NULL)
    real_vict = victim;

  /* Artus> Is this really needed anymore? :o)
  assert(real_vict); */ 

  /* Find the weapon type (for display purposes only) */
  if (wielded && GET_OBJ_TYPE(wielded) == ITEM_WEAPON)
    w_type = GET_OBJ_VAL(wielded, 3) + TYPE_HIT;
  else {
    if (IS_NPC(ch) && (ch->mob_specials.attack_type != 0))
      w_type = ch->mob_specials.attack_type + TYPE_HIT;
    else
      w_type = TYPE_HIT;
  }

/* JA ------------------------- ammo code  */
  /* changed so mobs dont use ammo - Vader */
  if (wielded && !IS_NPC(ch) && OBJ_IS_GUN(wielded))
  {
    /* out of ammo */
    if (GET_OBJ_VAL(wielded, 0) <= 0)
    {
      send_to_char("*CLICK*\n\r", ch);
      return;
    } else
      MAX(0, --GET_OBJ_VAL(wielded, 0));
  }      


  calc_thaco = thaco(ch, victim) - (int)(ch->points.hitroll / 5); 

  /* Calculate the raw armor including magic armor.  Lower AC is better. */
  victim_ac = compute_armor_class(victim, 1);

  /* roll the die and take your chances... */
  diceroll = number(1, 20);

  /* decide whether this is a hit or a miss */
  // Artus - Time for me to play.
#ifndef IGNORE_DEBUG
  if (GET_DEBUG(ch))
  {
    sprintf(buf, "DBG: Thaco(%s)/AC(%s)/Diceroll: %d/%d/%d\r\n", GET_NAME(ch), 
	GET_NAME(victim), calc_thaco, victim_ac, diceroll);
    send_to_char(buf, ch);
  }
  if (GET_DEBUG(victim))
  {
    sprintf(buf, "DBG: Thaco(%s)/AC(%s)/Diceroll: %d/%d/%d\r\n", GET_NAME(ch),
	GET_NAME(victim), calc_thaco, victim_ac, diceroll);
    send_to_char(buf, victim);
  }
#endif
  if ((((diceroll < 20) && AWAKE(victim)) &&
       ((diceroll == 1) || ((calc_thaco - diceroll) > victim_ac))))
  {
    /* the attacker missed the victim */
    if (type == SKILL_BACKSTAB)
      damage(ch, victim, 0, SKILL_BACKSTAB, FALSE); 
    else if (type == SKILL_2ND_ATTACK || type == SKILL_3RD_ATTACK)
      damage(ch, real_vict, 0, type, FALSE);  /* thisll make it use the rite messages for missing */
    else
      damage(ch, real_vict, 0, w_type, FALSE);
  } else {
    /* okay, we know the guy has been hit.  now calculate damage. */

    /* Start with the damage bonuses: the damroll and strength apply */
    // DM: make todam also level based - lvl 1 char with 21 dam will kick
    // some major arse ...
    // DM: ok changed it from the apply to number(0, apply) ...
    dam = number(0, str_app[STRENGTH_REAL_APPLY_INDEX(ch)].todam);
    dam += GET_DAMROLL(ch);

    if (!IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_MINOTAUR))
      dam += MAX(5, (int)((GET_DAMROLL(ch) * 0.1)));

    if (!IS_NPC(ch) && IS_SET(GET_SPECIALS(ch) , SPECIAL_SUPERMAN))
      dam += MAX(5, (int)((GET_DAMROLL(ch) * 0.1)));

    /* Maybe holding arrow? */
    if (wielded && GET_OBJ_TYPE(wielded) == ITEM_WEAPON) {
      /* Add weapon-based damage if a weapon is being wielded */
      dam += dice(GET_OBJ_VAL(wielded, 1), GET_OBJ_VAL(wielded, 2));
#if 0 // Artus> Lets change this so that NPCs do their bare hand damage, too.
    } else {
      /* If no weapon, add bare hand damage instead */
      if (IS_NPC(ch)) {
	dam += dice(ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
      } else {
	dam += number(0, 2);	/* Max 2 bare hand damage for players */
      }
    }
#endif
    } else {
      if (!IS_NPC(ch))
	dam += number(0, 2);
    }
    // Artus> Add NPC bare hand damage.
    if (IS_NPC(ch))
      dam += dice(ch->mob_specials.damnodice, ch->mob_specials.damsizedice);

    /*
     * Include a damage multiplier if victim isn't ready to fight:
     *
     * Position sitting  1.33 x normal
     * Position resting  1.66 x normal
     * Position sleeping 2.00 x normal
     * Position stunned  2.33 x normal
     * Position incap    2.66 x normal
     * Position mortally 3.00 x normal
     *
     * Note, this is a hack because it depends on the particular
     * values of the POSITION_XXX constants.
     */
    if (GET_POS(victim) < POS_FIGHTING)
      dam *= 1 + (POS_FIGHTING - GET_POS(victim)) / 3;

    /* Check for protection from evil/good on victim - DM */
    if (((IS_GOOD(ch) && affected_by_spell(real_vict,SPELL_PROT_FROM_GOOD)) ||
        (IS_EVIL(ch) && affected_by_spell(real_vict,SPELL_PROT_FROM_EVIL))) &&
        (GET_LEVEL(ch) >= PROTECT_LEVEL))
      dam -= (GET_LEVEL(real_vict) / MAX(2,num_attacks(real_vict)));

    /* at least 1 hp damage min per hit */
    dam = MAX(1, dam);
    if(type == SKILL_2ND_ATTACK && dam > 1)
      dam = (int) (dam * 0.666); /* 2 3rds damage on second attack */
    if(type == SKILL_3RD_ATTACK && dam > 1)
      dam = (int) (dam * 0.333); /* 1/3 damage if on 3rd attack */

    // dual wield/attack (dam * skill ability percentage)
    if ((type == TYPE_DUAL_ATTACK) && (GET_SKILL(ch, SKILL_AMBIDEXTERITY)))
    {
      dam = (int)(dam * GET_SKILL(ch, SKILL_AMBIDEXTERITY) / 100);
      apply_spell_skill_abil(ch, SKILL_AMBIDEXTERITY);
    }
    
    if (type == SKILL_BACKSTAB)
    {
      dam *= (1+GET_LEVEL(ch)/10);
      if (damage(ch, real_vict, dam, SKILL_BACKSTAB, FALSE) > 0)
      { // ^ Check it's still alive
        if (GET_SKILL(ch, SKILL_DOUBLE_BACKSTAB))
        { // Give it another go
    	  if (number(1, 101 - (GET_LEVEL(victim) - GET_LEVEL(ch))) 
		< GET_SKILL(ch, SKILL_DOUBLE_BACKSTAB))		// Good enough?
	  {
	    act("...$n whirls with lightning speed backstabbing again!", FALSE, ch, 0, 0, TO_ROOM);
	    act("...you whirl and deal a double backstab to $N!", FALSE, ch, 0, victim, TO_CHAR);
	    act("...$n whirls with lightning speed backstabbing you again!", FALSE, ch, 0, victim, TO_VICT);
	    damage(ch, real_vict, dam * 2, SKILL_BACKSTAB, FALSE);
	    apply_spell_skill_abil(ch, SKILL_DOUBLE_BACKSTAB);
	  }
        }
      }	 
    } else
      damage(ch, real_vict, dam, w_type, FALSE);
    
    if (!VALID_FIGHT(ch, real_vict))
      return;

    /* if they have reflect then reflect */
    if ((IS_AFFECTED(real_vict, AFF_REFLECT)) && (dam > 0) && 
	(GET_POS(real_vict)> POS_MORTALLYW) && 
	(IN_ROOM(ch) == IN_ROOM(real_vict)))
    {
      damage(real_vict,ch,MIN(dam,MAX(GET_HIT(ch) - 1,0)),SPELL_SERPENT_SKIN,FALSE);
      if (!VALID_FIGHT(ch, real_vict))
	return;
    }
 
/* offensive/defensive spells - Lighting/Fire Shield, Fire Wall */
    if (affected_by_spell(real_vict,SPELL_LIGHT_SHIELD))
      if (mag_savingthrow(real_vict,SAVING_SPELL,0))
      {
        damage(real_vict,ch,MIN(GET_LEVEL(real_vict)/4,MAX(GET_HIT(ch)-1,0)),SPELL_LIGHT_SHIELD,FALSE);
	if (!VALID_FIGHT(ch, real_vict))
	  return;
      }
    if (affected_by_spell(real_vict,SPELL_FIRE_SHIELD))
      if (mag_savingthrow(real_vict,SAVING_SPELL,0))
      {
        damage(real_vict,ch,MIN(GET_LEVEL(real_vict)/3,MAX(GET_HIT(ch)-1,0)),SPELL_FIRE_SHIELD,FALSE);
	if (!VALID_FIGHT(ch, real_vict))
	  return;
      }
    if (affected_by_spell(real_vict,SPELL_FIRE_WALL))
      if (mag_savingthrow(real_vict,SAVING_SPELL,0))
      {
        damage(real_vict,ch,MIN(GET_LEVEL(real_vict)/2,MAX(GET_HIT(ch)-1,0)),SPELL_FIRE_WALL,FALSE);
	if (!VALID_FIGHT(ch, real_vict))
	  return;
      }
 
/* if its a magic weapon decided whether to cast or not then do it - Vader */
    if(wielded && FIGHTING(ch))
    {
      if(IS_OBJ_STAT(wielded,ITEM_MAGIC) && (GET_OBJ_VAL(wielded,0) > 0))
      {
        if(number(0,3))
	{
        // DM - only use spells we know ... Artus> This sucks
        /* if (has_stats_for_skill(ch, GET_OBJ_VAL(wielded, 0), FALSE) 
                && GET_SKILL(ch, GET_OBJ_VAL(wielded, 0)) > 0 
                && number(0, 3)) */
	  // Artus> TODO - Remove Areas Spells.
	  if (IS_SET(spell_info[GET_OBJ_VAL(wielded, 0)].routines, MAG_AREAS) &&
	      !IS_OBJ_STAT(wielded, ITEM_QEQ))
	  {
	    sprintf(buf, "SYSERR: %s [Vnum %d] attempting MAG_AREAS.",
		    wielded->short_description, GET_OBJ_VNUM(wielded));
	    mudlog(buf, NRM, LVL_IMPL, TRUE);
	    if (ch->desc)
	    {
	      sprintf(buf, "&rLighting comes from the sky, disintegrating &5%s&r.&n\r\n", OBJS(wielded, ch));
	      send_to_char(buf, ch);
	    }
	    for(int where = 0; where < NUM_WEARS; where++)
	      if (GET_EQ(ch, where) == wielded)
		unequip_char(ch, where, FALSE);
	    extract_obj(wielded);
	    wielded = NULL;
	  } else {
	    call_magic(ch, real_vict, NULL, GET_OBJ_VAL(wielded,0), 
		       2 * GET_LEVEL(ch), CAST_MAGIC_OBJ); 
	    if (!VALID_FIGHT(ch, real_vict))
	      return;
	  } // MAG_AREAS Rorting.
	} // Random chance of spell happening.
      } // Wielded item is MAGIC.
    } // Is Wielding && Fighting.
  } // Artus> End - Did we hit check.

  /* DM - autoassist check */ // Artus> Added in charmed/clone autoassist.
  if ((GET_POS(victim) == POS_FIGHTING) && IS_NPC(victim) &&
      (IN_ROOM(ch) == IN_ROOM(victim)))
  {
    struct char_data *prior = NULL;
    if (world[ch->in_room].people != victim)
    {
      for(prior = world[ch->in_room].people; prior; prior = prior->next)
      {
        if (prior->next == victim)
	  break;
	if (!(prior->next))
	  return;
      }
    }
      
    for (char_room=world[ch->in_room].people;char_room;char_room=char_room->next_in_room)
    {
      if (FIGHTING(char_room)) // Artus> We're already fighting.
	continue;
      if (IS_NPC(char_room))
      {
	// Artus> NPCs autoassist master.
	if ((char_room->master == ch) && CAN_SEE(char_room,ch) && 
	    CAN_SEE(char_room,victim))
	{
	  act("$n assists $N!", FALSE, char_room, 0, ch, TO_NOTVICT);
	  act("$N assists you!", FALSE, ch, 0, char_room, TO_CHAR);
	  sprintf(buf, "You assist %s!\r\n", GET_NAME(ch));
	  hit(char_room, victim, TYPE_UNDEFINED);
	  if (prior)
	  {
	    if (prior->next != victim)
	      return;
	  } else {
	    if (world[ch->in_room].people != victim)
	      return;
	  }
	}
	continue;
      }
      if ((AUTOASSIST(char_room) == ch) && CAN_SEE(char_room,ch) && 
	  CAN_SEE(char_room,victim))
      {
	act("$n assists $N!", FALSE, char_room, 0, ch, TO_NOTVICT);
	act("$N assists you!", FALSE, ch, 0, char_room, TO_CHAR);
	sprintf(buf,"You assist %s!\n\r",GET_NAME(ch));
	send_to_char(buf,char_room);
	hit(char_room,victim,TYPE_UNDEFINED);
	if (prior)
	{
	  if (prior->next != victim)
	    return;
	} else {
	  if (world[ch->in_room].people != victim)
	    return;
	}
      }
    }
  }

    // If they're disguised, their disguise is broken
    // Tali.. Not sure if I should put this in. Should be okay without it.
/*    if( !IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_DISGUISE) && CHAR_DISGUISED(ch)){
	send_to_char("You can no longer maintain your disguise!\r\n", ch);
	CHAR_DISGUISED(ch) = 0;
    }
    if( !IS_NPC(ch) && IS_SET(GET_SPECIALS(victim), SPECIAL_DISGUISE) && CHAR_DISGUISED(victim) ) {
	send_to_char("You can no longer maintain your disguise!\r\n",victim);
	CHAR_DISGUISED(victim) = 0;
    } */

  /* check if the victim has a hitprcnt trigger */
  hitprcnt_mtrigger(victim);
}


void perform_mount_violence(struct char_data *rider)
{

  /* TODO: Extend function here to allow specials on items and such */

  // Check if the opponent is history
  if (!FIGHTING(rider))
    return;

  if (MOUNTING(rider) && !FIGHTING(MOUNTING(rider)) ) {
    send_to_char("Your mount joins the fray!\r\n", rider);
    do_violent_skill(MOUNTING(rider), (FIGHTING(rider))->player.name, 
                     0, SCMD_HIT);
  }

  if (MOUNTING_OBJ(rider)) {
    send_to_char("Your mount aids your efforts in battle.\r\n", rider);
    act("$n's mount aids $m against $s opponent.", FALSE, rider, 0, 0, TO_ROOM);
    hit(rider, FIGHTING(rider), TYPE_UNDEFINED);
  }
}


/* control the fights going on.  Called every 2 seconds from comm.c. */
void perform_violence(void)
{
  int loop=1, second=0, third=0, i;
  struct char_data *ch;
  void show_wounded_to_char(struct char_data *ch);
  int has_stats_for_prac(struct char_data *ch, int skillnum, bool show);

  for (ch = combat_list; ch; ch = next_combat_list)
  {
    next_combat_list = ch->next_fighting;

    loop = 1; /* Artus - Haste Fix (Hack/Slash).. Hal sucks ass */

    if (!VALID_FIGHTING(ch))
    {
      stop_fighting(ch);
      continue;
    } /* else { // Artus> Why?!? */

    if (affected_by_spell(ch, SPELL_HASTE))
      loop = 2;

    for (i=0;i<loop;i++) 
    {
      if (!VALID_FIGHTING(ch))
	break;

      if (i == 1)
	send_to_char("You are hastened and get more attacks\r\n", ch);
      	
      hit(ch, FIGHTING(ch), TYPE_UNDEFINED);
      if (!VALID_FIGHTING(ch))
	break;

      // dual wield
      if (IS_DUAL_WIELDING(ch))
      {
	hit(ch, FIGHTING(ch), TYPE_DUAL_ATTACK);
	if (!VALID_FIGHTING(ch))
	  break;
      }

      /* the below bit is added to allow multiple attacks per turn - VADER */
      /* Artus> No 3rd without second.. Also, changed the way npcs are handled
       *        to remove some repeat npc checking. */ 
      second = third = 0;
      if(IS_NPC(ch)) 
      {
	if (MOB_FLAGGED(ch, MOB_2ND_ATTACK))
	{
	  second = 100;
	  if (MOB_FLAGGED(ch, MOB_3RD_ATTACK))
	    third = 100;
	}
      } else {
	if ((second = GET_SKILL(ch, SKILL_2ND_ATTACK)))
	{
	  if (has_stats_for_prac(ch, SKILL_2ND_ATTACK, false))
	  {
	    third = GET_SKILL(ch, SKILL_3RD_ATTACK);
	    if (!has_stats_for_prac(ch, SKILL_3RD_ATTACK, false))
	      third = 0;
	  } else
	    second = 0;
	}
      }  

      if (second > 0)
      {
	if((second + dice(3,(ch->aff_abils.dex))) > number(5,175))
	{
	  hit(ch, FIGHTING(ch), SKILL_2ND_ATTACK);
	  if (ch)
	    apply_spell_skill_abil(ch, SKILL_2ND_ATTACK);
	  if (!VALID_FIGHTING(ch))
	    break;
	  // dual wielding
	  if (IS_DUAL_WIELDING(ch))
	  {
	    hit(ch, FIGHTING(ch), TYPE_DUAL_ATTACK);
	    if (!VALID_FIGHTING(ch))
	      break;
	  }
	} else { 
	  damage(ch, FIGHTING(ch), 0, SKILL_2ND_ATTACK, FALSE);
	}

	if(third > 0)
	{
	  if ((third + dice(3,(ch->aff_abils.dex))) > number(5,200))
	  {
	    hit(ch, FIGHTING(ch), SKILL_3RD_ATTACK);
	    apply_spell_skill_abil(ch, SKILL_3RD_ATTACK);
	    if (!VALID_FIGHTING(ch))
	      break;
	    // dual wield
            if (IS_DUAL_WIELDING(ch))
	    {
	      hit(ch, FIGHTING(ch), TYPE_DUAL_ATTACK);
	      if (!VALID_FIGHTING(ch))
		break;
	    }
	  } else { 
	    damage(ch, FIGHTING(ch), 0, SKILL_3RD_ATTACK,FALSE);
          }
	}

	/* vampires and wolfs get an extra attack when changed - Vader */
	if (affected_by_spell(ch,SPELL_CHANGED) && (number(0,4) == 0))
	{
	  if(PRF_FLAGGED(ch,PRF_WOLF))
	    damage(ch,FIGHTING(ch),dice(4,GET_LEVEL(ch)),TYPE_CLAW,FALSE);
	  else if(PRF_FLAGGED(ch,PRF_VAMPIRE))
	    damage(ch,FIGHTING(ch),dice(4,GET_LEVEL(ch)),TYPE_BITE,FALSE);
	  if (!VALID_FIGHTING(ch))
	    break;
	}
      } // End Haste Loop
      if ((ch) && !IS_NPC(ch) && AFF_FLAGGED(ch, AFF_SENSE_WOUNDS))
	show_wounded_to_char(ch);
    }

    if (!(ch))
      continue;

    if (IS_NPC(ch))
    {
      if (GET_MOB_WAIT(ch) > 0)
      {
        GET_MOB_WAIT(ch) -= PULSE_VIOLENCE;
        continue;
      }
      GET_MOB_WAIT(ch) = 0;
      if ((GET_POS(ch) < POS_FIGHTING) && (GET_POS(ch) > POS_STUNNED))
      {
        GET_POS(ch) = POS_FIGHTING;
        act("$n scrambles to $s feet!", TRUE, ch, 0, 0, TO_ROOM);
        send_to_char("You scramble to your feet\r\n", ch);
      }
    } 

    /* Mounts add their own special attack */
    if (MOUNTING(ch) || MOUNTING_OBJ(ch))
      perform_mount_violence(ch);

    /* XXX: Need to see if they can handle "" instead of NULL. */
    if (MOB_FLAGGED(ch, MOB_SPEC) && mob_index[GET_MOB_RNUM(ch)].func != NULL)
      (mob_index[GET_MOB_RNUM(ch)].func) (ch, ch, 0, "");
  } // End Fighting Loop.
}
@


1.91
log
@Artus> Killer flag should get wiped when killed now.
@
text
@d156 4
a159 1
    armorclass += 5;
@


1.90
log
@Artus> Changed a few logs to LVL_GOD instead of LVL_IMMORT
       Death by poison is now logged appropriately.
@
text
@d731 1
a731 1
  if (PRF_FLAGGED(ch,PRF_MORTALK))
a732 2
    REMOVE_BIT(PRF_FLAGS(ch), PLR_KILLER | PLR_THIEF);
  } else {
d747 2
@


1.89
log
@Artus> Fixed a bug where things that were stunned would try to scramble to
       their feet.
@
text
@d445 1
a445 1
	mudlog(buf, NRM, MAX(GET_INVIS_LEV(ch), LVL_IMMORT), TRUE);
d451 1
a451 1
    mudlog(buf, CMP, MAX(GET_INVIS_LEV(ch), LVL_IMMORT), TRUE);
d1629 1
a1629 1
	if (GET_LEVEL(ch) >= LVL_IMMORT)
d1873 3
a1875 10
      if (!IS_NPC(ch)) 
      {
        sprintf(buf2, "%s died at %s", GET_NAME(ch), 
		world[victim->in_room].name);
        mudlog(buf2, BRF, LVL_ETRNL1, TRUE);
      } else {
        if (MOB_FLAGGED(ch, MOB_MEMORY))
          forget(ch, victim);
      }
      die(victim,ch);
@


1.88
log
@Artus> QEQ should no longer be damaged in inventory.
@
text
@d1505 1
d1755 2
a1756 1
  if (!IS_WEAPON(attacktype)) {
d1759 3
a1761 2
    if (GET_POS(victim) == POS_DEAD || dam == 0) {
      if (!skill_message(dam, ch, victim, attacktype)) {
a1762 1
      }
d1790 1
a1790 1
			TRUE, victim, 0, 0, TO_ROOM);
d1792 1
a1792 1
			"aided.\r\n", victim);
d1796 1
a1796 1
			TRUE, victim, 0, 0, TO_ROOM);
d1802 1
a1802 1
			TRUE, victim, 0, 0, TO_ROOM);
d1804 1
a1804 1
			"again.\r\n", victim);
a1809 1

d1812 1
a1812 2
        send_to_char("That really did HURT!\r\n", victim);

d1816 2
a1817 2
			  "much!%s\r\n",
		CCRED(victim, C_SPR), CCNRM(victim, C_SPR));
a1818 1

d1821 1
a1821 2
	      (IN_ROOM(ch) == IN_ROOM(victim))) // Don't flee if not in the 
	    					// room anymore - Artus
a1823 1

d1831 1
a1831 1
      break;
a1838 1
  // Artus> Doesn't make sense to damage the eq when the attack misses.
d1845 1
a1845 1
	  damChance = 1;
d1847 1
a1847 1
	  damage_equipment(victim);
d1851 2
a1852 1
  if (!IS_NPC(victim) && !(victim->desc) && GET_POS(victim) > POS_STUNNED) {
d1854 2
a1855 1
    if (!FIGHTING(victim)) {
d1868 2
a1869 2
  if (GET_POS(victim) == POS_DEAD) {

d1876 1
a1876 1
                        world[victim->in_room].name);
d1886 2
a1887 1
    if ((ch != victim) && (IS_NPC(victim) || victim->desc)) {
d1909 1
a1909 1
  if( (dam > 0) && !IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_MANA_THIEF) ) 
d1911 25
a1935 26
        // Some semi random chance of draining
        // Current mana / (level * modifier) -- Becomes more likely when mana is lower
        if( number(0, (int)(GET_MANA(ch)/(GET_LEVEL(ch) * GET_MODIFIER(ch))) ) !=0)
                return (dam);
 
        if( GET_MANA(ch) < GET_MAX_MANA(ch) )
        {
          if( !IS_NPC(victim) )
                manastolen += number(1, (int)(GET_MAX_MANA(victim) * 0.05));
          else
                manastolen += number(1, (int)(GET_MAX_MANA(ch) * 0.05));
 
          if( manastolen > GET_MANA(victim) && !IS_NPC(victim) )
                manastolen = GET_MANA(victim);
          if( !IS_NPC(victim) )
               GET_MANA(victim) -= manastolen;
          GET_MANA(ch) += manastolen;
          if( GET_MANA(ch) > GET_MAX_MANA(ch) )
                GET_MANA(ch) = GET_MAX_MANA(ch);
          if( manastolen > 0 )
          {
             act("You manage to steal some mana from $N as you hit $M.", FALSE,
                ch, 0, victim, TO_CHAR);
             act("$n stole some of your mana!", FALSE, ch, 0, victim, TO_VICT);
          }
        }
d1939 3
a1941 2
  if ( (dam > 0 ) && !IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_FOREST_HELP) 
	&& (SECT(ch->in_room) == SECT_FOREST) && (victim != ch))
d1943 20
a1962 20
        // Semi random chance of aid
        // Current hp / (level * modifier) -- Becomes more likely as druid is dying 
        if( number(0, (int)(GET_HIT(ch)/(GET_LEVEL(ch) * GET_MODIFIER(ch))) ) !=0)
                return (dam);
 
        if (GET_CLASS(victim) == CLASS_DRUID )
        {
           act("Your forest allies are unable to harm another druid.",
                        FALSE, ch, 0, 0, TO_CHAR);
           act("You discourage $n's forest allies from attacking you.",
                        FALSE, ch, 0, victim, TO_VICT);
           return (dam);
        }
        act("Your forest allies come to your aid, briefly attacking $N.",
                FALSE, ch, 0, victim, TO_CHAR);
        act("$n's forest allies aid $s attack on $N.", FALSE, ch, 0, victim, TO_ROOM);
        act("$n's forest allies attack you briefly, aiding $m.",
                FALSE, ch, 0, victim, TO_VICT);
        dam += number(1, (int)(GET_LEVEL(ch) * GET_MODIFIER(ch)
                            * (GET_WIS(ch) < 15 ? 1 : GET_WIS(ch) < 19 ? 2 : 3) ) );
d1966 2
a1967 2
  if( (dam > 0) && !IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_HOLY) 
	&& (GET_CLASS(victim) == CLASS_UNDEAD) )
d1969 10
a1978 11
	if( number(1, (int) (GET_HIT(ch) / (GET_MODIFIER(ch) 
	                    * (GET_WIS(ch) < 15 ? 1 : GET_WIS(ch) < 19 ? 2 : 3)) ) ) != 1)
		return (dam);
	act("&WThe holy powers within you arise and slay $N as you strike at $m.&n",
		FALSE, ch, 0, 0, TO_CHAR);
	act("&WOverwhelmed by $n's holy power, $N is banished from this realm!&n",
		FALSE, ch, 0, victim, TO_ROOM);
	act("&R$n's holy power overwhelms you, banishing you to the nether realms!&n",
		FALSE, ch, 0, victim, TO_VICT); 
	raw_kill(victim, ch);
	return (-1); // deaaaaaaaaad
d1982 5
a1986 5
  if ( !IS_NPC(ch) && ((IS_SET(GET_SPECIALS(ch), SPECIAL_ELF) 
        && (SECT(ch->in_room) == SECT_FOREST))
   ||  (IS_SET(GET_SPECIALS(ch), SPECIAL_DWARF) 
        && (SECT(ch->in_room) == SECT_INSIDE))) )
     dam  = (int)(dam * 1.10); 	
d1989 1
a1989 1
  if ( (dam > 0 ) && !IS_NPC(ch) && IS_SET(GET_SPECIALS(ch), SPECIAL_GORE) )
d1991 20
a2010 20
	// Semi random chance of aid
	// Current hp / (level * modifier) -- Becomes more likely as character is dying
	if( number(0, (int)(GET_HIT(ch)/(GET_LEVEL(ch) * GET_MODIFIER(ch))) ) !=0)
		return (dam);	

        if (GET_CLASS(victim) == CLASS_DRUID )
	{
	   act("Your forest allies are unable to harm another druid.",
			FALSE, ch, 0, 0, TO_CHAR);
	   act("You discourage $n's forest allies from attacking you.",
			FALSE, ch, 0, victim, TO_VICT);
	   return (dam);
	}
	act("You viciously lay about with your horns, wounding $N.",
		FALSE, ch, 0, victim, TO_CHAR);
	act("$n's horns gore $N.", FALSE, ch, 0, victim, TO_ROOM);
	act("$n's horns dig deeply into you.",
		FALSE, ch, 0, victim, TO_VICT);
	dam += number(1, (int)(GET_LEVEL(ch) * GET_MODIFIER(ch) 
	                    * (GET_STR(ch) < 15 ? 1 : GET_STR(ch) < 19 ? 2 : 3) ) ); 
a2011 1

d2520 2
a2521 1
      if (GET_POS(ch) < POS_FIGHTING) {
@


1.87
log
@Artus> Fixed crash / memory leak.
@
text
@d1433 2
a1434 1
  if (!obj || !ch) {
a1437 1

d1456 9
a1464 11
  for (i = 0; i < NUM_WEARS && !found; i++) {
    if (GET_EQ(ch, i)) {
      if (number(1, NUM_WEARS) == NUM_WEARS) {
        if (GET_OBJ_MAX_DAMAGE(GET_EQ(ch, i)) == -1 || 
            OBJ_FLAGGED(GET_EQ(ch, i), ITEM_QEQ))
          continue;

	   damage_obj(GET_EQ(ch, i), number(1, 5), ch);
        found = 1;
        break;
      }
d1467 3
a1469 2

  if (found) {
d1471 2
a1472 1
                    GET_OBJ_MAX_DAMAGE(GET_EQ(ch, i)) != -1) {
d1476 13
a1488 13
  } else {	
    // nothing was damaged, slight chance of getting inventory
    for (obj = ch->carrying; obj; obj = obj->next_content) {
      if (!number(0, 10)) {
        if (GET_OBJ_DAMAGE(obj) != -1 || OBJ_FLAGGED(obj, ITEM_QEQ)) {
          damage_obj(obj, number(1, 5), ch);

          if (GET_OBJ_DAMAGE(obj) <= 0) {
            GET_OBJ_DAMAGE(obj) = 0;
            break_obj(obj, ch);
          }
          return;
        }
d1490 1
d1492 1
a1492 1
  } 
@


1.86
log
@Artus> Superman now sets real str and con to 21.
@
text
@a722 1

@


1.85
log
@Artus> Removed some no longer necessary debug info.
@
text
@d881 2
a882 1
      if (!IS_NPC(f->follower)) {
d1579 1
a1579 1
	die(ch, victim);
d2130 1
a2130 1
      dam += (int)((GET_DAMROLL(ch) * 0.05) + 1);
d2133 1
a2133 1
      dam += (int)((GET_DAMROLL(ch) * 0.02) + 1);
@


1.84
log
@Artus> Second/Third attack check has_stats_for_prac().
       Implemented SPECIAL_BATTLEMAGE.
@
text
@a586 15
#ifndef IGNORE_DEBUG
      if ((killer) && !IS_NPC(killer) && GET_DEBUG(killer))
      {
	int titanrnum = GET_MOB_RNUM(ch);
	sprintf(buf, "DBG: 1) %d\r\n", mob_index[titanrnum].number);
	send_to_char(buf, killer);
	make_titan_corpse(ch);
	sprintf(buf, "DBG: 1) %d\r\n", mob_index[titanrnum].number);
	send_to_char(buf, killer);
	extract_char(ch);
	sprintf(buf, "DBG: 1) %d\r\n", mob_index[titanrnum].number);
	send_to_char(buf, killer);
	return;
      }
#endif
a1650 5
      {
#ifndef IGNORE_DEBUG
	if (GET_DEBUG(ch))
	{
	  sprintf(buf, "DBG: BattleMage: %d / ", dam);
a1651 6
	  sprintf(buf + strlen(buf), "%d\r\n", dam);
	  send_to_char(buf, ch);
	} else
#endif
	  dam = (int)((double)(dam * 1.5));
      }
@


1.83
log
@Artus> Added call to handle_quest_mob_death() to raw_kill().
@
text
@d1575 2
a1576 1
          (victim->master->in_room == ch->in_room)) {
d1638 2
a1639 1
    if (!IS_NPC(victim) && GET_SKILL(victim, SKILL_DEFEND)) {
d1659 20
a1678 3
    if (!IS_NPC(ch) && (AFF_FLAGGED(ch, AFF_BERSERK)))
      if ((SPELL_EFFEC(ch, SKILL_BERSERK) / 100) > 0.5)
	dam = (int)(dam * (2 * (SPELL_EFFEC(ch, SKILL_BERSERK) / 100)));
d1696 2
a1697 1
	if (number(1, 100) < GET_SKILL(victim, SKILL_TUMBLE)) {
d2420 1
d2471 9
a2479 1
	  third = GET_SKILL(ch, SKILL_3RD_ATTACK);
@


1.82
log
@Artus> Slightly modified titan corpse stuff. (Added debug)
@
text
@d527 1
d539 3
@


1.81
log
@Artus> Clan tax.
@
text
@d582 21
a602 3
      make_titan_corpse(ch);    
    else
      corpse = make_corpse(ch);
@


1.80
log
@Artus> Added CRLF to magic weapon disintegrate message.
@
text
@d519 1
d570 1
d572 2
@


1.79
log
@Artus> Fixed another crash bug.
       MAG_AREAS can no longer be used on weapons. (QEQ Excepted.)
@
text
@d2249 1
a2249 1
	      sprintf(buf, "&rLighting comes from the sky, disintegrating &5%s&r.&n", OBJS(wielded, ch));
@


1.78
log
@Artus> Clean up only.
@
text
@d34 1
d2231 1
d2233 1
d2240 26
a2265 6
          call_magic(ch, real_vict, NULL, GET_OBJ_VAL(wielded,0), 
                          2 * GET_LEVEL(ch), CAST_MAGIC_OBJ); 
	  if (!VALID_FIGHT(ch, real_vict))
	    return;
	}

d2298 8
a2305 2
	  if (prior->next != victim)
	    return;
d2317 8
a2324 2
	if (prior->next != victim)
	  return;
@


1.77
log
@Artus> Poison fix.
@
text
@d2357 3
a2360 3
      {
	if (!VALID_FIGHTING(ch))
	  break;
a2361 1
      }
@


1.76
log
@Artus> fixed another crash.
@
text
@d1821 1
a1821 1
  if (dam > 0) 
@


1.75
log
@Artus> Anyone can now become a ghost.
@
text
@d2249 12
d2275 2
d2288 2
@


1.74
log
@Artus> NPC barehanddam is always calculated into NPC attacks.
@
text
@d554 1
d556 2
@


1.73
log
@Artus> Cleanup.
@
text
@d2114 1
d2123 8
@


1.72
log
@Artus> Changes for object spells.
@
text
@d795 1
a795 1
  if (PRF_FLAGGED(ch, PRF_MORTALK))
d834 2
a835 1
  if (PRF_FLAGGED(ch, PRF_MORTALK)){
d839 1
a839 1
                     ch);
@


1.71
log
@Artus> Now warning free :o)
@
text
@d539 2
a540 1
    if (af->duration != CLASS_ABILITY)
@


1.70
log
@Artus> Conditionals for IGNORE_DEBUG.
       Mortal Kombat should no longer set KILLER. (Really)
       Should no longer get EXP from NOKILL mobs if you manage to hit them.
@
text
@d518 1
a518 1
  struct obj_data *corpse = NULL, *obj, *next_obj;
d825 1
a825 1
  int tot_members, base, tot_gain, exp;
a1999 3
  int attacktype;
  int reloadable;   

@


1.69
log
@Artus> Mortal should no longer set killer bit.
       DTs should now create corpses outside the DT.
@
text
@d795 1
a795 1
        return;
d797 4
a800 1
        return;  
d972 7
d1513 1
d1519 1
d1687 7
a1693 3
    if (!IS_NPC(ch) && !PRF_FLAGGED(ch, PRF_MORTALK))  
      gain_exp(ch, GET_LEVEL(victim) * dam);
    else if (IS_NPC(ch))
d1695 1
d2071 1
d2084 1
@


1.68
log
@Artus> Added a tonne of death checking into the fight loop.
       -- Should hopefully prevent things like crashing when a hasted player
          dies, etc.
@
text
@a344 2


d349 1
d399 2
a400 1
    if (GET_EQ(ch, i)) {
d406 2
a407 1
  if (GET_GOLD(ch) > 0) {
d409 2
a410 1
    if (IS_NPC(ch) || (!IS_NPC(ch) && ch->desc)) {
d421 31
a451 1
  room_vnum roomvnum;
d453 2
a454 1
  if (!IS_NPC(ch) && EXT_FLAGGED(ch, EXT_AUTOCORPSE)) {
d456 2
a457 3
  } else {
    roomvnum = GET_ROOM_VNUM(ch->in_room);
  }
d461 2
a462 3
  if (!IS_NPC(ch)) {
    corpseData.addCorpse(corpse, roomvnum, GET_WEIGHT(ch)); 
  }
d464 1
a464 1
  obj_to_room(corpse, real_room(roomvnum));
a515 2


d532 3
@


1.67
log
@Artus> Can now improve second/third attack.
@
text
@d675 1
d682 2
d694 1
a694 1
      exp_lost = 0-gain_exp(ch, -exp_lost);
d696 2
a697 2
      if (!IS_NPC(ch) && EXT_FLAGGED(ch, EXT_AUTOCORPSE))
        exp_lost += gain_exp(ch, (int)(0-exp_lost/2));
d722 2
d1509 11
d1521 1
d1954 8
d1967 2
a1968 1
  fight_mtrigger(ch);
d1974 1
d1976 1
d1980 2
a1981 1
 
a1983 1
        assert(real_vict);  
d1985 2
a1986 6
  /* Do some sanity checking, in case someone flees, etc. */
  if (ch->in_room != victim->in_room) {
    if (FIGHTING(ch) && FIGHTING(ch) == victim)
      stop_fighting(ch);
    return;
  }
d2000 2
a2001 2
  if (wielded && !IS_NPC(ch) && OBJ_IS_GUN(wielded)) {

d2003 2
a2004 1
    if (GET_OBJ_VAL(wielded, 0) <= 0) {
d2035 2
a2036 1
       ((diceroll == 1) || ((calc_thaco - diceroll) > victim_ac)))) {
a2037 1

a2043 1

d2054 2
a2055 2
    if ( !IS_NPC(ch) && IS_SET(GET_SPECIALS(ch) , SPECIAL_MINOTAUR))
	dam += (int)((GET_DAMROLL(ch) * 0.05) + 1);
d2058 1
a2058 1
	dam += (int)((GET_DAMROLL(ch) * 0.02) + 1);
d2092 2
a2093 4
        (GET_LEVEL(ch) >= PROTECT_LEVEL) ) {
 
      dam -= ( GET_LEVEL(real_vict) / MAX(2,num_attacks(real_vict)) );
    } 
d2105 1
a2105 1
      dam = (int) (dam * GET_SKILL(ch, SKILL_AMBIDEXTERITY) / 100);
d2109 2
a2110 1
    if (type == SKILL_BACKSTAB) {
d2112 4
a2115 4
      if (damage(ch, real_vict, dam, SKILL_BACKSTAB, FALSE) > 0)// Check it's still alive
      {
        if (GET_SKILL(ch, SKILL_DOUBLE_BACKSTAB))		// Give it another go
        {
d2123 1
d2130 3
d2134 1
a2134 1
    if ((IS_AFFECTED(real_vict,AFF_REFLECT)) && (dam > 0) && 
d2137 1
d2139 3
d2146 1
d2148 3
d2153 1
d2155 3
d2160 1
d2162 3
d2170 1
d2177 3
d2181 33
a2215 23
  /* DM - autoassist check */
  if (GET_POS(victim) == POS_FIGHTING)
    for (char_room=world[ch->in_room].people;char_room;char_room=char_room->next_in_room) {
      if (!IS_NPC(char_room))
        if (AUTOASSIST(char_room) == ch)
 
          /* Ensure all in room and vict fighting
          if ((world[ch->in_room].number == world[victim->in_room].number) &&
              (world[ch->in_room].number == world[char_room->in_room].number) &&
              (GET_POS(victim) = POS_FIGHTING)) */
 
          if (IS_NPC(victim) && (GET_POS(victim) == POS_FIGHTING) &&
            (world[char_room->in_room].number == world[victim->in_room].number) &&
            (!FIGHTING(char_room)) && CAN_SEE(char_room,ch) && CAN_SEE(char_room,victim)) {
 
            act("$n assists $N!", FALSE, char_room, 0, ch, TO_NOTVICT);
            act("$N assists you!", FALSE, ch, 0, char_room, TO_CHAR);
            sprintf(buf,"You assist %s!\n\r",GET_NAME(ch));
            send_to_char(buf,char_room);
            hit(char_room,victim,TYPE_UNDEFINED);
          }
    }       

d2232 2
a2233 1
void perform_mount_violence(struct char_data *rider) {
d2262 2
a2263 1
  for (ch = combat_list; ch; ch = next_combat_list) {
d2268 1
a2268 1
    if (FIGHTING(ch) == NULL || ch->in_room != FIGHTING(ch)->in_room) 
d2272 13
a2284 10
    } else {
      if (affected_by_spell(ch, SPELL_HASTE)) {
	loop = 2;
      } 

      for (i=0;i<loop;i++) 
      {
	if (i == 1)
	  if (FIGHTING(ch))	
            send_to_char("You are hastened and get more attacks\r\n", ch);
d2286 19
a2304 1
	if (FIGHTING(ch)) 
d2306 8
a2313 1
	  hit(ch, FIGHTING(ch), TYPE_UNDEFINED);
d2315 12
a2326 2
	  // dual wield
          if (FIGHTING(ch) && IS_DUAL_WIELDING(ch))
d2328 5
d2335 3
a2337 10
  	/* the below bit is added to allow multiple attacks per turn - VADER */
	if(IS_NPC(ch)) 
	  second = third = 100;  			
	else {
	  second = GET_SKILL(ch, SKILL_2ND_ATTACK);
	  third  = GET_SKILL(ch, SKILL_3RD_ATTACK);
	}  

	if(((!IS_NPC(ch) && second) || (IS_NPC(ch) && MOB_FLAGGED(ch,MOB_2ND_ATTACK))) && FIGHTING(ch))
	  if((second + dice(3,(ch->aff_abils.dex))) > number(5,175))
a2338 11
	    hit(ch, FIGHTING(ch), SKILL_2ND_ATTACK);
	    apply_spell_skill_abil(ch, SKILL_2ND_ATTACK);
	    // dual wielding
            if (FIGHTING(ch) && IS_DUAL_WIELDING(ch))
	      hit(ch, FIGHTING(ch), TYPE_DUAL_ATTACK);
	  } else { 
	    damage(ch, FIGHTING(ch), 0, SKILL_2ND_ATTACK, FALSE);
          }

	if(((!IS_NPC(ch) && third) || (IS_NPC(ch) && MOB_FLAGGED(ch,MOB_3RD_ATTACK))) && FIGHTING(ch))
	  if((third  + dice(3,(ch->aff_abils.dex))) > number(5,200)) {
d2341 2
d2344 2
a2345 1
            if (FIGHTING(ch) && IS_DUAL_WIELDING(ch))
d2347 3
d2353 2
d2356 2
a2357 1
	if(affected_by_spell(ch,SPELL_CHANGED) && (number(0,4) == 0) && FIGHTING(ch))
d2362 3
d2366 1
a2366 1
      if (!IS_NPC(ch) && AFF_FLAGGED(ch, AFF_SENSE_WOUNDS))
d2370 2
d2373 4
a2376 2
    if (IS_NPC(ch)) {
      if (GET_MOB_WAIT(ch) > 0) {
d2388 3
a2390 8
    // if (GET_POS(ch) < POS_FIGHTING) {
    //  send_to_char("You can't fight while sitting!!\r\n", ch);
    //  continue;
    //}

   /* Mounts add their own special attack */
   if (MOUNTING(ch) || MOUNTING_OBJ(ch))
	perform_mount_violence(ch);
a2391 1
//    hit(ch, FIGHTING(ch), TYPE_UNDEFINED);
d2395 1
a2395 1
  }
@


1.66
log
@Artus> Fixed bug where having autocorpse on was actually REDUCING the exp lost,
         rather than increasing it.
       Fixed bug that was converting all events to happy hour events.
       Fixed typo in Mortal Kombat win message.
@
text
@d2245 1
d2256 1
@


1.65
log
@Artus> Now calling show_wounded_to_char() for sense wounds.
@
text
@d694 1
a694 1
        exp_lost -= gain_exp(ch, (int)(exp_lost/2));
d772 1
a772 1
      if (ev->type = EVENT_HAPPY_HR)
d796 1
a796 1
     send_to_char("You are the SUPREME warrior of the MOrtal Kombat arena!\r\n",
d1039 1
a1039 1
      if (ev->type = EVENT_HAPPY_HR)
@


1.64
log
@Artus> minor change for wolf
@
text
@d2202 1
d2268 2
a2269 28
      if (!IS_NPC(ch) && AFF_FLAGGED(ch, AFF_SENSE_WOUNDS) &&
	  AFF_FLAGGED(ch, AFF_GROUP))
      {
	struct char_data *lead;
	struct follow_type *fol;
	if (ch->master)
	{
	  lead = ch->master;
	  if (!IS_NPC(lead) && AFF_FLAGGED(lead, AFF_GROUP) &&
	      GET_HIT(lead) <= (int)(GET_MAX_HIT(lead)/3) &&
	      IN_ROOM(lead) == IN_ROOM(ch))
	    act("$N&r could use a little healing!&n", FALSE, ch, NULL, lead, 
		TO_CHAR);
	} else {
	  lead = ch;
	}
	for (fol = lead->followers; fol; fol = fol->next) 
	{
	  if (!(fol->follower) || IS_NPC(fol->follower) || 
	      !AFF_FLAGGED(fol->follower, AFF_GROUP) || 
	      (fol->follower == ch) ||
	      (GET_HIT(fol->follower) > (int)(GET_MAX_HIT(fol->follower)/3)) ||
	      (IN_ROOM(ch) != IN_ROOM(fol->follower)))
	    continue;
	  act("$N&r could use a little healing!&n", FALSE, ch, NULL, 
	      fol->follower, TO_CHAR);
	}
      }
@


1.63
log
@Artus> Changed the clone exp stuff, added happy hour.
@
text
@d515 1
a515 1
    GET_HIT(ch)= GET_MAX_HIT(ch);
@


1.62
log
@Artus> Removed that damn reqiure stats from magic weapons.
@
text
@d752 2
d764 1
a764 1
    sprintf(buf2, "You receive your share of experience -- &5%d&n points.\r\n", (int)(share * (1/GET_MODIFIER(ch))));
d769 10
a778 1
  gain_exp(ch, share);
d927 2
d980 3
d985 1
a985 1
    if (IS_CLONE(ch) && IS_CLONE_ROOM(ch))
d989 1
d994 1
a994 1
    if (IS_CLONE(ch) && IS_CLONE_ROOM(ch))
d998 1
d1002 1
a1002 1
    if (IS_CLONE(ch) && IS_CLONE_ROOM(ch)) {
d1011 4
d1016 1
a1016 1
    if (IS_CLONE(ch) && IS_CLONE_ROOM(ch))
d1019 1
d1023 1
d1025 1
a1025 1
    gain_exp(ch->master, exp);
d1028 1
a1028 1
    gain_exp(ch, exp);
d1032 14
@


1.61
log
@Artus> Group exp should now factor in modifier for display.
@
text
@d2088 3
a2090 3
        //if(number(0,3))
        // DM - only use spells we know
        if (has_stats_for_skill(ch, GET_OBJ_VAL(wielded, 0), FALSE) 
d2092 1
a2092 1
                && number(0, 3))
@


1.60
log
@Artus> No longer remove abilities when leaving mortal kombat.
@
text
@d760 3
a762 2
  if (share > 1) {
    sprintf(buf2, "You receive your share of experience -- &5%d&n points.\r\n", share);
@


1.59
log
@Artus> Passing attacktype to set_fighting.
@
text
@d482 1
a482 1
		world[ch->in_room].dir_option[door]->to_room);
d494 1
d502 1
a502 1
 stop_fighting(ch);
d504 6
a509 2
  while (ch->affected)
    affect_remove(ch, ch->affected);
d514 1
a514 1
    call_magic(ch,ch,NULL,42,GET_LEVEL(ch),CAST_MAGIC_OBJ);
@


1.58
log
@Artus> LR_FAIL_MAX() for ghost.
@
text
@d269 1
a269 1
void set_fighting(struct char_data * ch, struct char_data * vict)
d285 14
d637 1
d1439 2
a1440 2
    if (GET_POS(ch) > POS_STUNNED && (FIGHTING(ch) == NULL) &&
	IN_ROOM(ch) == IN_ROOM(victim)) 
d1442 1
a1442 1
      set_fighting(ch, victim);
d1472 1
a1472 1
      set_fighting(victim, ch);
@


1.57
log
@Artus> Only providing ambidex bonus if they have the skill.
@
text
@d700 1
a700 1
  if (!LR_FAIL(ch, LVL_NEWBIE))
@


1.56
log
@Artus>
act.comm.c       : Completely rewrote the auction code.
act.informative.c: New event type: Fire.
                   Fixed colour bleed in exits.
act.item.c       : invalid_level() now only allows remort classes to use eq
                   earlier if it was usable before they remorted.
act.movement.c   : Gateways now pass through the standard invalid_level()
                   check. This should make it possible to restrict entrance
                   based on class.
act.offensive.c  : Cleaned up.
act.other.c      : Hide now applies to spell/skill ability.
                   Title length limit removed, title restricted level 5.
act.wizard.c     : "debug sm" will now display the integer value of current
                   rooms "small_bits"
                   Added annoying poofin for me.
                   New event type: Fire.
boards.c         : Boards now use max level as opposed to level.
clan.c           : Cleaned up.
class.c          : Cleaned up.
comm.c           : Minor changes for remort max levels to exp prompt.
db.c             : Auctions are now stored in file.
                   Initial zone resets moved before houses and auctions load.
db.h             : Auctions are now stored in file.
dg_mobcmd.c      : Cleaned up.
dg_objcmd.c      : Cleaned up.
dg_scripts.c     : Cleaned up.
dg_wldcmd.c      : Cleaned up.
fight.c          : Added pcorpse alias to corpses.
graph.c          : Cleaned up.
handler.c        : Item counter changed so item count won't be reduced below
                   zero.
house.c          : Removed item decrementor.
interpreter.c    : Command level checks are now done against max level.
interpreter.h    : Removed old auction SCMD_xxx, Added new auction AUC_xxx
limits.c         : First remort max exp * 12500, second max exp * 15000
magic.c          : Cleaned up.
mail.c           : Added support for mail from auction system.
mail.h           : Added support for mail from auction system.
medit.c          : Cleaned up.
modify.c         : Cleaned up.
oasis.c          : Added zedit sect # support - Sets the base sect to the
                   same value in all rooms in zone.
oasis.h          : Added zedit sect # support.
objsave.c        : Added Obj_to_file_elem routine.
reports.cpp      : Replaced 0 with MAIL_FROM_REPORT in store_mail calls.
shop.c           : Replaced GET_OBJ_LR() check with invalid_level() call.
spec_procs.c     : Fixed bug where repair wasn't listing costs.
                   Cleaned up.
spell_parser.c   : Replaced various damage calcs with calc_dam_amt.
spells.c         : Added identify_obj_to_char, called by SPELL_IDENTIFY and
                   auction stat.
                   Colourised identify output.
structs.h        : Added EVENT_FIRE macro.
                   Removed old auction defines.
                   Added auction structures auc_data, auc_file_elem.
                   Added auction macros AUC_STAT_COST, AUC_ROOM< AUC_LIMIT.
                   Added RMSM_BURNED macro to identify burned rooms.
                   Added small_bits to room structure. Unsaved bitvector.
tedit.c          : Cleaned up.
utils.c          : Added calc_dam_amt to separate damage calculations for
                   skills.
                   Added init_auctions and write_auction_file for storage
                   and retrieval of auctions.
utils.h          : RMSM_FLAGS(room_rnum) - Room's Small Bits.
                   RMSM_FLAGS(room_rnum, bit) - Check small bits.
                   LR_FAIL(ch, lvl) - Basic level test.
                   LR_FAIL_MAX(ch, lvl) - Level test against max level,
                   unless lvl > LVL_IMMORT.
                   CAN_LEVEL(ch) macro.
                   STRTODAM(ch) macro - str_app.todam
zedit.c          : Added zedit_sect_all().
@
text
@d2022 1
a2022 1
    if (type == TYPE_DUAL_ATTACK) 
d2182 2
a2183 1
	  if((second + dice(3,(ch->aff_abils.dex))) > number(5,175)) {
@


1.55
log
@Artus> Added pcorpse alias to player corpses.
@
text
@d131 1
a131 1
  if (GET_LEVEL(ch) < LVL_ANGEL)
d251 1
a251 1
  if (GET_LEVEL(ch) > LVL_IS_GOD) 
a342 1
  corpse->name = str_dup("pcorpse corpse");
d360 1
d364 1
d700 1
a700 1
  if (GET_LEVEL(ch) <= LVL_NEWBIE)
d1192 1
a1192 1
      if (!IS_NPC(vict) && (GET_LEVEL(vict) >= LVL_ANGEL)) {
d1413 1
a1413 1
  if (!IS_NPC(victim) && (GET_LEVEL(victim) >= LVL_ANGEL))
@


1.54
log
@Artus>
act.informative.c: Fixed bug where examining a container was always listng the
                   objects in the first container matched.
                   Gold rush finishing is now only displayed within the same
		   world.
act.movement.c   : Environmental damage is now passed through damage().
act.offensive.c  : Throw() now calls damage().
act.other.c      : When you fail to create a torch, it hurts.
dg_mobcmd.c      : mdamage() now calls damage().
dg_objcmd.c      : odamage() now calls damage().
dg_wldcmd.c      : wdamage() now calls damage().
fight.c          : Changed damage() to allow a NULL ch.
interpreter.c    : Falling because fly has worn off now calls damage().
limits.c         : No waterbreathe underwater now calls damage().
magic.c          : Added handle_fireball() for fire breathing, fireball, type
                   stuff..
                   Random chance of objs in inventory/open containers burning
                   up :o)
spec_assign.c    : Removed some unused/wasted assigns: corridor_guard,
                   receiptionist, virus, bacteria.
spec_procs.c     : Removed some unused/wasted procs. Changed lots of tali's
                   indenting.
                   Fixed gaping hole in deadlyblade proc.
                   Replaced GET_HIT(vict) -= with damage(ch, vict...
spell_parser.c   : Added awake and can_see checks to magic fail = mob attacks.
@
text
@d343 1
a343 1
  corpse->name = str_dup("corpse");
@


1.53
log
@Artus> Intermittent build.
act.informative.c: Affect/Timers now display something when no affects/timers
                   are present.
                   Sense curse now senses objects inside containers.
act.movement.c   : Optimised the aggravate stuff a little.
act.offensive.c  : Logging death by pit trap.
act.other.c      : Logging death by suicide.
                   Superman now sets affects rather than actual stats, for STR
                   and CON (CON bonus is +1, STR is 21 - GET_REAL_STR
                   Logging death by arrow.
clan.c           : Removed aggravate_check() function, no longer used.
db.c             : Now initialising character specials.
dg_mobcmd.c      : Logging death by mdamage.
dg_objcmd.c      : Logging death by odamage.
dg_wldcmd.c      : Logging death by wdamage.
fight.c          : New optional msg paramater to die(), for if the death was
                   not caused by a character.
                   Deaths are now logged to info channel.
handler.c        : Modified ability affect function to permit more than one
                   affect modifier per special. (Required for superman)
spec_procs.c     : Logging death by pit trap, archers and room blast.
spells.h         : Added SPELL_SUPERMAN for special affect modifiers.
utils.h          : Updated die() prototype to match changes in fight.c.
@
text
@d1380 13
a1392 1
  if (vcheck) 
d1397 2
a1398 1
    if (GET_POS(victim) <= POS_DEAD) {
d1400 1
a1400 1
		  GET_NAME(victim), GET_ROOM_VNUM(IN_ROOM(victim)), GET_NAME(ch));
d1406 1
a1406 1
  if (GET_DEBUG(ch))
d1418 4
a1421 1
  if (victim != ch) {
d1423 3
a1425 1
    if (GET_POS(ch) > POS_STUNNED && (FIGHTING(ch) == NULL)) {
d1442 12
a1464 1
  }
d1466 13
a1478 20
  /* If you attack a pet, it hates your guts */
  if (victim->master == ch)
    stop_follower(victim);

  if (AUTOASSIST(victim) == ch)
    stop_assisting(victim);

  /* If the attacker is invisible, he becomes visible */
  if (AFF_FLAGGED(ch, AFF_INVISIBLE | AFF_HIDE))
    appear(ch);

  /* check for particular type of weapon mastery for more damage */
  if (!IS_NPC(ch) && (GET_EQ(ch, WEAR_WIELD))) {
    if (GET_SKILL(ch, SKILL_AXEMASTERY) && is_axe(GET_EQ(ch, WEAR_WIELD))) {
      //send_to_char("Your axe mastery comes in handy.\r\n", ch);
      dam += (int)(dam * 0.10);
    }
    if (GET_SKILL(ch, SKILL_BLADEMASTERY) && is_blade(GET_EQ(ch, WEAR_WIELD))) {
      //send_to_char("Your blade mastery comes in handy.\r\n", ch);
      dam += (int)(dam * 0.10);
a1479 1
  }
d1481 21
a1501 13
  /* check if victim has DEFEND skill  */
  /* Could potentially do much more with this skill -- ie, parry, riposte, and so on */
  // TODO: check for attack type?
  if (!IS_NPC(victim) && GET_SKILL(victim, SKILL_DEFEND)) {
    if (number(1, 101) < GET_SKILL(victim, SKILL_DEFEND)) {
      if (GET_LEVEL(ch) >= LVL_IMMORT)
        dam -= ((int)(dam / 2));	// champs can halve damage
      else if (GET_LEVEL(ch) >= 75)
        dam -= ((int)(dam / 3));	// 2/3's damage
      else if (GET_LEVEL(ch) >= 40)
        dam -= ((int)(dam / 4));	// 3/4's damage
      else
        dam -= ((int)(dam  / 5));	// 4/5's damage
d1503 47
a1549 2
      if (dam < 0)
        dam = 0;   
d1551 13
a1563 4
      apply_spell_skill_abil(ch, SKILL_DEFEND);
//	act("You defend yourself well against $n's attack.", FALSE, ch, 0, victim, TO_VICT);
//	act("$N defends against your attack, avoiding some damage.", FALSE, ch, 0, victim,TO_CHAR);
     }
d1565 6
a1570 1
  }
d1578 2
a1579 2
    if ((SPELL_EFFEC(ch, SKILL_BERSERK) / 100) > 0.5) 
      dam = (int)(dam / (2 * (SPELL_EFFEC(ch, SKILL_BERSERK) / 100)));
a1580 61
  /* Double damage if char is berserk */
  if (!IS_NPC(ch) && (AFF_FLAGGED(ch, AFF_BERSERK)))
    if ((SPELL_EFFEC(ch, SKILL_BERSERK) / 100) > 0.5)
      dam = (int)(dam * (2 * (SPELL_EFFEC(ch, SKILL_BERSERK) / 100)));
  
  /* Check for PK if this is not a PK MUD */
  if (!pk_allowed) {
    check_killer(ch, victim);
    if (PLR_FLAGGED(ch, PLR_KILLER) && (ch != victim))
      dam = 0;
  }

  // DM: Tumble skill - chance vict tumbles avoiding attack
  // hmm is this best place? - first thoughts yeah, but of course this will
  // get called each attack (ie. wouldn't make sense tumbling three times if ch
  // has 3 attacks - not that it would be likely to happen. 
  // TODO: check for attack type?
  if (basic_skill_test(victim, SKILL_TUMBLE, FALSE)) {
    // 1 in 10 chance victim gets to attempt a tumble
    if (!number(0, 9)) {
      if (number(1, 100) < GET_SKILL(victim, SKILL_TUMBLE)) {
        dam = 0;
	act("$N performs a tumble roll avoiding your attack!",
	    TRUE, ch, 0, victim, TO_CHAR);
	act("You perform a tumble roll avoiding $n's attack!",
	    TRUE, ch, 0, victim, TO_VICT);
	act("$N performs a tumble roll avoiding $n's attack!",
	    TRUE, ch, 0, victim, TO_NOTVICT);
	apply_spell_skill_abil(victim, SKILL_TUMBLE);
      }
    }
  }
  
  // DM: Poison blade - Add percentage based poison damage, set poison on vict
  // NOTE: dont think there is a MAX_TYPE thingy for attacks - if anything is 
  // added after TYPE_STAB - this should be updated.
  //
  // We are ignoring the number of uses - it 
  // TODO: add in any resistance spells etc ...
  struct obj_data *weapon;
  if ((weapon = GET_EQ(ch, WEAR_WIELD))) {
    if (obj_affected_by_timer(weapon, TIMER_POISONBLADE) && attacktype >= 
	TYPE_HIT && attacktype <= TYPE_STAB) {
      dam = dam + (int)(MIN(50, (int)((SPELL_EFFEC(ch, SKILL_POISONBLADE) / 100) * (GET_SKILL(ch, SKILL_POISONBLADE) / 100) * (GET_LEVEL(ch) / 2))));
      act("$N is affected by your poison blade!", TRUE, ch, 0, victim, TO_CHAR);
      act("You are poisoned by $n's blade!", TRUE, ch, 0, victim, TO_VICT);
      act("$N is poisoned by $n's blade!", TRUE, ch, 0, victim, TO_ROOM);

      // add affect to char if not already affected by poison
      if (!IS_AFFECTED(victim, AFF_POISON)) {
        struct affected_type af;
        af.type = SPELL_POISON;
    	af.duration = MIN(1, (int)(GET_LEVEL(ch) / GET_LEVEL(victim)));
    	af.modifier = 0;
    	af.location = APPLY_NONE;
    	af.bitvector = AFF_POISON;
    	affect_join(victim, &af, FALSE, FALSE, FALSE, FALSE);
      }
    }
  }
   
d1585 1
a1585 6
  /* Gain exp for the hit */
  if (ch != victim)
    if (!IS_NPC(ch) && !PRF_FLAGGED(ch, PRF_MORTALK))  
      gain_exp(ch, GET_LEVEL(victim) * dam);
    else if (IS_NPC(ch))
      gain_exp(ch, GET_LEVEL(victim) * dam);
d1587 2
a1588 1
  update_pos(victim);
@


1.52
log
@Artus> Don't reflect damage if the mob just fled.
@
text
@d646 1
a646 1
void die(struct char_data * ch, struct char_data *killer)
d649 1
d682 8
d691 3
d1393 5
@


1.51
log
@Artus> Moving stuff across to live.

act.informative.c:
  Info on it's own will now display the info file. Use me or self to see your
own info.
  Score and Exp now both show gained and remaining exp.
  Gold value is now to a max of 30000. (60000 in lvl 40+ zones, 120 in 70+)
  Gold rushes no longer occur in !GOLDRUSH zones, city sectors, etc.

act.other.c:
  Mana retained on remort is now floored at 100 instead of 50.
  Added elitist bonus for chars who play past the earliest remort point(s).

act.wizard.c:
  Gold rush events are now only advertised within the world they occur.

genolc.h:
  Added special #defines for different OLC levels whether running live or test.
  (Noted by compiling with -DPRIMAL_LIVE)

interpreter.c:
  Aliases will now be saved automatically, when added or remoed.
  Added elitist_modifier() to modifier calculation.
  Replaced Huh?!? with HUH.

limits.c:
  NPC corpses are no longer emptied before they are purged. Too much clutter.

spells.c:
  Reduced the amount of weight applied by create water to 1/3 of what it was.

comm.c:       Added send_to_not_zone_world()
db.c:         Added elitist_modifier() to modifier calculation.
dg_mobcmd.c:  Replaced Huh?!? with the define, HUH.
dg_scripts.h: Changed version string so it will fit on one line :o)
fight.c:      Eq should no longer be damaged when a hit fails.
handler.c:    Now, when the sleep spell wears of an NPC, it will wake up.
structs.h:    Added HUH define.
utils.c:      Added elitist_modifier() calculation.
utils.h:      Added elitist_modifier() prototype.
@
text
@d2007 3
a2009 1
    if(IS_AFFECTED(real_vict,AFF_REFLECT) && dam > 0 && GET_POS(real_vict)> POS_MORTALLYW)
@


1.50
log
@Artus> Mostly just cosmetic changes, mostly for underwater stuff..
       Added some more stuff to dg_scripts:

       %actor.affected(aff_bit)% - Is actor affected by whatever.
       %self.people(countpc)%    - (Rooms): Count players.
       %self.people(countnpc)%   - (Rooms): Count npcs.
       %self.people(countall)%   - (Rooms): Count chars.
       %firstchar.<room_vnum>%   - First character in room <vnum>

       Possibly a bugfix to one of the forest specials that was attacking you
       if you were affected by poison.
@
text
@d1649 11
a1659 7
  damChance = 100 - (GET_LEVEL(ch) - GET_LEVEL(victim)) - GET_STR(ch);
  // Want to probably modify it depending on the
  // ch's damRoll as well (a % perhaps)
  if (damChance < 0)
	damChance = 1;
  if (number(0, damChance) == damChance) 	// Damaged eq! 
	damage_equipment(victim);
@


1.49
log
@Artus> Breakin now requires mount skill, and is tested vs it.
       Remort ability list changed some more, also remort ability parser.
       DGScript Force/Teleport commands now tell >=LVL_ANGEL what they were
       trying to do..
       MultiWeapon is once more required for dual wield.
       Lowered exp gained whilst grouping by about 30%.
@
text
@d1745 1
a1745 1
	&& (SECT(ch->in_room) == SECT_FOREST))
@


1.48
log
@Artus> Couple of colour bleeds fixed up.. Nothing major.
@
text
@d777 3
a779 1
      if (!IS_CLONE(f->follower)) {
d802 1
a802 1
        base=(GET_EXP(victim)*80)/100;
d804 1
a804 1
        base=(GET_EXP(victim)*85)/100;
d806 1
a806 1
        base=(GET_EXP(victim)*90)/100;
d808 1
a808 1
        base=(GET_EXP(victim)*70)/100;
d810 1
a810 1
        base=(GET_EXP(victim)*65)/100;
d812 1
a812 1
        base=(GET_EXP(victim)*55)/100;
d814 1
a814 1
        base=(GET_EXP(victim)*20)/100;
d1977 2
a1978 1
    if (type == TYPE_DUAL_ATTACK) {
@


1.47
log
@Artus> Fixed up sense wounds.. Implemented movement cost for autoeat..
       Moved autoeat after autoexits in interpreter.c.
@
text
@d2166 3
a2168 2
	      GET_HIT(lead) <= (int)(GET_MAX_HIT(lead)/4))
	    act("$N&r could use a little healing!", FALSE, ch, NULL, lead, 
d2178 2
a2179 1
	      (GET_HIT(fol->follower) > (int)(GET_MAX_HIT(fol->follower)/4)))
d2181 1
a2181 1
	  act("$N&r could use a little healing!", FALSE, ch, NULL, 
@


1.46
log
@Artus>
act.informative.c: Added Sense Wounds.
constants.c      : Added Sense Wounds.
db.c             : Fixed spell effectiveness.
dg_mobcmd.c      : mpurge will no longer purge player corpses.
dg_objcmd.c      : opurge will no longer purge player corpses.
dg_wldcmd.c      : wpurge will no longer purge player corpses.
fight.c          : Added Sense Wounds.
magic.c          : Added Sense Wounds.
spell_parser.c   : Added Sense Wounds.. Trialling changes do damage
                   done by headbutt, flytackle, piledrive.
spells.h         : Added Sense Wounds.
structs.h        : Added Sense Wounds.
@
text
@d2162 10
a2171 2
	lead = (ch->master ? ch->master : ch);

d2175 3
a2177 1
	      !AFF_FLAGGED(fol->follower, AFF_GROUP) || (fol->follower == ch))
@


1.45
log
@Artus> Added !KILL flag for mobs... Things like gamina, postmaster, etc, can
       have this set, which should make it pretty damn impossible for them to
       die..
       Modified more stuff for dark ritual and vampires.. Have added a switch
       statement to affect_remove, which should be a good central place to
       handle triggers on affect removal.. Mainly to reset mana/move/hit to
       make sure they're not higher than max values when removing werewolf/
       vampire.
@
text
@d2099 2
a2100 1
    if (FIGHTING(ch) == NULL || ch->in_room != FIGHTING(ch)->in_room) {
d2108 2
a2109 1
      for (i=0;i<loop;i++) {
d2114 2
a2115 1
	if (FIGHTING(ch)) {	
d2156 16
@


1.44
log
@Artus>

Files which have had log() replaced with basic_mud_log():

act.informative.c, act.item.c, act.offensive.c, act.other.c, act.social.c,
act.wizard.c, alias.c, balance.c, ban.c, boards.c, casino.c, castle.c, clan.c,
class.c, comm.c, corpses.cpp, db.c, dg_db_scripts.c, dg_olc.c, dg_scripts.c,
fight.c, genmob.c, genobj.c, genolc.c, genshp.c, genwld.c, genzon.c, graph.c,
handler.c, house.c, improved-edit.c, interpreter.c, magic.c, mail.c, medit.c,
mobact.c, modify.c, oasis.c, objsave.c, oedit.c, olc.c, redit.c, reports.cpp,
shop.c, spec_assign.c, spec_procs.c, spell_parser.c, tedit.c, utils.c,
utils.h, zedit.c.


Files which have been cpp standardised (list.h => list, etc):

comm.c, corpses.cpp, corpses.h, db.c, interpreter.c, modify.c, reports.cpp.


Specific changes to reports.cpp, reports.h:

Removed ofstream outReportFile, ofstream outChangeFile, and replaced them with
FILE *s. Removed no-longer functional c++ random-access file handling and
replaced it with straight C. Should be right from here on in..


Specific changes to act.movement.c:

Replaced log() with mudlog(), when logging players being killed by gravity.
@
text
@d1383 3
@


1.43
log
@Artus> Changes to do_simple_move().
       Added char_can_enter() -- Tests room levels, zone levels, water/fly/etc.

       Changes to die(): Exp lost is now whichever is lesser of half earned
       exp and quater max exp. When autocorpse, instead of doubling it, we
       multiply by 1.5.

       pc killed by char now logged in die(), with lost_exp display.

       gain_exp now returns the amount of exp that was gained rather than void.
@
text
@d171 1
a171 1
    log("SYSERR: Error reading combat message file %s: %s", MESS_FILE, strerror(errno));
d194 1
a194 1
      log("SYSERR: Too many combat messages.  Increase MAX_MESSAGES and recompile.");
d363 1
a363 1
    log(buf);
d367 1
a367 1
  //log(buf);
d1227 1
a1227 1
    log("SYSERR: NULL object or char passed to break_obj");
d1287 1
a1287 1
      log("SYSERR: invalid obj type given to break_obj (%d)", 
d1296 1
a1296 1
    log("SYSERR: NULL obj or char passed to damage_obj");
d1372 1
a1372 1
      log("SYSERR: Attempt to damage corpse '%s' in room #%d by '%s'.",
@


1.42
log
@Artus> Sorry, Dish.. Another bastard change..

       has_stats_for_skill now takes an extra arg (bool) to determine whether
       or not to display messages.

       new routine: has_stats_for_prac.. Basically the same as
       has_stas_for_skill, without GET_SKILL(ch, i) == 0 check..

       Force is now restricted for <GRGOD.

       Score no longer displays punishment lines twice.

       New macro: IS_SKILL(skillnum) .. Used to determine whether skillnum is
                  a skill.
@
text
@d483 3
a485 3
void perform_get_from_container(struct char_data * ch, struct obj_data * obj,
                                struct obj_data * cont, int mode, 
                                int *corpseModified);
d491 7
a497 6
  if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_MORTALK)){
        REMOVE_BIT(PRF_FLAGS(ch), PRF_MORTALK);
        call_magic(ch,ch,NULL,42,GET_LEVEL(ch),CAST_MAGIC_OBJ);
        GET_HIT(ch)= GET_MAX_HIT(ch);
        GET_MANA(ch) = 100;
        GET_POS(ch) = POS_STUNNED;
d499 1
a499 3
 

  /* remove wolf/vamp infections so ya hafta be reinfected after death */
d507 2
a508 1
    if (killer && killer != ch) {
d535 2
a536 1
    if (!killer || !corpse) {
d544 4
a547 4
    if ( ((!IS_NPC(killer) && IS_NPC(ch)) && 
           (killer->in_room == ch->in_room)) ||
         (IS_CLONE_ROOM(killer))) {
 
a549 1

a551 1

d553 2
a554 1
      if (EXT_FLAGGED(scab, EXT_AUTOLOOT)) {
d556 2
a557 1
          if (IS_CARRYING_N(scab) >= CAN_CARRY_N(scab)) {
d563 2
a564 1
          if (CAN_SEE_OBJ(scab, obj) && (GET_OBJ_TYPE(obj) != ITEM_MONEY)) {
d576 4
a579 2
      if (EXT_FLAGGED(scab, EXT_AUTOGOLD)) {
        for (obj = corpse->contains; obj; obj = next_obj) {
d581 2
a582 2
          if ((GET_OBJ_TYPE(obj) == ITEM_MONEY) && (GET_OBJ_VAL(obj, 0) > 0)) {
 
d584 3
a586 2
            if (EXT_FLAGGED(scab, EXT_AUTOSPLIT) && IS_AFFECTED(scab, AFF_GROUP)) {
 
a587 1
 
a588 1
 
d591 3
a593 3
                if (IS_AFFECTED(f->follower, AFF_GROUP) && (!IS_NPC(f->follower)) &&
                      (f->follower != scab) && 
                      (f->follower->in_room == scab->in_room))
a595 1

a598 1
 
d602 2
a603 1
              else {
a605 1
 
d607 1
a607 4
                sprintf(buf, "You split &Y%d&n coins among %d members -- &Y%d&n coins each.\r\n",
                        amount, num, share);
                        send_to_char(buf, scab);
 
d609 2
a610 1
                for (f=k->followers; f;f=f->next) {
d614 2
a615 1
                      f->follower != scab) {
a621 1

d624 2
a625 1
                    && !(IS_NPC(k))) {
d627 1
a627 2
                  sprintf(buf, "&7%s&n splits &Y%d&n coins; you receive &Y%d&n.\r\n", GET_NAME(scab),
                           amount, share);
a629 1
 
a639 1
    
a641 1

d648 4
d653 8
a660 2
  /* bm changed exp lost to  level minimum and 10% of carried gold*/
  if (!IS_NPC(ch) && PRF_FLAGGED(ch,PRF_MORTALK))
d662 1
a662 1
  else{
d665 5
a669 3
    if (GET_EXP(ch) > 0) {
      gain_exp(ch, -(GET_EXP(ch)/2));

d671 2
a672 3
      if (!IS_NPC(ch) && EXT_FLAGGED(ch, EXT_AUTOCORPSE)) {
        gain_exp(ch, -(level_exp(ch, GET_LEVEL(ch) + 1)/2));
      }
d675 7
a681 2
//      gain_exp(ch,-(level_exp(GET_CLASS(ch),GET_LEVEL(ch))*0.1));

d683 1
a683 2
    if (!IS_NPC(ch))
      REMOVE_BIT(PLR_FLAGS(ch), PLR_KILLER | PLR_THIEF);
a685 3
  if (killer)
    GET_WAIT_STATE(killer) = 0;

d687 13
a699 1
  if ((GET_LEVEL(ch) <= LVL_NEWBIE) && (!IS_NPC(ch))) {
d704 1
a704 1
    GET_POS(ch) = POS_STANDING;
d1671 4
a1674 2
    if (attacktype==SPELL_POISON || attacktype==TYPE_SUFFERING) {
      if (!IS_NPC(ch)) {
d1695 6
a1700 4
    if (!IS_NPC(victim)) {
      sprintf(buf2, "%s killed by %s at %s", GET_NAME(victim), GET_NAME(ch),
	      world[victim->in_room].name);
      mudlog(buf2, BRF, LVL_ANGEL, TRUE);
@


1.41
log
@Artus> Dual Wielding Wear/Remove/Display/Fighting Fixes.
       Cursed items can no longer be sold.
       Bodyslam message now appears in the right spot (hopefully).

       NOTE: IS_DUAL_WIELDING(ch) and IS_DUAL_CAPABLE(ch) defines in utils.h
             have been modified... If you plan to use them, check out how they
	     have changed first :o)
@
text
@d1561 1
a1561 1
       ((dam != 0) && (attacktype > MAX_SPELLS && attacktype <= MAX_SKILLS &&
d1992 1
a1992 1
        if (has_stats_for_skill(ch, GET_OBJ_VAL(wielded, 0)) 
@


1.40
log
@Artus> (Hopefully) Fixed all cases where the skill message would display after
       the victim had fled.

       Moved remaining violence checks from damage() to violence_check().

       damage() now takes an additional boolean arg, vcheck, when true,
       violence_check() will be called.

       added GET_EQ_WEIGHT(ch, wear_pos) define.
@
text
@a1550 3
 
  if (!((dam == 0) && (attacktype == SKILL_2ND_ATTACK || 
                                  attacktype == SKILL_3RD_ATTACK)))
d1552 13
d1566 24
a1589 23
    switch (GET_POS(victim)) {
    case POS_MORTALLYW:
      act("$n is mortally wounded, and will die soon, if not aided.", 
                      TRUE, victim, 0, 0, TO_ROOM);
      send_to_char("You are mortally wounded, and will die soon, if not "
                      "aided.\r\n", victim);
      break;
    case POS_INCAP:
      act("$n is incapacitated and will slowly die, if not aided.", 
                      TRUE, victim, 0, 0, TO_ROOM);
      send_to_char("You are incapacitated an will slowly die, if not "
                      "aided.\r\n", victim);
      break;
    case POS_STUNNED:
      act("$n is stunned, but will probably regain consciousness again.", 
                      TRUE, victim, 0, 0, TO_ROOM);
      send_to_char("You're stunned, but will probably regain consciousness "
                      "again.\r\n", victim);
      break;
    case POS_DEAD:
      act("$n is dead!  R.I.P.", FALSE, victim, 0, 0, TO_ROOM);
      send_to_char("You are dead!  Sorry...\r\n", victim);
      break;
d1591 2
a1592 2
    default:			/* >= POSITION SLEEPING */
      if (dam > (GET_MAX_HIT(victim) / 4))
d1595 11
a1605 8
      if (GET_HIT(victim) < (GET_MAX_HIT(victim) / 4)) {
        sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so "
                        "much!%s\r\n",
	      CCRED(victim, C_SPR), CCNRM(victim, C_SPR));
        send_to_char(buf2, victim);

        if (ch != victim && MOB_FLAGGED(victim, MOB_WIMPY) && 
	    GET_POS(victim) >= POS_FIGHTING)
d1607 1
a1607 1
      }
d1609 10
a1618 9

    if (!IS_NPC(victim) && GET_WIMP_LEV(victim) && (victim != ch) &&
	GET_HIT(victim) < GET_WIMP_LEV(victim) && GET_HIT(victim) > 0 &&
	GET_POS(victim) >= POS_FIGHTING) {
      send_to_char("You wimp out, and attempt to flee!\r\n", victim);
      do_flee(victim, NULL, 0, 0);
    }
    break;
  }
d2089 2
a2090 3
          if (FIGHTING(ch) && (IS_DUAL_WIELDING(ch) || IS_DUAL_CAPABLE(ch)))
	    if (GET_EQ(ch, WEAR_HOLD) != NULL)
	      hit(ch, FIGHTING(ch), TYPE_DUAL_ATTACK);
d2104 2
a2105 2
	    // dual wield
            if (FIGHTING(ch) && (IS_DUAL_WIELDING(ch) || IS_DUAL_CAPABLE(ch)))
d2115 1
a2115 1
            if (FIGHTING(ch) && (IS_DUAL_WIELDING(ch) || IS_DUAL_CAPABLE(ch)))
@


1.39
log
@Artus> Added mortal kombat check.
@
text
@d61 1
d1342 1
a1342 1
int damage(struct char_data * ch, struct char_data * victim, int dam, int attacktype)
d1346 3
a1348 11
  if (GET_POS(victim) <= POS_DEAD) {
    log("SYSERR: Attempt to damage corpse '%s' in room #%d by '%s'.",
		GET_NAME(victim), GET_ROOM_VNUM(IN_ROOM(victim)), GET_NAME(ch));
    die(victim,ch);
    return (0);			/* -je, 7/7/92 */
  }

  if (IS_NPC(victim))
    if(MOB_FLAGGED(victim,MOB_QUEST))
    {
      send_to_char("Sorry, they are part of a quest.\r\n",ch);
d1350 7
a1356 8
    } 

  /* peaceful rooms */
  if (ch->nr != real_mobile(DG_CASTER_PROXY) && 
                  ch != victim && ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char(PEACEROOM, ch);
    GET_WAIT_STATE(ch) = 0;
    return (0);
a1358 4
  /* shopkeeper protection */
  if (!ok_damage_shopkeeper(ch, victim))
    return (0);

a1362 13
  /* Can't attack your own mounts */
  if (victim == MOUNTING(ch)) {
	send_to_char("Better get off your mount before you attack it.\r\n", ch);
	return (0);
  }

  /* Mounts will not attack their riders */ // - May change this to make them buck instead
  if (victim == MOUNTING(ch) && IS_NPC(ch)) {
	send_to_char("Your rider controls your urge to kill them.\r\n", ch);
	return (0);
  }	

  
d1866 1
a1866 1
      damage(ch, victim, 0, SKILL_BACKSTAB); 
d1868 1
a1868 1
      damage(ch, real_vict, 0, type);  /* thisll make it use the rite messages for missing */
d1870 1
a1870 1
      damage(ch, real_vict, 0, w_type);
d1940 1
a1940 1
      if (damage(ch, real_vict, dam, SKILL_BACKSTAB) > 0)	// Check it's still alive
d1950 1
a1950 1
	    damage(ch, real_vict, dam * 2, SKILL_BACKSTAB);
d1955 1
a1955 1
      damage(ch, real_vict, dam, w_type);
d1959 1
a1959 1
      damage(real_vict,ch,MIN(dam,MAX(GET_HIT(ch) - 1,0)),SPELL_SERPENT_SKIN);
d1964 1
a1964 1
        damage(real_vict,ch,MIN(GET_LEVEL(real_vict)/4,MAX(GET_HIT(ch)-1,0)),SPELL_LIGHT_SHIELD);
d1967 1
a1967 1
        damage(real_vict,ch,MIN(GET_LEVEL(real_vict)/3,MAX(GET_HIT(ch)-1,0)),SPELL_FIRE_SHIELD);
d1970 1
a1970 1
        damage(real_vict,ch,MIN(GET_LEVEL(real_vict)/2,MAX(GET_HIT(ch)-1,0)),SPELL_FIRE_WALL);
d2094 1
a2094 1
	    damage(ch, FIGHTING(ch), 0, SKILL_2ND_ATTACK);
d2104 1
a2104 1
	    damage(ch, FIGHTING(ch), 0, SKILL_3RD_ATTACK);
d2109 1
a2109 1
	    damage(ch,FIGHTING(ch),dice(4,GET_LEVEL(ch)),TYPE_CLAW);
d2111 1
a2111 1
	    damage(ch,FIGHTING(ch),dice(4,GET_LEVEL(ch)),TYPE_BITE);
@


1.38
log
@Artus> A3_0_315
@
text
@d255 3
a257 1
  
d287 1
a287 1
  if (!IS_NPC(ch) && char_affected_by_timer(ch, TIMER_MEDITATE)) {
d289 1
a289 1
  }
@


1.37
log
@Artus>
Adrenaline : (Potion Quaffing): 6 per fight Round instead of 5.
             (Flying Tackle)  : 2 fight rounds vs 3.
Balance    : QEQ no longer gets written to the log file when unbalanced.
Colour     : &f is no longer flash, &@@ is. Keep it quiet(tm).
Corpse File: Flush()ing after write().
Double Kick: Now calls apply_spell_skill_abil()
Echo       : No longer sends text to mobs calling it.
Fighting   : Is only possible if STATE = CON_PLAYING
Glance     : Fixed erroneous dex check.
OLC        : No longer possible while fighting.
           : LVL_IMPL+ (150+) can now edit mob levels up to 120.
Pit Trap   : Now logs deaths.
             No longer says "theoretically" on creation.
Report File: Flush()ing after write().
Spell/Skill: Now allows up to NUM_CLASSES class lines in primal_spskls
             (Used to only allow up to 10)
@
text
@d1430 1
a1430 1
  if (GET_EQ(ch, WEAR_WIELD)) {
@


1.36
log
@Latest Version
@
text
@d271 6
@


1.35
log
@

Modified: DM

Changed:
- minor bug fixes, implementation of ideas on email from sandii on 5/4
@
text
@d1313 1
a1313 2
        if (GET_OBJ_DAMAGE(obj) != -1 ||
            OBJ_FLAGGED(GET_EQ(ch, i), ITEM_QEQ)) {
@


1.34
log
@
: ----------------------------------------------------------------------
: Enter Log.  Lines beginning with `CVS:' are removed automatically
:
: Committing in .
:
: Modified Files:
: 	act.informative.c act.other.c act.wizard.c balance.c class.c
: 	constants.c db.c fight.c handler.c interpreter.c magic.c
: 	oedit.c redit.c spec_procs.c spell_parser.c spells.h
: 	update_revisions
: ----------------------------------------------------------------------

Modified: DM

Changed:
- heaps: mostly minor bug fixes.
@
text
@d2093 2
a2094 1
	    hit(ch, FIGHTING(ch), TYPE_DUAL_ATTACK);
@


1.33
log
@
Modified: DM

Changed: (This is a group checkin)
- many many bug fixes
@
text
@d850 1
a850 1
  int exp, percent;
d891 11
d921 1
a921 1
                CCEXP(ch->master,C_NRM),exp,CCNRM(ch->master,C_NRM));
d925 1
a925 1
                CCEXP(ch,C_NRM),exp,CCNRM(ch,C_NRM));
@


1.32
log
@
Modified: DM

Changed:
- Don't ask (large group checkin) - lots of bug fixes mainly.
- Use cvs diff if you really wanna see the changes.
@
text
@a71 1
void die(struct char_data * ch, struct char_data *killer);
@


1.31
log
@
Modified: DM

Added:
- autocorpse retrieval code
- fix for damaging eq on mobs causing a core dump
@
text
@d358 2
a359 2
  sprintf(buf,"Idnum of corpse: %d", GET_CORPSEID(corpse));
  log(buf);
@


1.30
log
@*** empty log message ***
@
text
@d60 1
d395 9
d407 1
a407 2
    log("make_corpse: char weight = %d", GET_WEIGHT(ch));
    corpseData.addCorpse(corpse, GET_ROOM_VNUM(ch->in_room), GET_WEIGHT(ch)); 
d410 2
a411 1
  obj_to_room(corpse, ch->in_room);
d651 1
a651 1
    if (GET_EXP(ch) > 0)
d653 6
a658 1
    else
d1272 7
@


1.29
log
@Artus> Added ghosts.. Newbies no longer die, they become ghosts.
@
text
@d663 1
a663 1
    send_to_char("You wake up in Haven's riverside tavern, however you find yourself to be\r\nnot quite whole. You are have become a &WGhost&n. This affect will last\r\nuntil you have reached your maximum hit poit level.\r\n", ch);
@


1.28
log
@Jus> Changed score display again. Commiting to move to another machine.
     These changes are not final, this is an intermediate build.
@
text
@a650 1
  raw_kill(ch,killer);
d654 14
@


1.27
log
@Artus: There's the armor class stuff..
@
text
@d54 1
a54 1
int compute_armor_class(struct char_data *ch);
d76 1
a76 1
int compute_armor_class(struct char_data *ch);
d138 1
a138 1
int compute_armor_class(struct char_data *ch)
d152 7
a158 5
  armorclass += 5;
  armorclass /= 10;

  armorclass = MIN(armorclass, 20);
  return (MAX(-20, armorclass));      /* -20 is lowest */
d1815 1
a1815 1
  victim_ac = compute_armor_class(victim);
@


1.26
log
@Art> Modified compute_armor_class() and thaco().. Most notable, thaco() now
expects ch, victim (victim may be null), for mob thaco calculations. Probably
should have done it with FIGHTING(ch) but oh well. :o). Also added in some
debug stuff, including a debug flag. A byte sized bitvector that's not saved,
char_special_data.small_bits or SMALL_BITS(ch).. GET_DEBUG() for debug.
@
text
@d154 3
a156 3
  //  sprintf(buf, "\r\nDebug[AC]: %d\r\n", armorclass);
  send_to_char(buf, ch);
  return (MAX(-20, armorclass));      /* -100 is lowest */
@


1.25
log
@Modified: DM

Changed:
- initialised corpse in raw_kill to NULL as it should have originally been.
  (to fix titan corpse bug crash)
@
text
@d77 1
a77 1
int compute_thaco(struct char_data *ch);
d140 2
d145 1
a145 1
    armorclass += dex_app[GET_DEX(ch)].defensive * 10;
d151 6
a156 1
  return (MAX(-200, armorclass));      /* -100 is lowest */
d1810 1
a1810 1
  calc_thaco = thaco(ch) - (int)(ch->points.hitroll / 5); 
d1813 1
a1813 1
  victim_ac = compute_armor_class(victim) / 10;
d1819 13
@


1.24
log
@Modified: DM

Changed:
- receive spelling
@
text
@d447 1
a447 1
  struct obj_data *corpse, *obj, *next_obj;
@


1.23
log
@*** empty log message ***
@
text
@d691 1
a691 1
           send_to_char("You recieve No EXP for killing players with the KILLER flag\r\n", ch);
d858 1
a858 1
      send_to_char("You recieve No EXP for killing players with the KILLER "
d861 1
a861 1
      send_to_char("You recieve No EXP for killing players with the KILLER "
@


1.22
log
@*** empty log message ***
@
text
@d1238 2
a1239 1
        if (GET_OBJ_MAX_DAMAGE(GET_EQ(ch, i)) == -1)
d1259 2
a1260 1
        if (GET_OBJ_DAMAGE(obj) != -1) {
@


1.21
log
@Modified: DM or Artus

Added:
- dual wield
@
text
@d498 9
a615 9
    // Dismount
    if (MOUNTING(ch)) 
	MOUNTING(MOUNTING(ch)) = NULL;
    if (MOUNTING_OBJ(ch))
	OBJ_RIDDEN(MOUNTING_OBJ(ch)) = NULL;

    MOUNTING(ch) = NULL;
    MOUNTING_OBJ(ch) = NULL;

@


1.20
log
@Artus- Changed for heal trance..
@
text
@d1751 4
a1802 2
  // DM - TODO - decide whether we want this armor system here...

d1881 6
d2019 1
a2019 1
	if (FIGHTING(ch))	
d2022 5
d2038 3
d2048 3
@


1.19
log
@Modifications needed for tumble roll, meditate, berserk and so forth.
@
text
@d273 2
@


1.18
log
@Artus - Berserk, Efficiency.
@
text
@d270 4
d367 1
a367 1
      obj_to_obj(unequip_char(ch, i), corpse);
d478 2
a479 1
    if (killer) {
d1203 1
a1203 1
          unequip_char(ch, i);
d1407 3
a1409 2
  if (!IS_NPC(ch) && (AFF_FLAGGED(victim, AFF_BERSERK)))
    dam = (int)(dam * (2 * (SPELL_EFFEC(ch, SKILL_BERSERK) / 100)));
d1413 2
a1414 1
    dam = (int)(dam * (2 * (SPELL_EFFEC(ch, SKILL_BERSERK) / 100)));
d1428 1
a1428 2
  if (GET_SKILL(victim, SKILL_TUMBLE) > 0 && 
      has_stats_for_skill(victim, SKILL_TUMBLE)) {
d1433 1
a1433 1
	act("$M performs a tumble roll avoiding your attack!",
d1437 3
a1439 2
	act("$M performs a tumble roll avoiding $n's attack!",
	    TRUE, ch, 0, victim, TO_ROOM);
d1452 3
a1454 2
    if (obj_affected_by_timer(weapon, TIMER_POISONBLADE) && attacktype >= TYPE_HIT && attacktype <= TYPE_STAB) {
      dam = dam + (int)(MIN(50, (int)((SPELL_EFFEC(ch, SKILL_POISONBLADE) + 100) / 100) * ((GET_SKILL(ch, SKILL_POISONBLADE) + 100) / 100) * (GET_LEVEL(ch) / 2)));
d1551 1
a1551 1
	    GET_POS(victim) > POS_SITTING)
d1558 1
a1558 1
	GET_POS(victim) > POS_SITTING) {
a2002 4

// DM - TODO - fix haste - first glace it works properly now ...
// DM - TODO - although I did get it hanging for an IMP - it
// DM - TODO - still may get stuck in here or some crap - look into it ...
@


1.17
log
@Modified: DM

Added:
- tumble, poison blade

Changed:
- flee check for position ... (> POS_SITTING)
@
text
@d37 1
d1403 1
a1403 1
    dam /= 2;
d1407 1
a1407 1
    dam *= 2;
a1443 1
  extern struct spell_info_type spell_info[];
@


1.16
log
@Artus - Berserk
@
text
@d1374 1
d1388 2
d1415 49
d1542 2
a1543 1
        if (ch != victim && MOB_FLAGGED(victim, MOB_WIMPY))
d1549 2
a1550 1
	GET_HIT(victim) < GET_WIMP_LEV(victim) && GET_HIT(victim) > 0) {
@


1.15
log
@Artus - Minor mods to raw_kill to increase kills/killed bys..
@
text
@d299 3
d1397 8
@


1.14
log
@Artus - PK Changes, some clan shit as well.
@
text
@a461 2
    if (!IS_NPC(ch) && !IS_NPC(killer)) 
      clan_pk_update(killer, ch);
d471 6
@


1.13
log
@*** empty log message ***
@
text
@d26 1
d58 1
d235 1
d242 4
d274 4
d462 3
@


1.12
log
@Modified: DM

Removed:
- debug line ...
@
text
@d1126 1
a1126 1
  switch (GET_OBJ_TYPE(obj) == ITEM_LIGHT) {
d1144 2
a1145 1
      sprintf(buf, "&r%s is destroyed!&n\r\n", obj->short_description);
d1171 1
a1171 1
      sprintf(buf, "&r%s breaks!&n\r\n", obj->short_description);
d1212 1
a1212 1
        damage_obj(GET_EQ(ch, i), number(1, 5), ch);
d1479 2
@


1.11
log
@Modified: DM - Thaco/Strength Apply
@
text
@a1065 2
  log("skill_message: attacktype = %d", attacktype);

@


1.10
log
@Modified: DM

Changed:
- hit(): magic eq (weapons that cast spells), check to see player knows the
  spell
@
text
@d1703 1
a1703 1
  calc_thaco = thaco(ch) - ch->points.hitroll; 
d1729 1
a1729 1
    // TODO: make todam also level based - lvl 1 char with 21 dam will kick
d1731 2
a1732 1
    dam = str_app[STRENGTH_REAL_APPLY_INDEX(ch)].todam;
@


1.9
log
@
Added:
- TODO comment about str dam applies
@
text
@d1821 7
a1827 2
        if(number(0,3))
          call_magic(ch,real_vict,NULL,GET_OBJ_VAL(wielded,0),2*GET_LEVEL(ch),CAST_MAGIC_OBJ); 
@


1.8
log
@
Changed:
- tidy up of formatting in damage() function?
@
text
@d1729 2
@


1.7
log
@
Added:
- Initial inclusion of dgscripts
@
text
@d657 2
a658 1
     send_to_char("You are the SUPREME warrior of the MOrtal Kombat arena!\r\n", ch);
d674 4
d679 2
a680 1
    if (AFF_FLAGGED(f->follower, AFF_GROUP) && f->follower->in_room == ch->in_room)
d682 9
a690 8
    /* DM - Dont include CLONES if they are grouped */
    if (!IS_CLONE(f->follower))
    {
      tot_members++;
      group_level += GET_LEVEL(f->follower);
      min_level = MIN(min_level, GET_LEVEL(f->follower));
      max_level = MAX(max_level, GET_LEVEL(f->follower));
    }   
d692 2
a693 2
/* cap it to LVL_IMPL */
 group_level = MIN(LVL_IMPL, group_level - tot_members);  
d699 2
a700 2
  if (!IS_NPC(victim))
    base = MIN(max_exp_loss * 2 / 3, tot_gain);
d702 1
a702 6
//  if (tot_members >= 1)
//    base = MAX(1, tot_gain / tot_members);
//  else
//    base = 0;

/* DM group gain percentage */
d795 4
d805 2
a806 1
        sprintf(buf2, "Your opponent was out of your league! You don't learn as much.\n\r");
d829 2
a830 1
      send_to_char("You recieve No EXP for killing players with the KILLER flag!.\r\n", ch->master);
d832 2
a833 1
      send_to_char("You recieve No EXP for killing players with the KILLER flag!.\r\n", ch);
d837 2
a838 1
      send_to_char("You are the SUPREME winner of Mortal Kombat!!\r\n", ch->master);
d1341 9
a1349 12
  if (GET_EQ(ch, WEAR_WIELD))
  {
	if (GET_SKILL(ch, SKILL_AXEMASTERY) && is_axe(GET_EQ(ch, WEAR_WIELD)))
	{
		//send_to_char("Your axe mastery comes in handy.\r\n", ch);
		dam += (int)(dam * 0.10);
	}
	if (GET_SKILL(ch, SKILL_BLADEMASTERY) && is_blade(GET_EQ(ch, WEAR_WIELD)))
	{
		//send_to_char("Your blade mastery comes in handy.\r\n", ch);
		dam += (int)(dam * 0.10);
	}
d1354 10
a1363 12
  if (!IS_NPC(victim) && GET_SKILL(victim, SKILL_DEFEND))
  {
     if (number(1, 101) < GET_SKILL(victim, SKILL_DEFEND))
     {
     	if (GET_LEVEL(ch) >= LVL_IMMORT)
	  dam -= ((int)(dam / 2));	// champs can halve damage
     	else if (GET_LEVEL(ch) >= 75)
	  dam -= ((int)(dam / 3));	// 2/3's damage
     	else if (GET_LEVEL(ch) >= 40)
	  dam -= ((int)(dam / 4));	// 3/4's damage
     	else
	  dam -= ((int)(dam  / 5));	// 4/5's damage
d1365 2
a1366 2
     	if (dam < 0)
	  dam = 0;   
a1387 1
// DM - Fix getting all SYSERRS now cause MOBS are using PRF_FLAGGED stuff
d1392 1
a1392 1
    else
d1420 41
a1460 4
// DM - do we need a check in here for 2nd/3rd attack - when calling damage(ch,vict,0,2/3attack)?? 
// This seems to elimate the "extra message" shown when the 2nd or 3rd attack isn't called.
 
if (!((dam == 0) && (attacktype == SKILL_2ND_ATTACK || attacktype == SKILL_3RD_ATTACK)))
d1462 3
a1464 18
  /* Use send_to_char -- act() doesn't send message if you are DEAD. */
  switch (GET_POS(victim)) {
  case POS_MORTALLYW:
    act("$n is mortally wounded, and will die soon, if not aided.", TRUE, victim, 0, 0, TO_ROOM);
    send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", victim);
    break;
  case POS_INCAP:
    act("$n is incapacitated and will slowly die, if not aided.", TRUE, victim, 0, 0, TO_ROOM);
    send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", victim);
    break;
  case POS_STUNNED:
    act("$n is stunned, but will probably regain consciousness again.", TRUE, victim, 0, 0, TO_ROOM);
    send_to_char("You're stunned, but will probably regain consciousness again.\r\n", victim);
    break;
  case POS_DEAD:
    act("$n is dead!  R.I.P.", FALSE, victim, 0, 0, TO_ROOM);
    send_to_char("You are dead!  Sorry...\r\n", victim);
    break;
a1465 3
  default:			/* >= POSITION SLEEPING */
    if (dam > (GET_MAX_HIT(victim) / 4))
      send_to_char("That really did HURT!\r\n", victim);
a1466 7
    if (GET_HIT(victim) < (GET_MAX_HIT(victim) / 4)) {
      sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
	      CCRED(victim, C_SPR), CCNRM(victim, C_SPR));
      send_to_char(buf2, victim);
      if (ch != victim && MOB_FLAGGED(victim, MOB_WIMPY))
	do_flee(victim, NULL, 0, 0);
    }
d1503 9
a1511 14
   /* fix for poisoned players getting exp, and their group! bm */
      if (attacktype==SPELL_POISON || attacktype==TYPE_SUFFERING)
      {

        if (!IS_NPC(ch)) {
          sprintf(buf2, "%s died at %s", GET_NAME(ch),
                          world[victim->in_room].name);
          mudlog(buf2, BRF, LVL_ETRNL1, TRUE);
        } else {
          if (MOB_FLAGGED(ch, MOB_MEMORY))
            forget(ch, victim);
        }
        die(victim,ch);
        return(0);  
d1513 3
@


1.6
log
@
Added:
- Haste fix
- do_violent_skill changes
@
text
@d25 1
d345 3
a347 2
  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i))
d349 1
d458 6
a463 2
    death_cry(ch);
 
d1168 1
a1168 1
          obj_to_char(obj, ch); 
d1259 2
a1260 1
  if (ch != victim && ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
d1643 3
d1843 3
@


1.5
log
@
Added:
- corpse data additions
@
text
@d47 1
a47 1
ACMD(do_hit);
d145 1
a145 1
  return (MAX(-100, armorclass));      /* -100 is lowest */
d176 1
d361 2
a362 3
  obj_to_room(corpse, ch->in_room);

  // DM - Save the corpse data
d364 2
a365 1
    corpseData.addCorpse(corpse, GET_ROOM_VNUM(ch->in_room)); 
d368 1
d1049 2
d1100 84
d1187 2
a1188 2
	int i, found = 0;
	struct obj_data *obj;
d1190 5
a1194 15
	for (i = 0; i < NUM_WEARS && !found; i++)
	{
	   if (GET_EQ(ch, i)) 
           {
		if (number(1, NUM_WEARS) == NUM_WEARS) 
		{
                   if (GET_OBJ_MAX_DAMAGE(GET_EQ(ch, i)) == -1)
			continue;

		   GET_OBJ_DAMAGE(GET_EQ(ch, i)) -= number(1, 5);
		   found = 1;
		   break;
 		}
	   }
	}
d1196 6
a1201 16
	if(found)
	{
	   if (GET_OBJ_DAMAGE(GET_EQ(ch, i)) <= 0 && GET_OBJ_MAX_DAMAGE(GET_EQ(ch, i)) != -1) 
	   {
		GET_OBJ_DAMAGE(GET_EQ(ch,i)) = 0;
		sprintf(buf1, "&rYour &R%s&r just broke!&n\r\n", GET_EQ(ch,i)->short_description);
	   	send_to_char(buf1, ch);
	   }
	}
	else {	// nothing was damaged, slight chance of getting inventory
		for(obj = ch->carrying; obj; obj = obj->next_content)
		{
		  
		}
	} 
	
d1203 22
d1458 1
a1458 1
  if (1)//number(0, damChance) == damChance) 	// Damaged eq! 
d1694 1
a1694 1
      damage(ch, victim, 0, SKILL_BACKSTAB);
d1837 11
a1847 1
	/* TODO: Extend function here to allow specials on items and such */
d1849 5
a1853 13
	// Check if the opponent is history
	if (!FIGHTING(rider))
		return;

        if (MOUNTING(rider) && !FIGHTING(MOUNTING(rider)) ) {
	    send_to_char("Your mount joins the fray!\r\n", rider);
	    do_hit(MOUNTING(rider), (FIGHTING(rider))->player.name, 0, SCMD_HIT);
        }
	if (MOUNTING_OBJ(rider)) {
	   send_to_char("Your mount aids your efforts in battle.\r\n", rider);
	   act("$n's mount aids $m against $s opponent.", FALSE, rider, 0, 0, TO_ROOM);
	   hit(rider, FIGHTING(rider), TYPE_UNDEFINED);
        }
d1866 2
d1874 1
a1874 1
      }
@


1.4
log
@
Added:
- Ahh, too much stuff, sorry was ages since this stuff was last checked in
@
text
@d24 1
d40 3
d314 1
d316 12
d362 5
d426 1
d431 2
a432 1
                                     struct obj_data * cont, int mode);
d489 3
a491 1
            perform_get_from_container(scab, obj, corpse, 0);
d525 2
a526 1
                perform_get_from_container(scab, obj, corpse, 0);
d561 3
a563 1
              perform_get_from_container(scab, obj, corpse, 0);
d1393 8
a1400 9
// XXX: DM - bug, a mob came up here when killed - maybe its not, but logging it
// atm...
sprintf(buf2, "attacktype = %d", attacktype);
log(buf2);

        sprintf(buf2, "%s died at %s", GET_NAME(ch),world[victim->in_room].name);
        mudlog(buf2, BRF, LVL_ETRNL1, TRUE);
        if (MOB_FLAGGED(ch, MOB_MEMORY))
          forget(ch, victim);
@


1.3
log
@
Added:
- Check for !IS_NPC to fix excessive syslog errors.
@
text
@d402 1
a402 1
  struct char_data *k;
d445 3
a447 2
    if ( (!IS_NPC(killer) && IS_NPC(ch)) &&
        (killer->in_room == ch->in_room)) {
d449 8
a456 2
    /* Auto Loot */
      if (EXT_FLAGGED(killer, EXT_AUTOLOOT)) {
d458 2
a459 2
          if (IS_CARRYING_N(killer) >= CAN_CARRY_N(killer)) {
            send_to_char("Your arms are already full!\r\n", killer);
d464 2
a465 2
          if (CAN_SEE_OBJ(killer, obj) && (GET_OBJ_TYPE(obj) != ITEM_MONEY)) {
            perform_get_from_container(killer, obj, corpse, 0);
d470 1
a470 1
          act("$p seems to be empty.", FALSE, killer, corpse, 0, TO_CHAR);
d473 2
a474 2
    /* Auto Gold */
      if (EXT_FLAGGED(killer, EXT_AUTOGOLD)) {
d480 1
a480 1
            if (EXT_FLAGGED(killer, EXT_AUTOSPLIT) && IS_AFFECTED(killer, AFF_GROUP)) {
d484 1
a484 7
              k = (killer->master ? killer->master : killer);
 
sprintf(buf,"Master: %s, ",GET_NAME(k));
send_to_char(buf,killer);
 
        /* DM - TODO - rewrite autosplit?? */
       /* DM - fix in here when a follower makes kill not in room as others */
d486 2
a487 1
              for (f = k->followers; f; f = f->next)
d489 2
a490 2
                      /* (f->follower != killer) && */
                      (f->follower->in_room == killer->in_room))
d492 5
a496 3
 
sprintf(buf,"Number in Group: %d, ",num);
send_to_char(buf,killer);
d499 1
a499 1
                perform_get_from_container(killer, obj, corpse, 0);
d504 4
a507 14
                GET_GOLD(killer) += share;
                sprintf(buf, "You split %s%d%s coins among %d members -- %s%d%s coins each.\r\n",
                        CCGOLD(killer,C_NRM),amount,CCNRM(killer,C_NRM), num,
                        CCGOLD(killer,C_NRM),share,CCNRM(killer,C_NRM));
                        send_to_char(buf, killer);
 
                if (IS_AFFECTED(k, AFF_GROUP) && (k->in_room == killer->in_room)
                    && !(IS_NPC(k)) && k != killer) {
                  GET_GOLD(k) += share;
                  sprintf(buf, "%s splits %s%d%s coins; you receive %s%d%s.\r\n", GET_NAME(killer),
                           CCGOLD(k,C_NRM),amount,CCNRM(k,C_NRM),CCGOLD(k,C_NRM),
                           share,CCNRM(k,C_NRM));
                  send_to_char(buf, k);
                }
d509 1
d513 2
a514 2
                      (f->follower->in_room == killer->in_room) &&
                      f->follower != killer) {
d516 2
a517 3
                    sprintf(buf, "%s splits %s%d%s coins; you receive %s%d%s.\r\n",
                    GET_NAME(killer),CCGOLD(f->follower,C_NRM),amount,CCNRM(f->follower,C_NRM),
                    CCGOLD(f->follower,C_NRM), share,CCNRM(f->follower,C_NRM));
d521 10
d534 1
a534 1
              perform_get_from_container(killer, obj, corpse, 0);
d1363 6
d1548 10
a1557 15
//  w_type = attacktype & 0x7fff;
//  reloadable = attacktype & 0x8000;
 
/* changed so mobs dont use ammo - Vader */
//  if (reloadable && !IS_NPC(ch))
//  {
//    if (GET_OBJ_VAL(wielded, 0) <= 0)
//    {
//      send_to_char("*CLICK*\n\r", ch);
//      return;
//       /* out of ammo */
//    }
//    else
//      MAX(0, --GET_OBJ_VAL(wielded, 0));
//  }      
@


1.2
log
@my new skills!


Added:
-
-

Removed:
-
-

Changed:
-
-

TODO:
-
-
@
text
@d1216 1
a1216 1
  if (GET_SKILL(victim, SKILL_DEFEND))
@


1.1
log
@

Added:
- Modified files to compile with g++ - this is the initial import of those
  files.

TODO:
- Test it all works 100%
@
text
@d50 2
d1094 1
a1094 1
	else {	// nothing was damage, slight chance of getting inventory
d1097 1
a1097 1
		
d1199 38
d1335 1
a1335 1
  if (number(0, damChance) == damChance) 	// Damaged eq! 
d1636 14
a1649 1
      damage(ch, real_vict, dam, SKILL_BACKSTAB);
@

