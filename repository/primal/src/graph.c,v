head	1.2;
access;
symbols
	rel1:1.1.1.1 prim:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2001.10.01.04.23.09;	author primal;	state Exp;
branches;
next	1.1;

1.1
date	2000.01.26.14.31.02;	author michaeld;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.01.26.14.31.02;	author michaeld;	state Exp;
branches;
next	;


desc
@@


1.2
log
@*** empty log message ***
@
text
@/* ************************************************************************
*   File: graph.c                                       Part of CircleMUD *
*  Usage: various graph algorithms                                        *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#define TRACK_THROUGH_DOORS

/* You can define or not define TRACK_THOUGH_DOORS, above, depending on
   whether or not you want track to find paths which lead through closed
   or hidden doors.
*/

#include <stdio.h>
#include <stdlib.h>

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"


/* Externals */
extern int top_of_world;
extern const char *dirs[];
extern struct room_data *world;

struct bfs_queue_struct {
  sh_int room;
  char dir;
  struct bfs_queue_struct *next;
};

static struct bfs_queue_struct *queue_head = 0, *queue_tail = 0;

/* Local prototypes */
int MY_VALID_EDGE(sh_int room, int dir);
int getMeHere(sh_int chroom, sh_int victroom);

/* Utility macros */
#define MARK(room) (SET_BIT(ROOM_FLAGS(room), ROOM_BFS_MARK))
#define UNMARK(room) (REMOVE_BIT(ROOM_FLAGS(room), ROOM_BFS_MARK))
#define IS_MARKED(room) (IS_SET(ROOM_FLAGS(room), ROOM_BFS_MARK))
#define TOROOM(x, y) (world[(x)].dir_option[(y)]->to_room)
#define IS_CLOSED(x, y) (IS_SET(world[(x)].dir_option[(y)]->exit_info, EX_CLOSED))

#ifdef TRACK_THROUGH_DOORS
#define VALID_EDGE(x, y) (world[(x)].dir_option[(y)] && \
			  (TOROOM(x, y) != NOWHERE) &&	\
			  (!IS_MARKED(TOROOM(x, y))))
#else
#define VALID_EDGE(x, y) (world[(x)].dir_option[(y)] && \
			  (TOROOM(x, y) != NOWHERE) &&	\
			  (!IS_CLOSED(x, y)) &&		\
			  (!IS_MARKED(TOROOM(x, y))))
#endif


void bfs_enqueue(sh_int room, char dir)
{
  struct bfs_queue_struct *curr;

  CREATE(curr, struct bfs_queue_struct, 1);
  curr->room = room;
  curr->dir = dir;
  curr->next = 0;

  if (queue_tail) {
    queue_tail->next = curr;
    queue_tail = curr;
  } else
    queue_head = queue_tail = curr;
}


void bfs_dequeue(void)
{
  struct bfs_queue_struct *curr;

  curr = queue_head;

  if (!(queue_head = queue_head->next))
    queue_tail = 0;
  free(curr);
}


void bfs_clear_queue(void)
{
  while (queue_head)
    bfs_dequeue();
}


/* find_first_step: given a source room and a target room, find the first
   step on the shortest path from the source to the target.

   Intended usage: in mobile_activity, give a mob a dir to go if they're
   tracking another mob or a PC.  Or, a 'track' skill for PCs.
*/

int find_first_step(sh_int src, sh_int target)
{
  int curr_dir;
  sh_int curr_room;

  if (src < 0 || src > top_of_world || target < 0 || target > top_of_world) {
    log("Illegal value passed to find_first_step (graph.c)");
    return BFS_ERROR;
  }
  if (src == target)
    return BFS_ALREADY_THERE;

  /* clear marks first */
  for (curr_room = 0; curr_room <= top_of_world; curr_room++)
    UNMARK(curr_room);

  MARK(src);

  /* first, enqueue the first steps, saving which direction we're going. */
  for (curr_dir = 0; curr_dir < NUM_OF_DIRS; curr_dir++)
    if (VALID_EDGE(src, curr_dir)) {
      MARK(TOROOM(src, curr_dir));
      bfs_enqueue(TOROOM(src, curr_dir), curr_dir);
    }
  /* now, do the classic BFS. */
  while (queue_head) {
    if (queue_head->room == target) {
      curr_dir = queue_head->dir;
      bfs_clear_queue();
      return curr_dir;
    } else {
      for (curr_dir = 0; curr_dir < NUM_OF_DIRS; curr_dir++)
	if (VALID_EDGE(queue_head->room, curr_dir)) {
	  MARK(TOROOM(queue_head->room, curr_dir));
	  bfs_enqueue(TOROOM(queue_head->room, curr_dir), queue_head->dir);
	}
      bfs_dequeue();
    }
  }

  return BFS_NO_PATH;
}


/************************************************************************
*  Functions and Commands which use the above fns		        *
************************************************************************/

/* this is the modified do_track that incorporates the hunt skill - Vader */
ACMD(do_track)
{
  struct char_data *vict;
  int dir, num;

  if ((!GET_SKILL(ch, SKILL_TRACK)) || (!GET_SKILL(ch, SKILL_HUNT) && (subcmd == SCMD_HUNT))) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }

  if(subcmd == SCMD_AUTOHUNT) {
    vict = HUNTING(ch);
    if((!vict) || (!CAN_SEE(ch,vict)) || (HUNTING(ch)->in_room == NOWHERE)) {
      send_to_char("You seem to have lost the trail!\r\n",ch);
      HUNTING(ch) = NULL;
      return;
      }
    } else {
  one_argument(argument, arg);
  if (!*arg) {
    if(subcmd == SCMD_HUNT) {
      if(HUNTING(ch)) {
	act("You stop hunting $N.",FALSE,ch,0,HUNTING(ch),TO_CHAR);
	HUNTING(ch) = NULL;
	return;
	} else {
	  send_to_char("Hunt who?\r\n",ch);
	  return;
	  }
      } else {
      send_to_char("Whom are you trying to track?\r\n", ch);
      return;
    }
  }
  if (!(vict = get_char_vis(ch, arg, 0))) {
    send_to_char("No-one around by that name.\r\n", ch);
    return;
  }
  if (IS_AFFECTED(vict, AFF_NOTRACK)) {
    send_to_char("You sense no trail.\r\n", ch);
    return;
  }
  if(PRF_FLAGGED(vict, PRF_TAG)) {
    send_to_char("CHEAT! Ya can't track people who are playing tag!\r\n",ch);
    return;
  }
  if(subcmd == SCMD_HUNT)
    HUNTING(ch) = vict;
}
/* this shood stop errors if the peron ya hunting dies b4 ya get there */
if((subcmd == SCMD_HUNT || subcmd == SCMD_AUTOHUNT) && HUNTING(ch))
  if((HUNTING(ch)->in_room < 0 || HUNTING(ch)->in_room > top_of_world) ||
     (GET_HIT(HUNTING(ch)) <= 0)) {
    send_to_char("You can no longer find a path to your prey!\r\n",ch);
    HUNTING(ch) = NULL;
    return;
    }

  dir = find_first_step(ch->in_room, vict->in_room);

  switch (dir) {
  case BFS_ERROR:
    send_to_char("Hmm.. something seems to be wrong.\r\n", ch);
    break;
  case BFS_ALREADY_THERE:
    if((subcmd == SCMD_HUNT || subcmd == SCMD_AUTOHUNT) && HUNTING(ch)) {
      send_to_char("You've found your prey!\r\n",ch);
      HUNTING(ch) = NULL;
      } else {
	send_to_char("You're already in the same room!!\r\n", ch);
      }
    break;
  case BFS_NO_PATH:
    sprintf(buf, "You can't sense a trail to %s from here.\r\n",
	    HMHR(vict));
    send_to_char(buf, ch);
    break;
  default:
    num = number(0, 101);       /* 101% is a complete failure */
    if (GET_SKILL(ch, SKILL_TRACK) < num)
			dir = 0;
/* this can sometimes get into an endless loop */
/*      do {
	dir = number(0, NUM_OF_DIRS - 1);
      } while (!CAN_GO(ch, dir));
*/
		
    sprintf(buf, "You sense a trail %s from here!\r\n", dirs[dir]);
    send_to_char(buf, ch);
    break;
  }
}


void hunt_victim(struct char_data * ch)
{
  ACMD(do_say);
  extern struct char_data *character_list;

  int dir;
  byte found;
  struct char_data *tmp;

  if (!ch || !HUNTING(ch))
    return;

  /* make sure the char still exists */
  for (found = 0, tmp = character_list; tmp && !found; tmp = tmp->next)
    if (HUNTING(ch) == tmp)
      found = 1;

  if (!found) {
    do_say(ch, "Damn!  My prey is gone!!", 0, 0);
    HUNTING(ch) = 0;
    return;
  }
  dir = find_first_step(ch->in_room, HUNTING(ch)->in_room);
  if (dir < 0) {
    sprintf(buf, "Damn!  Lost %s!", HMHR(HUNTING(ch)));
    do_say(ch, buf, 0, 0);
    HUNTING(ch) = 0;
    return;
  } else {
    perform_move(ch, dir, 1);
    if (ch->in_room == HUNTING(ch)->in_room)
      hit(ch, HUNTING(ch), TYPE_UNDEFINED);
    return;
  }
}

void do_playerhunt( struct char_data *ch, struct char_data *victim ) {

  	ACMD(do_say);
        int direction = getMeHere(ch->in_room, victim->in_room);
 
        if( direction != -1 )
                perform_move( ch, direction, 0);
 
        // Check if we're there
        if( ch->in_room == victim->in_room ) {
                sprintf(buf1, "Your time is at hand %s, defend thyself!!", victim->player.name);
                do_say(ch, buf1, 0,0);
                hit(ch, victim, TYPE_UNDEFINED);
                return;
        }
} 

int getMeHere(sh_int chroom, sh_int victroom) {
 
        int currdir = 0;
        sh_int curr_room = 0;
 
        // Check if the rooms are the same
        if( chroom == victroom )
                return -1;
 
        // Clear all marks
        for (curr_room = 0; curr_room <= top_of_world; curr_room++)
                UNMARK(curr_room);
 
        MARK(chroom);                                   // Mark our start room
 
        // Get the initial directions available from current room, creating queue
        for( currdir = 0; currdir < NUM_OF_DIRS; currdir++) {
                if(MY_VALID_EDGE(chroom, currdir) ) {                   // If room exists
                        MARK( TOROOM(chroom, currdir));                 // Mark it
                        bfs_enqueue( TOROOM(chroom, currdir), currdir); // Queue it
                }
        }
                                                                    // now, loop through all the potential directions,
        // and return the direction to move in
        while( queue_head  ) {
                if( queue_head->room == victroom ) {                    // If we're at the last room
                        currdir = queue_head->dir;                      // Set direction
                        bfs_clear_queue();                              // Clean up
                        return currdir;                                 // Move
                }
                else {                                                  // Didn't find target at head
                        // Check this room for potential paths, add them to the queue if valid
                        for( currdir = 0; currdir < NUM_OF_DIRS; currdir++ ) {
                                if( MY_VALID_EDGE(queue_head->room, currdir) ) {
                                        MARK( TOROOM(queue_head->room, currdir) );
                                        bfs_enqueue( TOROOM(queue_head->room, currdir), currdir );
                                }
                        }
                        bfs_dequeue();          // Got all paths off this one, remove it
 
                }
        }
 
        // If we're here, there's no valid path
        return -1;
} 

int MY_VALID_EDGE(sh_int room, int dir ) {
 
        // If direction is invalid, or room goes nowhere
        if (world[room].dir_option[dir] == NULL || TOROOM(room, dir) == NOWHERE)
                return 0;
 
#ifdef TRACK_THORUGH_DOORS
#else
        // If there's a closed door in our way
        if (IS_CLOSED(room, dir))
                return 0;
#endif
 
        // If the room's been marked already, we don't want it
        if( IS_MARKED(TOROOM(room, dir)) )
                return 0;
 
        // If the room's marked with a !MOB flag, invalidate it
        if( ROOM_FLAGGED(TOROOM(room,dir), ROOM_NOMOB) )
                return 0;
 
        return 1;                       // Valid edge
} 
@


1.1
log
@Initial revision
@
text
@d170 1
a170 1
    if((!CAN_SEE(ch,vict)) || (HUNTING(ch)->in_room == NOWHERE)) {
@


1.1.1.1
log
@Intial Import of Source
@
text
@@
